<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <!-- Metas -->
    <title>gpu-curtains | Basic plane example</title>
    <meta name="description" content="A basic WebGL plane bound to a HTML DOM element with gpu-curtains" />

    <link href="https://fonts.googleapis.com/css?family=PT+Sans:400" rel="stylesheet" />

    <style>
      body {
        /* make the body fits our viewport */
        position: relative;
        width: 100%;
        height: 100vh;
        margin: 0;
        overflow: hidden;
        font-family: 'PT Sans', Verdana, sans-serif;
        font-size: 18px;
      }

      #canvas {
        /* make the canvas wrapper fits the document */
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
      }

      #back-to-lib-link {
        display: inline-block;
        position: fixed;
        top: 0;
        right: 0;
        padding: 0.25em 0.5em;
        background: #ee6557;
        color: white;
        text-decoration: none;
        z-index: 20;
        font-size: 0.85em;
      }

      #back-to-lib-link:hover {
        background: black;
      }

      #source-code-link {
        display: inline-block;
        position: fixed;
        bottom: 1em;
        right: 1em;
        padding: 0.25em 0.5em;
        background: #ee6557;
        color: white;
        text-decoration: none;
        z-index: 20;
      }

      #source-code-link:hover {
        background: black;
      }

      .wrapper {
        width: 100%;
        height: 100vh;
        display: flex;
      }

      .plane {
        /* define the size of your plane */
        width: 80%;
        height: 80vh;
        margin: 10vh auto;
      }

      .plane img {
        /* hide the img element */
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="canvas"></div>

    <a href="https://www.curtainsjs.com/" title="back to curtains.js website" id="back-to-lib-link" target="_blank"
      >back to curtains.js website</a
    >

    <div class="wrapper">
      <div class="plane">
        <img src="https://source.unsplash.com/featured/1920x1280/?nature" crossorigin="" />
      </div>
    </div>

    <a
      href="https://github.com/martinlaxenaire/gpu-curtains/blob/main/examples/basic-plane/index.html"
      title="Show source code"
      id="source-code-link"
      target="_blank"
      >&lt;/ &gt;</a
    >

    <script src="../../dist/gpu-curtains.umd.js"></script>
    <script>
      //import {GPUCurtains, Plane} from '../../dist/gpu-curtains.mjs';

      window.addEventListener('load', async () => {
        // set up our WebGL context and append the canvas to our wrapper
        const gpuCurtains = new GPUCurtains.GPUCurtains({
          container: 'canvas',
          pixelRatio: Math.min(1.5, window.devicePixelRatio), // limit pixel ratio for performance
        })

        await gpuCurtains.setRendererContext()

        // get our plane element
        const planeElements = document.getElementsByClassName('plane')

        const vertexShader = `
        struct VSOutput {
            @builtin(position) position: vec4f,
            @location(1) uv: vec2f,
          };

          @vertex fn main(
            attributes: Attributes,
          ) -> VSOutput {
            var vsOutput: VSOutput;

            var strength: f32 = 0.05;
            var nbWaves: f32 = 3.0;

            // map vertices coordinates to the 0->1 range on the X axis
            var normalizeXPos: f32 = (attributes.position.x + 0.5) * 0.5;

            // notice how the "uniforms" struct name matches our bindings object name property
            var time: f32 = uniforms.time * 0.0375;

            var waveSinusoid: f32 = sin(3.141595 * nbWaves * normalizeXPos - time);

            var transformed: vec3f = vec3(
                attributes.position.x,
                attributes.position.y,
                attributes.position.z - waveSinusoid * strength
            );

            vsOutput.position = getOutputPosition(camera, matrices, transformed);

            vsOutput.uv = getScaledUV(attributes.uv, texture0Matrix);

            return vsOutput;
          }
    `

        const fragmentShader = `
        struct VSOutput {
            @builtin(position) position: vec4f,
            @location(1) uv: vec2f,
          };

          @fragment fn main(fsInput: VSOutput) -> @location(0) vec4f {
            var texture: vec4f = textureSample(texture0, texture0Sampler, fsInput.uv);

            return texture;
          }
    `

        // set our initial parameters (basic uniforms)
        const params = {
          widthSegments: 20,
          shaders: {
            vertex: {
              code: vertexShader,
              entryPoint: 'main',
            },
            fragment: {
              code: fragmentShader,
              entryPoint: 'main',
            },
          },
          bindings: [
            {
              name: 'uniforms', // could be something else, like "frames"...
              label: 'Uniforms',
              uniforms: {
                time: {
                  type: 'f32', // this means our uniform is a float
                  value: 0,
                },
              },
            },
          ],
        }

        const plane = new GPUCurtains.Plane(gpuCurtains, planeElements[0], params)

        plane.onRender(() => {
          // update our time uniform value
          plane.uniforms.time.value++
        })
      })
    </script>
  </body>
</html>
