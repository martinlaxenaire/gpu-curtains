<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>gpu-curtains | Examples</title>
    <meta name="description" content="List of useful examples to learn gpu-curtains" />

    <link href="common-styles.css" rel="stylesheet" />

    <style>
      #sphere {
        position: fixed;
        z-index: -1;
        top: 50%;
        left: calc(100% * 2 / 3);
        width: 15vw;
        aspect-ratio: 1;
        transform: translate3d(-50%, -50%, 0);
      }

      @media screen and (orientation: portrait) {
        #sphere {
          left: 50%;
          width: 33vw;
        }
      }
    </style>
  </head>
  <body>
    <div id="canvas"></div>

    <div id="sphere"></div>

    <div id="page">
      <div class="large-container">
        <h1>Useful gpu-curtains examples</h1>
        <h2>Planes</h2>
        <ul>
          <li>
            <a href="./basic-plane/index.html" target="_blank">Basic plane</a>
          </li>
          <li>
            <a href="./multiple-planes/index.html" target="_blank">Multiple planes</a>
          </li>
          <li>
            <a href="./slideshow/index.html" target="_blank">Slideshow</a>
          </li>
          <li>
            <a href="./video-planes/index.html" target="_blank">Video planes</a>
          </li>
          <li>
            <a href="./canvas-text/index.html" target="_blank">Canvas text</a>
          </li>
          <li>
            <a href="./instanced-planes/index.html" target="_blank">Instanced planes</a>
          </li>
          <li>
            <a href="./ajax-navigation-with-plane-removal/index.html" target="_blank"
              >AJAX navigation with plane removal</a
            >
          </li>
          <li>
            <a href="./custom-scroll-and-transformations/index.html" target="_blank"
              >Custom scroll and plane transformations</a
            >
          </li>
        </ul>
        <h2>Meshes</h2>
        <ul>
          <li>
            <a href="./full-screen-plane-shader/index.html" target="_blank">FullscreenPlane shader</a>
          </li>
          <li>
            <a href="./custom-geometry/index.html" target="_blank">Custom instanced geometry</a>
          </li>
          <li>
            <a href="./dom-meshes/index.html" target="_blank">DOM Meshes</a>
          </li>
        </ul>
        <h2>Post processing / render to texture</h2>
        <ul>
          <li>
            <a href="./post-processing-transform-origin/index.html" target="_blank"
              >Post processing and custom transform origin</a
            >
          </li>
          <li>
            <a href="./selective-shader-passes-using-render-target/index.html" target="_blank"
              >Selective shader passes using render targets</a
            >
          </li>
          <li>
            <a href="./ping-pong-plane/index.html" target="_blank">Ping pong plane</a>
          </li>
        </ul>
        <h2>Compute passes</h2>
        <ul>
          <li>
            <a href="compute-boids/index.html" target="_blank">Compute boids</a>
          </li>
          <li>
            <a href="compute-particles/index.html" target="_blank">Compute curl particles</a>
          </li>
          <li>
            <a href="./cloth-simulation/index.html" target="_blank">Cloth simulation</a>
          </li>
          <li>
            <a href="./compute-blur/index.html" target="_blank">Compute blur</a>
          </li>
        </ul>
        <h2>Renderers</h2>
        <ul>
          <li>
            <a href="./multiple-canvases/index.html" target="_blank">Multiple canvases using one device</a>
          </li>
          <li>
            <a href="./multiple-canvases-updating-renderer/index.html" target="_blank"
              >Multiple canvases and runtime renderers switching</a
            >
          </li>
        </ul>
        <h2>Advanced rendering</h2>
        <ul>
          <li>
            <a href="camera-renderer-transforms-bloom-pass/index.html" target="_blank">
              GPUCameraRenderer, camera rotation and bloom pass
            </a>
          </li>
          <li>
            <a href="camera-renderer-selective-dithering/index.html" target="_blank">
              GPUCameraRenderer, camera rotation and selective dithering pass
            </a>
          </li>
        </ul>
      </div>
    </div>

    <script type="module">
      import { GPUCurtains, SphereGeometry, DOMMesh, Vec3 } from '../dist/gpu-curtains.js'

      window.addEventListener('DOMContentLoaded', async () => {
        // set up our WebGL context and append the canvas to our wrapper
        const gpuCurtains = new GPUCurtains({
          container: '#canvas',
          watchScroll: false,
          pixelRatio: Math.min(1.5, window.devicePixelRatio), // limit pixel ratio for performance
        })

        await gpuCurtains.setDevice()

        const meshVs = /* wgsl */ `
          struct VSOutput {
            @builtin(position) position: vec4f,
            @location(0) uv: vec2f,
            @location(1) normal: vec3f,
          };

          @vertex fn main(
            attributes: Attributes,
          ) -> VSOutput {
            var vsOutput : VSOutput;

            var transformed: vec3f = attributes.position;
            //transformed = transformed + attributes.normal * vec3(deformation.strength * sin(transformed.y * 10.0 + deformation.time * 0.05));

            vsOutput.position = getOutputPosition(camera, matrices, transformed);
            vsOutput.uv = attributes.uv;
            vsOutput.normal = attributes.normal;

            return vsOutput;
          }
        `

        const meshFs = /* wgsl */ `
          struct VSOutput {
            @builtin(position) position: vec4f,
            @location(0) uv: vec2f,
            @location(1) normal: vec3f,
          };

          @fragment fn main(fsInput: VSOutput) -> @location(0) vec4f {
            // debug normals
            return vec4(fsInput.normal * 0.5 + 0.5, 1.0);
          }
        `

        const sphereGeometry = new SphereGeometry()

        const sphereMesh = new DOMMesh(gpuCurtains, '#sphere', {
          label: 'Main Sphere',
          geometry: sphereGeometry,
          watchScroll: false,
        })

        const updateSphereScale = () => {
          // scale our sphere along the Z axis based on its height (Y axis scale)
          sphereMesh.scale.z = sphereMesh.worldScale.y
        }

        sphereMesh.onAfterResize(updateSphereScale).onRender(() => (sphereMesh.rotation.y += 0.01))
        updateSphereScale()

        // now the cubes
        for (let i = 0; i < 25; i++) {
          const satelliteMesh = new DOMMesh(gpuCurtains, '#sphere', {
            label: 'Cube ' + i,
            geometry: sphereGeometry,
            watchScroll: false,
          })

          const updateSatelliteScale = () => {
            const scale = 0.1 + Math.random() * 0.15

            // get the DOM #sphere size in the world space
            const sphereSize = sphereMesh.DOMObjectWorldScale.y

            // min distance so that the satellite sphere lies exactly at the border of our main sphere
            const minDistance = sphereSize + sphereSize * scale
            const distance = minDistance + Math.random() * sphereSize * 1.5

            satelliteMesh.userData.angle = Math.random() * Math.PI

            const positionAngle = Math.random() * Math.PI * 2

            satelliteMesh.userData.orbitPosition = new Vec3(
              Math.cos(positionAngle) * distance,
              Math.sin(positionAngle) * distance,
              0
            )

            const axisAngle = new Vec3(0, Math.sin(positionAngle), Math.cos(positionAngle)).normalize()

            satelliteMesh.userData.axisAngle = satelliteMesh.userData.orbitPosition.clone().cross(axisAngle).normalize()

            satelliteMesh.scale.x = scale
            satelliteMesh.scale.y = scale

            // scale our sphere along the Z axis based on its height (Y axis scale)
            satelliteMesh.scale.z = satelliteMesh.worldScale.y
          }

          const speed = (Math.random() * 0.015 + 0.01) * Math.sign(Math.random() - 0.5)

          let closeFactor = 0

          satelliteMesh.onAfterResize(updateSatelliteScale).onRender(() => {
            satelliteMesh.userData.angle += speed

            closeFactor += speed

            const orbitPosition = satelliteMesh.userData.orbitPosition
              .clone()
              //.multiplyScalar((Math.cos(closeFactor) * 0.5 + 0.5) * 0.25 + 0.75)
              .applyAxisAngle(satelliteMesh.userData.axisAngle, satelliteMesh.userData.angle)

            satelliteMesh.position.copy(orbitPosition)

            // look at our main sphere
            satelliteMesh.lookAt(sphereMesh.position)
          })

          updateSatelliteScale()
        }
      })
    </script>
  </body>
</html>
