<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>gpu-curtains | Examples</title>
    <meta name="description" content="List of useful examples to learn how to use gpu-curtains" />

    <meta property="og:title" content="gpu-curtains | Examples" />
    <meta property="og:type" content="article" />
    <meta property="og:description" content="List of useful examples to learn how to use gpu-curtains" />
    <meta
      property="og:image"
      content="https://raw.githubusercontent.com/martinlaxenaire/gpu-curtains/main/website/assets/gpu-curtains-logo-1920-1280.jpg"
    />
    <meta property="og:url" content="https://martinlaxenaire.github.io/gpu-curtains/examples/" />
    <meta name="twitter:card" content="summary_large_image" />

    <link href="common-styles.css" rel="stylesheet" />

    <link
      rel="icon"
      type="image/png"
      href="https://raw.githubusercontent.com/martinlaxenaire/gpu-curtains/main/website/assets/favicon.png"
    />

    <style>
      #examples h2 {
        margin-top: 2rem;
      }

      #examples ul {
        margin: 1.5rem 0;
      }

      #examples ul li {
        margin: 0.5rem 0;
      }

      #sphere {
        position: fixed;
        z-index: -1;
        top: 50%;
        left: calc(100% * 2 / 3);
        width: 15vw;
        aspect-ratio: 1;
        transform: translate3d(-50%, -50%, 0);
      }

      @media screen and (orientation: portrait) {
        #sphere {
          left: 50%;
          width: 33vw;
        }
      }
    </style>
  </head>
  <body>
    <div id="canvas"></div>

    <div id="sphere"></div>

    <div id="page">
      <header id="header">
        <nav id="main-menu" class="container">
          <h1><a href="../">gpu-curtains</a></h1>
          <ul>
            <li>
              <a class="primary-button" href="https://github.com/martinlaxenaire/gpu-curtains">Repository</a>
            </li>
            <li>
              <a class="primary-button" href="../docs/">Docs</a>
            </li>
            <li>
              <a class="primary-button active" href="../examples/">Examples</a>
            </li>
          </ul>
        </nav>
      </header>

      <div id="examples" class="large-container">
        <h1>Useful gpu-curtains examples</h1>
        <p>
          Here you'll find some examples covering various usages and possibilities.<br />
          They are ordered by difficulty, from the most basic to the most complex one.<br />
          Their source code is available on the
          <a href="https://github.com/martinlaxenaire/gpu-curtains/tree/main/examples" target="_blank"
            >repository examples directory</a
          >.
        </p>
        <h2 class="overlay-title">Planes</h2>
        <ul>
          <li>
            <a href="./basic-plane/" target="_blank">Basic plane</a>
          </li>
          <li>
            <a href="./multiple-planes/" target="_blank">Multiple planes</a>
          </li>
          <li>
            <a href="./slideshow/" target="_blank">Slideshow</a>
          </li>
          <li>
            <a href="./video-planes/" target="_blank">Video planes</a>
          </li>
          <li>
            <a href="./canvas-text/" target="_blank">Canvas text</a>
          </li>
          <li>
            <a href="./instanced-planes/" target="_blank">Instanced planes</a>
          </li>
          <li>
            <a href="./ajax-navigation-with-plane-removal/" target="_blank">AJAX navigation with plane removal</a>
          </li>
          <li>
            <a href="./custom-scroll-and-transformations/" target="_blank">Custom scroll and plane transformations</a>
          </li>
        </ul>
        <h2 class="overlay-title">Meshes</h2>
        <ul>
          <li>
            <a href="./full-screen-plane-shader/" target="_blank">FullscreenPlane shader</a>
          </li>
          <li>
            <a href="./custom-geometry/" target="_blank">Custom instanced geometry</a>
          </li>
          <li>
            <a href="./dom-meshes/" target="_blank">DOM Meshes</a>
          </li>
          <li>
            <a href="./camera-renderer-object-3d-pivot/" target="_blank">GPUCameraRenderer and Object3D as pivots</a>
          </li>
        </ul>
        <h2 class="overlay-title">Post processing / render to texture</h2>
        <ul>
          <li>
            <a href="./post-processing-transform-origin/" target="_blank"
              >Post processing and custom transform origin</a
            >
          </li>
          <li>
            <a href="./gsap-instanced-kinetic-typography/" target="_blank">Kinetic typography with GSAP</a>
          </li>
          <li>
            <a href="./selective-shader-passes-using-render-target/" target="_blank"
              >Selective shader passes using render targets</a
            >
          </li>
          <li>
            <a href="./ping-pong-plane/" target="_blank">Ping pong plane</a>
          </li>
        </ul>
        <h2 class="overlay-title">Renderers</h2>
        <ul>
          <li>
            <a href="./multiple-canvases/" target="_blank">Multiple canvases using one device</a>
          </li>
          <li>
            <a href="./multiple-canvases-updating-renderer/" target="_blank"
              >Multiple canvases and updating renderers at runtime</a
            >
          </li>
        </ul>
        <h2 class="overlay-title">Compute passes</h2>
        <ul>
          <li>
            <a href="compute-boids/" target="_blank">Compute boids</a>
          </li>
          <li>
            <a href="compute-particles/" target="_blank">Compute 1 million particles with curl noise</a>
          </li>
          <li>
            <a href="./compute-blur/" target="_blank">Compute blur</a>
          </li>
          <li>
            <a href="./cloth-simulation/" target="_blank">Cloth simulation</a>
          </li>
        </ul>

        <h2 class="overlay-title">Advanced rendering</h2>
        <ul>
          <li>
            <a href="camera-renderer-transforms-bloom-pass/" target="_blank"> Camera rotation and bloom pass </a>
          </li>
          <li>
            <a href="camera-renderer-selective-dithering/" target="_blank">
              Object3D pivot rotation and selective dithering pass
            </a>
          </li>
          <li>
            <a href="deferred-rendering/" target="_blank">Deferred rendering (Multiple Render Targets)</a>
          </li>
          <li>
            <a href="shadow-mapping/" target="_blank">Shadow mapping</a>
          </li>
        </ul>
      </div>
    </div>

    <script type="module">
      import { GPUCurtains, SphereGeometry, DOMMesh, Object3D } from '../dist/esm/index.mjs'

      window.addEventListener('DOMContentLoaded', async () => {
        // set up our WebGL context and append the canvas to our wrapper
        const gpuCurtains = new GPUCurtains({
          container: '#canvas',
          watchScroll: false,
          pixelRatio: Math.min(1.5, window.devicePixelRatio), // limit pixel ratio for performance
        })

        await gpuCurtains.setDevice()

        const sphereGeometry = new SphereGeometry()

        const sphereMesh = new DOMMesh(gpuCurtains, '#sphere', {
          label: 'Main Sphere',
          geometry: sphereGeometry,
          watchScroll: false,
        })

        const updateSphereScale = () => {
          // scale our sphere along the Z axis based on its height (Y axis scale)
          sphereMesh.scale.z = sphereMesh.worldScale.y
        }

        sphereMesh.onAfterResize(updateSphereScale).onRender(() => (sphereMesh.rotation.y += 0.01))
        updateSphereScale()

        // now the satellites
        const nbSatellites = 25
        for (let i = 0; i < nbSatellites; i++) {
          const satelliteMesh = new DOMMesh(gpuCurtains, '#sphere', {
            label: 'Cube ' + i,
            geometry: sphereGeometry,
            watchScroll: false,
          })

          // create a different pivot for each satellite
          const pivot = new Object3D()

          // random rotation speed
          const pivotRotationSpeed = (Math.random() * 0.015 + 0.01) * Math.sign(Math.random() - 0.5)
          // set the quaternion axis order
          pivot.quaternion.setAxisOrder('ZYX')
          // random init rotation values
          pivot.rotation.y = Math.random() * Math.PI * 2
          pivot.rotation.z = Math.random() * Math.PI

          // now add the satellite to our pivot
          satelliteMesh.parent = pivot

          // set satellite scale
          const scale = 0.1 + Math.random() * 0.15

          satelliteMesh.scale.x = scale
          satelliteMesh.scale.y = scale

          const minDistanceRatio = 1.5 * Math.random()

          const updateSatelliteScale = () => {
            // copy the main sphere world position
            pivot.position.copy(sphereMesh.worldPosition)

            // get the DOM #sphere size in the world space
            const sphereSize = sphereMesh.DOMObjectWorldScale.y

            // min distance so that the satellite sphere lies exactly at the border of our main sphere
            const minDistance = sphereSize + sphereSize * scale
            const distance = minDistance + sphereSize * minDistanceRatio

            // since we set the pivot position relative to our sphere world position
            // satellite position should be offseted by the same amount
            satelliteMesh.position.x = distance - sphereMesh.worldPosition.x

            // scale our sphere along the Z axis based on its height (Y axis scale)
            satelliteMesh.scale.z = satelliteMesh.worldScale.y

            // look at our pivot center
            satelliteMesh.lookAt(pivot.position)
          }

          satelliteMesh.onAfterResize(updateSatelliteScale).onRender(() => {
            // rotate the pivot
            pivot.rotation.y += pivotRotationSpeed
          })

          updateSatelliteScale()
        }
      })
    </script>
  </body>
</html>
