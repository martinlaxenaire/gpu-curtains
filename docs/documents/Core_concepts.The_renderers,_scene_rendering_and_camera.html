<!DOCTYPE html><html class="default" lang="en" data-base=".."><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>The renderers, scene rendering and camera | gpu-curtains</title><link rel="icon" href="../assets/favicon.png" type="image/png"/><meta name="description" content="Documentation for gpu-curtains"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="../assets/style.css"/><link rel="stylesheet" href="../assets/highlight.css"/><script defer src="../assets/main.js"></script><script async src="../assets/icons.js" id="tsd-icons-script"></script><script async src="../assets/search.js" id="tsd-search-script"></script><script async src="../assets/navigation.js" id="tsd-nav-script"></script><script async src="../assets/hierarchy.js" id="tsd-hierarchy-script"></script></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os";document.body.style.display="none";setTimeout(() => app?app.showPage():document.body.style.removeProperty("display"),500)</script><header class="tsd-page-toolbar"><div class="tsd-toolbar-contents container"><div class="table-cell" id="tsd-search"><div class="field"><label for="tsd-search-field" class="tsd-widget tsd-toolbar-icon search no-caption"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><use href="../assets/icons.svg#icon-search"></use></svg></label><input type="text" id="tsd-search-field" aria-label="Search"/></div><div class="field"><div id="tsd-toolbar-links"><a href="https://github.com/martinlaxenaire/gpu-curtains">Repository</a><a href="https://martinlaxenaire.github.io/gpu-curtains/docs/">Docs</a><a href="https://martinlaxenaire.github.io/gpu-curtains/examples/">Examples</a></div></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="https://martinlaxenaire.github.io/gpu-curtains/" class="title">gpu-curtains</a></div><div class="table-cell" id="tsd-widgets"><a href="#" class="tsd-widget tsd-toolbar-icon menu no-caption" data-toggle="menu" aria-label="Menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><use href="../assets/icons.svg#icon-menu"></use></svg></a></div></div></header><div class="container container-main"><div class="col-content"><div class="tsd-page-title"><ul class="tsd-breadcrumb"><li><a href="../modules.html">gpu-curtains</a></li><li><a href="Core_concepts.html">Core concepts</a></li><li><a href="Core_concepts.The_renderers,_scene_rendering_and_camera.html">The renderers, scene rendering and camera</a></li></ul></div><div class="tsd-panel tsd-typography"><a id="the-renderers-scene-rendering-and-camera" class="tsd-anchor"></a><h1 class="tsd-anchor-link">The renderers, scene rendering and camera<a href="#the-renderers-scene-rendering-and-camera" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h1><p>The scene rendering and eventually camera are taken care of by gpu-curtains renderers under the hood. But you can always render meshes and compute passes on demand if you prefer.</p>
<p>Let's see in detail how gpu-curtains handle internally the <a href="../classes/core_scenes_Scene.Scene.html" class="tsd-kind-class">Scene</a> class, the scene graph, the camera projection, and the lighting setup, and how you can decide to opt out of some of those features.</p>
<a id="the-renderers" class="tsd-anchor"></a><h2 class="tsd-anchor-link">The renderers<a href="#the-renderers" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>gpu-curtains’ library core exposes 2 renderers, the <a href="../classes/core_renderers_GPURenderer.GPURenderer.html" class="tsd-kind-class">GPURenderer</a> and the <a href="../classes/core_renderers_GPUCameraRenderer.GPUCameraRenderer.html" class="tsd-kind-class">GPUCameraRenderer</a> that extends the <a href="../classes/core_renderers_GPURenderer.GPURenderer.html" class="tsd-kind-class">GPURenderer</a>.</p>
<p>They both need at least a <a href="../classes/core_renderers_GPUDeviceManager.GPUDeviceManager.html" class="tsd-kind-class">GPUDeviceManager</a>, that handles the WebGPU device and adapter, and a canvas HTML element in order to be created.</p>
<a id="gpurenderer" class="tsd-anchor"></a><h3 class="tsd-anchor-link">GPURenderer<a href="#gpurenderer" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>This is the base renderer. When created it automatically uses a <a href="../classes/core_scenes_Scene.Scene.html" class="tsd-kind-class">Scene</a> class instance object, where all meshes, shader passes or compute passes will be added and automatically rendered in the right order.</p>
<p>It is mostly useful to render fullscreen quad meshes, shader passes (post processing effects) and/or compute passes.
It is therefore best suited for background effects or shadertoy like usage.</p>
<p>This renderer can handle:</p>
<ul>
<li><a href="../classes/core_meshes_FullscreenPlane.FullscreenPlane.html" class="tsd-kind-class">FullscreenPlane</a>
<ul>
<li><a href="../classes/core_renderPasses_ShaderPass.ShaderPass.html" class="tsd-kind-class">ShaderPass</a></li>
<li><a href="../classes/extras_meshes_PingPongPlane.PingPongPlane.html" class="tsd-kind-class">PingPongPlane</a></li>
</ul>
</li>
<li><a href="../classes/core_computePasses_ComputePass.ComputePass.html" class="tsd-kind-class">ComputePass</a></li>
</ul>
<pre><code class="javascript"><span class="hl-6">// first, we need a WebGPU device, that&#39;s what GPUDeviceManager is for</span><br/><span class="hl-5">const</span><span class="hl-1"> </span><span class="hl-7">gpuDeviceManager</span><span class="hl-1"> = </span><span class="hl-5">new</span><span class="hl-1"> </span><span class="hl-4">GPUDeviceManager</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-2">label:</span><span class="hl-1"> </span><span class="hl-3">&#39;Custom device manager&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">})</span><br/><br/><span class="hl-6">// we need to wait for the device to be created</span><br/><span class="hl-0">await</span><span class="hl-1"> </span><span class="hl-2">gpuDeviceManager</span><span class="hl-1">.</span><span class="hl-4">init</span><span class="hl-1">()</span><br/><br/><span class="hl-6">// then we can create a basic renderer</span><br/><span class="hl-6">// no need for camera or DOM syncing here</span><br/><span class="hl-5">const</span><span class="hl-1"> </span><span class="hl-7">gpuRenderer</span><span class="hl-1"> = </span><span class="hl-5">new</span><span class="hl-1"> </span><span class="hl-4">GPURenderer</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-2">label:</span><span class="hl-1"> </span><span class="hl-3">&#39;Basic GPU Renderer&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-2">deviceManager:</span><span class="hl-1"> </span><span class="hl-2">gpuDeviceManager</span><span class="hl-1">, </span><span class="hl-6">// the renderer is going to use our WebGPU device to create its context</span><br/><span class="hl-1">  </span><span class="hl-2">container:</span><span class="hl-1"> </span><span class="hl-2">document</span><span class="hl-1">.</span><span class="hl-4">querySelector</span><span class="hl-1">(</span><span class="hl-3">&#39;#canvas&#39;</span><span class="hl-1">),</span><br/><span class="hl-1">})</span>
</code><button type="button">Copy</button></pre>

<a id="gpucamerarenderer" class="tsd-anchor"></a><h3 class="tsd-anchor-link">GPUCameraRenderer<a href="#gpucamerarenderer" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>This is the renderer you’ll use if you want to render a typical 3D scene.
It internally creates a <a href="../classes/core_cameras_PerspectiveCamera.PerspectiveCamera.html" class="tsd-kind-class">PerspectiveCamera</a> and a <a href="../classes/core_bindings_BufferBinding.BufferBinding.html" class="tsd-kind-class">BufferBinding</a> for its matrices, as well as optional <a href="../classes/core_bindings_BufferBinding.BufferBinding.html" class="tsd-kind-class">buffer bindings</a> for the lights and shadows, a put all of them in a
<a href="../classes/core_bindGroups_BindGroup.BindGroup.html" class="tsd-kind-class">BindGroup</a>.
This bind group will be automatically added to all the meshes that should be projected onto the screen using the camera projection and view matrices.</p>
<p>This renderer can handle:</p>
<ul>
<li><a href="../classes/core_meshes_FullscreenPlane.FullscreenPlane.html" class="tsd-kind-class">FullscreenPlane</a>
<ul>
<li><a href="../classes/core_renderPasses_ShaderPass.ShaderPass.html" class="tsd-kind-class">ShaderPass</a></li>
<li><a href="../classes/extras_meshes_PingPongPlane.PingPongPlane.html" class="tsd-kind-class">PingPongPlane</a></li>
</ul>
</li>
<li><a href="../classes/core_meshes_Mesh.Mesh.html" class="tsd-kind-class">Mesh</a></li>
<li><a href="../classes/core_computePasses_ComputePass.ComputePass.html" class="tsd-kind-class">ComputePass</a></li>
</ul>
<pre><code class="javascript"><span class="hl-6">// first, we need a WebGPU device, that&#39;s what GPUDeviceManager is for</span><br/><span class="hl-5">const</span><span class="hl-1"> </span><span class="hl-7">gpuDeviceManager</span><span class="hl-1"> = </span><span class="hl-5">new</span><span class="hl-1"> </span><span class="hl-4">GPUDeviceManager</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-2">label:</span><span class="hl-1"> </span><span class="hl-3">&#39;Custom device manager&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">})</span><br/><br/><span class="hl-6">// we need to wait for the device to be created</span><br/><span class="hl-0">await</span><span class="hl-1"> </span><span class="hl-2">gpuDeviceManager</span><span class="hl-1">.</span><span class="hl-4">init</span><span class="hl-1">()</span><br/><br/><span class="hl-6">// then we can create a camera renderer</span><br/><span class="hl-5">const</span><span class="hl-1"> </span><span class="hl-7">gpuCameraRenderer</span><span class="hl-1"> = </span><span class="hl-5">new</span><span class="hl-1"> </span><span class="hl-4">GPUCameraRenderer</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-2">label:</span><span class="hl-1"> </span><span class="hl-3">&#39;GPU Camera Renderer&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-2">deviceManager:</span><span class="hl-1"> </span><span class="hl-2">gpuDeviceManager</span><span class="hl-1">, </span><span class="hl-6">// the renderer is going to use our WebGPU device to create its context</span><br/><span class="hl-1">  </span><span class="hl-2">container:</span><span class="hl-1"> </span><span class="hl-2">document</span><span class="hl-1">.</span><span class="hl-4">querySelector</span><span class="hl-1">(</span><span class="hl-3">&#39;#canvas&#39;</span><span class="hl-1">),</span><br/><span class="hl-1">})</span>
</code><button type="button">Copy</button></pre>

<a id="gpucurtainsrenderer" class="tsd-anchor"></a><h3 class="tsd-anchor-link">GPUCurtainsRenderer<a href="#gpucurtainsrenderer" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Finally, there’s a third renderer available, even tho it’s not part of the core but of the “curtains” part. The
<a href="../classes/curtains_renderers_GPUCurtainsRenderer.GPUCurtainsRenderer.html" class="tsd-kind-class">GPUCurtainsRenderer</a> extends the <a href="../classes/core_renderers_GPUCameraRenderer.GPUCameraRenderer.html" class="tsd-kind-class">GPUCameraRenderer</a> and is used to keep track of the special DOM synced <a href="../classes/curtains_meshes_DOMMesh.DOMMesh.html" class="tsd-kind-class">DOMMesh</a> and <a href="../classes/curtains_meshes_Plane.Plane.html" class="tsd-kind-class">Plane</a> meshes.</p>
<p>This renderer can handle:</p>
<ul>
<li><a href="../classes/core_meshes_FullscreenPlane.FullscreenPlane.html" class="tsd-kind-class">FullscreenPlane</a>
<ul>
<li><a href="../classes/core_renderPasses_ShaderPass.ShaderPass.html" class="tsd-kind-class">ShaderPass</a></li>
<li><a href="../classes/extras_meshes_PingPongPlane.PingPongPlane.html" class="tsd-kind-class">PingPongPlane</a></li>
</ul>
</li>
<li><a href="../classes/core_meshes_Mesh.Mesh.html" class="tsd-kind-class">Mesh</a></li>
<li><a href="../classes/curtains_meshes_DOMMesh.DOMMesh.html" class="tsd-kind-class">DOMMesh</a>
<ul>
<li><a href="../classes/curtains_meshes_Plane.Plane.html" class="tsd-kind-class">Plane</a></li>
</ul>
</li>
<li><a href="../classes/core_computePasses_ComputePass.ComputePass.html" class="tsd-kind-class">ComputePass</a></li>
</ul>
<p>Most of the time, you'll be using the default one created by a <a href="../classes/curtains_GPUCurtains.GPUCurtains.html" class="tsd-kind-class"> curtains/GPUCurtains.GPUCurtains</a> instance:</p>
<pre><code class="javascript"><span class="hl-6">// set our main GPUCurtains instance it will handle everything we need</span><br/><span class="hl-6">// a WebGPU device and a renderer with its scene, requestAnimationFrame, resize and scroll events...</span><br/><span class="hl-5">const</span><span class="hl-1"> </span><span class="hl-7">gpuCurtains</span><span class="hl-1"> = </span><span class="hl-5">new</span><span class="hl-1"> </span><span class="hl-4">GPUCurtains</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-2">container:</span><span class="hl-1"> </span><span class="hl-3">&#39;#canvas&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">})</span><br/><br/><span class="hl-6">// set the GPU device (note this is asynchronous)</span><br/><span class="hl-0">await</span><span class="hl-1"> </span><span class="hl-2">gpuCurtains</span><span class="hl-1">.</span><span class="hl-4">setDevice</span><span class="hl-1">()</span><br/><br/><span class="hl-6">// get the automatically created GPUCurtainsRenderer</span><br/><span class="hl-5">const</span><span class="hl-1"> { </span><span class="hl-7">renderer</span><span class="hl-1"> } = </span><span class="hl-2">gpuCurtains</span>
</code><button type="button">Copy</button></pre>

<a id="the-renderers-scene" class="tsd-anchor"></a><h2 class="tsd-anchor-link">The renderers’ scene<a href="#the-renderers-scene" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Each renderer is therefore responsible for its own scene, where the meshes will be automatically added and stacked using criterias such as:</p>
<ul>
<li>Unprotected vs projected (i.e. does it need to use the eventual renderer camera and light bind group)</li>
<li>Opaque and transparent</li>
<li>Render order property</li>
</ul>
<p>Compute passes are executed before drawing the meshes, and shader passes after.</p>
<a id="opt-out-of-the-scene-stack" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Opt out of the scene stack<a href="#opt-out-of-the-scene-stack" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>When creating any kind of meshes or compute pass, you can decide to not add it to the scene by setting the <code>autoRender</code> parameter to false.</p>
<p>That way, you’ll opt out of the scene rendering stack, but then you’d have to manually render the object somewhere in your code. It could be once on init, or once after an event happened, or each frame. It’s up to you.</p>
<pre><code class="javascript"><span class="hl-6">// first, we need a WebGPU device, that&#39;s what GPUDeviceManager is for</span><br/><span class="hl-5">const</span><span class="hl-1"> </span><span class="hl-7">gpuDeviceManager</span><span class="hl-1"> = </span><span class="hl-5">new</span><span class="hl-1"> </span><span class="hl-4">GPUDeviceManager</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-2">label:</span><span class="hl-1"> </span><span class="hl-3">&#39;Custom device manager&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">})</span><br/><br/><span class="hl-6">// we need to wait for the device to be created</span><br/><span class="hl-0">await</span><span class="hl-1"> </span><span class="hl-2">gpuDeviceManager</span><span class="hl-1">.</span><span class="hl-4">init</span><span class="hl-1">()</span><br/><br/><span class="hl-6">// then we can create a camera renderer</span><br/><span class="hl-5">const</span><span class="hl-1"> </span><span class="hl-7">gpuCameraRenderer</span><span class="hl-1"> = </span><span class="hl-5">new</span><span class="hl-1"> </span><span class="hl-4">GPUCameraRenderer</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-2">label:</span><span class="hl-1"> </span><span class="hl-3">&#39;GPU Camera Renderer&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-2">deviceManager:</span><span class="hl-1"> </span><span class="hl-2">gpuDeviceManager</span><span class="hl-1">, </span><span class="hl-6">// the renderer is going to use our WebGPU device to create its context</span><br/><span class="hl-1">  </span><span class="hl-2">container:</span><span class="hl-1"> </span><span class="hl-2">document</span><span class="hl-1">.</span><span class="hl-4">querySelector</span><span class="hl-1">(</span><span class="hl-3">&#39;#canvas&#39;</span><span class="hl-1">),</span><br/><span class="hl-1">  </span><span class="hl-2">lights:</span><span class="hl-1"> </span><span class="hl-5">false</span><span class="hl-1"> </span><span class="hl-6">// do not use lights</span><br/><span class="hl-1">})</span><br/><br/><span class="hl-6">// create a mesh that will be rendered just once</span><br/><span class="hl-5">const</span><span class="hl-1"> </span><span class="hl-7">mesh</span><span class="hl-1"> = </span><span class="hl-5">new</span><span class="hl-1"> </span><span class="hl-4">Mesh</span><span class="hl-1">(</span><span class="hl-2">gpuCameraRenderer</span><span class="hl-1">, {</span><br/><span class="hl-1">  </span><span class="hl-2">label:</span><span class="hl-1"> </span><span class="hl-3">&#39;Mesh rendered once&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-2">geometry:</span><span class="hl-1"> </span><span class="hl-5">new</span><span class="hl-1"> </span><span class="hl-4">BoxGeometry</span><span class="hl-1">(),</span><br/><span class="hl-1">  </span><span class="hl-2">autoRender:</span><span class="hl-1"> </span><span class="hl-5">false</span><span class="hl-1">, </span><span class="hl-6">// do not add it to the renderer scene</span><br/><span class="hl-1">})</span><br/><br/><span class="hl-6">// compile its material</span><br/><span class="hl-0">await</span><span class="hl-1"> </span><span class="hl-2">mesh</span><span class="hl-1">.</span><span class="hl-2">material</span><span class="hl-1">.</span><span class="hl-4">compileMaterial</span><span class="hl-1">()</span><br/><br/><span class="hl-6">// render once</span><br/><span class="hl-2">gpuCameraRenderer</span><span class="hl-1">.</span><span class="hl-4">renderOnce</span><span class="hl-1">([</span><span class="hl-2">mesh</span><span class="hl-1">])</span>
</code><button type="button">Copy</button></pre>

<a id="increase-or-disable-the-lights-buffers" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Increase or disable the lights buffers<a href="#increase-or-disable-the-lights-buffers" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The <a href="../classes/core_renderers_GPUCameraRenderer.GPUCameraRenderer.html" class="tsd-kind-class">GPUCameraRenderer</a> and <a href="../classes/curtains_renderers_GPUCurtainsRenderer.GPUCurtainsRenderer.html" class="tsd-kind-class">GPUCurtainsRenderer</a> both create fixed size buffers for your lighting setup. You can increase each light type buffers capacities or even disable them if you don’t need lighting by using the <code>lights</code> parameter when creating them.</p>
<a id="custom-lights-buffers" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Custom lights buffers<a href="#custom-lights-buffers" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h4><pre><code class="javascript"><span class="hl-6">// first, we need a WebGPU device, that&#39;s what GPUDeviceManager is for</span><br/><span class="hl-5">const</span><span class="hl-1"> </span><span class="hl-7">gpuDeviceManager</span><span class="hl-1"> = </span><span class="hl-5">new</span><span class="hl-1"> </span><span class="hl-4">GPUDeviceManager</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-2">label:</span><span class="hl-1"> </span><span class="hl-3">&#39;Custom device manager&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">})</span><br/><br/><span class="hl-6">// we need to wait for the device to be created</span><br/><span class="hl-0">await</span><span class="hl-1"> </span><span class="hl-2">gpuDeviceManager</span><span class="hl-1">.</span><span class="hl-4">init</span><span class="hl-1">()</span><br/><br/><span class="hl-6">// then we can create a basic renderer</span><br/><span class="hl-6">// no need for camera or DOM syncing here</span><br/><span class="hl-5">const</span><span class="hl-1"> </span><span class="hl-7">gpuCameraRenderer</span><span class="hl-1"> = </span><span class="hl-5">new</span><span class="hl-1"> </span><span class="hl-4">GPUCameraRenderer</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-2">label:</span><span class="hl-1"> </span><span class="hl-3">&#39;GPU Camera Renderer with custom lights setup&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-2">deviceManager:</span><span class="hl-1"> </span><span class="hl-2">gpuDeviceManager</span><span class="hl-1">, </span><span class="hl-6">// the renderer is going to use our WebGPU device to create its context</span><br/><span class="hl-1">  </span><span class="hl-2">container:</span><span class="hl-1"> </span><span class="hl-2">document</span><span class="hl-1">.</span><span class="hl-4">querySelector</span><span class="hl-1">(</span><span class="hl-3">&#39;#canvas&#39;</span><span class="hl-1">),</span><br/><span class="hl-1">  </span><span class="hl-2">lights:</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-2">maxAmbientLights:</span><span class="hl-1"> </span><span class="hl-15">5</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-2">maxDirectionalLights:</span><span class="hl-1"> </span><span class="hl-15">50</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-2">maxPointLights:</span><span class="hl-1"> </span><span class="hl-15">1</span><span class="hl-1">,</span><br/><span class="hl-1">  }</span><br/><span class="hl-1">})</span>
</code><button type="button">Copy</button></pre>

<a id="disable-lights-buffers" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Disable lights buffers<a href="#disable-lights-buffers" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h4><pre><code class="javascript"><span class="hl-6">// first, we need a WebGPU device, that&#39;s what GPUDeviceManager is for</span><br/><span class="hl-5">const</span><span class="hl-1"> </span><span class="hl-7">gpuDeviceManager</span><span class="hl-1"> = </span><span class="hl-5">new</span><span class="hl-1"> </span><span class="hl-4">GPUDeviceManager</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-2">label:</span><span class="hl-1"> </span><span class="hl-3">&#39;Custom device manager&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">})</span><br/><br/><span class="hl-6">// we need to wait for the device to be created</span><br/><span class="hl-0">await</span><span class="hl-1"> </span><span class="hl-2">gpuDeviceManager</span><span class="hl-1">.</span><span class="hl-4">init</span><span class="hl-1">()</span><br/><br/><span class="hl-6">// then we can create a basic renderer</span><br/><span class="hl-6">// no need for camera or DOM syncing here</span><br/><span class="hl-5">const</span><span class="hl-1"> </span><span class="hl-7">gpuCameraRenderer</span><span class="hl-1"> = </span><span class="hl-5">new</span><span class="hl-1"> </span><span class="hl-4">GPUCameraRenderer</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-2">label:</span><span class="hl-1"> </span><span class="hl-3">&#39;GPU Camera Renderer without lights&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-2">deviceManager:</span><span class="hl-1"> </span><span class="hl-2">gpuDeviceManager</span><span class="hl-1">, </span><span class="hl-6">// the renderer is going to use our WebGPU device to create its context</span><br/><span class="hl-1">  </span><span class="hl-2">container:</span><span class="hl-1"> </span><span class="hl-2">document</span><span class="hl-1">.</span><span class="hl-4">querySelector</span><span class="hl-1">(</span><span class="hl-3">&#39;#canvas&#39;</span><span class="hl-1">),</span><br/><span class="hl-1">  </span><span class="hl-2">lights:</span><span class="hl-1"> </span><span class="hl-5">false</span><span class="hl-1"> </span><span class="hl-6">// do not use lights</span><br/><span class="hl-1">})</span>
</code><button type="button">Copy</button></pre>

</div></div><div class="col-sidebar"><div class="page-menu"><div class="tsd-navigation settings"><details class="tsd-accordion"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><use href="../assets/icons.svg#icon-chevronDown"></use></svg>Settings</h3></summary><div class="tsd-accordion-details"><div class="tsd-filter-visibility"><span class="settings-label">Member Visibility</span><ul id="tsd-filter-options"><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Protected</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Inherited</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-external" name="external"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>External</span></label></li></ul></div><div class="tsd-theme-toggle"><label class="settings-label" for="tsd-theme">Theme</label><select id="tsd-theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></div></div></details></div><details open class="tsd-accordion tsd-page-navigation"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><use href="../assets/icons.svg#icon-chevronDown"></use></svg>On This Page</h3></summary><div class="tsd-accordion-details"><a href="#the-renderers-scene-rendering-and-camera"><span>The renderers, scene rendering and camera</span></a><ul><li><a href="#the-renderers"><span>The renderers</span></a></li><li><ul><li><a href="#gpurenderer"><span>GPURenderer</span></a></li><li><a href="#gpucamerarenderer"><span>GPUCamera<wbr/>Renderer</span></a></li><li><a href="#gpucurtainsrenderer"><span>GPUCurtains<wbr/>Renderer</span></a></li></ul></li><li><a href="#the-renderers-scene"><span>The renderers’ scene</span></a></li><li><ul><li><a href="#opt-out-of-the-scene-stack"><span>Opt out of the scene stack</span></a></li><li><a href="#increase-or-disable-the-lights-buffers"><span>Increase or disable the lights buffers</span></a></li><li><ul><li><a href="#custom-lights-buffers"><span>Custom lights buffers</span></a></li><li><a href="#disable-lights-buffers"><span>Disable lights buffers</span></a></li></ul></li></ul></li></ul></div></details></div><div class="site-menu"><nav id="tsd-sidebar-links" class="tsd-navigation"><a href="https://github.com/martinlaxenaire/gpu-curtains" class="tsd-nav-link">Repository</a><a href="https://martinlaxenaire.github.io/gpu-curtains/docs/" class="tsd-nav-link">Docs</a><a href="https://martinlaxenaire.github.io/gpu-curtains/examples/" class="tsd-nav-link">Examples</a></nav><nav class="tsd-navigation"><a href="../modules.html">gpu-curtains</a><ul class="tsd-small-nested-navigation" id="tsd-nav-container"><li>Loading...</li></ul></nav></div></div></div><footer></footer><div class="overlay"></div><script defer src="https://cloud.umami.is/script.js" data-website-id="5633e080-94cc-462b-9158-a45314c01630" data-domains="martinlaxenaire.github.io"></script></body></html>
