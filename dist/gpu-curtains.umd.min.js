(function(x,Y){typeof exports=="object"&&typeof module<"u"?Y(exports):typeof define=="function"&&define.amd?define(["exports"],Y):(x=typeof globalThis<"u"?globalThis:x||self,Y(x.window=x.window||{}))})(this,function(x){"use strict";const Y=()=>"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,n=>{const e=Math.random()*16|0;return(n==="x"?e:e&3|8).toString(16).toUpperCase()}),it=n=>n.replace(/(?:^\w|[A-Z]|\b\w)/g,(e,t)=>t===0?e.toLowerCase():e.toUpperCase()).replace(/\s+/g,""),st=n=>{const e=it(n);return e.charAt(0).toUpperCase()+e.slice(1)};let Si=0;const L=n=>{Si>100||(console.warn(Si===100?"GPUCurtains: too many warnings thrown, stop logging.":n),Si++)},ie=n=>{throw new Error(n)},Pi=(n,e="GPURenderer",t)=>{const i=t?`Unable to create ${t} because the ${e} is not defined: ${n}`:`The ${e} is not defined: ${n}`;ie(i)},W=(n,e)=>(n=n&&n.renderer||n,n&&(n.type==="GPURenderer"||n.type==="GPUCameraRenderer"||n.type==="GPUCurtainsRenderer")||Pi(n,"GPURenderer",e),n),Le=(n,e)=>(n=n&&n.renderer||n,n&&(n.type==="GPUCameraRenderer"||n.type==="GPUCurtainsRenderer")||Pi(n,"GPUCameraRenderer",e),n),Ti=(n,e)=>(n=n&&n.renderer||n,n&&n.type==="GPUCurtainsRenderer"||Pi(n,"GPUCurtainsRenderer",e),n),vn=n=>n.constructor.name==="Mesh"||n.constructor.name==="DOMMesh"||n.constructor.name==="Plane"?n:!1,Ri=(()=>{let n,e;const t={};return function(s,r){e||(e=s.createShaderModule({label:"textured quad shaders for mip level generation",code:`
            struct VSOutput {
              @builtin(position) position: vec4f,
              @location(0) texcoord: vec2f,
            };

            @vertex fn vs(
              @builtin(vertex_index) vertexIndex : u32
            ) -> VSOutput {
              let pos = array(

                vec2f( 0.0,  0.0),  // center
                vec2f( 1.0,  0.0),  // right, center
                vec2f( 0.0,  1.0),  // center, top

                // 2st triangle
                vec2f( 0.0,  1.0),  // center, top
                vec2f( 1.0,  0.0),  // right, center
                vec2f( 1.0,  1.0),  // right, top
              );

              var vsOutput: VSOutput;
              let xy = pos[vertexIndex];
              vsOutput.position = vec4f(xy * 2.0 - 1.0, 0.0, 1.0);
              vsOutput.texcoord = vec2f(xy.x, 1.0 - xy.y);
              return vsOutput;
            }

            @group(0) @binding(0) var ourSampler: sampler;
            @group(0) @binding(1) var ourTexture: texture_2d<f32>;

            @fragment fn fs(fsInput: VSOutput) -> @location(0) vec4f {
              return textureSample(ourTexture, ourSampler, fsInput.texcoord);
            }
          `}),n=s.createSampler({minFilter:"linear",magFilter:"linear"})),t[r.format]||(t[r.format]=s.createRenderPipeline({label:"Mip level generator pipeline",layout:"auto",vertex:{module:e},fragment:{module:e,targets:[{format:r.format}]}}));const o=t[r.format],a=s.createCommandEncoder({label:"Mip gen encoder"});let h=r.width,l=r.height,u=0;for(;h>1||l>1;){h=Math.max(1,h/2|0),l=Math.max(1,l/2|0);for(let c=0;c<r.depthOrArrayLayers;++c){const p=s.createBindGroup({layout:o.getBindGroupLayout(0),entries:[{binding:0,resource:n},{binding:1,resource:r.createView({dimension:"2d",baseMipLevel:u,mipLevelCount:1,baseArrayLayer:c,arrayLayerCount:1})}]}),g={label:"Mip generation render pass",colorAttachments:[{view:r.createView({dimension:"2d",baseMipLevel:u+1,mipLevelCount:1,baseArrayLayer:c,arrayLayerCount:1}),loadOp:"clear",storeOp:"store"}]},m=a.beginRenderPass(g);m.setPipeline(o),m.setBindGroup(0,p),m.draw(6),m.end()}++u}const d=a.finish();s.queue.submit([d])}})(),wn=new Map([["vertex",GPUShaderStage.VERTEX],["fragment",GPUShaderStage.FRAGMENT],["compute",GPUShaderStage.COMPUTE]]),bn=(n=[])=>n.reduce((e,t)=>e|wn.get(t),0),Bn={i32:{numElements:1,align:4,size:4,type:"i32",View:Int32Array},u32:{numElements:1,align:4,size:4,type:"u32",View:Uint32Array},f32:{numElements:1,align:4,size:4,type:"f32",View:Float32Array},f16:{numElements:1,align:2,size:2,type:"u16",View:Uint16Array},vec2f:{numElements:2,align:8,size:8,type:"f32",View:Float32Array},vec2i:{numElements:2,align:8,size:8,type:"i32",View:Int32Array},vec2u:{numElements:2,align:8,size:8,type:"u32",View:Uint32Array},vec2h:{numElements:2,align:4,size:4,type:"u16",View:Uint16Array},vec3i:{numElements:3,align:16,size:12,type:"i32",View:Int32Array},vec3u:{numElements:3,align:16,size:12,type:"u32",View:Uint32Array},vec3f:{numElements:3,align:16,size:12,type:"f32",View:Float32Array},vec3h:{numElements:3,align:8,size:6,type:"u16",View:Uint16Array},vec4i:{numElements:4,align:16,size:16,type:"i32",View:Int32Array},vec4u:{numElements:4,align:16,size:16,type:"u32",View:Uint32Array},vec4f:{numElements:4,align:16,size:16,type:"f32",View:Float32Array},vec4h:{numElements:4,align:8,size:8,type:"u16",View:Uint16Array},mat2x2f:{numElements:4,align:8,size:16,type:"f32",View:Float32Array},mat2x2h:{numElements:4,align:4,size:8,type:"u16",View:Uint16Array},mat3x2f:{numElements:6,align:8,size:24,type:"f32",View:Float32Array},mat3x2h:{numElements:6,align:4,size:12,type:"u16",View:Uint16Array},mat4x2f:{numElements:8,align:8,size:32,type:"f32",View:Float32Array},mat4x2h:{numElements:8,align:4,size:16,type:"u16",View:Uint16Array},mat2x3f:{numElements:8,align:16,size:32,pad:[3,1],type:"f32",View:Float32Array},mat2x3h:{numElements:8,align:8,size:16,pad:[3,1],type:"u16",View:Uint16Array},mat3x3f:{numElements:12,align:16,size:48,pad:[3,1],type:"f32",View:Float32Array},mat3x3h:{numElements:12,align:8,size:24,pad:[3,1],type:"u16",View:Uint16Array},mat4x3f:{numElements:16,align:16,size:64,pad:[3,1],type:"f32",View:Float32Array},mat4x3h:{numElements:16,align:8,size:32,pad:[3,1],type:"u16",View:Uint16Array},mat2x4f:{numElements:8,align:16,size:32,type:"f32",View:Float32Array},mat2x4h:{numElements:8,align:8,size:16,type:"u16",View:Uint16Array},mat3x4f:{numElements:12,align:16,size:48,pad:[3,1],type:"f32",View:Float32Array},mat3x4h:{numElements:12,align:8,size:24,pad:[3,1],type:"u16",View:Uint16Array},mat4x4f:{numElements:16,align:16,size:64,type:"f32",View:Float32Array},mat4x4h:{numElements:16,align:8,size:32,type:"u16",View:Uint16Array}},ks=n=>Bn[n],Tt=n=>(()=>{switch(n.bindingType){case"storage":return`var<${n.bindingType}, ${n.options.access}>`;case"uniform":default:return"var<uniform>"}})(),Mn=n=>n.bindingType==="externalTexture"?`var ${n.name}: texture_external;`:n.bindingType==="storage"?`var ${n.name}: texture_storage_${n.options.viewDimension.replace("-","_")}<${n.options.format}, ${n.options.access}>;`:n.bindingType==="depth"?`var ${n.name}: texture_depth${n.options.multisampled?"_multisampled":""}_${n.options.viewDimension.replace("-","_")};`:`var ${n.name}: texture${n.options.multisampled?"_multisampled":""}_${n.options.viewDimension.replace("-","_")}<f32>;`,zi=n=>n.bindingType==="storage"&&n.options.access==="read_write"?"storage":n.bindingType==="storage"?"read-only-storage":"uniform",Cn=n=>(()=>{switch(n.bindingType){case"externalTexture":return{externalTexture:{}};case"storage":return{storageTexture:{format:n.options.format,viewDimension:n.options.viewDimension}};case"texture":return{texture:{multisampled:n.options.multisampled,viewDimension:n.options.viewDimension,sampleType:n.options.multisampled?"unfilterable-float":"float"}};case"depth":return{texture:{multisampled:n.options.multisampled,viewDimension:n.options.viewDimension,sampleType:"depth"}};default:return null}})(),Sn=n=>(()=>{switch(n.bindingType){case"externalTexture":return`externalTexture,${n.visibility},`;case"storage":return`storageTexture,${n.options.format},${n.options.viewDimension},${n.visibility},`;case"texture":return`texture,${n.options.multisampled},${n.options.viewDimension},${n.options.multisampled?"unfilterable-float":"float"},${n.visibility},`;case"depth":return`depthTexture,${n.options.format},${n.options.viewDimension},${n.visibility},`;default:return`${n.visibility},`}})();class Rt{constructor({label:e="Uniform",name:t="uniform",bindingType:i="uniform",visibility:s=["vertex","fragment","compute"]}){this.label=e,this.name=it(t),this.bindingType=i,this.visibility=bn(s),this.options={label:e,name:t,bindingType:i,visibility:s},this.shouldResetBindGroup=!1,this.shouldResetBindGroupLayout=!1,this.cacheKey=`${i},${this.visibility},`}}class _{constructor(e=0,t=e){this.type="Vec2",this._x=e,this._y=t}get x(){return this._x}set x(e){const t=e!==this._x;this._x=e,t&&this._onChangeCallback&&this._onChangeCallback()}get y(){return this._y}set y(e){const t=e!==this._y;this._y=e,t&&this._onChangeCallback&&this._onChangeCallback()}onChange(e){return e&&(this._onChangeCallback=e),this}set(e=0,t=e){return this.x=e,this.y=t,this}add(e=new _){return this.x+=e.x,this.y+=e.y,this}addScalar(e=0){return this.x+=e,this.y+=e,this}sub(e=new _){return this.x-=e.x,this.y-=e.y,this}subScalar(e=0){return this.x-=e,this.y-=e,this}multiply(e=new _(1)){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e=1){return this.x*=e,this.y*=e,this}divide(e=new _(1)){return this.x/=e.x,this.y/=e.y,this}divideScalar(e=1){return this.x/=e,this.y/=e,this}copy(e=new _){return this.x=e.x,this.y=e.y,this}clone(){return new _(this.x,this.y)}max(e=new _){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}min(e=new _){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}clamp(e=new _,t=new _){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}equals(e=new _){return this.x===e.x&&this.y===e.y}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.lengthSq())}normalize(){let e=this.x*this.x+this.y*this.y;return e>0&&(e=1/Math.sqrt(e)),this.x*=e,this.y*=e,this}dot(e=new _){return this.x*e.x+this.y*e.y}lerp(e=new _,t=1){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}}class ce{constructor(e=new Float32Array([0,0,0,1]),t="XYZ"){this.type="Quat",this.elements=e,this.axisOrder=t}setFromArray(e=new Float32Array([0,0,0,1])){return this.elements[0]=e[0],this.elements[1]=e[1],this.elements[2]=e[2],this.elements[3]=e[3],this}setAxisOrder(e="XYZ"){switch(e=e.toUpperCase(),e){case"XYZ":case"YXZ":case"ZXY":case"ZYX":case"YZX":case"XZY":this.axisOrder=e;break;default:this.axisOrder="XYZ"}return this}copy(e=new ce){return this.elements=e.elements,this.axisOrder=e.axisOrder,this}clone(){return new ce().copy(this)}equals(e=new ce){return this.elements[0]===e.elements[0]&&this.elements[1]===e.elements[1]&&this.elements[2]===e.elements[2]&&this.elements[3]===e.elements[3]&&this.axisOrder===e.axisOrder}setFromVec3(e){const t=e.x*.5,i=e.y*.5,s=e.z*.5,r=Math.cos(t),o=Math.cos(i),a=Math.cos(s),h=Math.sin(t),l=Math.sin(i),u=Math.sin(s);return this.axisOrder==="XYZ"?(this.elements[0]=h*o*a+r*l*u,this.elements[1]=r*l*a-h*o*u,this.elements[2]=r*o*u+h*l*a,this.elements[3]=r*o*a-h*l*u):this.axisOrder==="YXZ"?(this.elements[0]=h*o*a+r*l*u,this.elements[1]=r*l*a-h*o*u,this.elements[2]=r*o*u-h*l*a,this.elements[3]=r*o*a+h*l*u):this.axisOrder==="ZXY"?(this.elements[0]=h*o*a-r*l*u,this.elements[1]=r*l*a+h*o*u,this.elements[2]=r*o*u+h*l*a,this.elements[3]=r*o*a-h*l*u):this.axisOrder==="ZYX"?(this.elements[0]=h*o*a-r*l*u,this.elements[1]=r*l*a+h*o*u,this.elements[2]=r*o*u-h*l*a,this.elements[3]=r*o*a+h*l*u):this.axisOrder==="YZX"?(this.elements[0]=h*o*a+r*l*u,this.elements[1]=r*l*a+h*o*u,this.elements[2]=r*o*u-h*l*a,this.elements[3]=r*o*a-h*l*u):this.axisOrder==="XZY"&&(this.elements[0]=h*o*a-r*l*u,this.elements[1]=r*l*a-h*o*u,this.elements[2]=r*o*u+h*l*a,this.elements[3]=r*o*a+h*l*u),this}setFromAxisAngle(e,t=0){const i=t/2,s=Math.sin(i);return this.elements[0]=e.x*s,this.elements[1]=e.y*s,this.elements[2]=e.z*s,this.elements[3]=Math.cos(i),this}setFromRotationMatrix(e){const t=e.elements,i=t[0],s=t[4],r=t[8],o=t[1],a=t[5],h=t[9],l=t[2],u=t[6],d=t[10],c=i+a+d;if(c>0){const p=.5/Math.sqrt(c+1);this.elements[3]=.25/p,this.elements[0]=(u-h)*p,this.elements[1]=(r-l)*p,this.elements[2]=(o-s)*p}else if(i>a&&i>d){const p=2*Math.sqrt(1+i-a-d);this.elements[3]=(u-h)/p,this.elements[0]=.25*p,this.elements[1]=(s+o)/p,this.elements[2]=(r+l)/p}else if(a>d){const p=2*Math.sqrt(1+a-i-d);this.elements[3]=(r-l)/p,this.elements[0]=(s+o)/p,this.elements[1]=.25*p,this.elements[2]=(h+u)/p}else{const p=2*Math.sqrt(1+d-i-a);this.elements[3]=(o-s)/p,this.elements[0]=(r+l)/p,this.elements[1]=(h+u)/p,this.elements[2]=.25*p}return this}}class f{constructor(e=0,t=e,i=e){this.type="Vec3",this._x=e,this._y=t,this._z=i}get x(){return this._x}set x(e){const t=e!==this._x;this._x=e,t&&this._onChangeCallback&&this._onChangeCallback()}get y(){return this._y}set y(e){const t=e!==this._y;this._y=e,t&&this._onChangeCallback&&this._onChangeCallback()}get z(){return this._z}set z(e){const t=e!==this._z;this._z=e,t&&this._onChangeCallback&&this._onChangeCallback()}onChange(e){return e&&(this._onChangeCallback=e),this}set(e=0,t=e,i=e){return this.x=e,this.y=t,this.z=i,this}add(e=new f){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e=0){return this.x+=e,this.y+=e,this.z+=e,this}sub(e=new f){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e=0){return this.x-=e,this.y-=e,this.z-=e,this}multiply(e=new f(1)){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e=1){return this.x*=e,this.y*=e,this.z*=e,this}divide(e=new f(1)){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e=1){return this.x/=e,this.y/=e,this.z/=e,this}copy(e=new f){return this.x=e.x,this.y=e.y,this.z=e.z,this}clone(){return new f(this.x,this.y,this.z)}max(e=new f){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}min(e=new f){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}clamp(e=new f,t=new f){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}equals(e=new f){return this.x===e.x&&this.y===e.y&&this.z===e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.lengthSq())}distance(e=new f){return Math.hypot(e.x-this.x,e.y-this.y,e.z-this.z)}normalize(){let e=this.lengthSq();return e>0&&(e=1/Math.sqrt(e)),this.x*=e,this.y*=e,this.z*=e,this}dot(e=new f){return this.x*e.x+this.y*e.y+this.z*e.z}cross(e=new f){return this.crossVectors(this,e)}crossVectors(e=new f,t=new f){const i=e.x,s=e.y,r=e.z,o=t.x,a=t.y,h=t.z;return this.x=s*h-r*a,this.y=r*o-i*h,this.z=i*a-s*o,this}lerp(e=new f,t=1){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}applyMat4(e){const t=this._x,i=this._y,s=this._z,r=e.elements;let o=r[3]*t+r[7]*i+r[11]*s+r[15];return o=o||1,this.x=(r[0]*t+r[4]*i+r[8]*s+r[12])/o,this.y=(r[1]*t+r[5]*i+r[9]*s+r[13])/o,this.z=(r[2]*t+r[6]*i+r[10]*s+r[14])/o,this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}applyQuat(e=new ce){const t=this.x,i=this.y,s=this.z,r=e.elements[0],o=e.elements[1],a=e.elements[2],h=e.elements[3],l=h*t+o*s-a*i,u=h*i+a*t-r*s,d=h*s+r*i-o*t,c=-r*t-o*i-a*s;return this.x=l*h+c*-r+u*-a-d*-o,this.y=u*h+c*-o+d*-r-l*-a,this.z=d*h+c*-a+l*-o-u*-r,this}applyAxisAngle(e=new f,t=0,i=new ce){return this.applyQuat(i.setFromAxisAngle(e,t))}transformDirection(e){const t=this.x,i=this.y,s=this.z,r=e.elements;return this.x=r[0]*t+r[4]*i+r[8]*s,this.y=r[1]*t+r[5]*i+r[9]*s,this.z=r[2]*t+r[6]*i+r[10]*s,this.normalize()}project(e){return this.applyMat4(e.viewMatrix).applyMat4(e.projectionMatrix),this}unproject(e){return this.applyMat4(e.projectionMatrix.getInverse()).applyMat4(e.modelMatrix),this}}const Pn=4,zt=4,K=Pn*zt;class Ei{constructor({name:e,key:t,type:i="f32"}){this.name=e,this.key=t,this.type=i,this.bufferLayout=ks(this.type.replace("array","").replace("<","").replace(">","")),this.alignment={start:{row:0,byte:0},end:{row:0,byte:0}},this.setValue=null}get rowCount(){return this.alignment.end.row-this.alignment.start.row+1}get byteCount(){return Math.abs(this.endOffset-this.startOffset)+1}get paddedByteCount(){return(this.alignment.end.row+1)*K}get startOffset(){return this.getByteCountAtPosition(this.alignment.start)}get startOffsetToIndex(){return this.startOffset/zt}get endOffset(){return this.getByteCountAtPosition(this.alignment.end)}get endOffsetToIndex(){return Math.floor(this.endOffset/zt)}getPositionAtOffset(e=0){return{row:Math.floor(e/K),byte:e%K}}getByteCountAtPosition(e={row:0,byte:0}){return e.row*K+e.byte}applyOverflowToPosition(e={row:0,byte:0}){if(e.byte>K-1){const t=e.byte%K;e.row+=Math.floor(e.byte/K),e.byte=t}return e}getByteCountBetweenPositions(e={row:0,byte:0},t={row:0,byte:0}){return Math.abs(this.getByteCountAtPosition(t)-this.getByteCountAtPosition(e))}getElementAlignment(e={row:0,byte:0}){const t={start:e,end:e},{size:i,align:s}=this.bufferLayout;return e.byte%s!==0&&(e.byte+=e.byte%s),(i<=K&&e.byte+i>K||i>K&&(e.byte>K||e.byte>0))&&(e.row+=1,e.byte=0),t.end={row:e.row+Math.ceil(i/K)-1,byte:e.byte+(i%K===0?K-1:i%K-1)},t.end=this.applyOverflowToPosition(t.end),t}setAlignmentFromPosition(e={row:0,byte:0}){this.alignment=this.getElementAlignment(e)}setAlignment(e=0){this.setAlignmentFromPosition(this.getPositionAtOffset(e))}setView(e,t){this.view=new this.bufferLayout.View(e,this.startOffset,this.byteCount/this.bufferLayout.View.BYTES_PER_ELEMENT)}setValueFromFloat(e){this.view[0]=e}setValueFromVec2(e){this.view[0]=e.x??e[0]??0,this.view[1]=e.y??e[1]??0}setValueFromVec3(e){this.view[0]=e.x??e[0]??0,this.view[1]=e.y??e[1]??0,this.view[2]=e.z??e[2]??0}setValueFromMat4OrQuat(e){this.view.set(e.elements)}setValueFromMat3(e){this.setValueFromArrayWithPad(e.elements)}setValueFromArray(e){this.view.set(e)}setValueFromArrayWithPad(e){for(let t=0,i=0;t<this.view.length;t+=this.bufferLayout.pad[0]+this.bufferLayout.pad[1],i++)for(let s=0;s<this.bufferLayout.pad[0];s++)this.view[t+s]=e[t+s-i]}update(e){this.setValue||(this.setValue=(t=>{if(this.type==="f32"||this.type==="u32"||this.type==="i32")return this.setValueFromFloat;if(this.type==="vec2f")return this.setValueFromVec2;if(this.type==="vec3f")return this.setValueFromVec3;if(this.type==="mat3x3f")return t.elements?this.setValueFromMat3:this.setValueFromArrayWithPad;if(t.elements)return this.setValueFromMat4OrQuat;if(ArrayBuffer.isView(t)||Array.isArray(t))return this.bufferLayout.pad?this.setValueFromArrayWithPad:this.setValueFromArray;L(`${this.constructor.name}: value passed to ${this.name} cannot be used: ${t}`)})(e)),this.setValue(e)}extractDataFromBufferResult(e){return e.slice(this.startOffsetToIndex,this.endOffsetToIndex)}}class Is extends Ei{constructor({name:e,key:t,type:i="f32",arrayLength:s=1}){super({name:e,key:t,type:i}),this.arrayLength=s,this.numElements=Math.ceil(this.arrayLength/this.bufferLayout.numElements)}get arrayStrideToIndex(){return this.arrayStride/zt}setAlignment(e=0){super.setAlignment(e);const t=this.getElementAlignment(this.getPositionAtOffset(this.endOffset+1));this.arrayStride=this.getByteCountBetweenPositions(this.alignment.end,t.end),this.alignment.end=this.getPositionAtOffset(this.endOffset+this.arrayStride*(this.numElements-1))}setValueFromArray(e){let t=0;const i=this.byteCount/this.bufferLayout.View.BYTES_PER_ELEMENT,s=Math.ceil(i/this.numElements);for(let r=0;r<this.numElements;r++)for(let o=0;o<this.bufferLayout.numElements;o++)this.view[o+r*s]=e[t],t++}}class Li extends Is{constructor({name:e,key:t,type:i="f32",arrayLength:s=1}){super({name:e,key:t,type:i,arrayLength:s}),this.arrayStride=1,this.arrayLength=s,this.numElements=Math.ceil(this.arrayLength/this.bufferLayout.numElements)}get byteCount(){return this.bufferLayout.size*this.numElements}setAlignment(e=0,t=0){this.alignment=this.getElementAlignment(this.getPositionAtOffset(e)),this.arrayStride=t,this.alignment.end=this.getPositionAtOffset(this.endOffset+t*(this.numElements-1))}setView(e,t){this.view=new this.bufferLayout.View(this.bufferLayout.numElements*this.numElements),this.viewSetFunction=(i=>{switch(this.bufferLayout.View){case Int32Array:return i.setInt32.bind(i);case Uint16Array:return i.setUint16.bind(i);case Uint32Array:return i.setUint32.bind(i);case Float32Array:default:return i.setFloat32.bind(i)}})(t)}update(e){super.update(e);for(let t=0;t<this.numElements;t++){const i=this.view.subarray(t*this.bufferLayout.numElements,t*this.bufferLayout.numElements+this.bufferLayout.numElements),s=this.startOffset+t*this.arrayStride;i.forEach((r,o)=>{this.viewSetFunction(s+o*this.bufferLayout.View.BYTES_PER_ELEMENT,r,!0)})}}extractDataFromBufferResult(e){const t=new Float32Array(this.arrayLength);for(let i=0;i<this.numElements;i++){const s=this.startOffsetToIndex+i*this.arrayStrideToIndex;for(let r=0;r<this.bufferLayout.numElements;r++)t[i*this.bufferLayout.numElements+r]=e[s+r]}return t}}const Tn=new Map([["copySrc",GPUBufferUsage.COPY_SRC],["copyDst",GPUBufferUsage.COPY_DST],["index",GPUBufferUsage.INDEX],["indirect",GPUBufferUsage.INDIRECT],["mapRead",GPUBufferUsage.MAP_READ],["mapWrite",GPUBufferUsage.MAP_WRITE],["queryResolve",GPUBufferUsage.QUERY_RESOLVE],["storage",GPUBufferUsage.STORAGE],["uniform",GPUBufferUsage.UNIFORM],["vertex",GPUBufferUsage.VERTEX]]),Vs=(n=[])=>n.reduce((e,t)=>e|Tn.get(t),0);class Ie{constructor({label:e="Buffer",size:t=0,usage:i=["copySrc","copyDst"],mappedAtCreation:s=!1}={}){this.type="Buffer",this.reset(),this.uuid=Y(),this.consumers=new Set,this.options={label:e,size:t,usage:Vs(i),mappedAtCreation:s}}reset(){this.GPUBuffer=null}set size(e){this.options.size=e}createBuffer(e,t={}){const{usage:i,...s}=t;this.options={...this.options,...s,...i!==void 0&&{usage:Vs(i)}},this.setBuffer(e.createBuffer(this))}setBuffer(e){this.GPUBuffer=e}copy(e,t=!1){t&&this.destroy(),this.options=e.options,this.GPUBuffer=e.GPUBuffer,this.consumers=new Set([...this.consumers,...e.consumers])}async mapBufferAsync(){if(!this.GPUBuffer||this.GPUBuffer.mapState!=="unmapped")return new Float32Array(0);await this.GPUBuffer.mapAsync(GPUMapMode.READ);const e=new Float32Array(this.GPUBuffer.getMappedRange().slice(0));return this.GPUBuffer.unmap(),e}destroy(){this.GPUBuffer?.destroy(),this.reset(),this.consumers.clear()}}class pe extends Rt{constructor({label:e="Uniform",name:t="uniform",bindingType:i,visibility:s,useStruct:r=!0,access:o="read",usage:a=[],struct:h={},bindings:l=[]}){i=i??"uniform",super({label:e,name:t,bindingType:i,visibility:s}),this.options={...this.options,useStruct:r,access:o,usage:a,struct:h,bindings:l},this.cacheKey+=`${r},${o},`,this.arrayBufferSize=0,this.shouldUpdate=!1,this.useStruct=r,this.bufferElements=[],this.inputs={},this.buffer=new Ie,Object.keys(h).length&&(this.setBindings(h),this.setInputsAlignment()),(Object.keys(h).length||this.options.bindings.length)&&(this.setBufferAttributes(),this.setWGSLFragment())}get resourceLayout(){return{buffer:{type:zi(this)}}}get resourceLayoutCacheKey(){return`buffer,${zi(this)},${this.visibility},`}get resource(){return{buffer:this.buffer.GPUBuffer}}clone(e){const{struct:t,...i}=e,s=new this.constructor(i);return t&&s.setBindings(t),s.options.struct=t,s.arrayBufferSize=this.arrayBufferSize,s.arrayBuffer=new ArrayBuffer(s.arrayBufferSize),s.arrayView=new DataView(s.arrayBuffer,0,s.arrayBuffer.byteLength),s.buffer.size=s.arrayBuffer.byteLength,this.bufferElements.forEach(r=>{const o=new r.constructor({name:r.name,key:r.key,type:r.type,...r.arrayLength&&{arrayLength:r.arrayLength}});o.alignment=JSON.parse(JSON.stringify(r.alignment)),r.arrayStride&&(o.arrayStride=r.arrayStride),o.setView(s.arrayBuffer,s.arrayView),s.bufferElements.push(o)}),this.name===s.name&&this.label===s.label?(s.wgslStructFragment=this.wgslStructFragment,s.wgslGroupFragment=this.wgslGroupFragment):s.setWGSLFragment(),s.shouldUpdate=s.arrayBufferSize>0,s}setBindings(e){for(const t of Object.keys(e)){const i={};for(const s in e[t])s!=="value"&&(i[s]=e[t][s]);if(i.name=t,Object.defineProperty(i,"value",{get(){return i._value},set(s){i._value=s,i.shouldUpdate=!0}}),i.value=e[t].value,i.value instanceof _||i.value instanceof f){const s=i.value._onChangeCallback;i.value._onChangeCallback=()=>{s&&s(),i.shouldUpdate=!0}}this.inputs[t]=i,this.cacheKey+=`${t},${e[t].type},`}}setInputsAlignment(){let e=Object.keys(this.inputs);const t=e.filter(i=>this.inputs[i].type.includes("array"));t.length&&(e.sort((i,s)=>{const r=Math.min(0,this.inputs[i].type.indexOf("array")),o=Math.min(0,this.inputs[s].type.indexOf("array"));return r-o}),t.length>1&&(e=e.filter(i=>!t.includes(i))));for(const i of e){const s=this.inputs[i],r={name:it(s.name??i),key:i,type:s.type},o=s.type.includes("array")&&(Array.isArray(s.value)||ArrayBuffer.isView(s.value));this.bufferElements.push(o?new Is({...r,arrayLength:s.value.length}):new Ei(r))}if(this.bufferElements.forEach((i,s)=>{const r=s===0?0:this.bufferElements[s-1].endOffset+1;i.setAlignment(r)}),t.length>1)if(t.map(r=>{const o=this.inputs[r],a=ks(o.type.replace("array","").replace("<","").replace(">",""));return Math.ceil(o.value.length/a.numElements)}).every((r,o,a)=>r===a[0])){const r=t.map(h=>{const l=this.inputs[h];return new Li({name:it(l.name??h),key:h,type:l.type,arrayLength:l.value.length})}),o=t.map(h=>{const l=this.inputs[h];return new Ei({name:it(l.name??h),key:h,type:l.type.replace("array","").replace("<","").replace(">","")})});o.forEach((h,l)=>{l===0?this.bufferElements.length?h.setAlignmentFromPosition({row:this.bufferElements[this.bufferElements.length-1].alignment.end.row+1,byte:0}):h.setAlignment(0):h.setAlignment(o[l-1].endOffset+1)});const a=o[o.length-1].endOffset+1-o[0].startOffset;r.forEach((h,l)=>{h.setAlignment(o[l].startOffset,Math.ceil(a/K)*K)}),this.bufferElements=[...this.bufferElements,...r]}else L(`BufferBinding: "${this.label}" contains multiple array inputs that should use an interleaved array, but their sizes do not match. These inputs cannot be added to the BufferBinding: "${t.join(", ")}"`)}setBufferAttributes(){const e=this.bufferElements.length?this.bufferElements[this.bufferElements.length-1].paddedByteCount:0;this.arrayBufferSize=e,this.options.bindings.forEach(t=>{this.arrayBufferSize+=t.arrayBufferSize}),this.arrayBuffer=new ArrayBuffer(this.arrayBufferSize),this.arrayView=new DataView(this.arrayBuffer,0,e),this.options.bindings.forEach((t,i)=>{let s=e;for(let a=0;a<i;a++)s+=this.options.bindings[a].arrayBuffer.byteLength;const r=this.bufferElements.length?this.bufferElements[this.bufferElements.length-1].alignment.end.row+1:0,o=i>0&&this.options.bindings[i-1].bufferElements.length?this.options.bindings[i-1].bufferElements[this.options.bindings[i-1].bufferElements.length-1].alignment.end.row+1:0;t.bufferElements.forEach(a=>{a.alignment.start.row+=r+o,a.alignment.end.row+=r+o}),t.arrayView=new DataView(this.arrayBuffer,s,t.arrayBuffer.byteLength);for(const a of t.bufferElements)a.setView(this.arrayBuffer,t.arrayView)}),this.buffer.size=this.arrayBuffer.byteLength;for(const t of this.bufferElements)t.setView(this.arrayBuffer,this.arrayView);this.shouldUpdate=this.arrayBufferSize>0}setWGSLFragment(){if(!this.bufferElements.length&&!this.options.bindings.length)return;const e=[];this.options.bindings.forEach(i=>{const s=e.find(r=>r.name===i.name);s?s.count++:e.push({name:i.name,label:i.label,count:1,wgslStructFragment:i.wgslStructFragment})});const t=st(this.label);if(this.useStruct){const i={};i[t]={};const s=this.bufferElements.filter(a=>!(a instanceof Li)),r=this.bufferElements.filter(a=>a instanceof Li);if(r.length){const a=this.bindingType==="uniform"?`, ${r[0].numElements}`:"";if(s.length){i[`${t}Element`]={},r.forEach(u=>{i[`${t}Element`][u.name]=u.type.replace("array","").replace("<","").replace(">","")}),s.forEach(u=>{i[t][u.name]=u.type});const h=this.bufferElements.find(u=>u.name==="elements")?`${this.name}Elements`:"elements";i[t][h]=`array<${t}Element${a}>`;const l=Tt(this);this.wgslGroupFragment=[`${l} ${this.name}: ${t};`]}else{this.bufferElements.forEach(l=>{i[t][l.name]=l.type.replace("array","").replace("<","").replace(">","")});const h=Tt(this);this.wgslGroupFragment=[`${h} ${this.name}: array<${t}${a}>;`]}}else{s.forEach(h=>{const l=this.bindingType==="uniform"&&"numElements"in h?`array<${h.type.replace("array","").replace("<","").replace(">","")}, ${h.numElements}>`:h.type;i[t][h.name]=l});const a=Tt(this);this.wgslGroupFragment=[`${a} ${this.name}: ${t};`]}e.length&&e.forEach(a=>{i[t][a.name]=a.count>1?`array<${st(a.label)}>`:st(a.label)});const o=e.length?e.map(a=>a.wgslStructFragment).join(`

`)+`

`:"";this.wgslStructFragment=o+Object.keys(i).reverse().map(a=>`struct ${a} {
	${Object.keys(i[a]).map(h=>`${h}: ${i[a][h]}`).join(`,
	`)}
};`).join(`

`)}else this.wgslStructFragment="",this.wgslGroupFragment=this.bufferElements.map(i=>`${Tt(this)} ${i.name}: ${i.type};`)}shouldUpdateBinding(e=""){this.inputs[e]&&(this.inputs[e].shouldUpdate=!0)}update(){const e=Object.values(this.inputs);for(const t of e){const i=this.bufferElements.find(s=>s.key===t.name);t.shouldUpdate&&i&&(t.onBeforeUpdate&&t.onBeforeUpdate(),i.update(t.value),this.shouldUpdate=!0,t.shouldUpdate=!1)}this.options.bindings.forEach(t=>{t.update(),t.shouldUpdate&&(this.shouldUpdate=!0)})}extractBufferElementDataFromBufferResult({result:e,bufferElementName:t}){const i=this.bufferElements.find(s=>s.name===t);return i?i.extractDataFromBufferResult(e):e}}class _i extends pe{constructor({label:e="Work",name:t="work",bindingType:i,visibility:s,useStruct:r=!0,access:o="read_write",usage:a=[],struct:h={},shouldCopyResult:l=!1}){i="storage",s=["compute"],super({label:e,name:t,bindingType:i,visibility:s,useStruct:r,access:o,usage:a,struct:h}),this.options={...this.options,shouldCopyResult:l},this.shouldCopyResult=l,this.cacheKey+=`${l},`,this.resultBuffer=new Ie}}class Et{constructor(e,{label:t="BindGroup",index:i=0,bindings:s=[],uniforms:r,storages:o}={}){this.type="BindGroup",e=W(e,this.type),this.renderer=e,this.options={label:t,index:i,bindings:s,...r&&{uniforms:r},...o&&{storages:o}},this.index=i,this.uuid=Y(),this.bindings=[],s.length&&this.addBindings(s),(this.options.uniforms||this.options.storages)&&this.setInputBindings(),this.layoutCacheKey="",this.pipelineCacheKey="",this.resetEntries(),this.bindGroupLayout=null,this.bindGroup=null,this.needsPipelineFlush=!1,this.consumers=new Set;for(const a of this.bufferBindings)"buffer"in a&&("parent"in a&&a.parent?a.parent.buffer.consumers.add(this.uuid):a.buffer.consumers.add(this.uuid)),"resultBuffer"in a&&a.resultBuffer.consumers.add(this.uuid);this.renderer.addBindGroup(this)}setIndex(e){this.index=e}addBindings(e=[]){e.forEach(t=>{"buffer"in t&&("parent"in t&&t.parent?(this.renderer.deviceManager.bufferBindings.set(t.parent.cacheKey,t.parent),t.parent.buffer.consumers.add(this.uuid)):(this.renderer.deviceManager.bufferBindings.set(t.cacheKey,t),t.buffer.consumers.add(this.uuid)))}),this.bindings=[...this.bindings,...e]}addBinding(e){this.bindings.push(e)}destroyBufferBinding(e){"buffer"in e&&(this.renderer.removeBuffer(e.buffer),e.buffer.consumers.delete(this.uuid),e.buffer.consumers.size||e.buffer.destroy(),"parent"in e&&e.parent&&(e.parent.buffer.consumers.delete(this.uuid),e.parent.buffer.consumers.size||(this.renderer.removeBuffer(e.parent.buffer),e.parent.buffer.destroy()))),"resultBuffer"in e&&(this.renderer.removeBuffer(e.resultBuffer),e.resultBuffer.consumers.delete(this.uuid),e.resultBuffer.consumers.size||e.resultBuffer.destroy())}createInputBindings(e="uniform",t={}){let i=[...Object.keys(t).map(s=>{const r=t[s];if(!r.struct)return;const o={label:st(r.label||s),name:s,bindingType:e,visibility:r.access==="read_write"?["compute"]:r.visibility,useStruct:!0,access:r.access??"read",...r.usage&&{usage:r.usage},struct:r.struct,...r.shouldCopyResult!==void 0&&{shouldCopyResult:r.shouldCopyResult}};if(r.useStruct!==!1){let h=`${e},${r.visibility===void 0?"all":r.access==="read_write"?"compute":r.visibility},true,${r.access??"read"},`;Object.keys(r.struct).forEach(u=>{h+=`${u},${r.struct[u].type},`}),r.shouldCopyResult!==void 0&&(h+=`${r.shouldCopyResult},`);const l=this.renderer.deviceManager.bufferBindings.get(h);if(l)return l.clone(o)}const a=o.access==="read_write"?_i:pe;return r.useStruct!==!1?new a(o):Object.keys(r.struct).map(h=>(o.label=st(r.label?r.label+h:s+h),o.name=s+h,o.useStruct=!1,o.struct={[h]:r.struct[h]},new a(o)))})].flat();return i=i.filter(Boolean),i.forEach(s=>{this.renderer.deviceManager.bufferBindings.set(s.cacheKey,s)}),i}setInputBindings(){this.addBindings([...this.createInputBindings("uniform",this.options.uniforms),...this.createInputBindings("storage",this.options.storages)])}get shouldCreateBindGroup(){return!this.bindGroup&&!!this.bindings.length}resetEntries(){this.entries={bindGroupLayout:[],bindGroup:[]}}createBindGroup(){this.fillEntries(),this.setBindGroupLayout(),this.setBindGroup()}resetBindGroup(){this.entries.bindGroup=[],this.pipelineCacheKey="";for(const e of this.bindings)this.addBindGroupEntry(e);this.setBindGroup()}addBindGroupEntry(e){this.entries.bindGroup.push({binding:this.entries.bindGroup.length,resource:e.resource}),this.pipelineCacheKey+=e.cacheKey}resetBindGroupLayout(){this.entries.bindGroupLayout=[],this.layoutCacheKey="";for(const e of this.bindings)this.addBindGroupLayoutEntry(e);this.setBindGroupLayout()}addBindGroupLayoutEntry(e){this.entries.bindGroupLayout.push({binding:this.entries.bindGroupLayout.length,...e.resourceLayout,visibility:e.visibility}),this.layoutCacheKey+=e.resourceLayoutCacheKey}loseContext(){this.resetEntries();for(const e of this.bufferBindings)e.buffer.reset(),"parent"in e&&e.parent&&e.parent.buffer.reset(),"resultBuffer"in e&&e.resultBuffer.reset();this.bindGroup=null,this.bindGroupLayout=null,this.needsPipelineFlush=!0}restoreContext(){this.shouldCreateBindGroup&&this.createBindGroup();for(const e of this.bufferBindings)e.shouldUpdate=!0}get bufferBindings(){return this.bindings.filter(e=>e instanceof pe||e instanceof _i)}createBindingBuffer(e,t=null){e.buffer.createBuffer(this.renderer,{label:t||this.options.label+": "+e.bindingType+" buffer from: "+e.label,usage:["copySrc","copyDst",e.bindingType,...e.options.usage]}),"resultBuffer"in e&&e.resultBuffer.createBuffer(this.renderer,{label:this.options.label+": Result buffer from: "+e.label,size:e.arrayBuffer.byteLength,usage:["copyDst","mapRead"]})}fillEntries(){for(const e of this.bindings){if(e.visibility||(e.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE),"buffer"in e){const t="parent"in e&&e.parent;t&&!e.parent.buffer.GPUBuffer?this.createBindingBuffer(e.parent,e.parent.options.label):!e.buffer.GPUBuffer&&!t&&this.createBindingBuffer(e)}this.addBindGroupLayoutEntry(e),this.addBindGroupEntry(e)}}getBindingByName(e=""){return this.bindings.find(t=>t.name===e)}setBindGroupLayout(){const e=this.renderer.deviceManager.bindGroupLayouts.get(this.layoutCacheKey);e?this.bindGroupLayout=e:(this.bindGroupLayout=this.renderer.createBindGroupLayout({label:this.options.label+" layout",entries:this.entries.bindGroupLayout}),this.renderer.deviceManager.bindGroupLayouts.set(this.layoutCacheKey,this.bindGroupLayout))}setBindGroup(){this.bindGroup=this.renderer.createBindGroup({label:this.options.label,layout:this.bindGroupLayout,entries:this.entries.bindGroup})}updateBufferBindings(){this.bindings.forEach((e,t)=>{"buffer"in e&&(e.update(),e.shouldUpdate&&e.buffer.GPUBuffer&&(!e.useStruct&&e.bufferElements.length>1?this.renderer.queueWriteBuffer(e.buffer.GPUBuffer,0,e.bufferElements[t].view):this.renderer.queueWriteBuffer(e.buffer.GPUBuffer,0,e.arrayBuffer),e.shouldUpdate=!1))})}update(){this.updateBufferBindings();const e=this.bindings.some(i=>i.shouldResetBindGroup),t=this.bindings.some(i=>i.shouldResetBindGroupLayout);(e||t)&&this.renderer.onAfterCommandEncoderSubmission.add(()=>{for(const i of this.bindings)i.shouldResetBindGroup=!1,i.shouldResetBindGroupLayout=!1},{once:!0}),t&&(this.resetBindGroupLayout(),this.needsPipelineFlush=!0),e&&this.resetBindGroup()}clone({bindings:e=[],keepLayout:t=!1}={}){const i={...this.options};i.label+=" (copy)";const s=new this.constructor(this.renderer,{label:i.label});s.setIndex(this.index),s.options=i;const r=e.length?e:this.bindings;for(const o of r){if(s.addBinding(o),"buffer"in o){const a="parent"in o&&o.parent;a&&!o.parent.buffer.GPUBuffer?(this.createBindingBuffer(o.parent,o.parent.options.label),o.parent.buffer.consumers.add(s.uuid)):!o.buffer.GPUBuffer&&!a&&this.createBindingBuffer(o),"resultBuffer"in o&&o.resultBuffer.consumers.add(s.uuid)}t||s.addBindGroupLayoutEntry(o),s.addBindGroupEntry(o)}return t&&(s.entries.bindGroupLayout=[...this.entries.bindGroupLayout],s.layoutCacheKey=this.layoutCacheKey),s.setBindGroupLayout(),s.setBindGroup(),s}destroy(){this.renderer.removeBindGroup(this);for(const e of this.bufferBindings)this.destroyBufferBinding(e);this.bindings=[],this.bindGroupLayout=null,this.bindGroup=null,this.resetEntries()}}class Ai extends Rt{constructor({label:e="Texture",name:t="texture",bindingType:i,visibility:s,texture:r,format:o="rgba8unorm",access:a="write",viewDimension:h="2d",multisampled:l=!1}){i=i??"texture",i==="storage"&&(s=["compute"]),super({label:e,name:t,bindingType:i,visibility:s}),this.options={...this.options,texture:r,format:o,access:a,viewDimension:h,multisampled:l},this.cacheKey+=`${o},${a},${h},${l},`,this.resource=r,this.setWGSLFragment()}get resourceLayout(){return Cn(this)}get resourceLayoutCacheKey(){return Sn(this)}get resource(){return this.texture instanceof GPUTexture?this.texture.createView({label:this.options.label+" view",dimension:this.options.viewDimension}):this.texture instanceof GPUExternalTexture?this.texture:null}set resource(e){(e||this.texture)&&(this.shouldResetBindGroup=!0),this.texture=e}setBindingType(e){e!==this.bindingType&&(e&&(this.shouldResetBindGroupLayout=!0),this.bindingType=e,this.cacheKey=`${this.bindingType},${this.visibility},${this.options.format},${this.options.access},${this.options.viewDimension},${this.options.multisampled},`,this.setWGSLFragment())}setFormat(e){const t=e!==this.options.format;this.options.format=e,t&&this.bindingType==="storage"&&(this.setWGSLFragment(),this.shouldResetBindGroupLayout=!0,this.cacheKey=`${this.bindingType},${this.visibility},${this.options.format},${this.options.access},${this.options.viewDimension},${this.options.multisampled},`)}setMultisampled(e){const t=e!==this.options.multisampled;this.options.multisampled=e,t&&this.bindingType!=="storage"&&(this.setWGSLFragment(),this.shouldResetBindGroupLayout=!0,this.cacheKey=`${this.bindingType},${this.visibility},${this.options.format},${this.options.access},${this.options.viewDimension},${this.options.multisampled},`)}setWGSLFragment(){this.wgslGroupFragment=[`${Mn(this)}`]}}const ee=new f,fe=new f,I=new f;class G{constructor(e=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])){this.type="Mat4",this.elements=e}set(e,t,i,s,r,o,a,h,l,u,d,c,p,g,m,y){const v=this.elements;return v[0]=e,v[1]=t,v[2]=i,v[3]=s,v[4]=r,v[5]=o,v[6]=a,v[7]=h,v[8]=l,v[9]=u,v[10]=d,v[11]=c,v[12]=p,v[13]=g,v[14]=m,v[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}setFromArray(e=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])){for(let t=0;t<this.elements.length;t++)this.elements[t]=e[t];return this}copy(e=new G){const t=e.elements;return this.elements[0]=t[0],this.elements[1]=t[1],this.elements[2]=t[2],this.elements[3]=t[3],this.elements[4]=t[4],this.elements[5]=t[5],this.elements[6]=t[6],this.elements[7]=t[7],this.elements[8]=t[8],this.elements[9]=t[9],this.elements[10]=t[10],this.elements[11]=t[11],this.elements[12]=t[12],this.elements[13]=t[13],this.elements[14]=t[14],this.elements[15]=t[15],this}clone(){return new G().copy(this)}multiply(e=new G){return this.multiplyMatrices(this,e)}premultiply(e=new G){return this.multiplyMatrices(e,this)}multiplyMatrices(e=new G,t=new G){const i=e.elements,s=t.elements,r=this.elements,o=i[0],a=i[4],h=i[8],l=i[12],u=i[1],d=i[5],c=i[9],p=i[13],g=i[2],m=i[6],y=i[10],v=i[14],M=i[3],T=i[7],b=i[11],S=i[15],C=s[0],w=s[4],R=s[8],E=s[12],z=s[1],$=s[5],D=s[9],J=s[13],Q=s[2],H=s[6],O=s[10],q=s[14],N=s[3],Z=s[7],te=s[11],be=s[15];return r[0]=o*C+a*z+h*Q+l*N,r[4]=o*w+a*$+h*H+l*Z,r[8]=o*R+a*D+h*O+l*te,r[12]=o*E+a*J+h*q+l*be,r[1]=u*C+d*z+c*Q+p*N,r[5]=u*w+d*$+c*H+p*Z,r[9]=u*R+d*D+c*O+p*te,r[13]=u*E+d*J+c*q+p*be,r[2]=g*C+m*z+y*Q+v*N,r[6]=g*w+m*$+y*H+v*Z,r[10]=g*R+m*D+y*O+v*te,r[14]=g*E+m*J+y*q+v*be,r[3]=M*C+T*z+b*Q+S*N,r[7]=M*w+T*$+b*H+S*Z,r[11]=M*R+T*D+b*O+S*te,r[15]=M*E+T*J+b*q+S*be,this}premultiplyTranslate(e=new f){const o=e.x,a=e.y,h=e.z,l=this.elements,u=this.elements,d=l[0],c=l[4],p=l[8],g=l[12],m=l[1],y=l[5],v=l[9],M=l[13],T=l[2],b=l[6],S=l[10],C=l[14],w=l[3],R=l[7],E=l[11],z=l[15];return u[0]=1*d+o*w,u[4]=1*c+o*R,u[8]=1*p+o*E,u[12]=1*g+o*z,u[1]=1*m+a*w,u[5]=1*y+a*R,u[9]=1*v+a*E,u[13]=1*M+a*z,u[2]=1*T+h*w,u[6]=1*b+h*R,u[10]=1*S+h*E,u[14]=1*C+h*z,u[3]=1*w,u[7]=1*R,u[11]=1*E,u[15]=1*z,this}premultiplyScale(e=new f){const t=this.elements,i=this.elements,s=e.x,r=e.y,o=e.z,a=1,h=t[0],l=t[4],u=t[8],d=t[12],c=t[1],p=t[5],g=t[9],m=t[13],y=t[2],v=t[6],M=t[10],T=t[14],b=t[3],S=t[7],C=t[11],w=t[15];return i[0]=s*h,i[4]=s*l,i[8]=s*u,i[12]=s*d,i[1]=r*c,i[5]=r*p,i[9]=r*g,i[13]=r*m,i[2]=o*y,i[6]=o*v,i[10]=o*M,i[14]=o*T,i[3]=a*b,i[7]=a*S,i[11]=a*C,i[15]=a*w,this}invert(){const e=this.elements,t=e[0],i=e[1],s=e[2],r=e[3],o=e[4],a=e[5],h=e[6],l=e[7],u=e[8],d=e[9],c=e[10],p=e[11],g=e[12],m=e[13],y=e[14],v=e[15],M=d*y*l-m*c*l+m*h*p-a*y*p-d*h*v+a*c*v,T=g*c*l-u*y*l-g*h*p+o*y*p+u*h*v-o*c*v,b=u*m*l-g*d*l+g*a*p-o*m*p-u*a*v+o*d*v,S=g*d*h-u*m*h-g*a*c+o*m*c+u*a*y-o*d*y,C=t*M+i*T+s*b+r*S;if(C===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const w=1/C;return e[0]=M*w,e[1]=(m*c*r-d*y*r-m*s*p+i*y*p+d*s*v-i*c*v)*w,e[2]=(a*y*r-m*h*r+m*s*l-i*y*l-a*s*v+i*h*v)*w,e[3]=(d*h*r-a*c*r-d*s*l+i*c*l+a*s*p-i*h*p)*w,e[4]=T*w,e[5]=(u*y*r-g*c*r+g*s*p-t*y*p-u*s*v+t*c*v)*w,e[6]=(g*h*r-o*y*r-g*s*l+t*y*l+o*s*v-t*h*v)*w,e[7]=(o*c*r-u*h*r+u*s*l-t*c*l-o*s*p+t*h*p)*w,e[8]=b*w,e[9]=(g*d*r-u*m*r-g*i*p+t*m*p+u*i*v-t*d*v)*w,e[10]=(o*m*r-g*a*r+g*i*l-t*m*l-o*i*v+t*a*v)*w,e[11]=(u*a*r-o*d*r-u*i*l+t*d*l+o*i*p-t*a*p)*w,e[12]=S*w,e[13]=(u*m*s-g*d*s+g*i*c-t*m*c-u*i*y+t*d*y)*w,e[14]=(g*a*s-o*m*s-g*i*h+t*m*h+o*i*y-t*a*y)*w,e[15]=(o*d*s-u*a*s+u*i*h-t*d*h-o*i*c+t*a*c)*w,this}getInverse(){return this.clone().invert()}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}translate(e=new f){const t=this.elements;return t[12]=t[0]*e.x+t[4]*e.y+t[8]*e.z+t[12],t[13]=t[1]*e.x+t[5]*e.y+t[9]*e.z+t[13],t[14]=t[2]*e.x+t[6]*e.y+t[10]*e.z+t[14],t[15]=t[3]*e.x+t[7]*e.y+t[11]*e.z+t[15],this}getTranslation(e=new f){return e.set(this.elements[12],this.elements[13],this.elements[14])}scale(e=new f){const t=this.elements;return t[0]*=e.x,t[1]*=e.x,t[2]*=e.x,t[3]*=e.x,t[4]*=e.y,t[5]*=e.y,t[6]*=e.y,t[7]*=e.y,t[8]*=e.z,t[9]*=e.z,t[10]*=e.z,t[11]*=e.z,this}rotateFromQuaternion(e=new ce){const t=this.elements,i=e.elements[0],s=e.elements[1],r=e.elements[2],o=e.elements[3],a=i+i,h=s+s,l=r+r,u=i*a,d=i*h,c=i*l,p=s*h,g=s*l,m=r*l,y=o*a,v=o*h,M=o*l;return t[0]=1-(p+m),t[4]=d-M,t[8]=c+v,t[1]=d+M,t[5]=1-(u+m),t[9]=g-y,t[2]=c-v,t[6]=g+y,t[10]=1-(u+p),this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],i=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],s=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,i,s))}compose(e=new f,t=new ce,i=new f(1)){const s=this.elements,r=t.elements[0],o=t.elements[1],a=t.elements[2],h=t.elements[3],l=r+r,u=o+o,d=a+a,c=r*l,p=r*u,g=r*d,m=o*u,y=o*d,v=a*d,M=h*l,T=h*u,b=h*d,S=i.x,C=i.y,w=i.z;return s[0]=(1-(m+v))*S,s[1]=(p+b)*S,s[2]=(g-T)*S,s[3]=0,s[4]=(p-b)*C,s[5]=(1-(c+v))*C,s[6]=(y+M)*C,s[7]=0,s[8]=(g+T)*w,s[9]=(y-M)*w,s[10]=(1-(c+m))*w,s[11]=0,s[12]=e.x,s[13]=e.y,s[14]=e.z,s[15]=1,this}composeFromOrigin(e=new f,t=new ce,i=new f(1),s=new f){const r=this.elements,o=t.elements[0],a=t.elements[1],h=t.elements[2],l=t.elements[3],u=o+o,d=a+a,c=h+h,p=o*u,g=o*d,m=o*c,y=a*d,v=a*c,M=h*c,T=l*u,b=l*d,S=l*c,C=i.x,w=i.y,R=i.z,E=s.x,z=s.y,$=s.z,D=(1-(y+M))*C,J=(g+S)*C,Q=(m-b)*C,H=(g-S)*w,O=(1-(p+M))*w,q=(v+T)*w,N=(m+b)*R,Z=(v-T)*R,te=(1-(p+y))*R;return r[0]=D,r[1]=J,r[2]=Q,r[3]=0,r[4]=H,r[5]=O,r[6]=q,r[7]=0,r[8]=N,r[9]=Z,r[10]=te,r[11]=0,r[12]=e.x+E-(D*E+H*z+N*$),r[13]=e.y+z-(J*E+O*z+Z*$),r[14]=e.z+$-(Q*E+q*z+te*$),r[15]=1,this}lookAt(e=new f,t=new f,i=new f(0,1,0)){const s=this.elements;return I.copy(e).sub(t),I.lengthSq()===0&&(I.z=1),I.normalize(),ee.crossVectors(i,I),ee.lengthSq()===0&&(Math.abs(i.z)===1?I.x+=1e-4:I.z+=1e-4,I.normalize(),ee.crossVectors(i,I)),ee.normalize(),fe.crossVectors(I,ee),s[0]=ee.x,s[1]=ee.y,s[2]=ee.z,s[3]=0,s[4]=fe.x,s[5]=fe.y,s[6]=fe.z,s[7]=0,s[8]=I.x,s[9]=I.y,s[10]=I.z,s[11]=0,s[12]=e.x,s[13]=e.y,s[14]=e.z,s[15]=1,this}makeView(e=new f,t=new f,i=new f(0,1,0)){const s=this.elements;return I.copy(e).sub(t).normalize(),ee.crossVectors(i,I).normalize(),fe.crossVectors(I,ee).normalize(),s[0]=ee.x,s[1]=fe.x,s[2]=I.x,s[3]=0,s[4]=ee.y,s[5]=fe.y,s[6]=I.y,s[7]=0,s[8]=ee.z,s[9]=fe.z,s[10]=I.z,s[11]=0,s[12]=-(ee.x*e.x+ee.y*e.y+ee.z*e.z),s[13]=-(fe.x*e.x+fe.y*e.y+fe.z*e.z),s[14]=-(I.x*e.x+I.y*e.y+I.z*e.z),s[15]=1,this}makeOrthographic({left:e=-5,right:t=5,bottom:i=-5,top:s=5,near:r=.1,far:o=50}){const a=this.elements;return a[0]=2/(t-e),a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=2/(s-i),a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=1/(r-o),a[11]=0,a[12]=(t+e)/(e-t),a[13]=(s+i)/(i-s),a[14]=r/(r-o),a[15]=1,this}makePerspective({fov:e=90,aspect:t=1,near:i=.1,far:s=150}){const r=i*Math.tan(Math.PI/180*.5*e),o=2*r,a=t*o,h=-.5*a,l=h+a,u=r-o,d=2*i/(l-h),c=2*i/(r-u),p=(l+h)/(l-h),g=(r+u)/(r-u),m=-s/(s-i),y=-s*i/(s-i);return this.set(d,0,0,0,0,c,0,0,p,g,m,-1,0,0,y,0),this}}let Rn=0;const zn=new G;class xe{constructor(){this._parent=null,this.children=[],this.matricesNeedUpdate=!1,Object.defineProperty(this,"object3DIndex",{value:Rn++}),this.setMatrices(),this.setTransforms()}get parent(){return this._parent}set parent(e){this._parent&&e&&this._parent.object3DIndex===e.object3DIndex||(this._parent&&(this._parent.children=this._parent.children.filter(t=>t.object3DIndex!==this.object3DIndex)),e&&this.shouldUpdateWorldMatrix(),this._parent=e,this._parent?.children.push(this))}setTransforms(){this.transforms={origin:{model:new f},quaternion:new ce,rotation:new f,position:{world:new f},scale:new f(1)},this.rotation.onChange(()=>this.applyRotation()),this.position.onChange(()=>this.applyPosition()),this.scale.onChange(()=>this.applyScale()),this.transformOrigin.onChange(()=>this.applyTransformOrigin())}get rotation(){return this.transforms.rotation}set rotation(e){this.transforms.rotation=e,this.applyRotation()}get quaternion(){return this.transforms.quaternion}set quaternion(e){this.transforms.quaternion=e}get position(){return this.transforms.position.world}set position(e){this.transforms.position.world=e}get scale(){return this.transforms.scale}set scale(e){this.transforms.scale=e,this.applyScale()}get transformOrigin(){return this.transforms.origin.model}set transformOrigin(e){this.transforms.origin.model=e}applyRotation(){this.quaternion.setFromVec3(this.rotation),this.shouldUpdateModelMatrix()}applyPosition(){this.shouldUpdateModelMatrix()}applyScale(){this.shouldUpdateModelMatrix()}applyTransformOrigin(){this.shouldUpdateModelMatrix()}setMatrices(){this.matrices={model:{matrix:new G,shouldUpdate:!0,onUpdate:()=>this.updateModelMatrix()},world:{matrix:new G,shouldUpdate:!0,onUpdate:()=>this.updateWorldMatrix()}}}get modelMatrix(){return this.matrices.model.matrix}set modelMatrix(e){this.matrices.model.matrix=e,this.shouldUpdateModelMatrix()}shouldUpdateModelMatrix(){this.matrices.model.shouldUpdate=!0,this.shouldUpdateWorldMatrix()}get worldMatrix(){return this.matrices.world.matrix}set worldMatrix(e){this.matrices.world.matrix=e,this.shouldUpdateWorldMatrix()}shouldUpdateWorldMatrix(){this.matrices.world.shouldUpdate=!0}lookAt(e=new f,t=this.position,i=new f(0,1,0)){const s=zn.lookAt(e,t,i);this.quaternion.setFromRotationMatrix(s),this.shouldUpdateModelMatrix()}updateModelMatrix(){this.modelMatrix=this.modelMatrix.composeFromOrigin(this.position,this.quaternion,this.scale,this.transformOrigin),this.shouldUpdateWorldMatrix()}updateWorldMatrix(){this.parent?this.worldMatrix.multiplyMatrices(this.parent.worldMatrix,this.modelMatrix):this.worldMatrix.copy(this.modelMatrix);for(let e=0,t=this.children.length;e<t;e++)this.children[e].shouldUpdateWorldMatrix()}shouldUpdateMatrices(){this.matricesNeedUpdate=!!Object.values(this.matrices).find(e=>e.shouldUpdate)}updateMatrixStack(){if(this.shouldUpdateMatrices(),this.matricesNeedUpdate)for(const e in this.matrices)this.matrices[e].shouldUpdate&&(this.matrices[e].onUpdate(),this.matrices[e].shouldUpdate=!1);for(let e=0,t=this.children.length;e<t;e++)this.children[e].updateMatrixStack()}destroy(){for(let e=0,t=this.children.length;e<t;e++)this.children[e]&&(this.children[e].parent=null);this.parent=null}}const En=new Map([["copySrc",GPUTextureUsage.COPY_SRC],["copyDst",GPUTextureUsage.COPY_DST],["renderAttachment",GPUTextureUsage.RENDER_ATTACHMENT],["storageBinding",GPUTextureUsage.STORAGE_BINDING],["textureBinding",GPUTextureUsage.TEXTURE_BINDING]]),Ln=(n=[])=>n.reduce((e,t)=>e|En.get(t),0),_n=(n=[],e)=>n.length?Ln(n):e!=="storage"?GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,Ns=(...n)=>{const e=Math.max(...n);return 1+Math.log2(e)|0};var An=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},se=(n,e,t)=>(An(n,e,"read from private field"),t?t.call(n):e.get(n)),Lt=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},_e,Ae,_t,At;const Ws={name:"texture",generateMips:!1,flipY:!1,format:"rgba8unorm",premultipliedAlpha:!1,placeholderColor:[0,0,0,255],useExternalTextures:!0,fromTexture:null,viewDimension:"2d",visibility:["fragment"],cache:!0};class Oe extends xe{constructor(e,t=Ws){super(),Lt(this,_e,new f(1)),Lt(this,Ae,new f(1)),Lt(this,_t,new f(1)),Lt(this,At,new G),this._onSourceLoadedCallback=()=>{},this._onSourceUploadedCallback=()=>{},this.type="Texture",e=W(e,t.label?t.label+" "+this.type:this.type),this.renderer=e,this.uuid=Y();const i={...Ws,source:t.fromTexture?t.fromTexture.options.source:null,sourceType:t.fromTexture?t.fromTexture.options.sourceType:null};this.options={...i,...t},this.options.label=this.options.label??this.options.name,this.texture=null,this.externalTexture=null,this.source=null,this.size={width:1,height:1,depth:1},this.textureMatrix=new pe({label:this.options.label+": model matrix",name:this.options.name+"Matrix",useStruct:!1,struct:{[this.options.name+"Matrix"]:{type:"mat4x4f",value:this.modelMatrix}}}),this.renderer.deviceManager.bufferBindings.set(this.textureMatrix.cacheKey,this.textureMatrix),this.setBindings(),this._parentMesh=null,this.sourceLoaded=!1,this.sourceUploaded=!1,this.shouldUpdate=!1,this.renderer.addDOMTexture(this),this.createTexture()}setBindings(){this.bindings=[new Ai({label:this.options.label+": texture",name:this.options.name,bindingType:this.options.sourceType==="externalVideo"?"externalTexture":"texture",visibility:this.options.visibility,texture:this.options.sourceType==="externalVideo"?this.externalTexture:this.texture,viewDimension:this.options.viewDimension}),this.textureMatrix]}get textureBinding(){return this.bindings[0]}get parentMesh(){return this._parentMesh}set parentMesh(e){this._parentMesh=e,this.resize()}get sourceLoaded(){return this._sourceLoaded}set sourceLoaded(e){e&&!this.sourceLoaded&&this._onSourceLoadedCallback&&this._onSourceLoadedCallback(),this._sourceLoaded=e}get sourceUploaded(){return this._sourceUploaded}set sourceUploaded(e){e&&!this.sourceUploaded&&this._onSourceUploadedCallback&&this._onSourceUploadedCallback(),this._sourceUploaded=e}setTransforms(){super.setTransforms(),this.transforms.quaternion.setAxisOrder("ZXY"),this.transforms.origin.model.set(.5,.5,0)}updateModelMatrix(){if(!this.parentMesh)return;const e=this.parentMesh.scale?this.parentMesh.scale:new f(1,1,1),t=this.parentMesh.boundingRect?this.parentMesh.boundingRect.width*e.x:this.size.width,i=this.parentMesh.boundingRect?this.parentMesh.boundingRect.height*e.y:this.size.height,s=t/i,r=this.size.width/this.size.height;t>i?(se(this,_e).set(s,1,1),se(this,Ae).set(1/r,1,1)):(se(this,_e).set(1,1/s,1),se(this,Ae).set(1,r,1));const o=s>r!=t>i?1:t>i?se(this,_e).x*se(this,Ae).x:se(this,Ae).y*se(this,_e).y;se(this,_t).set(1/(o*this.scale.x),1/(o*this.scale.y),1),se(this,At).rotateFromQuaternion(this.quaternion),this.modelMatrix.identity().premultiplyTranslate(this.transformOrigin.clone().multiplyScalar(-1)).premultiplyScale(se(this,_t)).premultiplyScale(se(this,_e)).premultiply(se(this,At)).premultiplyScale(se(this,Ae)).premultiplyTranslate(this.transformOrigin).translate(this.position)}updateMatrixStack(){super.updateMatrixStack(),this.matricesNeedUpdate&&this.textureMatrix.shouldUpdateBinding(this.options.name+"Matrix")}resize(){this.source&&this.source instanceof HTMLCanvasElement&&(this.source.width!==this.size.width||this.source.height!==this.size.height)&&(this.setSourceSize(),this.createTexture()),this.shouldUpdateModelMatrix()}uploadTexture(){this.renderer.uploadTexture(this),this.shouldUpdate=!1}uploadVideoTexture(){this.externalTexture=this.renderer.importExternalTexture(this.source),this.textureBinding.resource=this.externalTexture,this.textureBinding.setBindingType("externalTexture"),this.shouldUpdate=!1,this.sourceUploaded=!0}copy(e){if(this.options.sourceType==="externalVideo"&&e.options.sourceType!=="externalVideo"){L(`${this.options.label}: cannot copy a GPUTexture to a GPUExternalTexture`);return}else if(this.options.sourceType!=="externalVideo"&&e.options.sourceType==="externalVideo"){L(`${this.options.label}: cannot copy a GPUExternalTexture to a GPUTexture`);return}this.options.fromTexture=e,this.options.sourceType=e.options.sourceType,this.options.generateMips=e.options.generateMips,this.options.flipY=e.options.flipY,this.options.format=e.options.format,this.options.premultipliedAlpha=e.options.premultipliedAlpha,this.options.placeholderColor=e.options.placeholderColor,this.options.useExternalTextures=e.options.useExternalTextures,this.sourceLoaded=e.sourceLoaded,this.sourceUploaded=e.sourceUploaded,e.texture&&(e.sourceLoaded&&(this.size=e.size,this.source=e.source,this.resize()),e.sourceUploaded?(this.texture=e.texture,this.textureBinding.resource=this.texture):this.createTexture())}createTexture(){const e={label:this.options.label,format:this.options.format,size:[this.size.width,this.size.height,this.size.depth],dimensions:this.options.viewDimension==="1d"?"1d":this.options.viewDimension==="3d"?"3d":"2d",usage:this.source?GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST};this.options.sourceType!=="externalVideo"&&(e.mipLevelCount=this.options.generateMips?Ns(this.size.width,this.size.height):1,this.texture?.destroy(),this.texture=this.renderer.createTexture(e),this.textureBinding.resource=this.texture),this.shouldUpdate=!0}setSourceSize(){this.size={width:this.source.naturalWidth||this.source.width||this.source.videoWidth,height:this.source.naturalHeight||this.source.height||this.source.videoHeight,depth:1}}async loadImageBitmap(e){const i=await(await fetch(e)).blob();return await createImageBitmap(i,{colorSpaceConversion:"none"})}async loadImage(e){const t=typeof e=="string"?e:e.getAttribute("src");this.options.source=t,this.options.sourceType="image";const i=this.renderer.domTextures.find(s=>s.options.source===t);if(i&&i.texture&&i.sourceUploaded){this.copy(i);return}this.sourceLoaded=!1,this.sourceUploaded=!1,this.source=await this.loadImageBitmap(this.options.source),this.setSourceSize(),this.resize(),this.sourceLoaded=!0,this.createTexture()}onVideoFrameCallback(){this.videoFrameCallbackId&&(this.shouldUpdate=!0,this.source.requestVideoFrameCallback(this.onVideoFrameCallback.bind(this)))}onVideoLoaded(e){this.sourceLoaded||(this.source=e,this.setSourceSize(),this.resize(),this.options.useExternalTextures?(this.options.sourceType="externalVideo",this.texture?.destroy()):(this.options.sourceType="video",this.createTexture()),"requestVideoFrameCallback"in HTMLVideoElement.prototype&&(this.videoFrameCallbackId=this.source.requestVideoFrameCallback(this.onVideoFrameCallback.bind(this))),this.sourceLoaded=!0)}get isVideoSource(){return this.source&&(this.options.sourceType==="video"||this.options.sourceType==="externalVideo")}loadVideo(e){let t;typeof e=="string"?(t=document.createElement("video"),t.src=e):t=e,t.preload="auto",t.muted=!0,t.loop=!0,t.crossOrigin="anonymous",t.setAttribute("playsinline",""),this.options.source=t.src,this.sourceLoaded=!1,this.sourceUploaded=!1,t.readyState>=t.HAVE_ENOUGH_DATA?this.onVideoLoaded(t):t.addEventListener("canplaythrough",this.onVideoLoaded.bind(this,t),{once:!0}),isNaN(t.duration)&&t.load()}loadCanvas(e){this.options.source=e,this.options.sourceType="canvas",this.sourceLoaded=!1,this.sourceUploaded=!1,this.source=e,this.setSourceSize(),this.resize(),this.sourceLoaded=!0,this.createTexture()}onSourceLoaded(e){return e&&(this._onSourceLoadedCallback=e),this}onSourceUploaded(e){return e&&(this._onSourceUploadedCallback=e),this}render(){this.updateMatrixStack(),this.textureMatrix.update(),this.options.sourceType==="externalVideo"&&(this.shouldUpdate=!0),this.isVideoSource&&!this.videoFrameCallbackId&&this.source.readyState>=this.source.HAVE_CURRENT_DATA&&!this.source.paused&&(this.shouldUpdate=!0),this.shouldUpdate&&this.options.sourceType&&this.options.sourceType!=="externalVideo"&&this.uploadTexture()}destroy(){this.videoFrameCallbackId&&this.source.cancelVideoFrameCallback(this.videoFrameCallbackId),this.isVideoSource&&this.source.removeEventListener("canplaythrough",this.onVideoLoaded.bind(this,this.source),{once:!0}),this.renderer.removeDOMTexture(this),this.texture?.destroy(),this.texture=null}}_e=new WeakMap,Ae=new WeakMap,_t=new WeakMap,At=new WeakMap;class Oi extends Et{constructor(e,{label:t,index:i=0,bindings:s=[],uniforms:r,storages:o,textures:a=[],samplers:h=[]}={}){const l="TextureBindGroup";if(e=W(e,l),super(e,{label:t,index:i,bindings:s,uniforms:r,storages:o}),this.options={...this.options,textures:[],samplers:[]},a.length)for(const u of a)this.addTexture(u);if(h.length)for(const u of h)this.addSampler(u);this.type=l}addTexture(e){this.textures.push(e),this.addBindings([...e.bindings])}get textures(){return this.options.textures}addSampler(e){this.samplers.push(e),this.addBindings([e.binding])}get samplers(){return this.options.samplers}get shouldCreateBindGroup(){return!this.bindGroup&&!!this.bindings.length&&!this.textures.find(e=>!(e.texture||e.externalTexture))&&!this.samplers.find(e=>!e.sampler)}updateTextures(){for(const e of this.textures)e instanceof Oe&&(e.options.fromTexture&&e.options.fromTexture.sourceUploaded&&!e.sourceUploaded&&e.copy(e.options.fromTexture),e.shouldUpdate&&e.options.sourceType&&e.options.sourceType==="externalVideo"&&e.uploadVideoTexture())}update(){this.updateTextures(),super.update()}destroy(){super.destroy(),this.options.textures=[],this.options.samplers=[]}}class js extends Rt{constructor({label:e="Sampler",name:t="sampler",bindingType:i,visibility:s,sampler:r,type:o="filtering"}){i=i??"sampler",super({label:e,name:t,bindingType:i,visibility:s}),this.cacheKey+=`${o},`,this.options={...this.options,sampler:r,type:o},this.resource=r,this.setWGSLFragment()}get resourceLayout(){return{sampler:{type:this.options.type}}}get resourceLayoutCacheKey(){return`sampler,${this.options.type},${this.visibility},`}get resource(){return this.sampler}set resource(e){e&&this.sampler&&(this.shouldResetBindGroup=!0),this.sampler=e}setWGSLFragment(){this.wgslGroupFragment=[`var ${this.name}: ${this.options.type==="comparison"?`${this.bindingType}_comparison`:this.bindingType};`]}}var qs=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},Ot=(n,e,t)=>(qs(n,e,"read from private field"),t?t.call(n):e.get(n)),Gt=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},Dt=(n,e,t,i)=>(qs(n,e,"write to private field"),i?i.call(n,t):e.set(n,t),t),Ft,$t,Ut,kt;class Ys extends xe{constructor({fov:e=50,near:t=.1,far:i=150,width:s=1,height:r=1,pixelRatio:o=1,onMatricesChanged:a=()=>{}}={}){super(),Gt(this,Ft,void 0),Gt(this,$t,void 0),Gt(this,Ut,void 0),Gt(this,kt,void 0),this.uuid=Y(),this.position.set(0,0,10),this.up=new f(0,1,0),this.onMatricesChanged=a,this.size={width:1,height:1},this.setPerspective({fov:e,near:t,far:i,width:s,height:r,pixelRatio:o})}setMatrices(){super.setMatrices(),this.matrices={...this.matrices,view:{matrix:new G,shouldUpdate:!0,onUpdate:()=>{this.viewMatrix.copy(this.worldMatrix).invert()}},projection:{matrix:new G,shouldUpdate:!0,onUpdate:()=>this.updateProjectionMatrix()},viewProjection:{matrix:new G,shouldUpdate:!0,onUpdate:()=>this.viewProjectionMatrix.multiplyMatrices(this.projectionMatrix,this.viewMatrix)}}}get viewMatrix(){return this.matrices.view.matrix}set viewMatrix(e){this.matrices.view.matrix=e,this.shouldUpdateViewMatrices()}get projectionMatrix(){return this.matrices.projection.matrix}set projectionMatrix(e){this.matrices.projection.matrix=e,this.shouldUpdateProjectionMatrices()}get viewProjectionMatrix(){return this.matrices.viewProjection.matrix}shouldUpdateViewMatrices(){this.matrices.view.shouldUpdate=!0,this.matrices.viewProjection.shouldUpdate=!0}shouldUpdateProjectionMatrices(){this.matrices.projection.shouldUpdate=!0,this.matrices.viewProjection.shouldUpdate=!0}updateModelMatrix(){super.updateModelMatrix(),this.setVisibleSize(),this.shouldUpdateViewMatrices()}updateWorldMatrix(){super.updateWorldMatrix(),this.shouldUpdateViewMatrices()}updateMatrixStack(){super.updateMatrixStack(),this.matricesNeedUpdate&&this.onMatricesChanged()}get fov(){return Ot(this,Ft)}set fov(e){e=Math.max(1,Math.min(e??this.fov,179)),e!==this.fov&&(Dt(this,Ft,e),this.shouldUpdateProjectionMatrices()),this.setVisibleSize(),this.setCSSPerspective()}get near(){return Ot(this,$t)}set near(e){e=Math.max(e??this.near,.01),e!==this.near&&(Dt(this,$t,e),this.shouldUpdateProjectionMatrices())}get far(){return Ot(this,Ut)}set far(e){e=Math.max(e??this.far,this.near+1),e!==this.far&&(Dt(this,Ut,e),this.shouldUpdateProjectionMatrices())}get pixelRatio(){return Ot(this,kt)}set pixelRatio(e){Dt(this,kt,e??this.pixelRatio),this.setCSSPerspective()}setSize({width:e,height:t}){(e!==this.size.width||t!==this.size.height)&&this.shouldUpdateProjectionMatrices(),this.size.width=e,this.size.height=t,this.setVisibleSize(),this.setCSSPerspective()}setPerspective({fov:e=this.fov,near:t=this.near,far:i=this.far,width:s=this.size.width,height:r=this.size.height,pixelRatio:o=this.pixelRatio}={}){this.setSize({width:s,height:r}),this.pixelRatio=o,this.fov=e,this.near=t,this.far=i}setCSSPerspective(){this.CSSPerspective=Math.pow(Math.pow(this.size.width/(2*this.pixelRatio),2)+Math.pow(this.size.height/(2*this.pixelRatio),2),.5)/Math.tan(this.fov*.5*Math.PI/180)}getVisibleSizeAtDepth(e=0){const t=this.position.z;e<t?e-=t:e+=t;const i=this.fov*Math.PI/180,s=2*Math.tan(i/2)*Math.abs(e);return{width:s*this.size.width/this.size.height,height:s}}setVisibleSize(){this.visibleSize=this.getVisibleSizeAtDepth()}lookAt(e=new f,t=this.position){super.lookAt(t,e,this.up)}updateProjectionMatrix(){this.projectionMatrix.makePerspective({fov:this.fov,aspect:this.size.width/this.size.height,near:this.near,far:this.far})}}Ft=new WeakMap,$t=new WeakMap,Ut=new WeakMap,kt=new WeakMap;class Ve{constructor(e,{label:t="Sampler",name:i,addressModeU:s="repeat",addressModeV:r="repeat",magFilter:o="linear",minFilter:a="linear",mipmapFilter:h="linear",maxAnisotropy:l=1,type:u="filtering",compare:d=null}={}){this.type="Sampler",this.uuid=Y(),e=W(e,t?t+" "+this.type:this.type),this.renderer=e,this.label=t,!i&&!this.renderer.production&&(i="sampler"+this.renderer.samplers.length,L(`Sampler: you are trying to create a sampler without the mandatory name parameter. A default name will be used instead: ${i}`)),this.name=i,this.options={addressModeU:s,addressModeV:r,magFilter:o,minFilter:a,mipmapFilter:h,maxAnisotropy:l,type:u,...d!==null&&{compare:d}},this.createSampler(),this.createBinding()}createSampler(){this.sampler=this.renderer.createSampler(this)}createBinding(){this.binding=new js({label:this.label,name:this.name,bindingType:"sampler",sampler:this.sampler,type:this.options.type})}}var Xs=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},On=(n,e,t)=>(Xs(n,e,"read from private field"),t?t.call(n):e.get(n)),Gn=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},Dn=(n,e,t,i)=>(Xs(n,e,"write to private field"),i?i.call(n,t):e.set(n,t),t),It;const Hs={label:"Texture",name:"renderTexture",type:"texture",access:"write",fromTexture:null,viewDimension:"2d",sampleCount:1,qualityRatio:1,generateMips:!1,flipY:!1,premultipliedAlpha:!1,autoDestroy:!0};class re{constructor(e,t=Hs){Gn(this,It,!0),e=W(e,t.label?t.label+" Texture":"Texture"),this.type="Texture",this.renderer=e,this.uuid=Y(),this.options={...Hs,...t},this.options.format==="rgba32float"&&!this.renderer.deviceManager.adapter.features.has("float32-filterable")&&(this.options.format="rgba16float"),t.fromTexture&&(this.options.format=t.fromTexture.texture.format,this.options.sampleCount=t.fromTexture.texture.sampleCount,this.options.viewDimension=t.fromTexture.options.viewDimension),this.options.format||(this.options.format=this.renderer.options.preferredFormat),this.size=this.options.fixedSize?{width:this.options.fixedSize.width*this.options.qualityRatio,height:this.options.fixedSize.height*this.options.qualityRatio,depth:this.options.fixedSize.depth??this.options.viewDimension.indexOf("cube")!==-1?6:1}:{width:Math.floor(this.renderer.canvas.width*this.options.qualityRatio),height:Math.floor(this.renderer.canvas.height*this.options.qualityRatio),depth:this.options.viewDimension.indexOf("cube")!==-1?6:1},this.options.fixedSize&&Dn(this,It,!1),this.setBindings(),this.renderer.addTexture(this),this.createTexture()}copy(e){this.options.fromTexture=e,this.createTexture()}copyGPUTexture(e){this.size={width:e.width,height:e.height,depth:e.depthOrArrayLayers},this.options.format=e.format,this.options.sampleCount=e.sampleCount,this.texture=e,this.textureBinding.setFormat(this.options.format),this.textureBinding.setMultisampled(this.options.sampleCount>1),this.textureBinding.resource=this.texture}createTexture(){if(!(!this.size.width||!this.size.height)){if(this.options.fromTexture){this.copyGPUTexture(this.options.fromTexture.texture);return}this.texture?.destroy(),this.texture=this.renderer.createTexture({label:this.options.label,format:this.options.format,size:[this.size.width,this.size.height,this.size.depth??1],dimensions:this.options.viewDimension,sampleCount:this.options.sampleCount,mipLevelCount:this.options.generateMips?Ns(this.size.width,this.size.height,this.size.depth??1):1,usage:_n(this.options.usage,this.options.type)}),this.textureBinding.resource=this.texture}}uploadSource({source:e,width:t=this.size.width,height:i=this.size.height,depth:s=this.size.depth,origin:r=[0,0,0],colorSpace:o="srgb"}){this.renderer.device.queue.copyExternalImageToTexture({source:e,flipY:this.options.flipY},{texture:this.texture,premultipliedAlpha:this.options.premultipliedAlpha,origin:r,colorSpace:o},[t,i,s]),this.texture.mipLevelCount>1&&Ri(this.renderer.device,this.texture)}uploadData({width:e=this.size.width,height:t=this.size.height,depth:i=this.size.depth,origin:s=[0,0,0],data:r=new Float32Array(e*t*4)}){this.renderer.device.queue.writeTexture({texture:this.texture,origin:s},r,{bytesPerRow:e*r.BYTES_PER_ELEMENT*4,rowsPerImage:t},[e,t,i]),this.texture.mipLevelCount>1&&Ri(this.renderer.device,this.texture)}setBindings(){this.bindings=[new Ai({label:this.options.label+": "+this.options.name+" texture",name:this.options.name,bindingType:this.options.type,visibility:this.options.visibility,texture:this.texture,format:this.options.format,viewDimension:this.options.viewDimension,multisampled:this.options.sampleCount>1})]}get textureBinding(){return this.bindings[0]}resize(e=null){On(this,It)&&(e||(e={width:Math.floor(this.renderer.canvas.width*this.options.qualityRatio),height:Math.floor(this.renderer.canvas.height*this.options.qualityRatio),depth:1}),!(e.width===this.size.width&&e.height===this.size.height&&e.depth===this.size.depth)&&(this.size=e,this.createTexture()))}destroy(){this.renderer.removeTexture(this),this.options.fromTexture||this.texture?.destroy(),this.texture=null}}It=new WeakMap;class Gi{constructor(e,t){this.type="Material",e=W(e,this.type),this.renderer=e,this.uuid=Y();const{shaders:i,label:s,useAsyncPipeline:r,uniforms:o,storages:a,bindings:h,bindGroups:l,samplers:u,textures:d,domTextures:c}=t;this.options={shaders:i,label:s,useAsyncPipeline:r===void 0?!0:r,...o!==void 0&&{uniforms:o},...a!==void 0&&{storages:a},...h!==void 0&&{bindings:h},...l!==void 0&&{bindGroups:l},...u!==void 0&&{samplers:u},...d!==void 0&&{textures:d},...c!==void 0&&{domTextures:c}},this.bindGroups=[],this.texturesBindGroups=[],this.clonedBindGroups=[],this.setBindGroups(),this.setTextures(),this.setSamplers()}compileMaterial(){const e=this.texturesBindGroup.bindings.length?1:0;this.bindGroups.length>=this.inputsBindGroups.length+e||this.createBindGroups()}get ready(){return!!(this.renderer.ready&&this.pipelineEntry&&this.pipelineEntry.pipeline&&this.pipelineEntry.ready)}loseContext(){for(const e of this.domTextures)e.texture=null,e.sourceUploaded=!1;for(const e of this.textures)e.texture=null;[...this.bindGroups,...this.clonedBindGroups,...this.inputsBindGroups].forEach(e=>e.loseContext()),this.pipelineEntry.pipeline=null}restoreContext(){for(const e of this.samplers)e.createSampler(),e.binding.resource=e.sampler;for(const e of this.domTextures)e.createTexture(),e.resize();for(const e of this.textures)e.resize(e.size);[...this.bindGroups,...this.clonedBindGroups,...this.inputsBindGroups].forEach(e=>{e.restoreContext()})}getShaderCode(e="full"){return this.pipelineEntry?(e=(()=>{switch(e){case"vertex":case"fragment":case"compute":case"full":return e;default:return"full"}})(),this.pipelineEntry.shaders[e].code):""}getAddedShaderCode(e="vertex"){return this.pipelineEntry?(e=(()=>{switch(e){case"vertex":case"fragment":case"compute":return e;default:return"vertex"}})(),this.pipelineEntry.shaders[e].head):""}setBindGroups(){if(this.uniforms={},this.storages={},this.inputsBindGroups=[],this.inputsBindings=new Map,this.options.uniforms||this.options.storages||this.options.bindings){const e=new Et(this.renderer,{label:this.options.label+": Bindings bind group",uniforms:this.options.uniforms,storages:this.options.storages,bindings:this.options.bindings});this.processBindGroupBindings(e),this.inputsBindGroups.push(e),e.consumers.add(this.uuid)}this.options.bindGroups?.forEach(e=>{this.processBindGroupBindings(e),this.inputsBindGroups.push(e),e.consumers.add(this.uuid)})}get texturesBindGroup(){return this.texturesBindGroups[0]}processBindGroupBindings(e){for(const t of e.bindings)t.bindingType==="uniform"&&(this.uniforms={...this.uniforms,[t.name]:t.inputs}),t.bindingType==="storage"&&(this.storages={...this.storages,[t.name]:t.inputs}),this.inputsBindings.set(t.name,t)}createBindGroups(){this.texturesBindGroup.shouldCreateBindGroup&&(this.texturesBindGroup.setIndex(this.bindGroups.length),this.texturesBindGroup.createBindGroup(),this.bindGroups.push(this.texturesBindGroup));for(const e of this.inputsBindGroups)e.shouldCreateBindGroup&&(e.setIndex(this.bindGroups.length),e.createBindGroup(),this.bindGroups.push(e));this.options.bindGroups?.forEach(e=>{if(!e.shouldCreateBindGroup&&!this.bindGroups.find(t=>t.uuid===e.uuid)&&(e.setIndex(this.bindGroups.length),this.bindGroups.push(e)),e instanceof Oi&&!this.texturesBindGroups.find(t=>t.uuid===e.uuid)){this.texturesBindGroups.push(e);for(const t of e.textures)t instanceof Oe&&!this.domTextures.find(i=>i.uuid===t.uuid)?this.domTextures.push(t):t instanceof re&&!this.textures.find(i=>i.uuid===t.uuid)&&this.textures.push(t)}})}cloneBindGroup({bindGroup:e,bindings:t=[],keepLayout:i=!0}){if(!e)return null;const s=e.clone({bindings:t,keepLayout:i});return this.clonedBindGroups.push(s),s}getBindGroupByBindingName(e=""){return(this.ready?this.bindGroups:this.inputsBindGroups).find(t=>t.bindings.find(i=>i.name===e))}destroyBindGroup(e){e.consumers.delete(this.uuid),e.consumers.size||e.destroy()}destroyBindGroups(){this.bindGroups.forEach(e=>this.destroyBindGroup(e)),this.clonedBindGroups.forEach(e=>this.destroyBindGroup(e)),this.texturesBindGroups.forEach(e=>this.destroyBindGroup(e)),this.texturesBindGroups=[],this.inputsBindGroups=[],this.bindGroups=[],this.clonedBindGroups=[]}updateBindGroups(){for(const e of this.bindGroups)this.updateBindGroup(e)}updateBindGroup(e){e.update(),e.needsPipelineFlush&&this.pipelineEntry.ready&&(this.pipelineEntry.flushPipelineEntry(this.bindGroups),e.needsPipelineFlush=!1)}getBindingByName(e=""){return this.inputsBindings.get(e)}getBufferBindingByName(e=""){const t=this.getBindingByName(e);return t&&"buffer"in t?t:void 0}shouldUpdateInputsBindings(e,t){if(!e)return;const i=this.getBindingByName(e);i&&(t?i.shouldUpdateBinding(t):Object.keys(i.inputs).forEach(s=>i.shouldUpdateBinding(s)))}setTextures(){this.domTextures=[],this.textures=[],this.texturesBindGroups.push(new Oi(this.renderer,{label:this.options.label+": Textures bind group"})),this.texturesBindGroup.consumers.add(this.uuid),this.options.domTextures?.forEach(e=>{this.addTexture(e)}),this.options.textures?.forEach(e=>{this.addTexture(e)})}addTexture(e){e instanceof Oe?this.domTextures.push(e):e instanceof re&&this.textures.push(e),(this.options.shaders.vertex&&this.options.shaders.vertex.code.indexOf(e.options.name)!==-1||this.options.shaders.fragment&&this.options.shaders.fragment.code.indexOf(e.options.name)!==-1||this.options.shaders.compute&&this.options.shaders.compute.code.indexOf(e.options.name)!==-1)&&this.texturesBindGroup.addTexture(e)}destroyTexture(e){if(e.options.cache||!e.options.autoDestroy)return;const t=this.renderer.getObjectsByTexture(e);(!t||!t.some(s=>s.material.uuid!==this.uuid))&&e.destroy()}destroyTextures(){this.domTextures?.forEach(e=>this.destroyTexture(e)),this.textures?.forEach(e=>this.destroyTexture(e)),this.domTextures=[],this.textures=[]}setSamplers(){if(this.samplers=[],this.options.samplers?.forEach(t=>{this.addSampler(t)}),!this.samplers.find(t=>t.name==="defaultSampler")){const t=new Ve(this.renderer,{label:"Default sampler",name:"defaultSampler"});this.addSampler(t)}}addSampler(e){this.samplers.push(e),(this.options.shaders.vertex&&this.options.shaders.vertex.code.indexOf(e.name)!==-1||this.options.shaders.fragment&&this.options.shaders.fragment.code.indexOf(e.name)!==-1||this.options.shaders.compute&&this.options.shaders.compute.code.indexOf(e.name)!==-1)&&this.texturesBindGroup.addSampler(e)}async getBufferResult(e){return await e.mapBufferAsync()}async getBufferBindingResultByBindingName(e=""){const t=this.getBufferBindingByName(e);if(t&&"buffer"in t){const i=this.renderer.copyBufferToBuffer({srcBuffer:t.buffer});return await this.getBufferResult(i)}else return new Float32Array(0)}async getBufferElementResultByNames({bindingName:e,bufferElementName:t}){const i=await this.getBufferBindingResultByBindingName(e);if(!t||i.length)return i;{const s=this.getBufferBindingByName(e);return s?s.extractBufferElementDataFromBufferResult({result:i,bufferElementName:t}):i}}onBeforeRender(){this.compileMaterial();for(const e of this.domTextures)e.render();this.updateBindGroups()}setPipeline(e){this.renderer.pipelineManager.setCurrentPipeline(e,this.pipelineEntry)}setActiveBindGroups(e){this.renderer.pipelineManager.setActiveBindGroups(e,this.bindGroups)}render(e){this.ready&&(this.setPipeline(e),this.setActiveBindGroups(e))}destroy(){this.destroyBindGroups(),this.destroyTextures()}}class Zs extends Gi{constructor(e,t){const i="ComputeMaterial";e=W(e,i),super(e,t),this.type=i,this.renderer=e;let{shaders:s,dispatchSize:r}=t;(!s||!s.compute)&&(s={compute:{code:"",entryPoint:"main"}}),s.compute.code||(s.compute.code="@compute @workgroup_size(1) fn main(){}"),s.compute.entryPoint||(s.compute.entryPoint="main"),this.options={...this.options,shaders:s,...t.dispatchSize!==void 0&&{dispatchSize:t.dispatchSize}},r||(r=1),Array.isArray(r)?(r[0]=Math.ceil(r[0]??1),r[1]=Math.ceil(r[1]??1),r[2]=Math.ceil(r[2]??1)):isNaN(r)||(r=[Math.ceil(r),1,1]),this.dispatchSize=r,this.pipelineEntry=this.renderer.pipelineManager.createComputePipeline({renderer:this.renderer,label:this.options.label+" compute pipeline",shaders:this.options.shaders,useAsync:this.options.useAsyncPipeline})}setPipelineEntryProperties(){this.pipelineEntry.setPipelineEntryProperties({bindGroups:this.bindGroups})}async compilePipelineEntry(){await this.pipelineEntry.compilePipelineEntry()}async compileMaterial(){this.ready||(super.compileMaterial(),this.pipelineEntry&&this.pipelineEntry.canCompile&&(this.setPipelineEntryProperties(),await this.compilePipelineEntry()))}getShaderCode(e="compute"){return super.getShaderCode(e)}getAddedShaderCode(e="compute"){return super.getAddedShaderCode(e)}useCustomRender(e){e&&(this._useCustomRenderCallback=e)}render(e){if(this.ready)if(this.setPipeline(e),this._useCustomRenderCallback!==void 0)this._useCustomRenderCallback(e);else{for(const t of this.bindGroups)e.setBindGroup(t.index,t.bindGroup);e.dispatchWorkgroups(this.dispatchSize[0],this.dispatchSize[1],this.dispatchSize[2])}}copyBufferToResult(e){for(const t of this.bindGroups)t.bufferBindings.forEach(i=>{i.shouldCopyResult&&this.renderer.copyBufferToBuffer({srcBuffer:i.buffer,dstBuffer:i.resultBuffer,commandEncoder:e})})}async getComputeResult({bindingName:e="",bufferElementName:t=""}){const i=this.getBufferBindingByName(e);if(i&&"resultBuffer"in i){const s=await this.getBufferResult(i.resultBuffer);return t&&s.length?i.extractBufferElementDataFromBufferResult({result:s,bufferElementName:t}):s}else return new Float32Array(0)}}var Ks=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},Js=(n,e,t)=>(Ks(n,e,"read from private field"),t?t.call(n):e.get(n)),Fn=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},$n=(n,e,t,i)=>(Ks(n,e,"write to private field"),i?i.call(n,t):e.set(n,t),t),rt;let Un=0;class Qs{constructor(e,t={}){Fn(this,rt,!0),this._onReadyCallback=()=>{},this._onBeforeRenderCallback=()=>{},this._onRenderCallback=()=>{},this._onAfterRenderCallback=()=>{},this._onAfterResizeCallback=()=>{};const i="ComputePass";e=W(e,t.label?`${t.label} ${i}`:i),t.label=t.label??"ComputePass "+e.computePasses?.length,this.renderer=e,this.type=i,this.uuid=Y(),Object.defineProperty(this,"index",{value:Un++});const{label:s,shaders:r,renderOrder:o,uniforms:a,storages:h,bindGroups:l,samplers:u,domTextures:d,textures:c,autoRender:p,useAsyncPipeline:g,texturesOptions:m,dispatchSize:y}=t;this.options={label:s,shaders:r,...p!==void 0&&{autoRender:p},...o!==void 0&&{renderOrder:o},...y!==void 0&&{dispatchSize:y},useAsyncPipeline:g===void 0?!0:g,texturesOptions:m},this.renderOrder=o??0,p!==void 0&&$n(this,rt,p),this.userData={},this.ready=!1,this.setMaterial({label:this.options.label,shaders:this.options.shaders,uniforms:a,storages:h,bindGroups:l,samplers:u,textures:c,domTextures:d,useAsyncPipeline:g,dispatchSize:y}),this.addToScene()}get ready(){return this._ready}set ready(e){e&&this._onReadyCallback&&this._onReadyCallback(),this._ready=e}addToScene(){this.renderer.computePasses.push(this),Js(this,rt)&&this.renderer.scene.addComputePass(this)}removeFromScene(){Js(this,rt)&&this.renderer.scene.removeComputePass(this),this.renderer.computePasses=this.renderer.computePasses.filter(e=>e.uuid!==this.uuid)}setMaterial(e){this.useMaterial(new Zs(this.renderer,e))}useMaterial(e){this.material=e}loseContext(){this.material.loseContext()}restoreContext(){this.material.restoreContext()}get domTextures(){return this.material?.domTextures||[]}get textures(){return this.material?.textures||[]}createDOMTexture(e){e.name||(e.name="texture"+(this.textures.length+this.domTextures.length)),e.label||(e.label=this.options.label+" "+e.name);const t=new Oe(this.renderer,{...e,...this.options.texturesOptions});return this.addTexture(t),t}createTexture(e){e.name||(e.name="texture"+(this.textures.length+this.domTextures.length));const t=new re(this.renderer,e);return this.addTexture(t),t}addTexture(e){this.material.addTexture(e)}get uniforms(){return this.material?.uniforms}get storages(){return this.material?.storages}resize(){this._onAfterResizeCallback&&this._onAfterResizeCallback()}onReady(e){return e&&(this._onReadyCallback=e),this}onBeforeRender(e){return e&&(this._onBeforeRenderCallback=e),this}onRender(e){return e&&(this._onRenderCallback=e),this}onAfterRender(e){return e&&(this._onAfterRenderCallback=e),this}useCustomRender(e){return this.material.useCustomRender(e),this}onAfterResize(e){return e&&(this._onAfterResizeCallback=e),this}onBeforeRenderPass(){this.renderer.ready&&(this.material&&this.material.ready&&!this.ready&&(this.ready=!0),this._onBeforeRenderCallback&&this._onBeforeRenderCallback(),this.material.onBeforeRender())}onRenderPass(e){this.material.ready&&(this._onRenderCallback&&this._onRenderCallback(),this.material.render(e))}onAfterRenderPass(){this._onAfterRenderCallback&&this._onAfterRenderCallback()}render(e){this.onBeforeRenderPass(),this.renderer.ready&&(!this.renderer.production&&e.pushDebugGroup(this.options.label),this.onRenderPass(e),!this.renderer.production&&e.popDebugGroup(),this.onAfterRenderPass())}copyBufferToResult(e){this.material?.copyBufferToResult(e)}async getComputeResult({bindingName:e,bufferElementName:t}){return await this.material?.getComputeResult({bindingName:e,bufferElementName:t})}remove(){this.removeFromScene(),this.destroy()}destroy(){this.material?.destroy()}}rt=new WeakMap;const le=[new f,new f,new f,new f,new f,new f,new f,new f];class ve{constructor(e=new f(1/0),t=new f(-1/0)){this.min=e,this.max=t}set(e=new f(1/0),t=new f(-1/0)){return this.min.copy(e),this.max.copy(t),this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}copy(e){return this.set(e.min.clone(),e.max.clone()),this}clone(){return new ve().copy(this)}get center(){return this.max.clone().add(this.min).multiplyScalar(.5)}get size(){return this.max.clone().sub(this.min)}get radius(){return this.max.distance(this.min)*.5}applyMat4(e=new G,t=new ve){if(this.isEmpty())return this;const i=[];this.min.z===this.max.z?(i[0]=le[0].set(this.min.x,this.min.y,this.min.z).applyMat4(e),i[1]=le[2].set(this.min.x,this.max.y,this.min.z).applyMat4(e),i[2]=le[4].set(this.max.x,this.min.y,this.min.z).applyMat4(e),i[3]=le[6].set(this.max.x,this.max.y,this.min.z).applyMat4(e)):(i[0]=le[0].set(this.min.x,this.min.y,this.min.z).applyMat4(e),i[1]=le[1].set(this.min.x,this.min.y,this.max.z).applyMat4(e),i[2]=le[2].set(this.min.x,this.max.y,this.min.z).applyMat4(e),i[3]=le[3].set(this.min.x,this.max.y,this.max.z).applyMat4(e),i[4]=le[4].set(this.max.x,this.min.y,this.min.z).applyMat4(e),i[5]=le[5].set(this.max.x,this.min.y,this.max.z).applyMat4(e),i[6]=le[6].set(this.max.x,this.max.y,this.min.z).applyMat4(e),i[7]=le[7].set(this.max.x,this.max.y,this.max.z).applyMat4(e));for(let s=0,r=i.length;s<r;s++)t.min.min(i[s]),t.max.max(i[s]);return t}}const er={top:0,right:0,bottom:0,left:0};class tr{constructor({boundingBox:e=new ve,modelViewProjectionMatrix:t=new G,containerBoundingRect:i={top:0,right:0,bottom:0,left:0,width:0,height:0,x:0,y:0},DOMFrustumMargins:s=er,onReEnterView:r=()=>{},onLeaveView:o=()=>{}}){this.boundingBox=e,this.clipSpaceOBB=new ve,this.modelViewProjectionMatrix=t,this.containerBoundingRect=i,this.DOMFrustumMargins={...er,...s},this.clipSpaceBoundingRect={top:0,left:0,width:0,height:0},this.projectedBoundingRect={top:0,right:0,bottom:0,left:0,width:0,height:0,x:0,y:0},this.onReEnterView=r,this.onLeaveView=o,this.isIntersecting=!1}setContainerBoundingRect(e){this.containerBoundingRect=e}get DOMFrustumBoundingRect(){return{top:this.projectedBoundingRect.top-this.DOMFrustumMargins.top,right:this.projectedBoundingRect.right+this.DOMFrustumMargins.right,bottom:this.projectedBoundingRect.bottom+this.DOMFrustumMargins.bottom,left:this.projectedBoundingRect.left-this.DOMFrustumMargins.left}}computeClipSpaceOBB(){this.clipSpaceOBB.set(),this.boundingBox.applyMat4(this.modelViewProjectionMatrix,this.clipSpaceOBB)}setDocumentCoordsFromClipSpaceOBB(){this.computeClipSpaceOBB(),this.clipSpaceBoundingRect={top:this.clipSpaceOBB.max.y,left:this.clipSpaceOBB.min.x,width:this.clipSpaceOBB.max.x-this.clipSpaceOBB.min.x,height:this.clipSpaceOBB.max.y-this.clipSpaceOBB.min.y};const e=(this.clipSpaceOBB.min.x+1)*.5,t=(this.clipSpaceOBB.max.x+1)*.5,i=1-(this.clipSpaceOBB.min.y+1)*.5,s=1-(this.clipSpaceOBB.max.y+1)*.5,{width:r,height:o,top:a,left:h}=this.containerBoundingRect;this.projectedBoundingRect={left:e*r+h,x:e*r+h,top:s*o+a,y:s*o+a,right:t*r+h,bottom:i*o+a,width:t*r+h-(e*r+h),height:i*o+a-(s*o+a)}}setDocumentCoordsFromClipSpaceSphere(e={center:new f,radius:0}){this.clipSpaceBoundingRect={top:e.center.y+e.radius,left:e.center.x-e.radius,width:e.radius*2,height:e.radius*2};const t=(e.center.x+1)*.5,i=1-(e.center.y+1)*.5,{width:s,height:r,top:o,left:a}=this.containerBoundingRect;this.projectedBoundingRect.width=e.radius*r,this.projectedBoundingRect.height=e.radius*r,this.projectedBoundingRect.left=t*s+a-this.projectedBoundingRect.width*.5,this.projectedBoundingRect.x=this.projectedBoundingRect.left,this.projectedBoundingRect.top=i*r+o-this.projectedBoundingRect.height*.5,this.projectedBoundingRect.y=this.projectedBoundingRect.top,this.projectedBoundingRect.right=this.projectedBoundingRect.left+this.projectedBoundingRect.width,this.projectedBoundingRect.bottom=this.projectedBoundingRect.top+this.projectedBoundingRect.height}intersectsContainer(){Math.round(this.DOMFrustumBoundingRect.right)<=this.containerBoundingRect.left||Math.round(this.DOMFrustumBoundingRect.left)>=this.containerBoundingRect.left+this.containerBoundingRect.width||Math.round(this.DOMFrustumBoundingRect.bottom)<=this.containerBoundingRect.top||Math.round(this.DOMFrustumBoundingRect.top)>=this.containerBoundingRect.top+this.containerBoundingRect.height?(this.isIntersecting&&this.onLeaveView(),this.isIntersecting=!1):(this.isIntersecting||this.onReEnterView(),this.isIntersecting=!0)}}class Di{constructor({verticesOrder:e="ccw",topology:t="triangle-list",instancesCount:i=1,vertexBuffers:s=[],mapBuffersAtCreation:r=!0}={}){this.verticesCount=0,this.verticesOrder=e,this.topology=t,this.instancesCount=i,this.ready=!1,this.boundingBox=new ve,this.type="Geometry",this.uuid=Y(),this.vertexBuffers=[],this.consumers=new Set,this.options={verticesOrder:e,topology:t,instancesCount:i,vertexBuffers:s,mapBuffersAtCreation:r};const o=s.find(a=>a.name==="attributes");!s.length||!o?this.addVertexBuffer({name:"attributes"}):o&&s.sort((a,h)=>{const l=a.name!=="attributes"?1/0:-1,u=h.name!=="attributes"?1/0:-1;return l-u});for(const a of s)this.addVertexBuffer({stepMode:a.stepMode??"vertex",name:a.name,attributes:a.attributes,...a.array&&{array:a.array},...a.buffer&&{buffer:a.buffer},...a.bufferOffset&&{bufferOffset:a.bufferOffset},...a.bufferSize&&{bufferSize:a.bufferSize}});o&&this.setWGSLFragment()}loseContext(){this.ready=!1;for(const e of this.vertexBuffers)e.buffer.destroy()}restoreContext(e){if(!this.ready){for(const t of this.vertexBuffers)!t.buffer.GPUBuffer&&t.buffer.consumers.size===0&&(t.buffer.createBuffer(e),this.uploadBuffer(e,t)),t.buffer.consumers.add(this.uuid);this.ready=!0}}addVertexBuffer({stepMode:e="vertex",name:t,attributes:i=[],buffer:s=null,array:r=null,bufferOffset:o=0,bufferSize:a=null}={}){s=s||new Ie;const h={name:t??"attributes"+this.vertexBuffers.length,stepMode:e,arrayStride:0,bufferLength:0,attributes:[],buffer:s,array:r,bufferOffset:o,bufferSize:a};return i?.forEach(l=>{this.setAttribute({vertexBuffer:h,...l})}),this.vertexBuffers.push(h),h}getVertexBufferByName(e=""){return this.vertexBuffers.find(t=>t.name===e)}setAttribute({vertexBuffer:e=this.vertexBuffers[0],name:t,type:i="vec3f",bufferFormat:s="float32x3",size:r=3,array:o=new Float32Array(this.verticesCount*r),verticesStride:a=1}){const h=e.attributes,l=h.length;t||(t="geometryAttribute"+l),t==="position"&&(i!=="vec3f"||s!=="float32x3"||r!==3)&&(L(`Geometry 'position' attribute must have this exact properties set:
	type: 'vec3f',
	bufferFormat: 'float32x3',
	size: 3`),i="vec3f",s="float32x3",r=3);let u=o.length;const d=u/r;t==="position"&&(this.verticesCount=d),e.stepMode==="vertex"&&this.verticesCount&&this.verticesCount!==d*a?ie(`Geometry vertex attribute error. Attribute array of size ${r} must be of length: ${this.verticesCount*r}, current given: ${o.length}. (${this.verticesCount} vertices).`):e.stepMode==="instance"&&d!==this.instancesCount&&(e.buffer?u=this.instancesCount*r:ie(`Geometry instance attribute error. Attribute array of size ${r} must be of length: ${this.instancesCount*r}, current given: ${o.length}. (${this.instancesCount} instances).`));const c={name:t,type:i,bufferFormat:s,size:r,bufferLength:u,offset:l?h.reduce((p,g)=>p+g.bufferLength,0):0,bufferOffset:l?h[l-1].bufferOffset+h[l-1].size*4:0,array:o,verticesStride:a};e.bufferLength+=c.bufferLength*a,e.arrayStride+=c.size,e.attributes.push(c)}get shouldCompute(){return this.vertexBuffers.length&&!this.vertexBuffers[0].array}getAttributeByName(e){let t;for(const i of this.vertexBuffers)if(t=i.attributes.find(s=>s.name===e),t)break;return t}computeGeometry(){this.ready||(this.vertexBuffers.forEach((e,t)=>{if(t===0){const r=e.attributes.find(o=>o.name==="position");r||ie("Geometry must have a 'position' attribute"),(r.type!=="vec3f"||r.bufferFormat!=="float32x3"||r.size!==3)&&(L(`Geometry 'position' attribute must have this exact properties set:
	type: 'vec3f',
	bufferFormat: 'float32x3',
	size: 3`),r.type="vec3f",r.bufferFormat="float32x3",r.size=3)}e.array=new Float32Array(e.bufferLength);let i=0,s=0;for(let r=0;r<e.bufferLength;r+=e.arrayStride){for(let o=0;o<e.attributes.length;o++){const{name:a,size:h,array:l,verticesStride:u}=e.attributes[o];for(let d=0;d<h;d++){const c=l[Math.floor(s/u)*h+d];e.array[i]=c??0,a==="position"&&(d%3===0?(this.boundingBox.min.x>c&&(this.boundingBox.min.x=c),this.boundingBox.max.x<c&&(this.boundingBox.max.x=c)):d%3===1?(this.boundingBox.min.y>c&&(this.boundingBox.min.y=c),this.boundingBox.max.y<c&&(this.boundingBox.max.y=c)):d%3===2&&(this.boundingBox.min.z>c&&(this.boundingBox.min.z=c),this.boundingBox.max.z<c&&(this.boundingBox.max.z=c))),i++}}s++}}),this.wgslStructFragment||this.setWGSLFragment())}setWGSLFragment(){let e=-1;this.wgslStructFragment=`struct Attributes {
	@builtin(vertex_index) vertexIndex : u32,
	@builtin(instance_index) instanceIndex : u32,${this.vertexBuffers.map(t=>t.attributes.map(i=>(e++,`
	@location(${e}) ${i.name}: ${i.type}`))).join(",")}
};`,this.layoutCacheKey=this.vertexBuffers.map(t=>t.name+","+t.attributes.map(i=>`${i.name},${i.size}`)).join(",")+","}createBuffers({renderer:e,label:t=this.type}){if(!this.ready){for(const i of this.vertexBuffers)i.bufferSize||(i.bufferSize=i.array.length*i.array.constructor.BYTES_PER_ELEMENT),!i.buffer.GPUBuffer&&!i.buffer.consumers.size&&(i.buffer.createBuffer(e,{label:t+": "+i.name+" buffer",size:i.bufferSize,usage:this.options.mapBuffersAtCreation?["vertex"]:["copyDst","vertex"],mappedAtCreation:this.options.mapBuffersAtCreation}),this.uploadBuffer(e,i)),i.buffer.consumers.add(this.uuid);this.ready=!0}}uploadBuffer(e,t){this.options.mapBuffersAtCreation?(new t.array.constructor(t.buffer.GPUBuffer.getMappedRange()).set(t.array),t.buffer.GPUBuffer.unmap()):e.queueWriteBuffer(t.buffer.GPUBuffer,0,t.array)}setGeometryBuffers(e){this.vertexBuffers.forEach((t,i)=>{e.setVertexBuffer(i,t.buffer.GPUBuffer,t.bufferOffset,t.bufferSize)})}drawGeometry(e){e.draw(this.verticesCount,this.instancesCount)}render(e){this.ready&&(this.setGeometryBuffers(e),this.drawGeometry(e))}destroy(e=null){this.ready=!1;for(const t of this.vertexBuffers)t.buffer.consumers.delete(this.uuid),t.buffer.consumers.size||t.buffer.destroy(),t.array=null,e&&e.removeBuffer(t.buffer)}}class nt extends Di{constructor({verticesOrder:e="ccw",topology:t="triangle-list",instancesCount:i=1,vertexBuffers:s=[],mapBuffersAtCreation:r=!0}={}){super({verticesOrder:e,topology:t,instancesCount:i,vertexBuffers:s,mapBuffersAtCreation:r}),this.type="IndexedGeometry"}loseContext(){super.loseContext(),this.indexBuffer&&this.indexBuffer.buffer.destroy()}restoreContext(e){this.ready||(this.indexBuffer.buffer.GPUBuffer||(this.indexBuffer.buffer.createBuffer(e),this.uploadBuffer(e,this.indexBuffer),this.indexBuffer.buffer.consumers.add(this.uuid)),super.restoreContext(e))}get useUint16IndexArray(){return this.verticesCount<256*256}setIndexBuffer({bufferFormat:e="uint32",array:t=new Uint32Array(0),buffer:i=new Ie,bufferOffset:s=0,bufferSize:r=null}){this.indexBuffer={array:t,bufferFormat:e,bufferLength:t.length,buffer:i,bufferOffset:s,bufferSize:r!==null?r:t.length*t.constructor.BYTES_PER_ELEMENT}}createBuffers({renderer:e,label:t=this.type}){this.indexBuffer.buffer.GPUBuffer||(this.indexBuffer.buffer.createBuffer(e,{label:t+": index buffer",size:this.indexBuffer.array.byteLength,usage:this.options.mapBuffersAtCreation?["index"]:["copyDst","index"],mappedAtCreation:this.options.mapBuffersAtCreation}),this.uploadBuffer(e,this.indexBuffer)),this.indexBuffer.buffer.consumers.add(this.uuid),super.createBuffers({renderer:e,label:t})}setGeometryBuffers(e){super.setGeometryBuffers(e),e.setIndexBuffer(this.indexBuffer.buffer.GPUBuffer,this.indexBuffer.bufferFormat,this.indexBuffer.bufferOffset,this.indexBuffer.bufferSize)}drawGeometry(e){e.drawIndexed(this.indexBuffer.bufferLength,this.instancesCount)}destroy(e=null){super.destroy(e),this.indexBuffer&&(this.indexBuffer.buffer.consumers.delete(this.uuid),this.indexBuffer.buffer.destroy(),e&&e.removeBuffer(this.indexBuffer.buffer))}}class Fi extends nt{constructor({widthSegments:e=1,heightSegments:t=1,instancesCount:i=1,vertexBuffers:s=[],topology:r}={}){super({verticesOrder:"ccw",topology:r,instancesCount:i,vertexBuffers:s,mapBuffersAtCreation:!0}),this.type="PlaneGeometry",e=Math.floor(e),t=Math.floor(t),this.definition={id:e*t+e,width:e,height:t,count:e*t};const o=(this.definition.width+1)*(this.definition.height+1),a=this.getIndexedVerticesAndUVs(o);for(const h of Object.values(a))this.setAttribute(h);this.setIndexArray()}setIndexArray(){const e=this.useUint16IndexArray?new Uint16Array(this.definition.count*6):new Uint32Array(this.definition.count*6);let t=0;for(let i=0;i<this.definition.height;i++)for(let s=0;s<this.definition.width;s++)e[t++]=s+i*(this.definition.width+1),e[t++]=this.definition.width+s+1+i*(this.definition.width+1),e[t++]=s+1+i*(this.definition.width+1),e[t++]=s+1+i*(this.definition.width+1),e[t++]=this.definition.width+s+1+i*(this.definition.width+1),e[t++]=this.definition.width+s+2+i*(this.definition.width+1);this.setIndexBuffer({array:e,bufferFormat:this.useUint16IndexArray?"uint16":"uint32"})}getIndexedVerticesAndUVs(e){const t={name:"uv",type:"vec2f",bufferFormat:"float32x2",size:2,array:new Float32Array(e*2)},i={name:"position",type:"vec3f",bufferFormat:"float32x3",size:3,array:new Float32Array(e*3)},s={name:"normal",type:"vec3f",bufferFormat:"float32x3",size:3,array:new Float32Array(e*3)};let r=0,o=0,a=0;for(let h=0;h<=this.definition.height;h++)for(let l=0;l<=this.definition.width;l++)t.array[a++]=1-l/this.definition.width,t.array[a++]=1-h/this.definition.height,i.array[r++]=1-l*2/this.definition.width,i.array[r++]=h*2/this.definition.height-1,i.array[r++]=0,s.array[o++]=0,s.array[o++]=0,s.array[o++]=1;return{position:i,uv:t,normal:s}}}var ir=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},Vt=(n,e,t)=>(ir(n,e,"read from private field"),t?t.call(n):e.get(n)),sr=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},rr=(n,e,t,i)=>(ir(n,e,"write to private field"),i?i.call(n,t):e.set(n,t),t),Nt,Ne;class $i extends xe{constructor(e,{color:t=new f(1),intensity:i=1,index:s=0,type:r="lights"}={}){super(),sr(this,Nt,void 0),sr(this,Ne,void 0),this.type=r,Object.defineProperty(this,"index",{value:s}),e=Le(e,this.constructor.name),this.renderer=e,this.setRendererBinding(),this.uuid=Y(),this.options={color:t,intensity:i},this.color=t,rr(this,Ne,this.color.clone()),this.color.onChange(()=>this.onPropertyChanged("color",Vt(this,Ne).copy(this.color).multiplyScalar(this.intensity))),this.intensity=i,this.renderer.addLight(this)}setRendererBinding(){this.renderer.bindings[this.type]&&(this.rendererBinding=this.renderer.bindings[this.type])}reset(){this.setRendererBinding(),this.onPropertyChanged("color",Vt(this,Ne).copy(this.color).multiplyScalar(this.intensity))}get intensity(){return Vt(this,Nt)}set intensity(e){rr(this,Nt,e),this.onPropertyChanged("color",Vt(this,Ne).copy(this.color).multiplyScalar(this.intensity))}onPropertyChanged(e,t){this.rendererBinding&&this.rendererBinding.inputs[e]&&(t instanceof f?(this.rendererBinding.inputs[e].value[this.index*3]=t.x,this.rendererBinding.inputs[e].value[this.index*3+1]=t.y,this.rendererBinding.inputs[e].value[this.index*3+2]=t.z):this.rendererBinding.inputs[e].value[this.index]=t,this.rendererBinding.inputs[e].shouldUpdate=!0,this.renderer.shouldUpdateCameraLightsBindGroup())}onMaxLightOverflow(e){this.rendererBinding&&(this.renderer.onMaxLightOverflow(e),this.rendererBinding=this.renderer.bindings[e])}remove(){this.renderer.removeLight(this)}destroy(){this.parent=null}}Nt=new WeakMap,Ne=new WeakMap;class kn extends $i{constructor(e,{color:t=new f(1),intensity:i=.1}={}){const s="ambientLights",r=e.lights.filter(o=>o.type===s).length;super(e,{color:t,intensity:i,index:r,type:s}),this.index+1>this.renderer.lightsBindingParams[this.type].max&&this.onMaxLightOverflow(this.type),this.rendererBinding.inputs.count.value=this.index+1,this.rendererBinding.inputs.count.shouldUpdate=!0}applyRotation(){}applyPosition(){}applyScale(){}applyTransformOrigin(){}}class Wt{constructor(e,{label:t="Render Pass",sampleCount:i=4,qualityRatio:s=1,useColorAttachments:r=!0,renderToSwapChain:o=!0,colorAttachments:a=[],useDepth:h=!0,depthTexture:l=null,depthLoadOp:u="clear",depthStoreOp:d="store",depthClearValue:c=1,depthFormat:p="depth24plus"}={}){if(e=W(e,"RenderPass"),this.type="RenderPass",this.uuid=Y(),this.renderer=e,r){const g={loadOp:"clear",storeOp:"store",clearValue:[0,0,0,0],targetFormat:this.renderer.options.preferredFormat};a.length?a=a.map(m=>({...g,...m})):a=[g]}this.options={label:t,sampleCount:i,qualityRatio:s,useColorAttachments:r,renderToSwapChain:o,colorAttachments:a,useDepth:h,...l!==void 0&&{depthTexture:l},depthLoadOp:u,depthStoreOp:d,depthClearValue:c,depthFormat:p},this.options.useDepth&&this.createDepthTexture(),this.viewTextures=[],this.resolveTargets=[],this.options.useColorAttachments&&(!this.options.renderToSwapChain||this.options.sampleCount>1)&&(this.createViewTextures(),this.createResolveTargets()),this.setRenderPassDescriptor()}createDepthTexture(){this.options.depthTexture?(this.depthTexture=this.options.depthTexture,this.options.depthFormat=this.options.depthTexture.options.format):this.depthTexture=new re(this.renderer,{label:this.options.label+" depth texture",name:"depthTexture",format:this.options.depthFormat,sampleCount:this.options.sampleCount,qualityRatio:this.options.qualityRatio,type:"depth",usage:["renderAttachment","textureBinding"]})}createViewTextures(){this.options.colorAttachments.forEach((e,t)=>{this.viewTextures.push(new re(this.renderer,{label:`${this.options.label} colorAttachment[${t}] view texture`,name:`colorAttachment${t}ViewTexture`,format:e.targetFormat,sampleCount:this.options.sampleCount,qualityRatio:this.options.qualityRatio,type:"texture",usage:["copySrc","copyDst","renderAttachment","textureBinding"]}))})}createResolveTargets(){this.options.sampleCount>1&&this.options.colorAttachments.forEach((e,t)=>{this.resolveTargets.push(this.options.renderToSwapChain&&t===0?null:new re(this.renderer,{label:`${this.options.label} resolve target[${t}] texture`,name:`resolveTarget${t}Texture`,format:e.targetFormat,sampleCount:1,qualityRatio:this.options.qualityRatio,type:"texture"}))})}get outputTextures(){return this.options.sampleCount>1?this.resolveTargets:this.viewTextures}setRenderPassDescriptor(e=null){this.descriptor={label:this.options.label+" descriptor",colorAttachments:this.options.colorAttachments.map((t,i)=>({view:this.viewTextures[i]?.texture.createView({label:this.viewTextures[i]?.texture.label+" view"}),...this.resolveTargets.length&&{resolveTarget:this.resolveTargets[i]?.texture.createView({label:this.resolveTargets[i]?.texture.label+" view"})},clearValue:t.clearValue,loadOp:t.loadOp,storeOp:t.storeOp})),...this.options.useDepth&&{depthStencilAttachment:{view:e||this.depthTexture.texture.createView({label:this.depthTexture.texture.label+" view"}),depthClearValue:this.options.depthClearValue,depthLoadOp:this.options.depthLoadOp,depthStoreOp:this.options.depthStoreOp}}}}resize(){this.options.useDepth&&(this.descriptor.depthStencilAttachment.view=this.depthTexture.texture.createView({label:this.depthTexture.options.label+" view"})),this.viewTextures.forEach((e,t)=>{this.descriptor.colorAttachments[t].view=e.texture.createView({label:e.options.label+" view"})}),this.resolveTargets.forEach((e,t)=>{e&&(this.descriptor.colorAttachments[t].resolveTarget=e.texture.createView({label:e.options.label+" view"}))})}setLoadOp(e="clear",t=0){this.options.useColorAttachments&&(this.options.colorAttachments[t]&&(this.options.colorAttachments[t].loadOp=e),this.descriptor&&this.descriptor.colorAttachments&&this.descriptor.colorAttachments[t]&&(this.descriptor.colorAttachments[t].loadOp=e))}setDepthLoadOp(e="clear"){this.options.depthLoadOp=e,this.options.useDepth&&this.descriptor.depthStencilAttachment&&(this.descriptor.depthStencilAttachment.depthLoadOp=e)}setClearValue(e=[0,0,0,0],t=0){if(this.options.useColorAttachments){if(this.renderer.alphaMode==="premultiplied"){const i=e[3];e[0]=Math.min(e[0],i),e[1]=Math.min(e[1],i),e[2]=Math.min(e[2],i)}this.options.colorAttachments[t]&&(this.options.colorAttachments[t].clearValue=e),this.descriptor&&this.descriptor.colorAttachments&&this.descriptor.colorAttachments[t]&&(this.descriptor.colorAttachments[t].clearValue=e)}}updateView(e=null){return!this.options.colorAttachments.length||!this.options.renderToSwapChain||(e||(e=this.renderer.context.getCurrentTexture(),e.label=`${this.renderer.type} context current texture`),this.options.sampleCount>1?(this.descriptor.colorAttachments[0].view=this.viewTextures[0].texture.createView({label:this.viewTextures[0].options.label+" view"}),this.descriptor.colorAttachments[0].resolveTarget=e.createView({label:e.label+" resolve target view"})):this.descriptor.colorAttachments[0].view=e.createView({label:e.label+" view"})),e}destroy(){this.viewTextures.forEach(e=>e.destroy()),this.resolveTargets.forEach(e=>e?.destroy()),!this.options.depthTexture&&this.depthTexture&&this.depthTexture.destroy()}}var nr=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},or=(n,e,t)=>(nr(n,e,"read from private field"),t?t.call(n):e.get(n)),In=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},Vn=(n,e,t,i)=>(nr(n,e,"write to private field"),i?i.call(n,t):e.set(n,t),t),ot;class Ui{constructor(e,t={}){In(this,ot,!0),e=W(e,"RenderTarget"),this.type="RenderTarget",this.renderer=e,this.uuid=Y();const{label:i,colorAttachments:s,depthTexture:r,autoRender:o,...a}=t,h=r||(this.renderer.renderPass.options.sampleCount===(t.sampleCount??4)?this.renderer.renderPass.depthTexture:null);this.options={label:i,...a,...h&&{depthTexture:h},...s&&{colorAttachments:s},autoRender:o===void 0?!0:o},o!==void 0&&Vn(this,ot,o),this.renderPass=new Wt(this.renderer,{label:this.options.label?`${this.options.label} Render Pass`:"Render Target Render Pass",...s&&{colorAttachments:s},depthTexture:this.options.depthTexture,...a}),a.useColorAttachments!==!1&&(this.renderTexture=new re(this.renderer,{label:this.options.label?`${this.options.label} Render Texture`:"Render Target render texture",name:"renderTexture",format:s&&s.length&&s[0].targetFormat?s[0].targetFormat:this.renderer.options.preferredFormat,...this.options.qualityRatio!==void 0&&{qualityRatio:this.options.qualityRatio},usage:["copySrc","renderAttachment","textureBinding"]})),this.addToScene()}get outputTextures(){return this.renderPass.outputTextures.length?this.renderPass.outputTextures.map((e,t)=>t===0&&this.renderPass.options.renderToSwapChain?this.renderTexture:e):this.renderTexture?[this.renderTexture]:[]}addToScene(){this.renderer.renderTargets.push(this),or(this,ot)&&this.renderer.scene.addRenderTarget(this)}removeFromScene(){or(this,ot)&&this.renderer.scene.removeRenderTarget(this),this.renderer.renderTargets=this.renderer.renderTargets.filter(e=>e.uuid!==this.uuid)}resize(){this.options.depthTexture&&(this.renderPass.options.depthTexture.texture=this.options.depthTexture.texture),this.renderPass?.resize()}remove(){this.destroy()}destroy(){this.renderer.meshes.forEach(e=>{e.outputTarget&&e.outputTarget.uuid===this.uuid&&e.setOutputTarget(null)}),this.renderer.shaderPasses.forEach(e=>{e.outputTarget&&e.outputTarget.uuid===this.uuid&&(e.outputTarget=null,e.setOutputTarget(null))}),this.removeFromScene(),this.renderPass?.destroy(),this.renderTexture?.destroy()}}ot=new WeakMap;let Nn=0;class ki{constructor(e){this.type="PipelineEntry";let{renderer:t}=e;const{label:i,shaders:s,useAsync:r}=e;t=W(t,i?i+" "+this.type:this.type),this.renderer=t,Object.defineProperty(this,"index",{value:Nn++}),this.layout=null,this.pipeline=null,this.status={compiling:!1,compiled:!1,error:null},this.options={label:i,shaders:s,useAsync:r!==void 0?r:!0}}get ready(){return!this.status.compiling&&this.status.compiled&&!this.status.error}get canCompile(){return!this.status.compiling&&!this.status.compiled&&!this.status.error}setPipelineEntryBindGroups(e){this.bindGroups=e}createShaderModule({code:e="",type:t="vertex"}){const i=this.renderer.createShaderModule({label:this.options.label+": "+t+" shader module",code:e});return"getCompilationInfo"in i&&!this.renderer.production&&i.getCompilationInfo().then(s=>{for(const r of s.messages){let o="";switch(r.lineNum&&(o+=`Line ${r.lineNum}:${r.linePos} - ${e.substring(r.offset,r.offset+r.length)}
`),o+=r.message,r.type){case"error":console.error(`${this.options.label} compilation error:
${o}`);break;case"warning":console.warn(`${this.options.label} compilation warning:
${o}`);break;case"info":console.log(`${this.options.label} compilation information:
${o}`);break}}}),i}createShaders(){}createPipelineLayout(){this.layout=this.renderer.createPipelineLayout({label:this.options.label+" layout",bindGroupLayouts:this.bindGroups.map(e=>e.bindGroupLayout)})}createPipelineDescriptor(){}flushPipelineEntry(e=[]){this.status.compiling=!1,this.status.compiled=!1,this.status.error=null,this.setPipelineEntryBindGroups(e),this.compilePipelineEntry()}compilePipelineEntry(){this.status.compiling=!0,this.createShaders(),this.createPipelineLayout(),this.createPipelineDescriptor()}}var Wn=`
fn getWorldPosition(position: vec3f) -> vec4f {
  return matrices.model * vec4f(position, 1.0);
}

fn getOutputPosition(position: vec3f) -> vec4f {
  return camera.projection * matrices.modelView * vec4f(position, 1.0);
}`,jn=`
fn getWorldNormal(normal: vec3f) -> vec3f {
  return normalize(matrices.normal * normal);
}

fn getViewNormal(normal: vec3f) -> vec3f {
  return normalize((camera.view * vec4(matrices.normal * normal, 0.0)).xyz);
}`,ar=`
fn getUVCover(uv: vec2f, textureMatrix: mat4x4f) -> vec2f {
  return (textureMatrix * vec4f(uv, 0.0, 1.0)).xy;
}`,qn=`
fn getVertex2DToUVCoords(vertex: vec2f) -> vec2f {
  return vec2(
    vertex.x * 0.5 + 0.5,
    0.5 - vertex.y * 0.5
  );
}

fn getVertex3DToUVCoords(vertex: vec3f) -> vec2f {
  return getVertex2DToUVCoords( vec2(vertex.x, vertex.y) );
}
`;const Ge={vertex:{get_uv_cover:ar},fragment:{get_uv_cover:ar,get_vertex_to_uv_coords:qn}},De={vertex:{get_output_position:Wn,get_normals:jn},fragment:{}};class We extends ki{constructor(e){let{renderer:t,...i}=e;const{label:s,attributes:r,bindGroups:o,cacheKey:a,...h}=i,l="RenderPipelineEntry";W(t,s?s+" "+l:l),super(e),this.type=l,this.shaders={vertex:{head:"",code:"",module:null},fragment:{head:"",code:"",module:null},full:{head:"",code:"",module:null}},this.descriptor=null,this.options={...this.options,attributes:r,bindGroups:o,cacheKey:a,...h},this.setPipelineEntryProperties({attributes:r,bindGroups:o})}setPipelineEntryProperties(e){const{attributes:t,bindGroups:i}=e;this.attributes=t,this.setPipelineEntryBindGroups(i)}patchShaders(){this.shaders.vertex.head="",this.shaders.vertex.code="",this.shaders.fragment.head="",this.shaders.fragment.code="",this.shaders.full.head="",this.shaders.full.code="";for(const t in Ge.vertex)this.shaders.vertex.head=`${Ge.vertex[t]}
${this.shaders.vertex.head}`,this.shaders.full.head=`${Ge.vertex[t]}
${this.shaders.full.head}`;if(this.options.shaders.fragment)for(const t in Ge.fragment)this.shaders.fragment.head=`${Ge.fragment[t]}
${this.shaders.fragment.head}`,this.shaders.full.head.indexOf(Ge.fragment[t])===-1&&(this.shaders.full.head=`${Ge.fragment[t]}
${this.shaders.full.head}`);if(this.options.rendering.useProjection){for(const t in De.vertex)this.shaders.vertex.head=`${De.vertex[t]}
${this.shaders.vertex.head}`,this.shaders.full.head=`${De.vertex[t]}
${this.shaders.full.head}`;if(this.options.shaders.fragment)for(const t in De.fragment)this.shaders.fragment.head=`${De.fragment[t]}
${this.shaders.fragment.head}`,this.shaders.full.head.indexOf(De.fragment[t])===-1&&(this.shaders.full.head=`${De.fragment[t]}
${this.shaders.full.head}`)}const e=[];for(const t of this.bindGroups){let i=0;t.bindings.forEach((s,r)=>{s.wgslGroupFragment.forEach((o,a)=>{e.push({groupIndex:t.index,visibility:s.options.visibility,bindIndex:i,wgslStructFragment:s.wgslStructFragment,wgslGroupFragment:o,newLine:r===t.bindings.length-1&&a===s.wgslGroupFragment.length-1}),i++})})}for(const t of e)t.visibility.includes("vertex")&&(t.wgslStructFragment&&this.shaders.vertex.head.indexOf(t.wgslStructFragment)===-1&&(this.shaders.vertex.head=`
${t.wgslStructFragment}
${this.shaders.vertex.head}`),this.shaders.vertex.head.indexOf(t.wgslGroupFragment)===-1&&(this.shaders.vertex.head=`${this.shaders.vertex.head}
@group(${t.groupIndex}) @binding(${t.bindIndex}) ${t.wgslGroupFragment}`,t.newLine&&(this.shaders.vertex.head+=`
`))),this.options.shaders.fragment&&t.visibility.includes("fragment")&&(t.wgslStructFragment&&this.shaders.fragment.head.indexOf(t.wgslStructFragment)===-1&&(this.shaders.fragment.head=`
${t.wgslStructFragment}
${this.shaders.fragment.head}`),this.shaders.fragment.head.indexOf(t.wgslGroupFragment)===-1&&(this.shaders.fragment.head=`${this.shaders.fragment.head}
@group(${t.groupIndex}) @binding(${t.bindIndex}) ${t.wgslGroupFragment}`,t.newLine&&(this.shaders.fragment.head+=`
`))),t.wgslStructFragment&&this.shaders.full.head.indexOf(t.wgslStructFragment)===-1&&(this.shaders.full.head=`
${t.wgslStructFragment}
${this.shaders.full.head}`),this.shaders.full.head.indexOf(t.wgslGroupFragment)===-1&&(this.shaders.full.head=`${this.shaders.full.head}
@group(${t.groupIndex}) @binding(${t.bindIndex}) ${t.wgslGroupFragment}`,t.newLine&&(this.shaders.full.head+=`
`));this.shaders.vertex.head=`${this.attributes.wgslStructFragment}
${this.shaders.vertex.head}`,this.shaders.full.head=`${this.attributes.wgslStructFragment}
${this.shaders.full.head}`,this.shaders.vertex.code=this.shaders.vertex.head+this.options.shaders.vertex.code,typeof this.options.shaders.fragment=="object"&&(this.shaders.fragment.code=this.shaders.fragment.head+this.options.shaders.fragment.code),typeof this.options.shaders.fragment=="object"&&(this.options.shaders.vertex.entryPoint!==this.options.shaders.fragment.entryPoint&&this.options.shaders.vertex.code.localeCompare(this.options.shaders.fragment.code)===0?this.shaders.full.code=this.shaders.full.head+this.options.shaders.vertex.code:this.shaders.full.code=this.shaders.full.head+this.options.shaders.vertex.code+this.options.shaders.fragment.code)}get shadersModulesReady(){return!(!this.shaders.vertex.module||this.options.shaders.fragment&&!this.shaders.fragment.module)}createShaders(){this.patchShaders();const e=typeof this.options.shaders.fragment=="object"&&this.options.shaders.vertex.entryPoint!==this.options.shaders.fragment.entryPoint&&this.options.shaders.vertex.code.localeCompare(this.options.shaders.fragment.code)===0;this.shaders.vertex.module=this.createShaderModule({code:this.shaders[e?"full":"vertex"].code,type:"vertex"}),this.options.shaders.fragment&&(this.shaders.fragment.module=this.createShaderModule({code:this.shaders[e?"full":"fragment"].code,type:"fragment"}))}static getDefaultTransparentBlending(){return{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}createPipelineDescriptor(){if(!this.shadersModulesReady)return;let e=-1;this.options.rendering.targets.length?this.options.rendering.transparent&&(this.options.rendering.targets[0].blend=this.options.rendering.targets[0].blend?this.options.rendering.targets[0].blend:We.getDefaultTransparentBlending()):this.options.rendering.targets=[],this.descriptor={label:this.options.label,layout:this.layout,vertex:{module:this.shaders.vertex.module,entryPoint:this.options.shaders.vertex.entryPoint,buffers:this.attributes.vertexBuffers.map(t=>({stepMode:t.stepMode,arrayStride:t.arrayStride*4,attributes:t.attributes.map(i=>(e++,{shaderLocation:e,offset:i.bufferOffset,format:i.bufferFormat}))}))},...this.options.shaders.fragment&&{fragment:{module:this.shaders.fragment.module,entryPoint:this.options.shaders.fragment.entryPoint,targets:this.options.rendering.targets}},primitive:{topology:this.options.rendering.topology,frontFace:this.options.rendering.verticesOrder,cullMode:this.options.rendering.cullMode},...this.options.rendering.depth&&{depthStencil:{depthWriteEnabled:this.options.rendering.depthWriteEnabled,depthCompare:this.options.rendering.depthCompare,format:this.options.rendering.depthFormat}},...this.options.rendering.sampleCount>1&&{multisample:{count:this.options.rendering.sampleCount}}}}createRenderPipeline(){if(this.shadersModulesReady)try{this.pipeline=this.renderer.createRenderPipeline(this.descriptor)}catch(e){this.status.error=e,ie(e)}}async createRenderPipelineAsync(){if(this.shadersModulesReady)try{this.pipeline=await this.renderer.createRenderPipelineAsync(this.descriptor),this.status.compiled=!0,this.status.compiling=!1,this.status.error=null}catch(e){this.status.error=e,ie(e)}}async compilePipelineEntry(){super.compilePipelineEntry(),this.options.useAsync?await this.createRenderPipelineAsync():(this.createRenderPipeline(),this.status.compiled=!0,this.status.compiling=!1,this.status.error=null)}}const hr=(n={},e={})=>Object.keys(n).filter(t=>Array.isArray(n[t])?JSON.stringify(n[t])!==JSON.stringify(e[t]):n[t]!==e[t]);var Ii=`
struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) uv: vec2f,
  @location(1) normal: vec3f,
  @location(2) worldPosition: vec3f,
  @location(3) viewDirection: vec3f,
};

@vertex fn main(
  attributes: Attributes,
) -> VSOutput {
  var vsOutput: VSOutput;

  vsOutput.position = getOutputPosition(attributes.position);
  vsOutput.uv = attributes.uv;
  vsOutput.normal = getWorldNormal(attributes.normal);
  vsOutput.worldPosition = getWorldPosition(attributes.position).xyz;
  vsOutput.viewDirection = camera.position - vsOutput.worldPosition;
  
  return vsOutput;
}`,Vi=`
struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) uv: vec2f,
};

@vertex fn main(
  attributes: Attributes,
) -> VSOutput {
  var vsOutput: VSOutput;

  vsOutput.position = vec4f(attributes.position, 1.0);
  vsOutput.uv = attributes.uv;
  
  return vsOutput;
}`,Ni=`
@fragment fn main() -> @location(0) vec4f {
  return vec4(0.0, 0.0, 0.0, 1.0);
}`;class Wi extends Gi{constructor(e,t){const i="RenderMaterial";e=W(e,i),t.shaders||(t.shaders={}),t.shaders?.vertex||(t.shaders.vertex={code:t.useProjection?Ii:Vi,entryPoint:"main"}),t.shaders.vertex.entryPoint||(t.shaders.vertex.entryPoint="main"),t.shaders.fragment===void 0&&(t.shaders.fragment={entryPoint:"main",code:Ni}),super(e,t),this.type=i,this.renderer=e;const{shaders:s}=t,{useProjection:r,transparent:o,depth:a,depthWriteEnabled:h,depthCompare:l,depthFormat:u,cullMode:d,sampleCount:c,verticesOrder:p,topology:g}=t;let{targets:m}=t;m===void 0&&(m=[{format:this.renderer.options.preferredFormat}]),m&&m.length&&!m[0].format&&(m[0].format=this.renderer.options.preferredFormat),this.options={...this.options,shaders:s,rendering:{useProjection:r,transparent:o,depth:a,depthWriteEnabled:h,depthCompare:l,depthFormat:u,cullMode:d,sampleCount:c,targets:m,verticesOrder:p,topology:g}},this.attributes=null,this.pipelineEntry=null}setPipelineEntry(){this.pipelineEntry=this.renderer.pipelineManager.createRenderPipeline({renderer:this.renderer,label:this.options.label+" render pipeline",shaders:this.options.shaders,useAsync:this.options.useAsyncPipeline,rendering:this.options.rendering,attributes:this.attributes,bindGroups:this.bindGroups})}async compilePipelineEntry(){await this.pipelineEntry.compilePipelineEntry()}async compileMaterial(){this.ready||(super.compileMaterial(),this.attributes&&!this.pipelineEntry&&this.setPipelineEntry(),this.pipelineEntry&&this.pipelineEntry.canCompile&&await this.compilePipelineEntry())}setRenderingOptions(e={}){e.transparent&&e.targets.length&&!e.targets[0].blend&&(e.targets[0].blend=We.getDefaultTransparentBlending());const t=hr(e,this.options.rendering),i={...this.options.rendering};if(this.options.rendering={...this.options.rendering,...e},this.pipelineEntry)if(this.pipelineEntry.ready&&t.length){if(!this.renderer.production){const s=t.map(o=>({[o]:Array.isArray(i[o])?i[o].map(a=>a):i[o]})),r=t.map(o=>({[o]:Array.isArray(e[o])?e[o].map(a=>a):e[o]}));L(`${this.options.label}: the change of rendering options is causing this RenderMaterial pipeline to be recompiled. This should be avoided.

Old rendering options: ${JSON.stringify(s.reduce((o,a)=>({...o,...a}),{}),null,4)}

--------

New rendering options: ${JSON.stringify(r.reduce((o,a)=>({...o,...a}),{}),null,4)}`)}this.setPipelineEntry()}else this.pipelineEntry.options.rendering={...this.pipelineEntry.options.rendering,...this.options.rendering}}setAttributesFromGeometry(e){this.attributes={wgslStructFragment:e.wgslStructFragment,vertexBuffers:e.vertexBuffers,layoutCacheKey:e.layoutCacheKey}}get useCameraBindGroup(){return"cameraLightsBindGroup"in this.renderer&&this.options.rendering.useProjection}createBindGroups(){this.useCameraBindGroup&&(this.bindGroups.push(this.renderer.cameraLightsBindGroup),this.renderer.cameraLightsBindGroup.consumers.add(this.uuid)),super.createBindGroups()}updateBindGroups(){const e=this.useCameraBindGroup?1:0;for(let t=e;t<this.bindGroups.length;t++)this.updateBindGroup(this.bindGroups[t])}}const lr=(n=!1)=>n?`
  var worldPosition: vec4f = instances[attributes.instanceIndex].modelMatrix * vec4f(attributes.position, 1.0);
  let normal = (instances[attributes.instanceIndex].normalMatrix * vec4(attributes.normal, 0.0)).xyz;
    `:`
  var worldPosition: vec4f = matrices.model * vec4(attributes.position, 1.0);
  let normal = getWorldNormal(attributes.normal);
    `,ur=(n=0,e=!1)=>`
@vertex fn main(
  attributes: Attributes,
) -> @builtin(position) vec4f {  
  let directionalShadow: DirectionalShadowsElement = directionalShadows.directionalShadowsElements[${n}];
  
  ${lr(e)}
  
  let lightDirection: vec3f = normalize(worldPosition.xyz - directionalLights.elements[${n}].direction);
  let NdotL: f32 = dot(normalize(normal), lightDirection);
  let sinNdotL = sqrt(1.0 - NdotL * NdotL);
  let normalBias: f32 = directionalShadow.normalBias * sinNdotL;
  
  worldPosition = vec4(worldPosition.xyz - normal * normalBias, worldPosition.w);
  
  return directionalShadow.projectionMatrix * directionalShadow.viewMatrix * worldPosition;
}`,dr=`
fn getPCFShadowContribution(index: i32, worldPosition: vec3f, depthTexture: texture_depth_2d) -> f32 {
  let directionalShadow: DirectionalShadowsElement = directionalShadows.directionalShadowsElements[index];
  
  // get shadow coords
  var shadowCoords: vec3f = vec3((directionalShadow.projectionMatrix * directionalShadow.viewMatrix * vec4(worldPosition, 1.0)).xyz);
  
  // Convert XY to (0, 1)
  // Y is flipped because texture coords are Y-down.
  shadowCoords = vec3(
    shadowCoords.xy * vec2(0.5, -0.5) + vec2(0.5),
    shadowCoords.z
  );
  
  // Percentage-closer filtering. Sample texels in the region
  // to smooth the result.
  var visibility = 0.0;
  
  let size: vec2f = vec2f(textureDimensions(depthTexture).xy);
  
  let texelSize: vec2f = 1.0 / size;
  
  let sampleCount: i32 = directionalShadow.pcfSamples;
  let maxSamples: f32 = f32(sampleCount) - 1.0;
  
  for (var x = 0; x < sampleCount; x++) {
    for (var y = 0; y < sampleCount; y++) {
      let offset = texelSize * vec2(
        f32(x) - maxSamples * 0.5,
        f32(y) - maxSamples * 0.5
      );
      
      visibility += textureSampleCompare(
        depthTexture,
        depthComparisonSampler,
        shadowCoords.xy + offset,
        shadowCoords.z - directionalShadow.bias
      );
    }
  }
  visibility /= f32(sampleCount * sampleCount);
  
  visibility = clamp(visibility, 1.0 - clamp(directionalShadow.intensity, 0.0, 1.0), 1.0);
  
  let inFrustum: bool = shadowCoords.x >= 0.0 && shadowCoords.x <= 1.0 && shadowCoords.y >= 0.0 && shadowCoords.y <= 1.0;
  let frustumTest: bool = inFrustum && shadowCoords.z <= 1.0;
  
  return select(1.0, visibility, frustumTest);
}
`,cr=n=>{const e=n.shadowCastingLights.filter(t=>t.type==="directionalLights");return`
fn getPCFDirectionalShadows(worldPosition: vec3f) -> array<f32, ${Math.max(n.lightsBindingParams.directionalLights.max,1)}> {
  var directionalShadowContribution: array<f32, ${Math.max(n.lightsBindingParams.directionalLights.max,1)}>;
  
  var lightDirection: vec3f;
  
  ${e.map((t,i)=>`lightDirection = worldPosition - directionalLights.elements[${i}].direction;
      
      ${t.shadow.isActive?`directionalShadowContribution[${i}] = select( 1.0, getPCFShadowContribution(${i}, worldPosition, shadowDepthTexture${i}), directionalShadows.directionalShadowsElements[${i}].isActive > 0);`:""}`).join(`
`)}
  
  return directionalShadowContribution;
}
`},pr=(n=0,e=!1)=>`
struct PointShadowVSOutput {
  @builtin(position) position: vec4f,
  @location(0) worldPosition: vec3f,
}

@vertex fn main(
  attributes: Attributes,
) -> PointShadowVSOutput {  
  var pointShadowVSOutput: PointShadowVSOutput;
  
  ${lr(e)}
  
  let pointShadow: PointShadowsElement = pointShadows.pointShadowsElements[${n}];
  
  let lightDirection: vec3f = normalize(pointLights.elements[${n}].position - worldPosition.xyz);
  let NdotL: f32 = dot(normalize(normal), lightDirection);
  let sinNdotL = sqrt(1.0 - NdotL * NdotL);
  let normalBias: f32 = pointShadow.normalBias * sinNdotL;
  
  worldPosition = vec4(worldPosition.xyz - normal * normalBias, worldPosition.w);
    
  var position: vec4f = pointShadow.projectionMatrix * pointShadow.viewMatrices[pointShadow.face] * worldPosition;

  pointShadowVSOutput.position = position;
  pointShadowVSOutput.worldPosition = worldPosition.xyz;

  return pointShadowVSOutput;
}`,fr=(n=0)=>`
struct PointShadowVSOutput {
  @builtin(position) position: vec4f,
  @location(0) worldPosition: vec3f,
}

@fragment fn main(fsInput: PointShadowVSOutput) -> @builtin(frag_depth) f32 {
  // get distance between fragment and light source
  var lightDistance: f32 = length(fsInput.worldPosition - pointLights.elements[${n}].position);
  
  let pointShadow: PointShadowsElement = pointShadows.pointShadowsElements[${n}];
  
  // map to [0, 1] range by dividing by far plane - near plane
  lightDistance = (lightDistance - pointShadow.cameraNear) / (pointShadow.cameraFar - pointShadow.cameraNear);
  
  // write this as modified depth
  return clamp(lightDistance, 0.0, 1.0);
}`,mr=`
fn getPCFPointShadowContribution(index: i32, shadowPosition: vec4f, depthCubeTexture: texture_depth_cube) -> f32 {
  let pointShadow: PointShadowsElement = pointShadows.pointShadowsElements[index];

  // Percentage-closer filtering. Sample texels in the region
  // to smooth the result.
  var visibility = 0.0;
  var closestDepth = 0.0;
  let currentDepth: f32 = shadowPosition.w;
  let cameraRange: f32 = pointShadow.cameraFar - pointShadow.cameraNear;
  let normalizedDepth: f32 = (shadowPosition.w - pointShadow.cameraNear) / cameraRange;

  let maxSize: f32 = f32(max(textureDimensions(depthCubeTexture).x, textureDimensions(depthCubeTexture).y));

  let texelSize: vec3f = vec3(1.0 / maxSize);
  let sampleCount: i32 = pointShadow.pcfSamples;
  let maxSamples: f32 = f32(sampleCount) - 1.0;
  
  for (var x = 0; x < sampleCount; x++) {
    for (var y = 0; y < sampleCount; y++) {
      for (var z = 0; z < sampleCount; z++) {
        let offset = texelSize * vec3(
          f32(x) - maxSamples * 0.5,
          f32(y) - maxSamples * 0.5,
          f32(z) - maxSamples * 0.5
        );

        closestDepth = textureSampleCompare(
          depthCubeTexture,
          depthComparisonSampler,
          shadowPosition.xyz + offset,
          normalizedDepth - pointShadow.bias
        );

        closestDepth *= cameraRange;
        if(currentDepth <= closestDepth) {
          visibility += 1.0;
        }
      }
    }
  }
  
  visibility /= f32(sampleCount * sampleCount * sampleCount);
  
  visibility = clamp(visibility, 1.0 - clamp(pointShadow.intensity, 0.0, 1.0), 1.0);
  
  return visibility;
}`,gr=n=>{const e=n.shadowCastingLights.filter(t=>t.type==="pointLights");return`
fn getPCFPointShadows(worldPosition: vec3f) -> array<f32, ${Math.max(n.lightsBindingParams.pointLights.max,1)}> {
  var pointShadowContribution: array<f32, ${Math.max(n.lightsBindingParams.pointLights.max,1)}>;
  
  var lightDirection: vec3f;
  
  ${e.map((t,i)=>`lightDirection = pointLights.elements[${i}].position - worldPosition;
      
      ${t.shadow.isActive?`pointShadowContribution[${i}] = select( 1.0, getPCFPointShadowContribution(${i}, vec4(lightDirection, length(lightDirection)), pointShadowCubeDepthTexture${i}), pointShadows.pointShadowsElements[${i}].isActive > 0);`:""}`).join(`
`)}
  
  return pointShadowContribution;
}
`},at=`
  let pointShadows = getPCFPointShadows(worldPosition);
  let directionalShadows = getPCFDirectionalShadows(worldPosition);
`,ht=`
    directLight.color *= directionalShadows[i];
`,lt=`
    if(directLight.visible) {
      directLight.color *= pointShadows[i];
    }
`;var ji=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},j=(n,e,t)=>(ji(n,e,"read from private field"),t?t.call(n):e.get(n)),we=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},ne=(n,e,t,i)=>(ji(n,e,"write to private field"),i?i.call(n,t):e.set(n,t),t),yr=(n,e,t)=>(ji(n,e,"access private method"),t),jt,qt,Yt,Xt,Ht,ut,je,ue,Te,Zt,qi;const xr={isActive:{type:"i32",value:0},pcfSamples:{type:"i32",value:0},bias:{type:"f32",value:0},normalBias:{type:"f32",value:0},intensity:{type:"f32",value:0}};class vr{constructor(e,{light:t,intensity:i=1,bias:s=0,normalBias:r=0,pcfSamples:o=1,depthTextureSize:a=new _(512),depthTextureFormat:h="depth24plus",autoRender:l=!0}={}){we(this,Zt),we(this,jt,void 0),we(this,qt,void 0),we(this,Yt,void 0),we(this,Xt,void 0),we(this,Ht,void 0),we(this,ut,void 0),we(this,je,void 0),we(this,ue,void 0),we(this,Te,void 0),e=Le(e,this.constructor.name),this.renderer=e,this.rendererBinding=null,this.light=t,this.index=this.light.index,this.options={light:t,intensity:i,bias:s,normalBias:r,pcfSamples:o,depthTextureSize:a,depthTextureFormat:h},this.sampleCount=1,this.meshes=new Map,ne(this,je,new Map),ne(this,ue,new Map),ne(this,Te,null),yr(this,Zt,qi).call(this,{intensity:i,bias:s,normalBias:r,pcfSamples:o,depthTextureSize:a,depthTextureFormat:h,autoRender:l}),this.isActive=!1}cast({intensity:e,bias:t,normalBias:i,pcfSamples:s,depthTextureSize:r,depthTextureFormat:o,autoRender:a}={}){yr(this,Zt,qi).call(this,{intensity:e,bias:t,normalBias:i,pcfSamples:s,depthTextureSize:r,depthTextureFormat:o,autoRender:a}),this.isActive=!0}setRendererBinding(){}reset(){this.isActive&&(this.onPropertyChanged("isActive",1),this.onPropertyChanged("intensity",this.intensity),this.onPropertyChanged("bias",this.bias),this.onPropertyChanged("normalBias",this.normalBias),this.onPropertyChanged("pcfSamples",this.pcfSamples))}get isActive(){return j(this,Ht)}set isActive(e){!e&&this.isActive?this.destroy():e&&!this.isActive&&this.init(),ne(this,Ht,e)}get intensity(){return j(this,jt)}set intensity(e){ne(this,jt,e),this.onPropertyChanged("intensity",this.intensity)}get bias(){return j(this,qt)}set bias(e){ne(this,qt,e),this.onPropertyChanged("bias",this.bias)}get normalBias(){return j(this,Yt)}set normalBias(e){ne(this,Yt,e),this.onPropertyChanged("normalBias",this.normalBias)}get pcfSamples(){return j(this,Xt)}set pcfSamples(e){ne(this,Xt,Math.max(1,Math.ceil(e))),this.onPropertyChanged("pcfSamples",this.pcfSamples)}init(){if(!this.depthComparisonSampler){const e=this.renderer.samplers.find(t=>t.name==="depthComparisonSampler");this.depthComparisonSampler=e||new Ve(this.renderer,{label:"Depth comparison sampler",name:"depthComparisonSampler",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",compare:"less",minFilter:"linear",magFilter:"linear",type:"comparison"})}this.setDepthTexture(),this.depthPassTarget||this.createDepthPassTarget(),j(this,Te)===null&&j(this,ut)&&(this.setDepthPass(),this.onPropertyChanged("isActive",1))}onDepthTextureSizeChanged(){this.setDepthTexture()}setDepthTexture(){this.depthTexture&&(this.depthTexture.size.width!==this.depthTextureSize.x||this.depthTexture.size.height!==this.depthTextureSize.y)?(this.depthTexture.options.fixedSize.width=this.depthTextureSize.x,this.depthTexture.options.fixedSize.height=this.depthTextureSize.y,this.depthTexture.size.width=this.depthTextureSize.x,this.depthTexture.size.height=this.depthTextureSize.y,this.depthTexture.createTexture(),this.depthPassTarget&&this.depthPassTarget.resize()):this.depthTexture||this.createDepthTexture()}createDepthTexture(){this.depthTexture=new re(this.renderer,{label:"Shadow depth texture "+this.index,name:"shadowDepthTexture"+this.index,type:"depth",format:this.depthTextureFormat,sampleCount:this.sampleCount,fixedSize:{width:this.depthTextureSize.x,height:this.depthTextureSize.y},autoDestroy:!1})}createDepthPassTarget(){this.depthPassTarget=new Ui(this.renderer,{label:"Depth pass render target for "+this.constructor.name+" "+this.index,useColorAttachments:!1,depthTexture:this.depthTexture,sampleCount:this.sampleCount})}onPropertyChanged(e,t){if(this.rendererBinding){if(t instanceof G){for(let i=0;i<t.elements.length;i++)this.rendererBinding.options.bindings[this.index].inputs[e].value[i]=t.elements[i];this.rendererBinding.options.bindings[this.index].inputs[e].shouldUpdate=!0}else this.rendererBinding.options.bindings[this.index].inputs[e].value=t;this.renderer.shouldUpdateCameraLightsBindGroup()}}setDepthPass(){ne(this,Te,this.render())}removeDepthPass(e){this.renderer.onBeforeRenderScene.remove(e)}render(e=!1){return this.renderer.onBeforeRenderScene.add(t=>{this.meshes.size&&(this.useDepthMaterials(),this.renderDepthPass(t),this.useOriginalMaterials(),this.renderer.pipelineManager.resetCurrentPipeline())},{once:e,order:this.index})}async renderOnce(){j(this,ut)||(this.onPropertyChanged("isActive",1),this.useDepthMaterials(),this.meshes.forEach(e=>{e.setGeometry()}),await Promise.all([...j(this,ue).values()].map(async e=>{await e.compileMaterial()})),this.render(!0))}renderDepthPass(e){const t=new Map;this.meshes.forEach(s=>{s.options.renderBundle&&t.set(s.options.renderBundle.uuid,s.options.renderBundle)}),t.forEach(s=>{s.updateBinding()}),t.clear(),this.renderer.pipelineManager.resetCurrentPipeline();const i=e.beginRenderPass(this.depthPassTarget.renderPass.descriptor);this.meshes.forEach(s=>{s.render(i)}),i.end()}getDefaultShadowDepthVs(e=!1){return{code:ur(this.index,e)}}getDefaultShadowDepthFs(){return!1}patchShadowCastingMeshParams(e,t={}){t={...e.material.options.rendering,...t},t.targets=[],t.sampleCount=this.sampleCount,t.depthFormat=this.depthTextureFormat,t.bindings?t.bindings=[e.material.getBufferBindingByName("matrices"),...t.bindings]:t.bindings=[e.material.getBufferBindingByName("matrices")];const i=e.material.inputsBindings.get("instances")&&e.geometry.instancesCount>1;return t.shaders||(t.shaders={vertex:this.getDefaultShadowDepthVs(i),fragment:this.getDefaultShadowDepthFs()}),t}addShadowCastingMesh(e,t={}){e.options.castShadows=!0,j(this,je).set(e.uuid,e.material),t=this.patchShadowCastingMeshParams(e,t),j(this,ue).get(e.uuid)&&(j(this,ue).get(e.uuid).destroy(),j(this,ue).delete(e.uuid)),j(this,ue).set(e.uuid,new Wi(this.renderer,{label:e.options.label+" depth render material",...t})),this.meshes.set(e.uuid,e)}useDepthMaterials(){this.meshes.forEach(e=>{e.useMaterial(j(this,ue).get(e.uuid))})}useOriginalMaterials(){this.meshes.forEach(e=>{e.useMaterial(j(this,je).get(e.uuid))})}removeMesh(e){const t=j(this,ue).get(e.uuid);t&&(t.destroy(),j(this,ue).delete(e.uuid)),this.meshes.delete(e.uuid)}destroy(){this.onPropertyChanged("isActive",0),j(this,Te)!==null&&(this.removeDepthPass(j(this,Te)),ne(this,Te,null)),this.meshes.forEach(e=>this.removeMesh(e)),ne(this,je,new Map),ne(this,ue,new Map),this.meshes=new Map,this.depthPassTarget?.destroy(),this.depthTexture?.destroy()}}jt=new WeakMap,qt=new WeakMap,Yt=new WeakMap,Xt=new WeakMap,Ht=new WeakMap,ut=new WeakMap,je=new WeakMap,ue=new WeakMap,Te=new WeakMap,Zt=new WeakSet,qi=function({intensity:n=1,bias:e=0,normalBias:t=0,pcfSamples:i=1,depthTextureSize:s=new _(512),depthTextureFormat:r="depth24plus",autoRender:o=!0}={}){this.intensity=n,this.bias=e,this.normalBias=t,this.pcfSamples=i,this.depthTextureSize=s,this.depthTextureSize.onChange(()=>this.onDepthTextureSizeChanged()),this.depthTextureFormat=r,ne(this,ut,o)};const Yn={...xr,viewMatrix:{type:"mat4x4f",value:new Float32Array(16)},projectionMatrix:{type:"mat4x4f",value:new Float32Array(16)}};class Xn extends vr{constructor(e,{light:t,intensity:i,bias:s,normalBias:r,pcfSamples:o,depthTextureSize:a,depthTextureFormat:h,autoRender:l,camera:u={left:-10,right:10,bottom:-10,top:10,near:.1,far:50}}={}){super(e,{light:t,intensity:i,bias:s,normalBias:r,pcfSamples:o,depthTextureSize:a,depthTextureFormat:h,autoRender:l}),this.options={...this.options,camera:u},this.setRendererBinding(),this.camera={projectionMatrix:new G,viewMatrix:new G,up:new f(0,1,0),_left:u.left,_right:u.right,_bottom:u.bottom,_top:u.top,_near:u.near,_far:u.far};const d=this;["left","right","bottom","top","near","far"].forEach(p=>{Object.defineProperty(d.camera,p,{get(){return d.camera["_"+p]},set(g){d.camera["_"+p]=g,d.updateProjectionMatrix()}})})}setRendererBinding(){this.rendererBinding=this.renderer.bindings.directionalShadows}cast({intensity:e,bias:t,normalBias:i,pcfSamples:s,depthTextureSize:r,depthTextureFormat:o,autoRender:a,camera:h}={}){h&&(this.camera.left=h.left??-10,this.camera.right=h.right??10,this.camera.bottom=h.bottom??-10,this.camera.top=h.right??10,this.camera.near=h.near??.1,this.camera.far=h.far??50),super.cast({intensity:e,bias:t,normalBias:i,pcfSamples:s,depthTextureSize:r,depthTextureFormat:o,autoRender:a})}init(){super.init(),this.updateProjectionMatrix()}reset(){this.setRendererBinding(),super.reset(),this.onPropertyChanged("projectionMatrix",this.camera.projectionMatrix),this.onPropertyChanged("viewMatrix",this.camera.viewMatrix)}updateProjectionMatrix(){this.camera.projectionMatrix.identity().makeOrthographic({left:this.camera.left,right:this.camera.right,bottom:this.camera.bottom,top:this.camera.top,near:this.camera.near,far:this.camera.far}),this.onPropertyChanged("projectionMatrix",this.camera.projectionMatrix)}updateViewMatrix(e=new f,t=new f){e.x===0&&e.z===0?this.camera.up.set(0,0,1):this.camera.up.set(0,1,0),this.camera.viewMatrix.makeView(e,t,this.camera.up),this.onPropertyChanged("viewMatrix",this.camera.viewMatrix)}}var wr=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},Kt=(n,e,t)=>(wr(n,e,"read from private field"),t?t.call(n):e.get(n)),br=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},Br=(n,e,t,i)=>(wr(n,e,"write to private field"),i?i.call(n,t):e.set(n,t),t),dt,ct;class Hn extends $i{constructor(e,{color:t=new f(1),intensity:i=1,position:s=new f(1),target:r=new f,shadow:o=null}={}){const a="directionalLights",h=e.lights.filter(l=>l.type===a).length;super(e,{color:t,intensity:i,index:h,type:a}),br(this,dt,void 0),br(this,ct,void 0),this.options={...this.options,position:s,target:r,shadow:o},Br(this,ct,new f),Br(this,dt,new f),this.target=r,this.target.onChange(()=>this.setDirection()),this.position.copy(s),this.parent=this.renderer.scene,this.index+1>this.renderer.lightsBindingParams[this.type].max&&this.onMaxLightOverflow(this.type),this.rendererBinding.inputs.count.value=this.index+1,this.rendererBinding.inputs.count.shouldUpdate=!0,this.shadow=new Xn(this.renderer,{autoRender:!1,light:this}),o&&this.shadow.cast(o)}reset(){super.reset(),this.setDirection(),this.shadow?.reset()}setDirection(){Kt(this,ct).copy(this.target).sub(this.worldMatrix.getTranslation(Kt(this,dt))),this.onPropertyChanged("direction",Kt(this,ct)),this.shadow?.updateViewMatrix(Kt(this,dt),this.target)}applyScale(){}applyTransformOrigin(){}updateMatrixStack(){super.updateMatrixStack(),this.matricesNeedUpdate&&this.setDirection()}onMaxLightOverflow(e){super.onMaxLightOverflow(e),this.shadow?.setRendererBinding()}destroy(){super.destroy(),this.shadow.destroy()}}dt=new WeakMap,ct=new WeakMap;var Mr=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},Cr=(n,e,t)=>(Mr(n,e,"read from private field"),t?t.call(n):e.get(n)),Zn=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},Kn=(n,e,t,i)=>(Mr(n,e,"write to private field"),i?i.call(n,t):e.set(n,t),t),pt;const Jn={face:{type:"i32",value:0},...xr,cameraNear:{type:"f32",value:0},cameraFar:{type:"f32",value:0},projectionMatrix:{type:"mat4x4f",value:new Float32Array(16)},viewMatrices:{type:"array<mat4x4f>",value:new Float32Array(16*6)}};class Qn extends vr{constructor(e,{light:t,intensity:i,bias:s,normalBias:r,pcfSamples:o,depthTextureSize:a,depthTextureFormat:h,autoRender:l,camera:u={near:.1,far:150}}={}){super(e,{light:t,intensity:i,bias:s,normalBias:r,pcfSamples:o,depthTextureSize:a,depthTextureFormat:h,autoRender:l}),Zn(this,pt,void 0),this.options={...this.options,camera:u},this.setRendererBinding(),this.cubeDirections=[new f(-1,0,0),new f(1,0,0),new f(0,-1,0),new f(0,1,0),new f(0,0,-1),new f(0,0,1)],Kn(this,pt,new f),this.cubeUps=[new f(0,-1,0),new f(0,-1,0),new f(0,0,1),new f(0,0,-1),new f(0,-1,0),new f(0,-1,0)],u.far<=0&&(u.far=150),this.camera={projectionMatrix:new G,viewMatrices:[],_near:u.near,_far:u.far};for(let p=0;p<6;p++)this.camera.viewMatrices.push(new G);const d=this;["near","far"].forEach(p=>{Object.defineProperty(d.camera,p,{get(){return d.camera["_"+p]},set(g){d.camera["_"+p]=g,d.updateProjectionMatrix()}})})}setRendererBinding(){this.rendererBinding=this.renderer.bindings.pointShadows}cast({intensity:e,bias:t,normalBias:i,pcfSamples:s,depthTextureSize:r,depthTextureFormat:o,autoRender:a,camera:h}={}){h&&(this.camera.near=h.near??.1,this.camera.far=h.far!==void 0?h.far:this.light.range>0?this.light.range:150),super.cast({intensity:e,bias:t,normalBias:i,pcfSamples:s,depthTextureSize:r,depthTextureFormat:o,autoRender:a})}init(){super.init(),this.updateProjectionMatrix()}reset(){this.setRendererBinding(),super.reset(),this.onPropertyChanged("cameraNear",this.camera.near),this.onPropertyChanged("cameraFar",this.camera.far),this.onPropertyChanged("projectionMatrix",this.camera.projectionMatrix),this.updateViewMatrices()}updateProjectionMatrix(){this.camera.projectionMatrix.identity().makePerspective({near:this.camera.near,far:this.camera.far,fov:90,aspect:1}),this.onPropertyChanged("projectionMatrix",this.camera.projectionMatrix),this.onPropertyChanged("cameraNear",this.camera.near),this.onPropertyChanged("cameraFar",this.camera.far)}updateViewMatrices(e=new f){for(let t=0;t<6;t++){Cr(this,pt).copy(this.cubeDirections[t]).add(e),this.camera.viewMatrices[t].makeView(e,Cr(this,pt),this.cubeUps[t]);for(let i=0;i<16;i++)this.rendererBinding.options.bindings[this.index].inputs.viewMatrices.value[t*16+i]=this.camera.viewMatrices[t].elements[i]}this.rendererBinding.options.bindings[this.index].inputs.viewMatrices.shouldUpdate=!0}setDepthTexture(){if(this.depthTexture&&(this.depthTexture.size.width!==this.depthTextureSize.x||this.depthTexture.size.height!==this.depthTextureSize.y)){const e=Math.max(this.depthTextureSize.x,this.depthTextureSize.y);this.depthTexture.options.fixedSize.width=e,this.depthTexture.options.fixedSize.height=e,this.depthTexture.size.width=e,this.depthTexture.size.height=e,this.depthTexture.createTexture(),this.depthPassTarget&&this.depthPassTarget.resize()}else this.depthTexture||this.createDepthTexture()}createDepthTexture(){const e=Math.max(this.depthTextureSize.x,this.depthTextureSize.y);this.depthTexture=new re(this.renderer,{label:"Point shadow cube depth texture "+this.index,name:"pointShadowCubeDepthTexture"+this.index,type:"depth",format:this.depthTextureFormat,viewDimension:"cube",sampleCount:this.sampleCount,fixedSize:{width:e,height:e},autoDestroy:!1})}removeDepthPass(e){this.renderer.onBeforeCommandEncoderCreation.remove(e)}render(e=!1){return this.renderer.onBeforeCommandEncoderCreation.add(()=>{if(this.meshes.size){this.useDepthMaterials();for(let t=0;t<6;t++){const i=this.renderer.device.createCommandEncoder();this.depthPassTarget.renderPass.setRenderPassDescriptor(this.depthTexture.texture.createView({label:this.depthTexture.texture.label+" cube face view "+t,dimension:"2d",arrayLayerCount:1,baseArrayLayer:t})),this.rendererBinding.options.bindings[this.index].inputs.face.value=t,this.renderer.cameraLightsBindGroup.update(),this.renderDepthPass(i);const s=i.finish();this.renderer.device.queue.submit([s])}this.useOriginalMaterials(),this.renderer.pipelineManager.resetCurrentPipeline()}},{once:e,order:this.index})}getDefaultShadowDepthVs(e=!1){return{code:pr(this.index,e)}}getDefaultShadowDepthFs(){return{code:fr(this.index)}}}pt=new WeakMap;var Sr=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},Yi=(n,e,t)=>(Sr(n,e,"read from private field"),t?t.call(n):e.get(n)),Pr=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},Tr=(n,e,t,i)=>(Sr(n,e,"write to private field"),i?i.call(n,t):e.set(n,t),t),Jt,ft;class eo extends $i{constructor(e,{color:t=new f(1),intensity:i=1,position:s=new f,range:r=0,shadow:o=null}={}){const a="pointLights",h=e.lights.filter(l=>l.type===a).length;super(e,{color:t,intensity:i,index:h,type:a}),Pr(this,Jt,void 0),Pr(this,ft,void 0),this.options={...this.options,position:s,range:r,shadow:o},Tr(this,ft,new f),this.position.copy(s),this.range=r,this.parent=this.renderer.scene,this.index+1>this.renderer.lightsBindingParams[this.type].max&&this.onMaxLightOverflow(this.type),this.rendererBinding.inputs.count.value=this.index+1,this.rendererBinding.inputs.count.shouldUpdate=!0,this.shadow=new Qn(this.renderer,{autoRender:!1,light:this}),o&&this.shadow.cast(o)}reset(){super.reset(),this.onPropertyChanged("range",this.range),this.setPosition(),this.shadow?.reset()}get range(){return Yi(this,Jt)}set range(e){Tr(this,Jt,e),this.onPropertyChanged("range",this.range)}setPosition(){this.onPropertyChanged("position",this.worldMatrix.getTranslation(Yi(this,ft))),this.shadow?.updateViewMatrices(Yi(this,ft))}applyScale(){}applyTransformOrigin(){}updateMatrixStack(){super.updateMatrixStack(),this.matricesNeedUpdate&&this.setPosition()}onMaxLightOverflow(e){super.onMaxLightOverflow(e),this.shadow?.setRendererBinding()}destroy(){super.destroy(),this.shadow.destroy()}}Jt=new WeakMap,ft=new WeakMap;var Rr=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},Xi=(n,e,t)=>(Rr(n,e,"read from private field"),t?t.call(n):e.get(n)),to=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},io=(n,e,t,i)=>(Rr(n,e,"write to private field"),i?i.call(n,t):e.set(n,t),t);let so=0;const zr={autoRender:!0,useProjection:!1,useAsyncPipeline:!0,cullMode:"back",depth:!0,depthWriteEnabled:!0,depthCompare:"less",depthFormat:"depth24plus",transparent:!1,visible:!0,renderOrder:0,texturesOptions:{},renderBundle:null};function Er(n){var e,t;return t=class extends n{constructor(...i){super(i[0],i[1],{...zr,...i[2]}),to(this,e,!0),this._onReadyCallback=()=>{},this._onBeforeRenderCallback=()=>{},this._onRenderCallback=()=>{},this._onAfterRenderCallback=()=>{},this._onAfterResizeCallback=()=>{};let s=i[0];const r={...zr,...i[2]};this.type="MeshBase",this.uuid=Y(),Object.defineProperty(this,"index",{value:so++}),s=W(s,r.label?r.label+" "+this.type:this.type),this.renderer=s;const{label:o,shaders:a,geometry:h,visible:l,renderOrder:u,outputTarget:d,renderBundle:c,texturesOptions:p,autoRender:g,...m}=r;this.outputTarget=d??null,this.renderBundle=c??null,m.sampleCount=m.sampleCount?m.sampleCount:this.outputTarget?this.outputTarget.renderPass.options.sampleCount:this.renderer&&this.renderer.renderPass?this.renderer.renderPass.options.sampleCount:1,this.options={...this.options??{},label:o??"Mesh "+this.renderer.meshes.length,...a!==void 0?{shaders:a}:{},...d!==void 0&&{outputTarget:d},...c!==void 0&&{renderBundle:c},texturesOptions:p,...g!==void 0&&{autoRender:g},...m},g!==void 0&&io(this,e,g),this.visible=l,this.renderOrder=u,this.ready=!1,this.userData={},h&&this.useGeometry(h),this.setMaterial({...this.cleanupRenderMaterialParameters({...this.options}),...h&&{verticesOrder:h.verticesOrder,topology:h.topology}}),this.addToScene(!0)}get autoRender(){return Xi(this,e)}get ready(){return this._ready}set ready(i){i&&!this._ready&&this._onReadyCallback&&this._onReadyCallback(),this._ready=i}addToScene(i=!1){i&&this.renderer.meshes.push(this),this.setRenderingOptionsForRenderPass(this.outputTarget?this.outputTarget.renderPass:this.renderer.renderPass),Xi(this,e)&&this.renderer.scene.addMesh(this)}removeFromScene(i=!1){Xi(this,e)&&this.renderer.scene.removeMesh(this),i&&(this.renderer.meshes=this.renderer.meshes.filter(s=>s.uuid!==this.uuid))}setRenderer(i){if(i=i&&i.renderer||i,!i||!(i.type==="GPURenderer"||i.type==="GPUCameraRenderer"||i.type==="GPUCurtainsRenderer")){L(`${this.options.label}: Cannot set ${i} as a renderer because it is not of a valid Renderer type.`);return}const s=this.renderer;this.removeFromScene(!0),this.renderer=i,this.addToScene(!0),s.meshes.length||s.onBeforeRenderScene.add(r=>{s.forceClear(r)},{once:!0})}setOutputTarget(i){if(i&&i.type!=="RenderTarget"){L(`${this.options.label??this.type}: outputTarget is not a RenderTarget: ${i.type}`);return}this.removeFromScene(),this.outputTarget=i,this.addToScene()}setRenderBundle(i,s=!0){s?(this.removeFromScene(),this.renderBundle=i,this.addToScene()):this.renderBundle=i}loseContext(){this.ready=!1,this.geometry.loseContext(),this.material.loseContext()}restoreContext(){this.geometry.restoreContext(this.renderer),this.material.restoreContext()}setShaders(){const{shaders:i}=this.options;i?((!i.vertex||!i.vertex.code)&&(i.vertex={code:Vi,entryPoint:"main"}),(i.fragment===void 0||i.fragment&&!i.fragment.code)&&(i.fragment={code:Ni,entryPoint:"main"})):this.options.shaders={vertex:{code:Vi,entryPoint:"main"},fragment:{code:Ni,entryPoint:"main"}}}useGeometry(i){if(this.geometry&&(i.shouldCompute&&i.computeGeometry(),this.geometry.layoutCacheKey!==i.layoutCacheKey&&(L(`${this.options.label} (${this.type}): the current and new geometries do not have the same vertexBuffers layout, causing a probable pipeline recompilation. This should be avoided.

Current geometry layout:

${this.geometry.wgslStructFragment}

--------

New geometry layout:

${i.wgslStructFragment}`),this.material.setAttributesFromGeometry(i),this.material.setPipelineEntry()),this.geometry.consumers.delete(this.uuid)),this.geometry=i,this.geometry.consumers.add(this.uuid),this.computeGeometry(),this.material){const s={...this.material.options.rendering,verticesOrder:i.verticesOrder,topology:i.topology};this.material.setRenderingOptions(s)}}computeGeometry(){this.geometry.shouldCompute&&this.geometry.computeGeometry()}setGeometry(){this.geometry&&(this.geometry.ready||this.geometry.createBuffers({renderer:this.renderer,label:this.options.label+" geometry"}),this.setMaterialGeometryAttributes())}setRenderingOptionsForRenderPass(i){const s={transparent:this.transparent,sampleCount:i.options.sampleCount,...i.options.colorAttachments.length&&{targets:i.options.colorAttachments.map((r,o)=>({format:r.targetFormat,...this.options.targets?.length&&this.options.targets[o]&&this.options.targets[o].blend&&{blend:this.options.targets[o].blend}}))},depth:i.options.useDepth,...i.options.useDepth&&{depthFormat:i.options.depthFormat}};this.material?.setRenderingOptions(s)}cleanupRenderMaterialParameters(i){return delete i.texturesOptions,delete i.outputTarget,delete i.autoRender,i}useMaterial(i){this.material=i,this.transparent=this.material.options.rendering.transparent,this.material.options.domTextures?.filter(s=>s instanceof Oe).forEach(s=>this.onDOMTextureAdded(s))}setMaterial(i){this.setShaders(),i.shaders=this.options.shaders,i.label=i.label+" material",this.useMaterial(new Wi(this.renderer,i))}setMaterialGeometryAttributes(){this.material&&!this.material.attributes&&this.material.setAttributesFromGeometry(this.geometry)}get transparent(){return this._transparent}set transparent(i){const s=this.transparent!==void 0&&i!==this.transparent;s&&this.removeFromScene(),this._transparent=i,s&&this.addToScene()}get visible(){return this._visible}set visible(i){this._visible=i}get domTextures(){return this.material?.domTextures||[]}get textures(){return this.material?.textures||[]}createDOMTexture(i){i.name||(i.name="texture"+(this.textures.length+this.domTextures.length)),i.label||(i.label=this.options.label+" "+i.name);const s={...i,...this.options.texturesOptions};this.renderBundle&&(s.useExternalTextures=!1);const r=new Oe(this.renderer,s);return this.addDOMTexture(r),r}addDOMTexture(i){this.material.addTexture(i),this.onDOMTextureAdded(i)}onDOMTextureAdded(i){i.parentMesh=this}createTexture(i){i.name||(i.name="texture"+(this.textures.length+this.domTextures.length));const s=new re(this.renderer,i);return this.addTexture(s),s}addTexture(i){this.material.addTexture(i)}get uniforms(){return this.material?.uniforms}get storages(){return this.material?.storages}resize(i){super.resize&&super.resize(i),this.textures?.forEach(s=>{s.options.fromTexture&&s.copy(s.options.fromTexture)}),this.domTextures?.forEach(s=>{s.resize()}),this._onAfterResizeCallback&&this._onAfterResizeCallback()}onReady(i){return i&&(this._onReadyCallback=i),this}onBeforeRender(i){return i&&(this._onBeforeRenderCallback=i),this}onRender(i){return i&&(this._onRenderCallback=i),this}onAfterRender(i){return i&&(this._onAfterRenderCallback=i),this}onAfterResize(i){return i&&(this._onAfterResizeCallback=i),this}onBeforeRenderScene(){!this.renderer.ready||!this.ready||!this.visible||this._onBeforeRenderCallback&&this._onBeforeRenderCallback()}onBeforeRenderPass(){this.renderer.ready&&(this.setGeometry(),this.visible&&this._onRenderCallback&&this._onRenderCallback(),this.material.onBeforeRender(),this.ready=this.material&&this.material.ready&&this.geometry&&this.geometry.ready)}onRenderPass(i){this.ready&&(this.material.render(i),this.geometry.render(i))}onAfterRenderPass(){this._onAfterRenderCallback&&this._onAfterRenderCallback()}render(i){this.onBeforeRenderPass(),!(!this.renderer.ready||!this.visible)&&(!this.renderer.production&&i.pushDebugGroup(this.options.label),this.onRenderPass(i),!this.renderer.production&&i.popDebugGroup(),this.onAfterRenderPass())}remove(){this.removeFromScene(!0),this.destroy(),this.renderer.meshes.length||this.renderer.onBeforeRenderScene.add(i=>{this.renderer.forceClear(i)},{once:!0})}destroy(){super.destroy&&super.destroy(),this.material?.destroy(),this.geometry.consumers.delete(this.uuid),this.geometry.consumers.size||this.geometry?.destroy(this.renderer)}},e=new WeakMap,t}class ro{constructor(){this.planeGeometries=[]}getPlaneGeometry(e){return this.planeGeometries.find(t=>t.definition.id===e.definition.id)}getPlaneGeometryByID(e){return this.planeGeometries.find(t=>t.definition.id===e)}addPlaneGeometry(e){this.planeGeometries.push(e)}destroy(){this.planeGeometries=[]}}const Qt=new ro;class Hi extends Er(class{}){constructor(e,t={}){e=W(e,t.label?t.label+" FullscreenQuadMesh":"FullscreenQuadMesh");let i=Qt.getPlaneGeometryByID(2);i||(i=new Fi({widthSegments:1,heightSegments:1}),Qt.addPlaneGeometry(i)),(!t.shaders||!t.shaders.vertex)&&["uniforms","storages"].forEach(s=>{Object.values(t[s]??{}).forEach(r=>r.visibility=["fragment"])}),t.depthWriteEnabled=!1,t.label||(t.label="FullscreenQuadMesh"),super(e,null,{geometry:i,...t}),this.size={document:{width:this.renderer.boundingRect.width,height:this.renderer.boundingRect.height,top:this.renderer.boundingRect.top,left:this.renderer.boundingRect.left}},this.type="FullscreenQuadMesh"}resize(e=null){this.size.document=e??this.renderer.boundingRect,super.resize(e)}mouseToPlaneCoords(e=new _){return new _((e.x-this.size.document.left)/this.size.document.width*2-1,1-(e.y-this.size.document.top)/this.size.document.height*2)}}class Be{constructor(e=new Float32Array([1,0,0,0,1,0,0,0,1])){this.type="Mat3",this.elements=e}set(e,t,i,s,r,o,a,h,l){const u=this.elements;return u[0]=e,u[1]=s,u[2]=a,u[3]=t,u[4]=r,u[5]=h,u[6]=i,u[7]=o,u[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}setFromArray(e=new Float32Array([1,0,0,0,1,0,0,0,1])){for(let t=0;t<this.elements.length;t++)this.elements[t]=e[t];return this}copy(e=new Be){const t=e.elements;return this.elements[0]=t[0],this.elements[1]=t[1],this.elements[2]=t[2],this.elements[3]=t[3],this.elements[4]=t[4],this.elements[5]=t[5],this.elements[6]=t[6],this.elements[7]=t[7],this.elements[8]=t[8],this}clone(){return new Be().copy(this)}setFromMat4(e=new G){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e=new Be){return this.multiplyMatrices(this,e)}premultiply(e=new Be){return this.multiplyMatrices(e,this)}multiplyMatrices(e=new Be,t=new Be){const i=e.elements,s=t.elements,r=this.elements,o=i[0],a=i[3],h=i[6],l=i[1],u=i[4],d=i[7],c=i[2],p=i[5],g=i[8],m=s[0],y=s[3],v=s[6],M=s[1],T=s[4],b=s[7],S=s[2],C=s[5],w=s[8];return r[0]=o*m+a*M+h*S,r[3]=o*y+a*T+h*C,r[6]=o*v+a*b+h*w,r[1]=l*m+u*M+d*S,r[4]=l*y+u*T+d*C,r[7]=l*v+u*b+d*w,r[2]=c*m+p*M+g*S,r[5]=c*y+p*T+g*C,r[8]=c*v+p*b+g*w,this}invert(){const e=this.elements,t=e[0],i=e[1],s=e[2],r=e[3],o=e[4],a=e[5],h=e[6],l=e[7],u=e[8],d=u*o-a*l,c=a*h-u*r,p=l*r-o*h,g=t*d+i*c+s*p;if(g===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/g;return e[0]=d*m,e[1]=(s*l-u*i)*m,e[2]=(a*i-s*o)*m,e[3]=c*m,e[4]=(u*t-s*h)*m,e[5]=(s*r-a*t)*m,e[6]=p*m,e[7]=(i*h-l*t)*m,e[8]=(o*t-i*r)*m,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e=new G){return this.setFromMat4(e).invert().transpose()}}class Zi extends xe{constructor(e){super(),e=Le(e,"ProjectedObject3D"),this.camera=e.camera}applyPosition(){super.applyPosition(),this.shouldUpdateProjectionMatrixStack()}applyRotation(){super.applyRotation(),this.shouldUpdateProjectionMatrixStack()}applyScale(){super.applyScale(),this.shouldUpdateProjectionMatrixStack()}applyTransformOrigin(){super.applyTransformOrigin(),this.shouldUpdateProjectionMatrixStack()}setMatrices(){super.setMatrices(),this.matrices={...this.matrices,modelView:{matrix:new G,shouldUpdate:!0,onUpdate:()=>{this.modelViewMatrix.multiplyMatrices(this.viewMatrix,this.worldMatrix)}},modelViewProjection:{matrix:new G,shouldUpdate:!0,onUpdate:()=>{this.modelViewProjectionMatrix.multiplyMatrices(this.projectionMatrix,this.modelViewMatrix)}},normal:{matrix:new Be,shouldUpdate:!0,onUpdate:()=>{this.normalMatrix.getNormalMatrix(this.worldMatrix)}}}}get modelViewMatrix(){return this.matrices.modelView.matrix}set modelViewMatrix(e){this.matrices.modelView.matrix=e,this.matrices.modelView.shouldUpdate=!0}get viewMatrix(){return this.camera.viewMatrix}get projectionMatrix(){return this.camera.projectionMatrix}get modelViewProjectionMatrix(){return this.matrices.modelViewProjection.matrix}set modelViewProjectionMatrix(e){this.matrices.modelViewProjection.matrix=e,this.matrices.modelViewProjection.shouldUpdate=!0}get normalMatrix(){return this.matrices.normal.matrix}set normalMatrix(e){this.matrices.normal.matrix=e,this.matrices.normal.shouldUpdate=!0}shouldUpdateProjectionMatrixStack(){this.matrices.modelView.shouldUpdate=!0,this.matrices.modelViewProjection.shouldUpdate=!0}shouldUpdateWorldMatrix(){super.shouldUpdateWorldMatrix(),this.shouldUpdateProjectionMatrixStack(),this.matrices.normal.shouldUpdate=!0}shouldUpdateMatrixStack(){this.shouldUpdateModelMatrix(),this.shouldUpdateProjectionMatrixStack()}}var Lr=`
struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) uv: vec2f,
  @location(1) normal: vec3f,
};

@fragment fn main(fsInput: VSOutput) -> @location(0) vec4f {
  // normals
  return vec4(normalize(fsInput.normal) * 0.5 + 0.5, 1.0);
}`,_r=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},no=(n,e,t)=>(_r(n,e,"read from private field"),t?t.call(n):e.get(n)),oo=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},ao=(n,e,t,i)=>(_r(n,e,"write to private field"),i?i.call(n,t):e.set(n,t),t),ei;class ho extends pe{constructor({label:e="Uniform",name:t="uniform",bindingType:i,visibility:s,useStruct:r=!0,access:o="read",usage:a=[],struct:h={},bindings:l=[],parent:u=null,minOffset:d=256,offset:c=0}){super({label:e,name:t,bindingType:i,visibility:s,useStruct:r,access:o,usage:a,struct:h,bindings:l}),oo(this,ei,void 0),this.options={...this.options,minOffset:d,offset:c},this.parent=u}get parent(){return no(this,ei)}set parent(e){ao(this,ei,e),e?(this.parentView=new DataView(e.arrayBuffer,this.offset,this.getMinOffsetSize(this.arrayBufferSize)),this.viewSetFunctions=this.bufferElements.map(t=>{switch(t.bufferLayout.View){case Int32Array:return this.parentView.setInt32.bind(this.parentView);case Uint16Array:return this.parentView.setUint16.bind(this.parentView);case Uint32Array:return this.parentView.setUint32.bind(this.parentView);case Float32Array:default:return this.parentView.setFloat32.bind(this.parentView)}})):(this.parentView=null,this.viewSetFunctions=null)}getMinOffsetSize(e){return Math.ceil(e/this.options.minOffset)*this.options.minOffset}get offset(){return this.getMinOffsetSize(this.options.offset*this.getMinOffsetSize(this.arrayBufferSize))}get resourceLayout(){return{buffer:{type:zi(this)},...this.parent&&{offset:this.offset,size:this.arrayBufferSize}}}get resource(){return{buffer:this.parent?this.parent.buffer.GPUBuffer:this.buffer.GPUBuffer,...this.parent&&{offset:this.offset,size:this.arrayBufferSize}}}update(){if(super.update(),this.shouldUpdate&&this.parent&&this.viewSetFunctions){let e=0;this.bufferElements.forEach((t,i)=>{t.view.forEach(s=>{this.viewSetFunctions[i](e*t.view.BYTES_PER_ELEMENT,s,!0),e++})}),this.parent.shouldUpdate=!0,this.shouldUpdate=!1}}}ei=new WeakMap;const Ar={frustumCulling:"OBB",DOMFrustumMargins:{top:0,right:0,bottom:0,left:0},receiveShadows:!1,castShadows:!1};function Or(n){return class extends Er(n){constructor(...t){super(t[0],t[1],{...Ar,...t[2],useProjection:!0}),this._onReEnterViewCallback=()=>{},this._onLeaveViewCallback=()=>{};let i=t[0];const s={...Ar,...t[2],useProjection:!0};this.type="MeshTransformed",i=Le(i,s.label?s.label+" "+this.type:this.type),this.renderer=i;const{frustumCulling:r,DOMFrustumMargins:o,receiveShadows:a,castShadows:h}=s;this.options={...this.options??{},frustumCulling:r,DOMFrustumMargins:o,receiveShadows:a,castShadows:h},this.options.castShadows&&this.renderer.shadowCastingLights.forEach(l=>{l.shadow.isActive&&l.shadow.addShadowCastingMesh(this)}),this.setDOMFrustum()}setRenderBundle(t,i=!0){const s=this.material.getBindGroupByBindingName("matrices"),r=this.material.getBufferBindingByName("matrices");!this.renderBundle&&t&&t.binding?s.destroyBufferBinding(r):this.renderBundle&&!t&&r.parent&&(r.parent=null,r.shouldResetBindGroup=!0,s.createBindingBuffer(r)),super.setRenderBundle(t,i),this.renderBundle&&this.renderBundle.binding&&(r.options.offset=this.renderBundle.meshes.size-1,r.parent=this.renderBundle.binding,r.shouldResetBindGroup=!0)}patchRenderBundleBinding(t=0){const i=this.material.getBufferBindingByName("matrices");i.options.offset=t,i.parent=this.renderBundle.binding,i.shouldResetBindGroup=!0}setShaders(){const{shaders:t}=this.options;t?((!t.vertex||!t.vertex.code)&&(t.vertex={code:Ii,entryPoint:"main"}),(t.fragment===void 0||t.fragment&&!t.fragment.code)&&(t.fragment={code:Lr,entryPoint:"main"})):this.options.shaders={vertex:{code:Ii,entryPoint:"main"},fragment:{code:Lr,entryPoint:"main"}}}useGeometry(t){super.useGeometry(t),this.domFrustum&&(this.domFrustum.boundingBox=this.geometry.boundingBox),this.shouldUpdateMatrixStack()}setDOMFrustum(){this.domFrustum=new tr({boundingBox:this.geometry?.boundingBox,modelViewProjectionMatrix:this.modelViewProjectionMatrix,containerBoundingRect:this.renderer.boundingRect,DOMFrustumMargins:this.options.DOMFrustumMargins,onReEnterView:()=>{this._onReEnterViewCallback&&this._onReEnterViewCallback()},onLeaveView:()=>{this._onLeaveViewCallback&&this._onLeaveViewCallback()}}),this.DOMFrustumMargins=this.domFrustum.DOMFrustumMargins,this.frustumCulling=this.options.frustumCulling}cleanupRenderMaterialParameters(t){if(delete t.frustumCulling,delete t.DOMFrustumMargins,this.options.receiveShadows){const i=[];let s=[];this.renderer.shadowCastingLights.forEach(o=>{o.shadow.isActive&&(i.push(o.shadow.depthTexture),s.push(o.shadow.depthComparisonSampler))}),this.renderer.shadowCastingLights.find(o=>o.shadow.isActive)&&t.shaders.fragment&&typeof t.shaders.fragment=="object"&&(t.shaders.fragment.code=cr(this.renderer)+dr+gr(this.renderer)+mr+t.shaders.fragment.code),s=s.filter((o,a,h)=>h.findIndex(l=>l.uuid===o.uuid)===a),t.textures?t.textures=[...t.textures,...i]:t.textures=i,t.samplers?t.samplers=[...t.samplers,...s]:t.samplers=s}return super.cleanupRenderMaterialParameters(t)}setMaterial(t){const i={label:"Matrices",name:"matrices",visibility:["vertex"],minOffset:this.renderer.device.limits.minUniformBufferOffsetAlignment,struct:{model:{type:"mat4x4f",value:this.worldMatrix},modelView:{type:"mat4x4f",value:this.modelViewMatrix},normal:{type:"mat3x3f",value:this.normalMatrix}}};this.options.renderBundle&&this.options.renderBundle.binding&&(i.parent=this.options.renderBundle.binding,i.offset=this.options.renderBundle.meshes.size);const s=new ho(i);t.bindings||(t.bindings=[]),t.bindings.unshift(s),super.setMaterial(t)}get visible(){return this._visible}set visible(t){this.shouldUpdateMatrixStack(),this._visible=t}resize(t){this.domFrustum&&this.domFrustum.setContainerBoundingRect(this.renderer.boundingRect),super.resize(t)}applyScale(){super.applyScale();for(const t of this.domTextures)t.resize()}get projectedBoundingRect(){return this.domFrustum?.projectedBoundingRect}onReEnterView(t){return t&&(this._onReEnterViewCallback=t),this}onLeaveView(t){return t&&(this._onLeaveViewCallback=t),this}get clipSpaceBoundingSphere(){const{center:t,radius:i,min:s,max:r}=this.geometry.boundingBox,o=this.worldMatrix.getTranslation(),a=i*this.worldMatrix.getMaxScaleOnAxis(),h=t.clone().add(o);h.z+=s.z;const l=t.clone().add(o);l.z+=r.z;const u=h.clone();u.y+=a;const d=l.clone();d.y+=a,h.applyMat4(this.camera.viewProjectionMatrix),l.applyMat4(this.camera.viewProjectionMatrix),u.applyMat4(this.camera.viewProjectionMatrix),d.applyMat4(this.camera.viewProjectionMatrix);const c=h.distance(u),p=l.distance(d),g={xMin:h.x-c,xMax:h.x+c,yMin:h.y-c,yMax:h.y+c},m={xMin:l.x-p,xMax:l.x+p,yMin:l.y-p,yMax:l.y+p},y={xMin:Math.min(g.xMin,m.xMin),yMin:Math.min(g.yMin,m.yMin),xMax:Math.max(g.xMax,m.xMax),yMax:Math.max(g.yMax,m.yMax)},v=l.add(h).multiplyScalar(.5).clone();v.x=(y.xMax+y.xMin)/2,v.y=(y.yMax+y.yMin)/2;const M=Math.max(y.xMax-y.xMin,y.yMax-y.yMin)*.5;return{center:v,radius:M}}checkFrustumCulling(){this.matricesNeedUpdate&&this.domFrustum&&this.frustumCulling&&(this.frustumCulling==="sphere"?this.domFrustum.setDocumentCoordsFromClipSpaceSphere(this.clipSpaceBoundingSphere):this.domFrustum.setDocumentCoordsFromClipSpaceOBB(),this.domFrustum.intersectsContainer())}onBeforeRenderPass(){this.material&&this.matricesNeedUpdate&&this.material.shouldUpdateInputsBindings("matrices"),super.onBeforeRenderPass()}onRenderPass(t){this.ready&&(this._onRenderCallback&&this._onRenderCallback(),(this.domFrustum&&this.domFrustum.isIntersecting||!this.frustumCulling)&&(this.material.render(t),this.geometry.render(t)))}destroy(){this.options.castShadows&&this.renderer.shadowCastingLights.forEach(t=>{t.shadow.isActive&&t.shadow.removeMesh(this)}),super.destroy()}}}class Gr extends Or(Zi){constructor(e,t={}){e=Le(e,t.label?t.label+" Mesh":"Mesh"),super(e,null,t),this.type="Mesh"}}class Dr extends ki{constructor(e){const{renderer:t}=e,{label:i}=e,s="ComputePipelineEntry";W(t,i?i+" "+s:s),super(e),this.type=s,this.shaders={compute:{head:"",code:"",module:null}},this.descriptor=null}setPipelineEntryProperties(e){const{bindGroups:t}=e;this.setPipelineEntryBindGroups(t)}patchShaders(){this.shaders.compute.head="",this.shaders.compute.code="";const e=[];for(const t of this.bindGroups){let i=0;t.bindings.forEach((s,r)=>{s.wgslGroupFragment.forEach((o,a)=>{e.push({groupIndex:t.index,bindIndex:i,wgslStructFragment:s.wgslStructFragment,wgslGroupFragment:o,newLine:r===t.bindings.length-1&&a===s.wgslGroupFragment.length-1}),i++})})}for(const t of e)t.wgslStructFragment&&this.shaders.compute.head.indexOf(t.wgslStructFragment)===-1&&(this.shaders.compute.head=`
${t.wgslStructFragment}
${this.shaders.compute.head}`),this.shaders.compute.head.indexOf(t.wgslGroupFragment)===-1&&(this.shaders.compute.head=`${this.shaders.compute.head}
@group(${t.groupIndex}) @binding(${t.bindIndex}) ${t.wgslGroupFragment}`),t.newLine&&(this.shaders.compute.head+=`
`);this.shaders.compute.code=this.shaders.compute.head+this.options.shaders.compute.code}createShaders(){this.patchShaders(),this.shaders.compute.module=this.createShaderModule({code:this.shaders.compute.code,type:"compute"})}createPipelineDescriptor(){this.shaders.compute.module&&(this.descriptor={label:this.options.label,layout:this.layout,compute:{module:this.shaders.compute.module,entryPoint:this.options.shaders.compute.entryPoint}})}createComputePipeline(){if(this.shaders.compute.module)try{this.pipeline=this.renderer.createComputePipeline(this.descriptor)}catch(e){this.status.error=e,ie(e)}}async createComputePipelineAsync(){if(this.shaders.compute.module)try{this.pipeline=await this.renderer.createComputePipelineAsync(this.descriptor),this.status.compiled=!0,this.status.compiling=!1,this.status.error=null}catch(e){this.status.error=e,ie(e)}}async compilePipelineEntry(){super.compilePipelineEntry(),this.options.useAsync?await this.createComputePipelineAsync():(this.createComputePipeline(),this.status.compiled=!0,this.status.compiling=!1,this.status.error=null)}}class Fr{constructor(){this.type="PipelineManager",this.currentPipelineIndex=null,this.pipelineEntries=[],this.activeBindGroups=[]}compareShaders(e,t){return e.code===t.code&&e.entryPoint===t.entryPoint}isSameRenderPipeline(e){return this.pipelineEntries.filter(t=>t instanceof We).find(t=>{const{options:i}=t,{shaders:s,rendering:r,cacheKey:o}=e,a=o===i.cacheKey,h=this.compareShaders(s.vertex,i.shaders.vertex),l=!s.fragment&&!i.shaders.fragment||this.compareShaders(s.fragment,i.shaders.fragment),u=hr(r,i.rendering);return a&&!u.length&&h&&l})}createRenderPipeline(e){const{attributes:t,bindGroups:i}=e;let s=t.layoutCacheKey;i.forEach(o=>{o.bindings.forEach(a=>{s+=a.name+","}),s+=o.pipelineCacheKey});const r=this.isSameRenderPipeline({...e,cacheKey:s});if(r)return r;{const o=new We({...e,cacheKey:s});return this.pipelineEntries.push(o),o}}createComputePipeline(e){const t=new Dr(e);return this.pipelineEntries.push(t),t}setCurrentPipeline(e,t){t.index!==this.currentPipelineIndex&&(e.setPipeline(t.pipeline),this.currentPipelineIndex=t.index)}setActiveBindGroups(e,t){t.forEach((i,s)=>{(!this.activeBindGroups[s]||this.activeBindGroups[s].uuid!==i.uuid||this.activeBindGroups[s].index!==i.index)&&(this.activeBindGroups[s]=i,e.setBindGroup(i.index,i.bindGroup))})}resetCurrentPipeline(){this.currentPipelineIndex=null,this.activeBindGroups=[]}}class lo{constructor(){this.shouldWatch=!0,this.entries=[],typeof window=="object"&&"ResizeObserver"in window&&(this.resizeObserver=new ResizeObserver(e=>{e.map(i=>this.entries.filter(s=>s.element.isSameNode(i.target))).flat().sort((i,s)=>s.priority-i.priority)?.forEach(i=>{i&&i.callback&&i.callback()})}))}useObserver(e=!0){this.shouldWatch=e}observe({element:e,priority:t,callback:i}){if(!e||!this.shouldWatch)return;this.resizeObserver?.observe(e);const s={element:e,priority:t,callback:i};this.entries.push(s)}unobserve(e){this.resizeObserver?.unobserve(e),this.entries=this.entries.filter(t=>!t.element.isSameNode(e))}destroy(){this.resizeObserver?.disconnect()}}const Ki=new lo;class Ji{constructor({element:e=document.body,priority:t=1,onSizeChanged:i=(r=null)=>{},onPositionChanged:s=(r=null)=>{}}={}){if(typeof e=="string"){if(this.element=document.querySelector(e),!this.element){const r=typeof e=="string"?`'${e}' selector`:`${e} HTMLElement`;ie(`DOMElement: corresponding ${r} not found.`)}}else this.element=e;this.priority=t,this.isResizing=!1,this.onSizeChanged=i,this.onPositionChanged=s,this.resizeManager=Ki,this.resizeManager.observe({element:this.element,priority:this.priority,callback:()=>{this.setSize()}}),this.setSize()}compareBoundingRect(e,t){return!["x","y","left","top","right","bottom","width","height"].some(i=>e[i]!==t[i])}get boundingRect(){return this._boundingRect}set boundingRect(e){const t=!!this.boundingRect&&this.compareBoundingRect(e,this.boundingRect);this._boundingRect={top:e.top,right:e.right,bottom:e.bottom,left:e.left,width:e.width,height:e.height,x:e.x,y:e.y},t||this.onSizeChanged(this.boundingRect)}updateScrollPosition(e={x:0,y:0}){this.isResizing||(this._boundingRect.top+=e.y,this._boundingRect.left+=e.x,(e.x||e.y)&&this.onPositionChanged(this.boundingRect))}setSize(e=null){!this.element||this.isResizing||(this.isResizing=!0,this.boundingRect=e??this.element.getBoundingClientRect(),setTimeout(()=>{this.isResizing=!1},10))}destroy(){this.resizeManager.unobserve(this.element)}}const uo=new f,co=new f,Qi=new f,es=new f;class $r extends xe{constructor({renderer:e}){super(),e=W(e,"Scene"),this.renderer=e,this.computePassEntries=[],this.renderPassEntries={pingPong:[],renderTarget:[],screen:[]}}setMainRenderPassEntry(){this.renderPassEntries.screen.push({renderPass:this.renderer.renderPass,renderTexture:null,onBeforeRenderPass:null,onAfterRenderPass:null,element:null,stack:{unProjected:{opaque:[],transparent:[]},projected:{opaque:[],transparent:[]}}})}getRenderPassEntryLength(e){return e?e.element?e.element.visible?1:0:e.stack.unProjected.opaque.length+e.stack.unProjected.transparent.length+e.stack.projected.opaque.length+e.stack.projected.transparent.length:0}addComputePass(e){this.computePassEntries.push(e),this.computePassEntries.sort((t,i)=>t.renderOrder!==i.renderOrder?t.renderOrder-i.renderOrder:t.index-i.index)}removeComputePass(e){this.computePassEntries=this.computePassEntries.filter(t=>t.uuid!==e.uuid)}addRenderTarget(e){this.renderPassEntries.renderTarget.find(t=>t.renderPass.uuid===e.renderPass.uuid)||this.renderPassEntries.renderTarget.push({renderPass:e.renderPass,renderTexture:e.renderTexture,onBeforeRenderPass:null,onAfterRenderPass:null,element:null,stack:{unProjected:{opaque:[],transparent:[]},projected:{opaque:[],transparent:[]}}})}removeRenderTarget(e){this.renderPassEntries.renderTarget=this.renderPassEntries.renderTarget.filter(t=>t.renderPass.uuid!==e.renderPass.uuid)}getMeshProjectionStack(e){const t=e.outputTarget?this.renderPassEntries.renderTarget.find(s=>s.renderPass.uuid===e.outputTarget.renderPass.uuid):this.renderPassEntries.screen[0],{stack:i}=t;return e.material.options.rendering.useProjection?i.projected:i.unProjected}orderStack(e){e.sort((t,i)=>t.renderOrder-i.renderOrder||t.index-i.index)}isStackObjectRenderBundle(e){return e.type==="RenderBundle"}addMesh(e){const t=this.getMeshProjectionStack(e),i=!!e.transparent,{useProjection:s}=e.material.options.rendering;if(e.renderBundle){const{renderBundle:r}=e;r.addMesh(e,e.outputTarget?e.outputTarget.renderPass:this.renderer.renderPass),e.renderBundle&&r.meshes.size===1&&(r.transparent===null&&(r.transparent=i),r.useProjection===null&&(r.useProjection=s),this.addRenderBundle(r,t))}if(!e.renderBundle){const r=i?t.transparent:t.opaque;r.push(e),this.orderStack(r)}"parent"in e&&!e.parent&&s&&(e.parent=this)}removeMesh(e){const t=this.getMeshProjectionStack(e),i=!!e.transparent;e.renderBundle?(e.renderBundle.meshes.size===1&&(i?t.transparent=t.transparent.filter(s=>s.uuid!==e.renderBundle.uuid):t.opaque=t.opaque.filter(s=>s.uuid!==e.renderBundle.uuid)),e.renderBundle.removeMesh(e,!1)):i?t.transparent=t.transparent.filter(s=>s.uuid!==e.uuid):t.opaque=t.opaque.filter(s=>s.uuid!==e.uuid),"parent"in e&&e.parent&&e.parent.object3DIndex===this.object3DIndex&&(e.parent=null)}addRenderBundle(e,t){const i=e.transparent?t.transparent:t.opaque;i.push(e),this.orderStack(i)}removeRenderBundle(e){if(!e.options.renderPass)return;const t=this.renderPassEntries.renderTarget.find(a=>a.renderPass.uuid===e.options.renderPass.uuid),{stack:i}=t||this.renderPassEntries.screen[0],r=!!e.useProjection?i.projected:i.unProjected;!!e.transparent?r.transparent=r.transparent.filter(a=>a.uuid!==e.uuid):r.opaque=r.opaque.filter(a=>a.uuid!==e.uuid)}addShaderPass(e){const t=e.inputTarget||e.outputTarget?null:(o,a)=>{e.renderTexture&&a&&o.copyTextureToTexture({texture:a},{texture:e.renderTexture.texture},[e.renderTexture.size.width,e.renderTexture.size.height]),this.renderer.postProcessingPass.setLoadOp("clear")},i=!e.outputTarget&&e.options.copyOutputToRenderTexture?(o,a)=>{e.renderTexture&&a&&o.copyTextureToTexture({texture:a},{texture:e.renderTexture.texture},[e.renderTexture.size.width,e.renderTexture.size.height])}:null,s=e.outputTarget?e.outputTarget.renderPass:this.renderer.postProcessingPass,r={renderPass:s,renderTexture:e.outputTarget?e.outputTarget.renderTexture:null,onBeforeRenderPass:t,onAfterRenderPass:i,element:e,stack:null};if(e.renderBundle){const o=!!e.transparent,{renderBundle:a}=e;a.meshes.size<1?(a.addMesh(e,s),a.size=1):(L(`${a.options.label} (${a.type}): Cannot add more than 1 ShaderPass to a render bundle. This ShaderPass will not be added: ${e.options.label}`),e.renderBundle=null),e.renderBundle&&(e.renderBundle.renderOrder=e.renderOrder,a.transparent=o,a.useProjection=!1)}this.renderPassEntries.screen.push(r),this.renderPassEntries.screen.sort((o,a)=>{const h=o.element&&!o.element.outputTarget,l=o.element?o.element.renderOrder:0,u=o.element?o.element.index:0,d=a.element&&!a.element.outputTarget,c=a.element?a.element.renderOrder:0,p=a.element?a.element.index:0;return h&&!d?1:!h&&d?-1:l!==c?l-c:u-p})}removeShaderPass(e){e.renderBundle&&e.renderBundle.meshes.delete(e.uuid),this.renderPassEntries.screen=this.renderPassEntries.screen.filter(t=>!t.element||t.element.uuid!==e.uuid)}addPingPongPlane(e){if(this.renderPassEntries.pingPong.push({renderPass:e.outputTarget.renderPass,renderTexture:e.outputTarget.renderTexture,onBeforeRenderPass:null,onAfterRenderPass:(t,i)=>{t.copyTextureToTexture({texture:i},{texture:e.renderTexture.texture},[e.renderTexture.size.width,e.renderTexture.size.height])},element:e,stack:null}),e.renderBundle){const t=!!e.transparent,{renderBundle:i}=e;i.meshes.size<1?(i.addMesh(e,e.outputTarget.renderPass),i.size=1):(L(`${i.options.label} (${i.type}): Cannot add more than 1 PingPongPlane to a render bundle. This PingPongPlane will not be added: ${e.options.label}`),e.renderBundle=null),e.renderBundle&&(e.renderBundle.renderOrder=e.renderOrder,i.transparent=t,i.useProjection=!1)}this.renderPassEntries.pingPong.sort((t,i)=>t.element.renderOrder-i.element.renderOrder)}removePingPongPlane(e){e.renderBundle&&e.renderBundle.meshes.delete(e.uuid),this.renderPassEntries.pingPong=this.renderPassEntries.pingPong.filter(t=>t.element.uuid!==e.uuid)}getObjectRenderPassEntry(e){if(e.type==="RenderTarget")return this.renderPassEntries.renderTarget.find(t=>t.renderPass.uuid===e.renderPass.uuid);if(e.type==="PingPongPlane")return this.renderPassEntries.pingPong.find(t=>t.element.uuid===e.uuid);if(e.type==="ShaderPass")return this.renderPassEntries.screen.find(t=>t.element?.uuid===e.uuid);{const t=e.outputTarget?"renderTarget":"screen";return e.renderBundle?this.renderPassEntries[t].find(i=>[...i.stack.unProjected.opaque,...i.stack.unProjected.transparent,...i.stack.projected.opaque,...i.stack.projected.transparent].filter(s=>s.type==="RenderBundle").some(s=>s.meshes.get(e.uuid))):this.renderPassEntries[t].find(i=>[...i.stack.unProjected.opaque,...i.stack.unProjected.transparent,...i.stack.projected.opaque,...i.stack.projected.transparent].some(s=>s.uuid===e.uuid))}}sortTransparentMeshes(e){e.sort((t,i)=>{if(t.renderOrder!==i.renderOrder||this.isStackObjectRenderBundle(t)||this.isStackObjectRenderBundle(i))return t.renderOrder-i.renderOrder;t.geometry?Qi.copy(t.geometry.boundingBox.center).applyMat4(t.worldMatrix):t.worldMatrix.getTranslation(Qi),i.geometry?es.copy(i.geometry.boundingBox.center).applyMat4(i.worldMatrix):i.worldMatrix.getTranslation(es);const s=t.geometry?t.geometry.boundingBox.radius*t.worldMatrix.getMaxScaleOnAxis():0,r=i.geometry?i.geometry.boundingBox.radius*i.worldMatrix.getMaxScaleOnAxis():0;return i.camera.worldMatrix.getTranslation(co).distance(es)-r-(t.camera.worldMatrix.getTranslation(uo).distance(Qi)-s)})}renderSinglePassEntry(e,t){const i=t.renderPass.updateView(t.renderTexture?.texture);t.onBeforeRenderPass&&t.onBeforeRenderPass(e,i);const s=e.beginRenderPass(t.renderPass.descriptor);if(!this.renderer.production&&s.pushDebugGroup(t.element?`${t.element.options.label} render pass using ${t.renderPass.options.label} descriptor`:`Render stack pass using ${t.renderPass.options.label}${t.renderTexture?" onto "+t.renderTexture.options.label:""}`),t.element)t.element.renderBundle?t.element.renderBundle.render(s):t.element.render(s);else if(t.stack){for(const r of t.stack.unProjected.opaque)r.render(s);for(const r of t.stack.unProjected.transparent)r.render(s);if(t.stack.projected.opaque.length||t.stack.projected.transparent.length){for(const r of t.stack.projected.opaque)r.render(s);this.sortTransparentMeshes(t.stack.projected.transparent);for(const r of t.stack.projected.transparent)r.render(s)}}!this.renderer.production&&s.popDebugGroup(),s.end(),t.onAfterRenderPass&&t.onAfterRenderPass(e,i),this.renderer.pipelineManager.resetCurrentPipeline()}onBeforeRender(){for(let e=0,t=this.renderer.meshes.length;e<t;e++)this.renderer.meshes[e].onBeforeRenderScene();this.updateMatrixStack();for(const e of this.renderer.meshes)"checkFrustumCulling"in e&&e.visible&&e.checkFrustumCulling()}render(e){for(const t of this.computePassEntries){const i=e.beginComputePass();t.render(i),i.end(),t.copyBufferToResult(e),this.renderer.pipelineManager.resetCurrentPipeline()}for(const t in this.renderPassEntries){let i=0;this.renderPassEntries[t].forEach(s=>{this.getRenderPassEntryLength(s)&&(s.renderPass.setLoadOp(t==="screen"&&i!==0?"load":"clear"),i++,this.renderSinglePassEntry(e,s))})}}}var Ur=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},kr=(n,e,t)=>(Ur(n,e,"read from private field"),t?t.call(n):e.get(n)),po=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},fo=(n,e,t,i)=>(Ur(n,e,"write to private field"),i?i.call(n,t):e.set(n,t),t),mo=(n,e,t,i)=>({set _(s){fo(n,e,s,t)},get _(){return kr(n,e,i)}}),ti;class ii{constructor(){po(this,ti,0),this.queue=[]}add(e=s=>{},{order:t=this.queue.length,once:i=!1}={}){const s={callback:e,order:t,once:i,id:kr(this,ti)};return mo(this,ti)._++,this.queue.push(s),this.queue.sort((r,o)=>r.order-o.order),s.id}remove(e=0){this.queue=this.queue.filter(t=>t.id!==e)}execute(e){this.queue.forEach(t=>{t.callback(e),t.once&&this.remove(t.id)})}}ti=new WeakMap;class ts{constructor({deviceManager:e,label:t="Main renderer",container:i,pixelRatio:s=1,autoResize:r=!0,preferredFormat:o,alphaMode:a="premultiplied",renderPass:h}){this._onBeforeRenderCallback=p=>{},this._onAfterRenderCallback=p=>{},this._onResizeCallback=()=>{},this._onAfterResizeCallback=()=>{},this.type="GPURenderer",this.uuid=Y(),e||ie(`GPURenderer (${t}): no device manager provided: ${e}`),this.deviceManager=e,this.deviceManager.addRenderer(this),this.shouldRender=!0,this.shouldRenderScene=!0,h={useDepth:!0,sampleCount:4,clearValue:[0,0,0,0],...h},o=o??this.deviceManager.gpu?.getPreferredCanvasFormat(),this.options={deviceManager:e,label:t,container:i,pixelRatio:s,autoResize:r,preferredFormat:o,alphaMode:a,renderPass:h},this.pixelRatio=s??window.devicePixelRatio??1,this.alphaMode=a;const l=i instanceof OffscreenCanvas,u=l||i instanceof HTMLCanvasElement;this.canvas=u?i:document.createElement("canvas");const{width:d,height:c}=this.canvas;this.rectBBox={width:d,height:c,top:0,left:0},this.setScene(),this.setTasksQueues(),this.setRendererObjects(),l||(this.domElement=new Ji({element:i,priority:5,onSizeChanged:()=>{this.options.autoResize&&this.resize()}}),this.resize(),u||this.domElement.element.appendChild(this.canvas)),this.deviceManager.device&&this.setContext()}setSize(e=null){e={width:Math.max(1,this.boundingRect.width),height:Math.max(1,this.boundingRect.height),top:this.boundingRect.top,left:this.boundingRect.left,...e},this.rectBBox=e;const t={width:this.rectBBox.width,height:this.rectBBox.height};t.width*=this.pixelRatio,t.height*=this.pixelRatio,this.clampToMaxDimension(t),this.canvas.width=Math.floor(t.width),this.canvas.height=Math.floor(t.height),this.canvas.style&&(this.canvas.style.width=this.rectBBox.width+"px",this.canvas.style.height=this.rectBBox.height+"px")}setPixelRatio(e=1){this.pixelRatio=e,this.resize(this.rectBBox)}resize(e=null){this.setSize(e),this._onResizeCallback&&this._onResizeCallback(),this.resizeObjects(),this._onAfterResizeCallback&&this._onAfterResizeCallback()}resizeObjects(){this.textures.forEach(e=>{e.resize()}),this.renderPass?.resize(),this.postProcessingPass?.resize(),this.renderTargets.forEach(e=>e.resize()),this.computePasses.forEach(e=>e.resize()),this.pingPongPlanes.forEach(e=>e.resize(this.boundingRect)),this.shaderPasses.forEach(e=>e.resize(this.boundingRect)),this.resizeMeshes()}resizeMeshes(){this.meshes.forEach(e=>{e.resize(this.boundingRect)})}get boundingRect(){if(this.domElement&&this.domElement.boundingRect)return this.domElement.boundingRect;if(this.domElement){const e=this.domElement.element?.getBoundingClientRect();return{top:e.top,right:e.right,bottom:e.bottom,left:e.left,width:e.width,height:e.height,x:e.x,y:e.y}}else return{top:this.rectBBox.top,right:this.rectBBox.left+this.rectBBox.width,bottom:this.rectBBox.top+this.rectBBox.height,left:this.rectBBox.left,width:this.rectBBox.width,height:this.rectBBox.height,x:this.rectBBox.left,y:this.rectBBox.top}}clampToMaxDimension(e){this.device&&(e.width=Math.min(this.device.limits.maxTextureDimension2D,e.width),e.height=Math.min(this.device.limits.maxTextureDimension2D,e.height))}get device(){return this.deviceManager.device}get ready(){return this.deviceManager.ready&&!!this.context&&!!this.canvas.width&&!!this.canvas.height}get production(){return this.deviceManager.production}get samplers(){return this.deviceManager.samplers}get buffers(){return this.deviceManager.buffers}get pipelineManager(){return this.deviceManager.pipelineManager}get deviceRenderedObjects(){return this.deviceManager.deviceRenderedObjects}configureContext(){this.context.configure({device:this.device,format:this.options.preferredFormat,alphaMode:this.alphaMode,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST})}setContext(){this.context=this.canvas.getContext("webgpu"),this.device&&(this.configureContext(),this.setMainRenderPasses())}loseContext(){this.renderBundles.forEach(e=>e.loseContext()),this.renderedObjects.forEach(e=>e.loseContext())}restoreContext(){this.configureContext(),this.textures.forEach(e=>{e.createTexture()}),this.renderPass?.resize(),this.postProcessingPass?.resize(),this.renderTargets.forEach(e=>e.resize()),this.renderedObjects.forEach(e=>e.restoreContext())}setMainRenderPasses(){this.renderPass=new Wt(this,{label:this.options.label+" render pass",...this.options.renderPass}),this.scene.setMainRenderPassEntry(),this.postProcessingPass=new Wt(this,{label:this.options.label+" post processing render pass",useDepth:!1,sampleCount:1})}setScene(){this.scene=new $r({renderer:this})}createBuffer(e){const t=this.deviceManager.device?.createBuffer(e.options);return this.deviceManager.addBuffer(e),t}removeBuffer(e){this.deviceManager.removeBuffer(e)}queueWriteBuffer(e,t,i){this.deviceManager.device?.queue.writeBuffer(e,t,i)}copyBufferToBuffer({srcBuffer:e,dstBuffer:t,commandEncoder:i}){if(!e||!e.GPUBuffer)return L(`${this.type} (${this.options.label}): cannot copy to buffer because the source buffer has not been provided`),null;if(t||(t=new Ie),t.GPUBuffer||t.createBuffer(this,{label:`GPURenderer (${this.options.label}): destination copy buffer from: ${e.options.label}`,size:e.GPUBuffer.size,usage:["copyDst","mapRead"]}),e.GPUBuffer.mapState!=="unmapped"){L(`${this.type} (${this.options.label}): Cannot copy from ${e.GPUBuffer} because it is currently mapped`);return}if(t.GPUBuffer.mapState!=="unmapped"){L(`${this.type} (${this.options.label}): Cannot copy from ${t.GPUBuffer} because it is currently mapped`);return}const s=!!i;if(s||(i=this.deviceManager.device?.createCommandEncoder({label:`${this.type} (${this.options.label}): Copy buffer command encoder`}),!this.production&&i.pushDebugGroup(`${this.type} (${this.options.label}): Copy buffer command encoder`)),i.copyBufferToBuffer(e.GPUBuffer,0,t.GPUBuffer,0,t.GPUBuffer.size),!s){!this.production&&i.popDebugGroup();const r=i.finish();this.deviceManager.device?.queue.submit([r])}return t}get bindGroups(){return this.deviceManager.bindGroups}addBindGroup(e){this.deviceManager.addBindGroup(e)}removeBindGroup(e){this.deviceManager.removeBindGroup(e)}createBindGroupLayout(e){return this.deviceManager.device?.createBindGroupLayout(e)}createBindGroup(e){return this.deviceManager.device?.createBindGroup(e)}createShaderModule(e){return this.device?.createShaderModule(e)}createPipelineLayout(e){return this.device?.createPipelineLayout(e)}createRenderPipeline(e){return this.device?.createRenderPipeline(e)}async createRenderPipelineAsync(e){return await this.device?.createRenderPipelineAsync(e)}createComputePipeline(e){return this.device?.createComputePipeline(e)}async createComputePipelineAsync(e){return await this.device?.createComputePipelineAsync(e)}get domTextures(){return this.deviceManager.domTextures}addDOMTexture(e){this.deviceManager.addDOMTexture(e)}removeDOMTexture(e){this.deviceManager.removeDOMTexture(e)}addTexture(e){this.textures.push(e)}removeTexture(e){this.textures=this.textures.filter(t=>t.uuid!==e.uuid)}createTexture(e){return this.deviceManager.device?.createTexture(e)}uploadTexture(e){this.deviceManager.uploadTexture(e)}importExternalTexture(e){return this.deviceManager.device?.importExternalTexture({source:e})}createSampler(e){const t=this.samplers.find(i=>JSON.stringify(i.options)===JSON.stringify(e.options)&&i.sampler);if(t)return t.sampler;{const{type:i,...s}=e.options,r=this.deviceManager.device?.createSampler({label:e.label,...s});return this.deviceManager.addSampler(e),r}}removeSampler(e){this.deviceManager.removeSampler(e)}setTasksQueues(){this.onBeforeCommandEncoderCreation=new ii,this.onBeforeRenderScene=new ii,this.onAfterRenderScene=new ii,this.onAfterCommandEncoderSubmission=new ii}setRendererObjects(){this.computePasses=[],this.pingPongPlanes=[],this.shaderPasses=[],this.renderTargets=[],this.meshes=[],this.textures=[],this.renderBundles=[]}get renderedObjects(){return[...this.computePasses,...this.meshes,...this.shaderPasses,...this.pingPongPlanes]}getObjectsByBindGroup(e){return this.deviceRenderedObjects.filter(t=>[...t.material.bindGroups,...t.material.inputsBindGroups,...t.material.clonedBindGroups].some(i=>i.uuid===e.uuid))}getObjectsByTexture(e){return this.deviceRenderedObjects.filter(t=>[...t.material.domTextures,...t.material.textures].some(i=>i.uuid===e.uuid))}onBeforeRender(e){return e&&(this._onBeforeRenderCallback=e),this}onAfterRender(e){return e&&(this._onAfterRenderCallback=e),this}onResize(e){return e&&(this._onResizeCallback=e),this}onAfterResize(e){return e&&(this._onAfterResizeCallback=e),this}renderSingleComputePass(e,t){const i=e.beginComputePass();t.render(i),i.end(),t.copyBufferToResult(e)}renderSingleMesh(e,t){const i=e.beginRenderPass(this.renderPass.descriptor);t.render(i),i.end()}renderOnce(e){const t=this.device?.createCommandEncoder({label:"Render once command encoder"});!this.production&&t.pushDebugGroup("Render once command encoder"),this.pipelineManager.resetCurrentPipeline(),e.forEach(s=>{s.type==="ComputePass"?this.renderSingleComputePass(t,s):this.renderSingleMesh(t,s)}),!this.production&&t.popDebugGroup();const i=t.finish();this.device?.queue.submit([i]),this.pipelineManager.resetCurrentPipeline()}forceClear(e){const t=!!e;if(t||(e=this.device?.createCommandEncoder({label:`${this.type} (${this.options.label}): Force clear command encoder`}),!this.production&&e.pushDebugGroup(`${this.type} (${this.options.label}): Force clear command encoder`)),this.renderPass.updateView(),e.beginRenderPass(this.renderPass.descriptor).end(),!t){!this.production&&e.popDebugGroup();const s=e.finish();this.device?.queue.submit([s])}}onBeforeCommandEncoder(){this.ready&&(this.shouldRenderScene&&this.scene?.onBeforeRender(),this.onBeforeCommandEncoderCreation.execute())}onAfterCommandEncoder(){this.ready&&this.onAfterCommandEncoderSubmission.execute()}render(e){!this.ready||!this.shouldRender||(this._onBeforeRenderCallback&&this._onBeforeRenderCallback(e),this.onBeforeRenderScene.execute(e),this.shouldRenderScene&&this.scene?.render(e),this._onAfterRenderCallback&&this._onAfterRenderCallback(e),this.onAfterRenderScene.execute(e))}destroy(){this.deviceManager.renderers=this.deviceManager.renderers.filter(e=>e.uuid!==this.uuid),this.domElement?.destroy(),this.renderBundles.forEach(e=>e.destroy()),this.renderPass?.destroy(),this.postProcessingPass?.destroy(),this.renderTargets.forEach(e=>e.destroy()),this.renderedObjects.forEach(e=>e.remove()),this.textures.forEach(e=>e.destroy()),this.context?.unconfigure()}}var Ir=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},go=(n,e,t)=>(Ir(n,e,"read from private field"),t?t.call(n):e.get(n)),yo=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},is=(n,e,t,i)=>(Ir(n,e,"write to private field"),i?i.call(n,t):e.set(n,t),t),qe;class ss extends ts{constructor({deviceManager:e,label:t,container:i,pixelRatio:s=1,autoResize:r=!0,preferredFormat:o,alphaMode:a="premultiplied",renderPass:h,camera:l={},lights:u={}}){super({deviceManager:e,label:t,container:i,pixelRatio:s,autoResize:r,preferredFormat:o,alphaMode:a,renderPass:h}),yo(this,qe,void 0),this.type="GPUCameraRenderer",l={fov:50,near:.1,far:1e3,...l},u={maxAmbientLights:2,maxDirectionalLights:5,maxPointLights:5,...u},this.options={...this.options,camera:l,lights:u},this.bindings={},is(this,qe,!0),this.lights=[],this.setCamera(l),this.setCameraBinding(),this.setLightsBinding(),this.setShadowsBinding(),this.setCameraLightsBindGroup()}loseContext(){super.loseContext(),this.cameraLightsBindGroup.loseContext()}restoreContext(){super.restoreContext(),this.cameraLightsBindGroup?.restoreContext(),this.updateCameraBindings()}setCamera(e){const{width:t,height:i}=this.rectBBox;this.useCamera(new Ys({fov:e.fov,near:e.near,far:e.far,width:t,height:i,pixelRatio:this.pixelRatio,onMatricesChanged:()=>{this.onCameraMatricesChanged()}}))}useCamera(e){if(!(this.camera&&e&&this.camera.uuid===e.uuid)&&(this.camera&&(this.camera.parent=null,this.camera.onMatricesChanged=()=>{}),this.camera=e,this.camera.parent=this.scene,this.bindings.camera)){this.camera.onMatricesChanged=()=>this.onCameraMatricesChanged(),this.bindings.camera.inputs.view.value=this.camera.viewMatrix,this.bindings.camera.inputs.projection.value=this.camera.projectionMatrix;for(const t of this.meshes)"modelViewMatrix"in t&&(t.camera=this.camera)}}onCameraMatricesChanged(){this.updateCameraBindings();for(const e of this.meshes)"modelViewMatrix"in e&&e.shouldUpdateProjectionMatrixStack()}setCameraBinding(){this.bindings.camera=new pe({label:"Camera",name:"camera",visibility:["vertex"],struct:{view:{type:"mat4x4f",value:this.camera.viewMatrix},projection:{type:"mat4x4f",value:this.camera.projectionMatrix},position:{type:"vec3f",value:this.camera.position.clone().setFromMatrixPosition(this.camera.worldMatrix),onBeforeUpdate:()=>{this.bindings.camera.inputs.position.value.copy(this.camera.position).setFromMatrixPosition(this.camera.worldMatrix)}}}})}addLight(e){this.lights.push(e)}removeLight(e){this.lights=this.lights.filter(t=>t.uuid!==e.uuid),e.destroy()}setLightsBinding(){this.lightsBindingParams={ambientLights:{max:this.options.lights.maxAmbientLights,label:"Ambient lights",params:{color:{type:"array<vec3f>",size:3}}},directionalLights:{max:this.options.lights.maxDirectionalLights,label:"Directional lights",params:{color:{type:"array<vec3f>",size:3},direction:{type:"array<vec3f>",size:3}}},pointLights:{max:this.options.lights.maxPointLights,label:"Point lights",params:{color:{type:"array<vec3f>",size:3},position:{type:"array<vec3f>",size:3},range:{type:"array<f32>",size:1}}}},Object.keys({ambientLights:null,directionalLights:null,pointLights:null}).forEach(t=>{this.setLightsTypeBinding(t)})}setLightsTypeBinding(e){const t=Object.keys(this.lightsBindingParams[e].params).map(i=>({key:i,type:this.lightsBindingParams[e].params[i].type,size:this.lightsBindingParams[e].params[i].size})).reduce((i,s)=>(i[s.key]={type:s.type,value:new Float32Array(this.lightsBindingParams[e].max*s.size)},i),{});this.bindings[e]=new pe({label:this.lightsBindingParams[e].label,name:e,bindingType:"storage",visibility:["vertex","fragment","compute"],struct:{count:{type:"i32",value:0},...t}})}onMaxLightOverflow(e){this.production||L(`${this.type}: You are overflowing the current max lights count of ${this.lightsBindingParams[e].max} for this type of lights: ${e}. This should be avoided by setting a larger ${"max"+e.charAt(0).toUpperCase()+e.slice(1)} when instancing your ${this.type}.`),this.lightsBindingParams[e].max++;const t=this.cameraLightsBindGroup.getBindingByName(e);this.cameraLightsBindGroup.destroyBufferBinding(t),this.setLightsTypeBinding(e);const i=this.cameraLightsBindGroup.bindings.findIndex(s=>s.name===e);if(this.cameraLightsBindGroup.bindings[i]=this.bindings[e],e==="directionalLights"||e==="pointLights"){const s=e.replace("Lights","")+"Shadows",r=this.cameraLightsBindGroup.getBindingByName(s);this.cameraLightsBindGroup.destroyBufferBinding(r),this.setShadowsTypeBinding(e);const o=this.cameraLightsBindGroup.bindings.findIndex(a=>a.name===s);this.cameraLightsBindGroup.bindings[o]=this.bindings[s]}this.cameraLightsBindGroup.resetEntries(),this.cameraLightsBindGroup.createBindGroup(),this.lights.forEach(s=>{s.type===e&&s.reset()})}get shadowCastingLights(){return this.lights.filter(e=>e.type==="directionalLights"||e.type==="pointLights")}setShadowsBinding(){this.shadowsBindingsStruct={directional:Yn,point:Jn},this.setShadowsTypeBinding("directionalLights"),this.setShadowsTypeBinding("pointLights")}setShadowsTypeBinding(e){const t=e.replace("Lights",""),i=t+"Shadows",s=this.shadowsBindingsStruct[t],r=t.charAt(0).toUpperCase()+t.slice(1)+" shadows",o=new pe({label:r+" element",name:i+"Elements",bindingType:"uniform",visibility:["vertex","fragment"],struct:s});this.bindings[i]=new pe({label:r,name:i,bindingType:"storage",visibility:["vertex","fragment","compute"],bindings:Array.from(Array(this.lightsBindingParams[e].max).keys()).map(a=>o.clone({...o.options,struct:Object.keys(s).reduce((h,l)=>{const u=s[l];return{...h,[l]:{type:u.type,value:Array.isArray(u.value)||ArrayBuffer.isView(u.value)?new u.value.constructor(u.value.length):u.value}}},{})}))})}setCameraLightsBindGroup(){this.cameraLightsBindGroup=new Et(this,{label:"Camera and lights uniform bind group",bindings:Object.keys(this.bindings).map(e=>this.bindings[e]).flat()}),this.cameraLightsBindGroup.consumers.add(this.uuid)}setCameraBindGroup(){this.cameraLightsBindGroup&&this.cameraLightsBindGroup.shouldCreateBindGroup&&(this.cameraLightsBindGroup.setIndex(0),this.cameraLightsBindGroup.createBindGroup())}shouldUpdateCameraLightsBindGroup(){is(this,qe,!0)}updateCameraBindings(){this.bindings.camera?.shouldUpdateBinding("view"),this.bindings.camera?.shouldUpdateBinding("projection"),this.bindings.camera?.shouldUpdateBinding("position"),this.shouldUpdateCameraLightsBindGroup()}getObjectsByBindGroup(e){return this.deviceRenderedObjects.filter(t=>[...t.material.bindGroups,...t.material.inputsBindGroups,...t.material.clonedBindGroups,this.cameraLightsBindGroup].some(i=>i.uuid===e.uuid))}setPerspective({fov:e,near:t,far:i}={}){this.camera?.setPerspective({fov:e,near:t,far:i,width:this.rectBBox.width,height:this.rectBBox.height,pixelRatio:this.pixelRatio})}setCameraPosition(e=new f(0,0,1)){this.camera.position.copy(e)}resize(e=null){this.setSize(e),this.setPerspective(),this._onResizeCallback&&this._onResizeCallback(),this.resizeObjects(),this._onAfterResizeCallback&&this._onAfterResizeCallback()}render(e){this.ready&&(this.setCameraBindGroup(),this.cameraLightsBindGroup&&go(this,qe)&&(this.cameraLightsBindGroup.update(),is(this,qe,!1)),super.render(e))}destroy(){this.cameraLightsBindGroup?.destroy(),this.lights.forEach(e=>this.removeLight(e)),super.destroy()}}qe=new WeakMap;class Vr{constructor({label:e,production:t=!1,adapterOptions:i={},onError:s=()=>{},onDeviceLost:r=o=>{}}={}){this.index=0,this.label=e??"GPUDeviceManager instance",this.production=t,this.ready=!1,this.adapterOptions=i,this.onError=s,this.onDeviceLost=r,this.gpu=navigator.gpu,this.setPipelineManager(),this.setDeviceObjects()}async setAdapterAndDevice({adapter:e=null,device:t=null}={}){await this.setAdapter(e),await this.setDevice(t)}async init({adapter:e=null,device:t=null}={}){if(await this.setAdapterAndDevice({adapter:e,device:t}),this.device)for(const i of this.renderers)i.context||i.setContext()}async setAdapter(e=null){if(this.gpu||(this.onError(),ie("GPUDeviceManager: WebGPU is not supported on your browser/OS. No 'gpu' object in 'navigator'.")),e)this.adapter=e;else try{this.adapter=await this.gpu?.requestAdapter(this.adapterOptions),this.adapter||(this.onError(),ie("GPUDeviceManager: WebGPU is not supported on your browser/OS. 'requestAdapter' failed."))}catch(t){this.onError(),ie("GPUDeviceManager: "+t.message)}}async setDevice(e=null){if(e)this.device=e,this.ready=!0,this.index++;else try{const t=[];this.adapter.features.has("float32-filterable")&&t.push("float32-filterable"),this.device=await this.adapter?.requestDevice({label:this.label+" "+this.index,requiredFeatures:t}),this.device&&(this.ready=!0,this.index++)}catch(t){this.onError(),ie(`${this.label}: WebGPU is not supported on your browser/OS. 'requestDevice' failed: ${t}`)}this.device?.lost.then(t=>{L(`${this.label}: WebGPU device was lost: ${t.message}`),this.loseDevice(),t.reason!=="destroyed"&&this.onDeviceLost(t)})}setPipelineManager(){this.pipelineManager=new Fr}loseDevice(){this.ready=!1,this.pipelineManager.resetCurrentPipeline(),this.samplers.forEach(e=>e.sampler=null),this.renderers.forEach(e=>e.loseContext()),this.bindGroupLayouts.clear(),this.buffers.clear()}async restoreDevice({adapter:e=null,device:t=null}={}){await this.setAdapterAndDevice({adapter:e,device:t}),this.device&&(this.samplers.forEach(i=>{const{type:s,...r}=i.options;i.sampler=this.device.createSampler({label:i.label,...r})}),this.renderers.forEach(i=>i.restoreContext()))}setDeviceObjects(){this.renderers=[],this.bindGroups=new Map,this.buffers=new Map,this.bindGroupLayouts=new Map,this.bufferBindings=new Map,this.samplers=[],this.domTextures=[],this.texturesQueue=[]}addRenderer(e){this.renderers.push(e)}removeRenderer(e){this.renderers=this.renderers.filter(t=>t.uuid!==e.uuid)}get deviceRenderedObjects(){return this.renderers.map(e=>e.renderedObjects).flat()}addBindGroup(e){this.bindGroups.set(e.uuid,e)}removeBindGroup(e){this.bindGroups.delete(e.uuid)}addBuffer(e){this.buffers.set(e.uuid,e)}removeBuffer(e){this.buffers.delete(e?.uuid)}addSampler(e){this.samplers.push(e)}removeSampler(e){this.samplers=this.samplers.filter(t=>t.uuid!==e.uuid)}addDOMTexture(e){this.domTextures.push(e)}uploadTexture(e){if(e.source)try{this.device?.queue.copyExternalImageToTexture({source:e.source,flipY:e.options.flipY},{texture:e.texture,premultipliedAlpha:e.options.premultipliedAlpha},{width:e.size.width,height:e.size.height}),e.texture.mipLevelCount>1&&Ri(this.device,e.texture),this.texturesQueue.push(e)}catch({message:t}){ie(`GPUDeviceManager: could not upload texture: ${e.options.name} because: ${t}`)}else this.device?.queue.writeTexture({texture:e.texture},new Uint8Array(e.options.placeholderColor),{bytesPerRow:e.size.width*4},{width:e.size.width,height:e.size.height})}removeDOMTexture(e){this.domTextures=this.domTextures.filter(t=>t.uuid!==e.uuid)}render(){if(!this.ready)return;for(const i of this.renderers)i.shouldRender&&i.onBeforeCommandEncoder();const e=this.device?.createCommandEncoder({label:this.label+" command encoder"});!this.production&&e.pushDebugGroup(this.label+" command encoder: main render loop"),this.renderers.forEach(i=>i.render(e)),!this.production&&e.popDebugGroup();const t=e.finish();this.device?.queue.submit([t]),this.domTextures.filter(i=>!i.parentMesh&&i.sourceLoaded&&!i.sourceUploaded).forEach(i=>this.uploadTexture(i));for(const i of this.texturesQueue)i.sourceUploaded=!0;this.texturesQueue=[];for(const i of this.renderers)i.shouldRender&&i.onAfterCommandEncoder()}destroy(){this.device?.destroy(),this.device=null,this.renderers.forEach(e=>e.destroy()),this.bindGroups.forEach(e=>e.destroy()),this.buffers.forEach(e=>e?.destroy()),this.domTextures.forEach(e=>e.destroy()),this.setDeviceObjects()}}var rs=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},Nr=(n,e,t)=>(rs(n,e,"read from private field"),t?t.call(n):e.get(n)),Fe=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},si=(n,e,t,i)=>(rs(n,e,"write to private field"),i?i.call(n,t):e.set(n,t),t),$e=(n,e,t)=>(rs(n,e,"access private method"),t),mt,gt,ns,Wr,ri,os,as,jr,ni,hs,ls,qr;let xo=0;class vo{constructor(e,{label:t="",renderPass:i=null,renderOrder:s=0,transparent:r=null,visible:o=!0,size:a=0,useBuffer:h=!1}={}){Fe(this,ns),Fe(this,ri),Fe(this,as),Fe(this,ni),Fe(this,ls),Fe(this,mt,void 0),Fe(this,gt,void 0),this.type="RenderBundle",e=W(e,this.type),this.renderer=e,this.uuid=Y(),Object.defineProperty(this,"index",{value:xo++}),this.renderOrder=s,this.renderer.renderBundles.push(this),this.transparent=r,this.visible=o,this.options={label:t,renderPass:i,useBuffer:h,size:a},i&&$e(this,ni,hs).call(this),this.meshes=new Map,this.encoder=null,this.bundle=null,si(this,gt,!1),this.binding=null,this.options.useBuffer&&(si(this,mt,!0),this.options.size!==0?$e(this,ns,Wr).call(this):(this.options.useBuffer=!1,this.renderer.production||L(`${this.options.label} (${this.type}): Cannot use a single transformation buffer if the size parameter has not been set upon creation.`)))}get useProjection(){return Nr(this,mt)}set useProjection(e){si(this,mt,e)}set size(e){e!==this.options.size&&(this.ready&&!this.renderer.production&&L(`${this.options.label} (${this.type}): The content of a render bundle is meant to be static. You should not change its size after it has been created.`),$e(this,as,jr).call(this,e),this.options.size=e)}get ready(){return Nr(this,gt)}set ready(e){e&&!this.ready?$e(this,ls,qr).call(this):!e&&this.ready&&(this.bundle=null),si(this,gt,e)}addMesh(e,t){if(!this.options.renderPass)this.options.renderPass=t,$e(this,ni,hs).call(this);else if(t.uuid!==this.options.renderPass.uuid){L(`${this.options.label} (${this.type}): Cannot add Mesh ${e.options.label} to this render bundle because the output render passes do not match.`),e.renderBundle=null;return}this.ready&&!this.renderer.production&&L(`${this.options.label} (${this.type}): The content of a render bundle is meant to be static. You should not add meshes to it after it has been created (mesh added: ${e.options.label}).`),this.ready=!1,this.meshes.set(e.uuid,e),this.size=this.meshes.size}removeMesh(e,t=!0){this.ready&&!this.renderer.production&&L(`${this.options.label} (${this.type}): The content of a render bundle is meant to be static. You should not remove meshes from it after it has been created (mesh removed: ${e.options.label}).`),this.ready=!1,this.meshes.delete(e.uuid),e.setRenderBundle(null,!1),this.size=this.meshes.size,t&&(e.type==="ShaderPass"?this.renderer.scene.addShaderPass(e):e.type==="PingPongPlane"?this.renderer.scene.addPingPongPlane(e):this.renderer.scene.addMesh(e))}updateBinding(){this.binding&&this.binding.shouldUpdate&&this.binding.buffer.GPUBuffer&&(this.renderer.queueWriteBuffer(this.binding.buffer.GPUBuffer,0,this.binding.arrayBuffer),this.binding.shouldUpdate=!1)}render(e){if(this.ready&&this.bundle&&this.visible&&(this.meshes.forEach(t=>{t.onBeforeRenderPass()}),this.updateBinding(),this.renderer.pipelineManager.resetCurrentPipeline(),e.executeBundles([this.bundle]),this.renderer.pipelineManager.resetCurrentPipeline(),this.meshes.forEach(t=>{t.onAfterRenderPass()})),!this.ready){let t=!0;for(const[i,s]of this.meshes)s.render(e),s.ready||(t=!1);this.ready=t}}loseContext(){this.ready=!1}remove(){this.destroy(!0)}destroy(e=!1){this.ready=!1,this.renderer.scene.removeRenderBundle(this),this.meshes.forEach(t=>{this.meshes.delete(t.uuid),t.setRenderBundle(null,!1),e&&this.renderer.scene.addMesh(t)}),this.binding&&this.binding.buffer.destroy()}}mt=new WeakMap,gt=new WeakMap,ns=new WeakSet,Wr=function(){this.binding=new pe({label:this.options.label+" matrices",name:"matrices",struct:{model:{type:"array<mat4x4f>",value:new Float32Array(16*this.options.size)},modelView:{type:"array<mat4x4f>",value:new Float32Array(16*this.options.size)},normal:{type:"array<mat3x3f>",value:new Float32Array(12*this.options.size)}}}),$e(this,ri,os).call(this,this.options.size)},ri=new WeakSet,os=function(n){const e=this.renderer.device.limits.minUniformBufferOffsetAlignment;this.binding.arrayBufferSize<n*e&&(this.binding.arrayBufferSize=n*e,this.binding.arrayBuffer=new ArrayBuffer(this.binding.arrayBufferSize),this.binding.buffer.size=this.binding.arrayBuffer.byteLength)},as=new WeakSet,jr=function(n){if(n>this.options.size&&this.binding&&($e(this,ri,os).call(this,n),this.binding.buffer.GPUBuffer)){this.binding.buffer.GPUBuffer.destroy(),this.binding.buffer.createBuffer(this.renderer,{label:this.binding.options.label,usage:["copySrc","copyDst",this.binding.bindingType,...this.binding.options.usage]});let e=0;this.meshes.forEach(t=>{t.patchRenderBundleBinding(e),e++}),this.binding.shouldUpdate=!0}},ni=new WeakSet,hs=function(){this.descriptor={...this.options.renderPass.options.colorAttachments&&{colorFormats:this.options.renderPass.options.colorAttachments.map(n=>n.targetFormat)},...this.options.renderPass.options.useDepth&&{depthStencilFormat:this.options.renderPass.options.depthFormat},sampleCount:this.options.renderPass.options.sampleCount}},ls=new WeakSet,qr=function(){this.renderer.pipelineManager.resetCurrentPipeline(),this.encoder=this.renderer.device.createRenderBundleEncoder({...this.descriptor,label:this.options.label+" (encoder)"}),this.meshes.forEach(n=>{n.material.render(this.encoder),n.geometry.render(this.encoder)}),this.bundle=this.encoder.finish({label:this.options.label+" (bundle)"}),this.renderer.pipelineManager.resetCurrentPipeline()};var wo=`
struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) uv: vec2f,
};

@fragment fn main(fsInput: VSOutput) -> @location(0) vec4f {
  return textureSample(renderTexture, defaultSampler, fsInput.uv);
}`;class bo extends Hi{constructor(e,t={}){e=W(e,t.label?t.label+" ShaderPass":"ShaderPass"),t.depth=!1;const i={color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}};t.targets?t.targets&&t.targets.length&&!t.targets[0].blend&&(t.targets[0].blend=i):t.targets=[{blend:i}],t.label=t.label??"ShaderPass "+e.shaderPasses?.length,t.sampleCount=t.sampleCount?t.sampleCount:e&&e.postProcessingPass?e&&e.postProcessingPass.options.sampleCount:1,t.shaders||(t.shaders={}),t.shaders.fragment||(t.shaders.fragment={code:wo,entryPoint:"main"}),t.depth=!1,super(e,t),t.inputTarget&&this.setInputTarget(t.inputTarget),this.outputTarget&&this.setRenderingOptionsForRenderPass(this.outputTarget.renderPass),this.type="ShaderPass",this.createTexture({label:t.label?`${t.label} render texture`:"Shader pass render texture",name:"renderTexture",fromTexture:this.inputTarget?this.inputTarget.renderTexture:null,usage:["copySrc","copyDst","textureBinding"],...this.outputTarget&&this.outputTarget.options.qualityRatio&&{qualityRatio:this.outputTarget.options.qualityRatio}})}cleanupRenderMaterialParameters(e){return delete e.copyOutputToRenderTexture,delete e.inputTarget,super.cleanupRenderMaterialParameters(e),e}get renderTexture(){return this.textures.find(e=>e.options.name==="renderTexture")}setInputTarget(e){if(e&&e.type!=="RenderTarget"){L(`${this.options.label??this.type}: inputTarget is not a RenderTarget: ${e}`);return}this.removeFromScene(),this.inputTarget=e,this.addToScene(),this.renderTexture&&(e?this.renderTexture.copy(this.inputTarget.renderTexture):(this.renderTexture.options.fromTexture=null,this.renderTexture.createTexture()))}addToScene(e=!1){e&&this.renderer.shaderPasses.push(this),this.setRenderingOptionsForRenderPass(this.outputTarget?this.outputTarget.renderPass:this.renderer.postProcessingPass),this.autoRender&&this.renderer.scene.addShaderPass(this)}removeFromScene(e=!1){this.outputTarget&&this.outputTarget.destroy(),this.autoRender&&this.renderer.scene.removeShaderPass(this),e&&(this.renderer.shaderPasses=this.renderer.shaderPasses.filter(t=>t.uuid!==this.uuid))}}var Bo=`
fn lessThan3(a: vec3f, b: vec3f) -> vec3f {
  return vec3f(vec3<bool>(a.x < b.x, a.y < b.y, a.z < b.z));
}

fn pow2( x: f32 ) -> f32 {
    return x * x;
}

fn pow3( x: f32 ) -> f32 {
    return x * x * x;
}

fn pow4( x: f32 ) -> f32 {
    return pow2(x) * pow2(x);
}
`,Mo=`
${Bo}

struct ReflectedLight {
  directDiffuse: vec3f,
  directSpecular: vec3f,
  indirectDiffuse: vec3f,
  indirectSpecular: vec3f,
}

struct DirectLight {
  color: vec3f,
  direction: vec3f,
  visible: bool,
}

fn rangeAttenuation(range: f32, distance: f32) -> f32 {
  var distanceFalloff: f32 = 1.0 / max( pow( distance, 2.0 ), 0.01 );
  if ( range > 0.0 ) {
      distanceFalloff *= pow2( clamp( 1.0 - pow4( distance / range ), 0.0, 1.0 ) );
  }
  
  return distanceFalloff;
}

fn BRDF_Lambert(diffuseColor: vec3f) -> vec3f {
  return RECIPROCAL_PI * diffuseColor;
}

fn F_Schlick(VdotH: f32, f0: vec3f) -> vec3f {
  let fresnel: f32 = pow( 1.0 - VdotH, 5.0 );
  
  // TODO if specular intensity is defined
  // it could be: mix( specularIntensity, 1.0, metallic );
  let f90: f32 = 1.0;
  return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}

fn getDirectionalLightInfo(directionalLight: DirectionalLightsElement, worldPosition: vec3f, ptr_light: ptr<function, DirectLight>) {
  (*ptr_light).color = directionalLight.color;
  (*ptr_light).direction = worldPosition - directionalLight.direction;
  (*ptr_light).visible = true;
}

fn getPointLightInfo(pointLight: PointLightsElement, worldPosition: vec3f, ptr_light: ptr<function, DirectLight>) {
  let lightDirection: vec3f = pointLight.position - worldPosition;
  (*ptr_light).direction = normalize(lightDirection);
  let lightDistance: f32 = length(lightDirection);
  (*ptr_light).color = pointLight.color;
  (*ptr_light).color *= rangeAttenuation(pointLight.range, lightDistance);
  (*ptr_light).visible = length((*ptr_light).color) > 0.0001;
}
`;const yt=`
fn linearToOutput3(value: vec3f) -> vec3f {
  return vec3( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThan3( value.rgb, vec3( 0.0031308 ) ) ) ) );
}

fn linearToOutput4(value: vec4f) -> vec4f {
  return vec4( linearToOutput3(value.rgb), value.a );
}

// linear <-> sRGB conversions
fn linearTosRGB(linear: vec3f) -> vec3f {
  if (all(linear <= vec3(0.0031308))) {
    return linear * 12.92;
  }
  return (pow(abs(linear), vec3(1.0/2.4)) * 1.055) - vec3(0.055);
}

fn sRGBToLinear(srgb: vec3f) -> vec3f {
  if (all(srgb <= vec3(0.04045))) {
    return srgb / vec3(12.92);
  }
  return pow((srgb + vec3(0.055)) / vec3(1.055), vec3(2.4));
}

fn toneMapKhronosPbrNeutral( color: vec3f ) -> vec3f {
  var toneMapColor = color; 
  const startCompression: f32 = 0.8 - 0.04;
  const desaturation: f32 = 0.15;
  var x: f32 = min(toneMapColor.r, min(toneMapColor.g, toneMapColor.b));
  var offset: f32 = select(0.04, x - 6.25 * x * x, x < 0.08);
  toneMapColor = toneMapColor - offset;
  var peak: f32 = max(toneMapColor.r, max(toneMapColor.g, toneMapColor.b));
  if (peak < startCompression) {
    return toneMapColor;
  }
  const d: f32 = 1. - startCompression;
  let newPeak: f32 = 1. - d * d / (peak + d - startCompression);
  toneMapColor *= newPeak / peak;
  let g: f32 = 1. - 1. / (desaturation * (peak - newPeak) + 1.);
  return mix(toneMapColor, newPeak * vec3(1, 1, 1), g);
}
`;var Co=`
fn getIndirectDiffuse(irradiance: vec3f, diffuseColor: vec3f, ptr_reflectedLight: ptr<function, ReflectedLight>) {
  (*ptr_reflectedLight).indirectDiffuse += irradiance * BRDF_Lambert( diffuseColor );
}

// Indirect Diffuse RenderEquations
fn RE_IndirectDiffuse(irradiance: vec3f, diffuseColor: vec3f, ptr_reflectedLight: ptr<function, ReflectedLight>) {
  var totalAmbientIrradiance: vec3f = irradiance;
  
  for(var i: i32 = 0; i < ambientLights.count; i++) {
    totalAmbientIrradiance += ambientLights.color[i];
  }
  
  getIndirectDiffuse(totalAmbientIrradiance, diffuseColor, ptr_reflectedLight);
}
`,So=`
const PI = ${Math.PI};
const RECIPROCAL_PI = ${1/Math.PI};
const RECIPROCAL_PI2 = ${.5/Math.PI};
const EPSILON = 1e-6;`;const oi=`
${So}
${Mo}
${Co}
`,Yr=`
fn getLambertDirect(
  normal: vec3f,
  diffuseColor: vec3f,
  directLight: DirectLight,
  ptr_reflectedLight: ptr<function, ReflectedLight>
) {
  let L = normalize(directLight.direction);
  let NdotL = max(dot(normal, L), 0.0);
  
  let irradiance: vec3f = NdotL * directLight.color;
  (*ptr_reflectedLight).directDiffuse += irradiance * BRDF_Lambert( diffuseColor );
}
`,Xr=({addUtils:n=!0,receiveShadows:e=!1,toneMapping:t="linear",useOcclusion:i=!1}={})=>`
${n?oi:""}
${Yr}
${t?yt:""}

fn getLambert(
  normal: vec3f,
  worldPosition: vec3f,
  diffuseColor: vec3f,
  ${i?"occlusion: f32,":""}
) -> vec3f {
  var directLight: DirectLight;
  var reflectedLight: ReflectedLight;
  
  ${e?at:""}

  // point lights
  for(var i = 0; i < pointLights.count; i++) {
    getPointLightInfo(pointLights.elements[i], worldPosition, &directLight);
    ${e?lt:""}
    getLambertDirect(normal, diffuseColor, directLight, &reflectedLight);
  }
  
  // directional lights
  for(var i = 0; i < directionalLights.count; i++) {
    getDirectionalLightInfo(directionalLights.elements[i], worldPosition, &directLight);
    ${e?ht:""}
    getLambertDirect(normal, diffuseColor, directLight, &reflectedLight);
  }
  
  // ambient lights
  var irradiance: vec3f = vec3(0.0);
  RE_IndirectDiffuse(irradiance, diffuseColor, &reflectedLight);
  
  let totalDirect: vec3f = reflectedLight.directDiffuse + reflectedLight.directSpecular;
  var totalIndirect: vec3f = reflectedLight.indirectDiffuse + reflectedLight.indirectSpecular;
  
  ${i?"totalIndirect *= occlusion;":""}
  
  var outgoingLight: vec3f = totalDirect + totalIndirect;
  
  ${t==="linear"?"outgoingLight = linearToOutput3(outgoingLight);":t==="khronos"?"outgoingLight = linearTosRGB(toneMapKhronosPbrNeutral(outgoingLight));":""}
  
  return outgoingLight;
}
`,Hr=`
fn D_BlinnPhong( shininess: f32, NdotH: f32 ) -> f32 {
  return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( NdotH, shininess );
}

fn BRDF_BlinnPhong(
  normal: vec3f,
  viewDirection: vec3f,
  specularColor: vec3f,
  shininess: f32,
  directLight: DirectLight
) -> vec3f {
  let L = normalize(directLight.direction);
  let NdotL = max(dot(normal, L), 0.0);
  let H: vec3f = normalize(viewDirection + L);
  
  let NdotH: f32 = clamp(dot(normal, H), 0.0, 1.0);
  let VdotH: f32 = clamp(dot(viewDirection, H), 0.0, 1.0);
  let NdotV: f32 = clamp( dot(normal, viewDirection), 0.0, 1.0 );
  
  let F: vec3f = F_Schlick(VdotH, specularColor);
  
  let G: f32 = 0.25; // blinn phong implicit
  
  let D = D_BlinnPhong(shininess, NdotH);
  
  let specular: vec3f = F * G * D;
        
  return specular;
}

fn getPhongDirect(
  normal: vec3f,
  diffuseColor: vec3f,
  viewDirection: vec3f,
  specularColor: vec3f,
  specularStrength: f32,
  shininess: f32,
  directLight: DirectLight,
  ptr_reflectedLight: ptr<function, ReflectedLight>
) {
  let L = normalize(directLight.direction);
  let NdotL = max(dot(normal, L), 0.0);
  
  let irradiance: vec3f = NdotL * directLight.color;
  (*ptr_reflectedLight).directDiffuse += irradiance * BRDF_Lambert( diffuseColor );
  (*ptr_reflectedLight).directSpecular += irradiance * BRDF_BlinnPhong( normal, viewDirection, specularColor, shininess, directLight ) * specularStrength;
}
`,Zr=({addUtils:n=!0,receiveShadows:e=!1,toneMapping:t="linear",useOcclusion:i=!1}={})=>`
${n?oi:""}
${Hr}
${t?yt:""}

fn getPhong(
  normal: vec3f,
  worldPosition: vec3f,
  diffuseColor: vec3f,
  viewDirection: vec3f,
  specularColor: vec3f,
  specularStrength: f32,
  shininess: f32,
  ${i?"occlusion: f32,":""}
) -> vec3f {
  var directLight: DirectLight;
  var reflectedLight: ReflectedLight;
  
  ${e?at:""}

  // point lights
  for(var i = 0; i < pointLights.count; i++) {  
    getPointLightInfo(pointLights.elements[i], worldPosition, &directLight);
    ${e?lt:""}
    getPhongDirect(normal, diffuseColor, viewDirection, specularColor, specularStrength, shininess, directLight, &reflectedLight);
  }
  
  // directional lights
  for(var i = 0; i < directionalLights.count; i++) {
    getDirectionalLightInfo(directionalLights.elements[i], worldPosition, &directLight);
    ${e?ht:""}
    getPhongDirect(normal, diffuseColor, viewDirection, specularColor, specularStrength, shininess, directLight, &reflectedLight);
  }
  
  // ambient lights
  var irradiance: vec3f = vec3(0.0);
  RE_IndirectDiffuse(irradiance, diffuseColor, &reflectedLight);
  
  let totalDirect: vec3f = reflectedLight.directDiffuse + reflectedLight.directSpecular;
  var totalIndirect: vec3f = reflectedLight.indirectDiffuse + reflectedLight.indirectSpecular;
  
  ${i?"totalIndirect *= occlusion;":""}
  
  var outgoingLight: vec3f = totalDirect + totalIndirect;
  
  ${t==="linear"?"outgoingLight = linearToOutput3(outgoingLight);":t==="khronos"?"outgoingLight = linearTosRGB(toneMapKhronosPbrNeutral(outgoingLight));":""}
  
  return outgoingLight;
}
`;var Po=`
fn DFGApprox(
  normal: vec3f,
  viewDirection: vec3f,
  roughness: f32,
) -> vec2f {
  let dotNV: f32 = clamp( dot( normal, viewDirection ), 0.0, 1.0 );

	let c0: vec4f = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	let c1: vec4f = vec4( 1, 0.0425, 1.04, - 0.04 );

	let r: vec4f = roughness * c0 + c1;
	let a004: f32 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	
	let fab: vec2f = vec2( - 1.04, 1.04 ) * a004 + r.zw;

	return fab;
}

struct TotalScattering {
  single: vec3f,
  multi: vec3f,
}

fn computeMultiscattering(
  normal: vec3f,
  viewDirection: vec3f,
  specularColor: vec3f,
  f90: f32,
  roughness: f32,
  ptr_totalScattering: ptr<function, TotalScattering>
) {
  let fab: vec2f = DFGApprox( normal, viewDirection, roughness );

	let Fr: vec3f = specularColor;

	let FssEss: vec3f = Fr * fab.x + f90 * fab.y;

	let Ess: f32 = fab.x + fab.y;
	let Ems: f32 = 1.0 - Ess;

	let Favg: vec3f = Fr + ( 1.0 - Fr ) * 0.047619; // 1/21
	let Fms: vec3f = FssEss * Favg / ( 1.0 - Ems * Favg );

	(*ptr_totalScattering).single += FssEss;
	(*ptr_totalScattering).multi += Fms * Ems;
}

// Indirect Specular RenderEquations
fn RE_IndirectSpecular(
  radiance: vec3f,
  irradiance: vec3f,
  normal: vec3f,
  diffuseColor: vec3f,
  viewDirection: vec3f,
  metallic: f32,
  roughness: f32,
  ptr_reflectedLight: ptr<function, ReflectedLight>
) {
  var totalScattering: TotalScattering;
  let cosineWeightedIrradiance: vec3f = irradiance * RECIPROCAL_PI;
  
  let specularColor: vec3f = mix( vec3( 0.04 ), diffuseColor, metallic );
  
  let f90: f32 = 1.0;
  
  computeMultiscattering( normal, viewDirection, specularColor, f90, roughness, &totalScattering );
  
  let totalScatter: vec3f = totalScattering.single + totalScattering.multi;
  let diffuse: vec3f = diffuseColor * ( 1.0 - max( max( totalScatter.r, totalScatter.g ), totalScatter.b ) );

  (*ptr_reflectedLight).indirectSpecular += radiance * totalScattering.single;
  (*ptr_reflectedLight).indirectSpecular += totalScattering.multi * cosineWeightedIrradiance;

  (*ptr_reflectedLight).indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
`;const us=`
${oi}
${Po}
`,ds=`
fn DistributionGGX(NdotH: f32, roughness: f32) -> f32 {
  let a: f32 = pow2( roughness );
  let a2: f32 = pow2( a );

  let denom: f32 = (pow2( NdotH ) * (a2 - 1.0) + 1.0);

  return RECIPROCAL_PI * a2 / ( pow2( denom ) );
}

fn GeometrySmith(NdotL: f32, NdotV: f32, roughness: f32) -> f32 {
  let a: f32 = pow2( roughness );
  let a2: f32 = pow2( a );
  
  let gv: f32 = NdotL * sqrt( a2 + ( 1.0 - a2 ) * pow2( NdotV ) );
  let gl: f32 = NdotV * sqrt( a2 + ( 1.0 - a2 ) * pow2( NdotL ) );

  return 0.5 / max( gv + gl, EPSILON );
}

fn BRDF_GGX(
  NdotV: f32,
  NdotL: f32,
  NdotH: f32,
  VdotH: f32,
  roughness: f32,
  f0: vec3f
) -> vec3f {
  // cook-torrance brdf
  let G: f32 = GeometrySmith(NdotL, NdotV, roughness);
  let D: f32 = DistributionGGX(NdotH, roughness);
  let F: vec3f = F_Schlick(VdotH, f0);
  
  return G * D * F;
}

fn getPBRDirect(
  normal: vec3f,
  diffuseColor: vec3f,
  viewDirection: vec3f,
  f0: vec3f,
  metallic: f32,
  roughness: f32,
  directLight: DirectLight,
  ptr_reflectedLight: ptr<function, ReflectedLight>
) {
  let N: vec3f = normalize(normal);
  let L: vec3f = normalize(directLight.direction);
  let V: vec3f = normalize(viewDirection);
  let H: vec3f = normalize(V + L);
  let NdotV: f32 = clamp(dot(N, V), 0.0, 1.0);
  let NdotL: f32 = clamp(dot(N, L), 0.0, 1.0);
  let NdotH: f32 = clamp(dot(N, H), 0.0, 1.0);
  let VdotH: f32 = clamp(dot(V, H), 0.0, 1.0);

  let irradiance: vec3f = NdotL * directLight.color;
  let ggx: vec3f = BRDF_GGX(NdotV, NdotL, NdotH, VdotH, roughness, f0);
  
  (*ptr_reflectedLight).directDiffuse += irradiance * BRDF_Lambert( diffuseColor );
  (*ptr_reflectedLight).directSpecular += ggx * irradiance;
}
`,Kr=({addUtils:n=!0,receiveShadows:e=!1,toneMapping:t="linear",useOcclusion:i=!1}={})=>`
${n?us:""}
${ds}
${t?yt:""}

fn getPBR(
  normal: vec3f,
  worldPosition: vec3f,
  diffuseColor: vec3f,
  viewDirection: vec3f,
  f0: vec3f,
  metallic: f32,
  roughness: f32,
  ${i?"occlusion: f32,":""}
) -> vec3f {
  var directLight: DirectLight;
  var reflectedLight: ReflectedLight;
  
  ${e?at:""}

  // point lights
  for(var i = 0; i < pointLights.count; i++) {
    getPointLightInfo(pointLights.elements[i], worldPosition, &directLight);
    ${e?lt:""}
    getPBRDirect(normal, diffuseColor, viewDirection, f0, metallic, roughness, directLight, &reflectedLight);
  }
  
  // directional lights
  for(var i = 0; i < directionalLights.count; i++) {
    getDirectionalLightInfo(directionalLights.elements[i], worldPosition, &directLight);
    ${e?ht:""}
    getPBRDirect(normal, diffuseColor, viewDirection, f0, metallic, roughness, directLight, &reflectedLight);
  }
  
  // ambient lights
  var irradiance: vec3f = vec3(0.0);
  RE_IndirectDiffuse(irradiance, diffuseColor, &reflectedLight);
  
  // ambient lights specular
  // var radiance: vec3f = vec3(0.0);
  // RE_IndirectSpecular(radiance, irradiance, normal, diffuseColor, viewDirection, metallic, roughness, &reflectedLight);
  
  let totalDirect: vec3f = reflectedLight.directDiffuse + reflectedLight.directSpecular;
  var totalIndirect: vec3f = reflectedLight.indirectDiffuse + reflectedLight.indirectSpecular;
  
  ${i?"totalIndirect *= occlusion;":""}
  
  var outgoingLight: vec3f = totalDirect + totalIndirect;
  
  ${t==="linear"?"outgoingLight = linearToOutput3(outgoingLight);":t==="khronos"?"outgoingLight = linearTosRGB(toneMapKhronosPbrNeutral(outgoingLight));":""}
  
  return outgoingLight;
}
`,Jr=`
// struct IBLIndirect {
//   diffuse: vec3f,
//   specular: vec3f
// }

fn getIBLIndirect(
  normal: vec3f,
  viewDirection: vec3f,
  roughness: f32,
  metallic: f32,
  diffuseColor: vec3f,
  f0: vec3f,
  lutTexture: texture_2d<f32>,
  lutSampler: sampler,
  envSpecularTexture: texture_cube<f32>,
  envSpecularSampler: sampler,
  envDiffuseTexture: texture_cube<f32>,
  envDiffuseSampler: sampler,
  ptr_reflectedLight: ptr<function, ReflectedLight>,
  // ptr_iblIndirect: ptr<function, IBLIndirect>
) {
  let N: vec3f = normalize(normal);
  let V: vec3f = normalize(viewDirection);
  let NdotV: f32 = clamp(dot(N, V), 0.0, 1.0);
  
  let reflection: vec3f = normalize(reflect(-V, N));
  
  let iblDiffuseColor: vec3f = mix(diffuseColor, vec3(0.0), vec3(metallic));

  let brdfSamplePoint: vec2f = clamp(vec2(NdotV, roughness), vec2(0.0), vec2(1.0));
  
  let brdf: vec3f = textureSample(
    lutTexture,
    lutSampler,
    brdfSamplePoint
  ).rgb;

  let Fr: vec3f = max(vec3(1.0 - roughness), f0) - f0;
  let k_S: vec3f = f0 + Fr * pow(1.0 - NdotV, 5.0);
  var FssEss: vec3f = k_S * brdf.x + brdf.y;
  
  // IBL specular (radiance)
  let lod: f32 = roughness * f32(textureNumLevels(envSpecularTexture) - 1);
  
  let specularLight: vec4f = textureSampleLevel(
    envSpecularTexture,
    envSpecularSampler,
    reflection,
    lod
  );
  
  // IBL diffuse (irradiance)
  let diffuseLight: vec4f = textureSample(
    envDiffuseTexture,
    envDiffuseSampler,
    normal
  );
  
  // product of specularFactor and specularTexture.a
  let specularWeight: f32 = 1.0;
        
  FssEss = specularWeight * k_S * brdf.x + brdf.y;
  
  let Ems: f32 = (1.0 - (brdf.x + brdf.y));
  let F_avg: vec3f = specularWeight * (f0 + (1.0 - f0) / 21.0);
  let FmsEms: vec3f = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);
  let k_D: vec3f = iblDiffuseColor * (1.0 - FssEss + FmsEms);
  
  (*ptr_reflectedLight).indirectSpecular += specularLight.rgb * FssEss * ibl.specularStrength;
  (*ptr_reflectedLight).indirectDiffuse += (FmsEms + k_D) * diffuseLight.rgb * ibl.diffuseStrength;
  
  // (*ptr_iblIndirect).diffuse = PI * diffuseLight.rgb * ibl.diffuseStrength;
  // (*ptr_iblIndirect).specular = specularLight.rgb * ibl.specularStrength;
}
`,Qr=({addUtils:n=!0,receiveShadows:e=!1,toneMapping:t="linear",useOcclusion:i=!1}={})=>`
${n?us:""}
${ds}
${Jr}
${t?yt:""}

fn getIBL(
  normal: vec3f,
  worldPosition: vec3f,
  diffuseColor: vec3f,
  viewDirection: vec3f,
  f0: vec3f,
  metallic: f32,
  roughness: f32,
  lutTexture: texture_2d<f32>,
  lutSampler: sampler,
  envSpecularTexture: texture_cube<f32>,
  envSpecularSampler: sampler,
  envDiffuseTexture: texture_cube<f32>,
  envDiffuseSampler: sampler,
  ${i?"occlusion: f32,":""}
) -> vec3f {
  var directLight: DirectLight;
  var reflectedLight: ReflectedLight;
  
  ${e?at:""}

  // point lights
  for(var i = 0; i < pointLights.count; i++) {
    getPointLightInfo(pointLights.elements[i], worldPosition, &directLight);
    ${e?lt:""}
    getPBRDirect(normal, diffuseColor, viewDirection, f0, metallic, roughness, directLight, &reflectedLight);
  }
  
  // directional lights
  for(var i = 0; i < directionalLights.count; i++) {
    getDirectionalLightInfo(directionalLights.elements[i], worldPosition, &directLight);
    ${e?ht:""}
    getPBRDirect(normal, diffuseColor, viewDirection, f0, metallic, roughness, directLight, &reflectedLight);
  }
  
  var irradiance: vec3f = vec3(0.0);
  var radiance: vec3f = vec3(0.0);
  
  // var iblIndirect: IBLIndirect;
  
  // IBL
  getIBLIndirect(
    normal,
    viewDirection,
    roughness,
    metallic,
    diffuseColor,
    f0,
    lutTexture,
    lutSampler,
    envSpecularTexture,
    envSpecularSampler,
    envDiffuseTexture,
    envDiffuseSampler,
    &reflectedLight,
    // &iblIndirect
  );
  
  // irradiance += iblIndirect.diffuse;
  // radiance += iblIndirect.specular;
  
  // ambient lights
  RE_IndirectDiffuse(irradiance, diffuseColor, &reflectedLight);
  
  // ambient lights specular
  // RE_IndirectSpecular(radiance, irradiance, normal, diffuseColor, viewDirection, metallic, roughness, &reflectedLight);  
  
  let totalDirect: vec3f = reflectedLight.directDiffuse + reflectedLight.directSpecular;
  var totalIndirect: vec3f = reflectedLight.indirectDiffuse + reflectedLight.indirectSpecular;
  
  ${i?"totalIndirect *= occlusion;":""}
  
  var outgoingLight: vec3f = totalDirect + totalIndirect;
  
  ${t==="linear"?"outgoingLight = linearToOutput3(outgoingLight);":t==="khronos"?"outgoingLight = linearTosRGB(toneMapKhronosPbrNeutral(outgoingLight));":""}
  
  return outgoingLight;
}
`;var en=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},Me=(n,e,t)=>(en(n,e,"read from private field"),t?t.call(n):e.get(n)),cs=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},To=(n,e,t,i)=>(en(n,e,"write to private field"),i?i.call(n,t):e.set(n,t),t),xt,Ue,ai;class tn extends Zi{constructor(e,t,i={}){super(e),cs(this,xt,new f),cs(this,Ue,new f(1)),cs(this,ai,1),this.boundingBox=new ve(new f(-1),new f(1)),this._onAfterDOMElementResizeCallback=()=>{},e=Ti(e,"DOM3DObject"),this.renderer=e,this.size={shouldUpdate:!0,normalizedWorld:{size:new _(1),position:new _},cameraWorld:{size:new _(1)},scaledWorld:{size:new f(1),position:new f}},this.watchScroll=i.watchScroll,this.camera=this.renderer.camera,this.boundingBox.min.onChange(()=>this.shouldUpdateComputedSizes()),this.boundingBox.max.onChange(()=>this.shouldUpdateComputedSizes()),this.setDOMElement(t),this.renderer.domObjects.push(this)}setDOMElement(e){this.domElement=new Ji({element:e,onSizeChanged:t=>this.resize(t),onPositionChanged:()=>this.onPositionChanged()}),this.updateSizeAndPosition()}onPositionChanged(){this.watchScroll&&this.shouldUpdateComputedSizes()}resetDOMElement(e){this.domElement&&this.domElement.destroy(),this.setDOMElement(e)}resize(e=null){!e&&(!this.domElement||this.domElement?.isResizing)||(this.updateSizeAndPosition(),this._onAfterDOMElementResizeCallback&&this._onAfterDOMElementResizeCallback())}get boundingRect(){return this.domElement?.boundingRect??{width:1,height:1,top:0,right:0,bottom:0,left:0,x:0,y:0}}setTransforms(){super.setTransforms(),this.transforms.origin.model.set(.5,.5,0),this.transforms.origin.world=new f,this.transforms.position.document=new f,this.documentPosition.onChange(()=>this.applyPosition()),this.transformOrigin.onChange(()=>this.setWorldTransformOrigin())}get documentPosition(){return this.transforms.position.document}set documentPosition(e){this.transforms.position.document=e,this.applyPosition()}get DOMObjectWorldScale(){return Me(this,Ue).clone()}get worldScale(){return this.DOMObjectWorldScale.multiply(this.scale)}get worldPosition(){return Me(this,xt).clone()}get transformOrigin(){return this.transforms.origin.model}set transformOrigin(e){this.transforms.origin.model=e,this.setWorldTransformOrigin()}get worldTransformOrigin(){return this.transforms.origin.world}set worldTransformOrigin(e){this.transforms.origin.world=e}shouldUpdateMatrices(){super.shouldUpdateMatrices(),(this.matricesNeedUpdate||this.size.shouldUpdate)&&(this.updateSizeAndPosition(),this.matricesNeedUpdate=!0),this.size.shouldUpdate=!1}shouldUpdateComputedSizes(){this.size.shouldUpdate=!0}updateSizeAndPosition(){this.setWorldSizes(),this.applyDocumentPosition(),this.shouldUpdateModelMatrix()}applyDocumentPosition(){let e=new f(0,0,0);this.documentPosition.equals(e)||(e=this.documentToWorldSpace(this.documentPosition)),Me(this,xt).set(this.position.x+this.size.scaledWorld.position.x+e.x,this.position.y+this.size.scaledWorld.position.y+e.y,this.position.z+this.size.scaledWorld.position.z+this.documentPosition.z/this.camera.CSSPerspective)}applyTransformOrigin(){this.size&&(this.setWorldTransformOrigin(),super.applyTransformOrigin())}updateModelMatrix(){this.modelMatrix.composeFromOrigin(Me(this,xt),this.quaternion,this.scale,this.worldTransformOrigin),this.modelMatrix.scale(this.DOMObjectWorldScale),this.shouldUpdateWorldMatrix()}documentToWorldSpace(e=new f){return new f(e.x*this.renderer.pixelRatio/this.renderer.boundingRect.width*this.camera.visibleSize.width,-(e.y*this.renderer.pixelRatio/this.renderer.boundingRect.height)*this.camera.visibleSize.height,e.z)}computeWorldSizes(){const e=this.renderer.boundingRect,t={x:this.boundingRect.width/2+this.boundingRect.left,y:this.boundingRect.height/2+this.boundingRect.top},i={x:e.width/2+e.left,y:e.height/2+e.top},{size:s,center:r}=this.boundingBox;s.x!==0&&s.y!==0&&s.z!==0&&r.divide(s),this.size.normalizedWorld.size.set(this.boundingRect.width/e.width,this.boundingRect.height/e.height),this.size.normalizedWorld.position.set((t.x-i.x)/e.width,(i.y-t.y)/e.height),this.size.cameraWorld.size.set(this.size.normalizedWorld.size.x*this.camera.visibleSize.width,this.size.normalizedWorld.size.y*this.camera.visibleSize.height),this.size.scaledWorld.size.set(this.size.cameraWorld.size.x/s.x,this.size.cameraWorld.size.y/s.y,1),this.size.scaledWorld.size.z=this.size.scaledWorld.size.y*(s.x/s.y/(this.boundingRect.width/this.boundingRect.height)),this.size.scaledWorld.position.set(this.size.normalizedWorld.position.x*this.camera.visibleSize.width,this.size.normalizedWorld.position.y*this.camera.visibleSize.height,0)}setWorldSizes(){this.computeWorldSizes(),this.setWorldScale(),this.setWorldTransformOrigin()}setWorldScale(){Me(this,Ue).set(this.size.scaledWorld.size.x,this.size.scaledWorld.size.y,this.size.scaledWorld.size.z*Me(this,ai)),this.shouldUpdateMatrixStack()}set DOMObjectDepthScaleRatio(e){To(this,ai,e),this.setWorldScale()}setWorldTransformOrigin(){this.transforms.origin.world=new f((this.transformOrigin.x*2-1)*Me(this,Ue).x,-(this.transformOrigin.y*2-1)*Me(this,Ue).y,this.transformOrigin.z*Me(this,Ue).z),this.shouldUpdateMatrixStack()}updateScrollPosition(e={x:0,y:0}){(e.x||e.y)&&this.domElement.updateScrollPosition(e)}onAfterDOMElementResize(e){return e&&(this._onAfterDOMElementResizeCallback=e),this}destroy(){super.destroy(),this.domElement?.destroy()}}xt=new WeakMap,Ue=new WeakMap,ai=new WeakMap;const sn={autoloadSources:!0,watchScroll:!0};class rn extends Or(tn){constructor(e,t,i){super(e,t,{...sn,...i}),this._onLoadingCallback=r=>{},i={...sn,...i},Ti(e,i.label?i.label+" DOMMesh":"DOMMesh"),this.type="DOMMesh";const{autoloadSources:s}=i;this.autoloadSources=s,this.sourcesReady=!1,this.setInitSources()}get ready(){return this._ready}set ready(e){e&&!this._ready&&this.sourcesReady&&this._onReadyCallback&&this._onReadyCallback(),this._ready=e}get sourcesReady(){return this._sourcesReady}set sourcesReady(e){e&&!this._sourcesReady&&this.ready&&this._onReadyCallback&&this._onReadyCallback(),this._sourcesReady=e}addToScene(e=!1){super.addToScene(e),e&&this.renderer.domMeshes.push(this)}removeFromScene(e=!1){super.removeFromScene(e),e&&(this.renderer.domMeshes=this.renderer.domMeshes.filter(t=>t.uuid!==this.uuid))}setInitSources(){let e=0,t=0;if(this.autoloadSources){const i=this.domElement.element.querySelectorAll("img"),s=this.domElement.element.querySelectorAll("video"),r=this.domElement.element.querySelectorAll("canvas");e=i.length+s.length+r.length;const o=a=>{t++,this._onLoadingCallback&&this._onLoadingCallback(a),t===e&&(this.sourcesReady=!0)};e||(this.sourcesReady=!0),i.length&&i.forEach(a=>{const h=this.createDOMTexture({name:a.getAttribute("data-texture-name")??"texture"+this.domTextures.length});h.onSourceUploaded(()=>o(h)).loadImage(a.src)}),s.length&&s.forEach(a=>{const h=this.createDOMTexture({name:a.getAttribute("data-texture-name")??"texture"+this.domTextures.length});h.onSourceUploaded(()=>o(h)).loadVideo(a)}),r.length&&r.forEach(a=>{const h=this.createDOMTexture({name:a.getAttribute("data-texture-name")??"texture"+this.domTextures.length});h.onSourceUploaded(()=>o(h)).loadCanvas(a)})}else this.sourcesReady=!0}resetDOMElement(e){e?super.resetDOMElement(e):!e&&!this.renderer.production&&L(`${this.options.label}: You are trying to reset a ${this.type} with a HTML element that does not exist. The old HTML element will be kept instead.`)}get pixelRatioBoundingRect(){const e=window.devicePixelRatio??1,t=this.renderer.pixelRatio/e;return Object.keys(this.domElement.boundingRect).reduce((i,s)=>({...i,[s]:this.domElement.boundingRect[s]*t}),{x:0,y:0,width:0,height:0,top:0,right:0,bottom:0,left:0})}computeGeometry(){super.computeGeometry(),this.boundingBox.copy(this.geometry.boundingBox)}onLoading(e){return e&&(this._onLoadingCallback=e),this}}const Ro={label:"Plane",instancesCount:1,vertexBuffers:[]};class nn extends rn{constructor(e,t,i={}){e=Ti(e,i.label?i.label+" Plane":"Plane");const s={...Ro,...i};let{geometry:r,widthSegments:o,heightSegments:a,...h}=s;const{instancesCount:l,vertexBuffers:u,...d}=h;if(!r||r.type!=="PlaneGeometry"){o=o??1,a=a??1;const c=o*a+o;u.length||(r=Qt.getPlaneGeometryByID(c)),r?r.instancesCount=l:(r=new Fi({widthSegments:o,heightSegments:a,instancesCount:l,vertexBuffers:u}),Qt.addPlaneGeometry(r))}super(e,t,{geometry:r,...d}),this.type="Plane"}}class hi extends ss{constructor({deviceManager:e,label:t,container:i,pixelRatio:s=1,autoResize:r=!0,preferredFormat:o,alphaMode:a="premultiplied",renderPass:h,camera:l,lights:u}){super({deviceManager:e,label:t,container:i,pixelRatio:s,autoResize:r,preferredFormat:o,alphaMode:a,renderPass:h,camera:l,lights:u}),this.type="GPUCurtainsRenderer"}setRendererObjects(){super.setRendererObjects(),this.domMeshes=[],this.domObjects=[]}onCameraMatricesChanged(){super.onCameraMatricesChanged(),this.domObjects.forEach(e=>{e.updateSizeAndPosition()})}resizeMeshes(){this.meshes.forEach(e=>{"domElement"in e||e.resize(this.boundingRect)}),this.domObjects.forEach(e=>{e.domElement.isResizing||e.domElement.setSize()})}}class zo{constructor({scroll:e={x:0,y:0},delta:t={x:0,y:0},shouldWatch:i=!0,onScroll:s=(r={x:0,y:0})=>{}}={}){this.scroll=e,this.delta=t,this.shouldWatch=i,this.onScroll=s,this.shouldWatch&&window.addEventListener("scroll",this.setScroll.bind(this),{passive:!0})}setScroll(){this.updateScrollValues({x:window.pageXOffset,y:window.pageYOffset})}updateScrollValues({x:e,y:t}){const i=this.scroll;this.scroll={x:e,y:t},this.delta={x:i.x-this.scroll.x,y:i.y-this.scroll.y},this.onScroll&&this.onScroll(this.delta)}destroy(){this.shouldWatch&&window.removeEventListener("scroll",this.setScroll.bind(this),{passive:!0})}}class Eo{constructor({container:e,label:t,pixelRatio:i=window.devicePixelRatio??1,preferredFormat:s,alphaMode:r="premultiplied",production:o=!1,adapterOptions:a={},renderPass:h,camera:l,lights:u,autoRender:d=!0,autoResize:c=!0,watchScroll:p=!0}={}){this._onRenderCallback=()=>{},this._onScrollCallback=()=>{},this._onErrorCallback=()=>{},this._onContextLostCallback=()=>{},this.type="CurtainsGPU",this.options={container:e,label:t,pixelRatio:i,camera:l,lights:u,production:o,adapterOptions:a,preferredFormat:s,alphaMode:r,renderPass:h,autoRender:d,autoResize:c,watchScroll:p},this.setDeviceManager(),e&&this.setContainer(e),this.initEvents(),this.options.autoRender&&this.animate()}setContainer(e){if(e)if(typeof e=="string")if(e=document.querySelector(e),e)this.options.container=e;else{const t=document.createElement("div");t.setAttribute("id","curtains-gpu-canvas"),document.body.appendChild(t),this.options.container=t}else e instanceof Element&&(this.options.container=e);else{const t=document.createElement("div");t.setAttribute("id","curtains-gpu-canvas"),document.body.appendChild(t),this.options.container=t}this.container=this.options.container,this.setMainRenderer()}setMainRenderer(){this.createCurtainsRenderer({deviceManager:this.deviceManager,label:this.options.label,container:this.options.container,pixelRatio:this.options.pixelRatio,autoResize:this.options.autoResize,preferredFormat:this.options.preferredFormat,alphaMode:this.options.alphaMode,renderPass:this.options.renderPass,camera:this.options.camera,lights:this.options.lights})}patchRendererOptions(e){return e.pixelRatio===void 0&&(e.pixelRatio=this.options.pixelRatio),e.autoResize===void 0&&(e.autoResize=this.options.autoResize),e}createRenderer(e){return e=this.patchRendererOptions(e),new ts({...e,deviceManager:this.deviceManager})}createCameraRenderer(e){return e=this.patchRendererOptions(e),new ss({...e,deviceManager:this.deviceManager})}createCurtainsRenderer(e){return e=this.patchRendererOptions(e),new hi({...e,deviceManager:this.deviceManager})}setDeviceManager(){this.deviceManager=new Vr({label:"GPUCurtains default device",production:this.options.production,adapterOptions:this.options.adapterOptions,onError:()=>setTimeout(()=>{this._onErrorCallback&&this._onErrorCallback()},0),onDeviceLost:e=>this._onContextLostCallback&&this._onContextLostCallback(e)})}get renderers(){return this.deviceManager.renderers}get renderer(){return this.renderers[0]}async setDevice({adapter:e=null,device:t=null}={}){await this.deviceManager.init({adapter:e,device:t})}async restoreContext(){await this.deviceManager.restoreDevice()}get pingPongPlanes(){return this.renderers?.map(e=>e.pingPongPlanes).flat()}get shaderPasses(){return this.renderers?.map(e=>e.shaderPasses).flat()}get meshes(){return this.renderers?.map(e=>e.meshes).flat()}get domMeshes(){return this.renderers?.filter(e=>e instanceof hi).map(e=>e.domMeshes).flat()}get domObjects(){return this.renderers?.filter(e=>e instanceof hi).map(e=>e.domObjects).flat()}get planes(){return this.domMeshes.filter(e=>e instanceof nn)}get computePasses(){return this.renderers?.map(e=>e.computePasses).flat()}get boundingRect(){return this.renderer?.boundingRect}initScroll(){this.scrollManager=new zo({scroll:{x:window.pageXOffset,y:window.pageYOffset},delta:{x:0,y:0},shouldWatch:this.options.watchScroll,onScroll:e=>this.updateScroll(e)})}updateScroll(e={x:0,y:0}){this.domObjects.forEach(t=>{t.domElement&&t.watchScroll&&t.updateScrollPosition(e)}),this._onScrollCallback&&this._onScrollCallback()}updateScrollValues(e={x:0,y:0}){this.scrollManager.updateScrollValues(e)}get scrollDelta(){return this.scrollManager.delta}get scrollValues(){return this.scrollManager.scroll}initEvents(){Ki.useObserver(this.options.autoResize),this.initScroll()}onRender(e){return e&&(this._onRenderCallback=e),this}onScroll(e){return e&&(this._onScrollCallback=e),this}onError(e){return e&&(this._onErrorCallback=e),this}onContextLost(e){return e&&(this._onContextLostCallback=e),this}animate(){this.render(),this.animationFrameID=window.requestAnimationFrame(this.animate.bind(this))}render(){this._onRenderCallback&&this._onRenderCallback(),this.deviceManager.render()}destroy(){this.animationFrameID&&window.cancelAnimationFrame(this.animationFrameID),this.deviceManager.destroy(),this.scrollManager?.destroy(),Ki.destroy()}}var ps=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},B=(n,e,t)=>(ps(n,e,"read from private field"),t?t.call(n):e.get(n)),k=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},Re=(n,e,t,i)=>(ps(n,e,"write to private field"),i?i.call(n,t):e.set(n,t),t),A=(n,e,t)=>(ps(n,e,"access private method"),t),V,oe,ze,U,Ye,Xe,vt,He,li,fs,ms,on,gs,an,ui,ys,di,xs,ci,vs,pi,ws,fi,bs,mi,Bs,gi,Ms,yi,Cs,ke,Ze,xi,Ss,Ps,hn,Ts,ln;const Ke=new _,Je=new _,Ee=new f;class Lo{constructor({camera:e,element:t=null,target:i=new f,enableZoom:s=!0,minZoom:r=0,maxZoom:o=1/0,zoomSpeed:a=1,enableRotate:h=!0,minPolarAngle:l=0,maxPolarAngle:u=Math.PI,minAzimuthAngle:d=-1/0,maxAzimuthAngle:c=1/0,rotateSpeed:p=1,enablePan:g=!0,panSpeed:m=1}){if(k(this,li),k(this,ms),k(this,gs),k(this,ui),k(this,di),k(this,ci),k(this,pi),k(this,fi),k(this,mi),k(this,gi),k(this,yi),k(this,ke),k(this,xi),k(this,Ps),k(this,Ts),k(this,V,null),k(this,oe,new f),k(this,ze,!1),k(this,U,{radius:1,phi:0,theta:0}),k(this,Ye,new _),k(this,Xe,!1),k(this,vt,new _),k(this,He,new f),!e){L("OrbitControls: cannot initialize without a camera.");return}this.camera=e,A(this,li,fs).call(this,{target:i,enableZoom:s,minZoom:r,maxZoom:o,zoomSpeed:a,enableRotate:h,minPolarAngle:l,maxPolarAngle:u,minAzimuthAngle:d,maxAzimuthAngle:c,rotateSpeed:p,enablePan:g,panSpeed:m}),B(this,oe).copy(this.camera.position).sub(this.target),B(this,U).radius=B(this,oe).length(),B(this,U).theta=Math.atan2(B(this,oe).x,B(this,oe).z),B(this,U).phi=Math.acos(Math.min(Math.max(B(this,oe).y/B(this,U).radius,-1),1)),this.camera.position.onChange(()=>{this.camera.lookAt(this.target)}),this.element=t??(typeof window<"u"?window:null),A(this,ke,Ze).call(this)}reset({position:e,target:t,enableZoom:i=this.enableZoom,minZoom:s=this.minZoom,maxZoom:r=this.maxZoom,zoomSpeed:o=this.zoomSpeed,enableRotate:a=this.enableRotate,minPolarAngle:h=this.minPolarAngle,maxPolarAngle:l=this.maxPolarAngle,minAzimuthAngle:u=this.minAzimuthAngle,maxAzimuthAngle:d=this.maxAzimuthAngle,rotateSpeed:c=this.rotateSpeed,enablePan:p=this.enablePan,panSpeed:g=this.panSpeed}={}){A(this,li,fs).call(this,{target:t,enableZoom:i,minZoom:s,maxZoom:r,zoomSpeed:o,enableRotate:a,minPolarAngle:h,maxPolarAngle:l,minAzimuthAngle:u,maxAzimuthAngle:d,rotateSpeed:c,enablePan:p,panSpeed:g}),e&&this.updatePosition(e)}updatePosition(e=new f){e.sub(this.target),B(this,U).radius=e.length(),B(this,U).theta=Math.atan2(e.x,e.z),B(this,U).phi=Math.acos(Math.min(Math.max(e.y/B(this,U).radius,-1),1)),A(this,ke,Ze).call(this)}set element(e){B(this,V)&&(!e||B(this,V)!==e)&&A(this,gs,an).call(this),Re(this,V,e),e&&A(this,ms,on).call(this)}get element(){return B(this,V)}destroy(){this.element=null}}V=new WeakMap,oe=new WeakMap,ze=new WeakMap,U=new WeakMap,Ye=new WeakMap,Xe=new WeakMap,vt=new WeakMap,He=new WeakMap,li=new WeakSet,fs=function({target:n,enableZoom:e=this.enableZoom,minZoom:t=this.minZoom,maxZoom:i=this.maxZoom,zoomSpeed:s=this.zoomSpeed,enableRotate:r=this.enableRotate,minPolarAngle:o=this.minPolarAngle,maxPolarAngle:a=this.maxPolarAngle,minAzimuthAngle:h=this.minAzimuthAngle,maxAzimuthAngle:l=this.maxAzimuthAngle,rotateSpeed:u=this.rotateSpeed,enablePan:d=this.enablePan,panSpeed:c=this.panSpeed}={}){n&&(this.target=n),this.enableZoom=e,this.minZoom=t,this.maxZoom=i,this.zoomSpeed=s,this.enableRotate=r,this.minPolarAngle=o,this.maxPolarAngle=a,this.minAzimuthAngle=h,this.maxAzimuthAngle=l,this.rotateSpeed=u,this.enablePan=d,this.panSpeed=c},ms=new WeakSet,on=function(){B(this,V).addEventListener("contextmenu",A(this,yi,Cs).bind(this),!1),B(this,V).addEventListener("mousedown",A(this,ui,ys).bind(this),!1),B(this,V).addEventListener("mousemove",A(this,ci,vs).bind(this),!1),B(this,V).addEventListener("mouseup",A(this,fi,bs).bind(this),!1),B(this,V).addEventListener("touchstart",A(this,di,xs).bind(this),{passive:!1}),B(this,V).addEventListener("touchmove",A(this,pi,ws).bind(this),{passive:!1}),B(this,V).addEventListener("touchend",A(this,mi,Bs).bind(this),!1),B(this,V).addEventListener("wheel",A(this,gi,Ms).bind(this),{passive:!1})},gs=new WeakSet,an=function(){B(this,V).removeEventListener("contextmenu",A(this,yi,Cs).bind(this),!1),B(this,V).removeEventListener("mousedown",A(this,ui,ys).bind(this),!1),B(this,V).removeEventListener("mousemove",A(this,ci,vs).bind(this),!1),B(this,V).removeEventListener("mouseup",A(this,fi,bs).bind(this),!1),B(this,V).removeEventListener("touchstart",A(this,di,xs).bind(this),{passive:!1}),B(this,V).removeEventListener("touchmove",A(this,pi,ws).bind(this),{passive:!1}),B(this,V).removeEventListener("touchend",A(this,mi,Bs).bind(this),!1),B(this,V).removeEventListener("wheel",A(this,gi,Ms).bind(this),{passive:!1})},ui=new WeakSet,ys=function(n){n.button===0&&this.enableRotate?(Re(this,ze,!0),B(this,Ye).set(n.clientX,n.clientY)):n.button===2&&this.enablePan&&(Re(this,Xe,!0),B(this,vt).set(n.clientX,n.clientY)),n.stopPropagation(),n.preventDefault()},di=new WeakSet,xs=function(n){n.touches.length===1&&this.enableRotate&&(Re(this,ze,!0),B(this,Ye).set(n.touches[0].pageX,n.touches[0].pageY))},ci=new WeakSet,vs=function(n){B(this,ze)&&this.enableRotate?A(this,xi,Ss).call(this,n.clientX,n.clientY):B(this,Xe)&&this.enablePan&&A(this,Ps,hn).call(this,n.clientX,n.clientY)},pi=new WeakSet,ws=function(n){B(this,ze)&&this.enableRotate&&A(this,xi,Ss).call(this,n.touches[0].pageX,n.touches[0].pageY)},fi=new WeakSet,bs=function(n){Re(this,ze,!1),Re(this,Xe,!1)},mi=new WeakSet,Bs=function(n){Re(this,ze,!1),Re(this,Xe,!1)},gi=new WeakSet,Ms=function(n){this.enableZoom&&(A(this,Ts,ln).call(this,n.deltaY),n.preventDefault())},yi=new WeakSet,Cs=function(n){n.preventDefault()},ke=new WeakSet,Ze=function(){const n=B(this,U).radius*Math.sin(Math.max(1e-6,B(this,U).phi));B(this,oe).x=n*Math.sin(B(this,U).theta),B(this,oe).y=B(this,U).radius*Math.cos(B(this,U).phi),B(this,oe).z=n*Math.cos(B(this,U).theta),this.camera.position.copy(this.target).add(B(this,oe))},xi=new WeakSet,Ss=function(n,e){Ke.set(n,e),Je.copy(Ke).sub(B(this,Ye)).multiplyScalar(this.rotateSpeed),B(this,U).theta-=2*Math.PI*Je.x/this.camera.size.height,B(this,U).phi-=2*Math.PI*Je.y/this.camera.size.height,B(this,U).theta=Math.min(this.maxAzimuthAngle,Math.max(this.minAzimuthAngle,B(this,U).theta)),B(this,U).phi=Math.min(this.maxPolarAngle,Math.max(this.minPolarAngle,B(this,U).phi)),B(this,Ye).copy(Ke),A(this,ke,Ze).call(this)},Ps=new WeakSet,hn=function(n,e){Ke.set(n,e),Je.copy(Ke).sub(B(this,vt)).multiplyScalar(this.panSpeed),B(this,He).set(0),Ee.copy(this.camera.position).sub(this.target);let t=Ee.length();t*=Math.tan(this.camera.fov/2*Math.PI/180),Ee.set(this.camera.modelMatrix.elements[0],this.camera.modelMatrix.elements[1],this.camera.modelMatrix.elements[2]),Ee.multiplyScalar(-(2*Je.x*t)/this.camera.size.height),B(this,He).add(Ee),Ee.set(this.camera.modelMatrix.elements[4],this.camera.modelMatrix.elements[5],this.camera.modelMatrix.elements[6]),Ee.multiplyScalar(2*Je.y*t/this.camera.size.height),B(this,He).add(Ee),B(this,vt).copy(Ke),this.target.add(B(this,He)),B(this,oe).copy(this.camera.position).sub(this.target),B(this,U).radius=B(this,oe).length(),A(this,ke,Ze).call(this)},Ts=new WeakSet,ln=function(n){B(this,U).radius=Math.min(this.maxZoom,Math.max(this.minZoom+1e-6,B(this,U).radius+n*this.zoomSpeed/100)),A(this,ke,Ze).call(this)};class _o extends nt{constructor({instancesCount:e=1,vertexBuffers:t=[],topology:i,mapBuffersAtCreation:s=!0,widthSegments:r=1,heightSegments:o=1,depthSegments:a=1}={}){super({verticesOrder:"ccw",topology:i,instancesCount:e,vertexBuffers:t,mapBuffersAtCreation:s}),this.type="BoxGeometry",r=Math.floor(r),o=Math.floor(o),a=Math.floor(a);const h=[],l=[],u=[],d=[];let c=0;const p=(g,m,y,v,M,T,b,S,C,w)=>{const R=T/C,E=b/w,z=T/2,$=b/2,D=S/2,J=C+1,Q=w+1;let H=0;const O=new f;for(let q=0;q<Q;q++){const N=q*E-$;for(let Z=0;Z<J;Z++){const te=Z*R-z;O[g]=te*v,O[m]=N*M,O[y]=D,h.push(O.x,O.y,O.z),O[g]=0,O[m]=0,O[y]=S>0?1:-1,u.push(O.x,O.y,O.z),l.push(Z/C),l.push(q/w),H+=1}}for(let q=0;q<w;q++)for(let N=0;N<C;N++){const Z=c+N+J*q,te=c+N+J*(q+1),be=c+(N+1)+J*(q+1),Ci=c+(N+1)+J*q;d.push(Z,te,Ci),d.push(te,be,Ci),c+=H}};p("z","y","x",-1,-1,2,2,2,a,o),p("z","y","x",1,-1,2,2,-2,a,o),p("x","z","y",1,1,2,2,2,r,a),p("x","z","y",1,-1,2,2,-2,r,a),p("x","y","z",1,-1,2,2,2,r,o),p("x","y","z",-1,-1,2,2,-2,r,o),this.setAttribute({name:"position",type:"vec3f",bufferFormat:"float32x3",size:3,array:new Float32Array(h)}),this.setAttribute({name:"uv",type:"vec2f",bufferFormat:"float32x2",size:2,array:new Float32Array(l)}),this.setAttribute({name:"normal",type:"vec3f",bufferFormat:"float32x3",size:3,array:new Float32Array(u)}),this.setIndexBuffer({array:this.useUint16IndexArray?new Uint16Array(d):new Uint32Array(d),bufferFormat:this.useUint16IndexArray?"uint16":"uint32"})}}class Ao extends nt{constructor({topology:e,instancesCount:t=1,vertexBuffers:i=[],mapBuffersAtCreation:s=!0,widthSegments:r=32,heightSegments:o=16,phiStart:a=0,phiLength:h=Math.PI*2,thetaStart:l=0,thetaLength:u=Math.PI}={}){super({verticesOrder:"ccw",topology:e,instancesCount:t,vertexBuffers:i,mapBuffersAtCreation:s}),this.type="SphereGeometry",r=Math.max(3,Math.floor(r)),o=Math.max(2,Math.floor(o));const d=1,c=Math.min(l+u,Math.PI);let p=0;const g=[],m=new f,y=new f,v=[],M=[],T=[],b=[];for(let S=0;S<=o;S++){const C=[],w=S/o;let R=0;S===0&&l===0?R=.5/r:S===o&&c===Math.PI&&(R=-.5/r);for(let E=0;E<=r;E++){const z=E/r;m.x=-d*Math.cos(a+z*h)*Math.sin(l+w*u),m.y=d*Math.cos(l+w*u),m.z=d*Math.sin(a+z*h)*Math.sin(l+w*u),M.push(m.x,m.y,m.z),y.copy(m).normalize(),T.push(y.x,y.y,y.z),b.push(z+R,w),C.push(p++)}g.push(C)}for(let S=0;S<o;S++)for(let C=0;C<r;C++){const w=g[S][C+1],R=g[S][C],E=g[S+1][C],z=g[S+1][C+1];(S!==0||l>0)&&v.push(w,R,z),(S!==o-1||c<Math.PI)&&v.push(R,E,z)}this.setAttribute({name:"position",type:"vec3f",bufferFormat:"float32x3",size:3,array:new Float32Array(M)}),this.setAttribute({name:"uv",type:"vec2f",bufferFormat:"float32x2",size:2,array:new Float32Array(b)}),this.setAttribute({name:"normal",type:"vec3f",bufferFormat:"float32x3",size:3,array:new Float32Array(T)}),this.setIndexBuffer({array:this.useUint16IndexArray?new Uint16Array(v):new Uint32Array(v),bufferFormat:this.useUint16IndexArray?"uint16":"uint32"})}}class Oo extends Hi{constructor(e,t={}){e=W(e,t.label?t.label+" PingPongPlane":"PingPongPlane");const i=t.targets&&t.targets.length&&t.targets.map(s=>({targetFormat:s.format}));t.outputTarget=new Ui(e,{label:t.label?t.label+" render target":"Ping Pong render target",useDepth:!1,...i&&{colorAttachments:i}}),t.transparent=!1,t.depth=!1,t.label=t.label??"PingPongPlane "+e.pingPongPlanes?.length,super(e,t),this.type="PingPongPlane",this.createTexture({label:t.label?`${t.label} render texture`:"PingPongPlane render texture",name:"renderTexture",...t.targets&&t.targets.length&&{format:t.targets[0].format},usage:["copyDst","textureBinding"]})}get renderTexture(){return this.textures.find(e=>e.options.name==="renderTexture")}addToScene(e=!1){e&&this.renderer.pingPongPlanes.push(this),this.autoRender&&this.renderer.scene.addPingPongPlane(this)}removeFromScene(e=!1){this.outputTarget&&this.outputTarget.destroy(),this.autoRender&&this.renderer.scene.removePingPongPlane(this),e&&(this.renderer.pingPongPlanes=this.renderer.pingPongPlanes.filter(t=>t.uuid!==this.uuid))}}var Rs=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},P=(n,e,t)=>(Rs(n,e,"read from private field"),t?t.call(n):e.get(n)),ae=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},de=(n,e,t,i)=>(Rs(n,e,"write to private field"),i?i.call(n,t):e.set(n,t),t),Go=(n,e,t)=>(Rs(n,e,"access private method"),t),me,Ce,Qe,et,ge,ye,wt,bt,Bt,Mt,Ct,St,zs,un;class Do{constructor(e){ae(this,zs),ae(this,me,void 0),ae(this,Ce,void 0),ae(this,Qe,void 0),ae(this,et,void 0),ae(this,ge,void 0),ae(this,ye,void 0),ae(this,wt,void 0),ae(this,bt,void 0),ae(this,Bt,void 0),ae(this,Mt,void 0),ae(this,Ct,void 0),ae(this,St,void 0),this.type="Raycaster",e=Le(e,this.type),this.renderer=e,this.camera=this.renderer.camera,this.pointer=new _(1/0),this.ray={origin:new f,direction:new f},de(this,me,{origin:this.ray.origin.clone(),direction:this.ray.direction.clone()}),de(this,Ce,new f),de(this,Qe,new f),de(this,et,new f),de(this,ge,new f),de(this,ye,new f),de(this,wt,new _),de(this,bt,new _),de(this,Bt,new _),de(this,Mt,new f),de(this,Ct,new f),de(this,St,new f)}setFromMouse(e){const{clientX:t,clientY:i}=e.targetTouches&&e.targetTouches.length?e.targetTouches[0]:e;this.setFromNDCCoords((t-this.renderer.boundingRect.left)/this.renderer.boundingRect.width*2-1,-((i-this.renderer.boundingRect.top)/this.renderer.boundingRect.height)*2+1)}setFromNDCCoords(e=0,t=0){this.pointer.set(e,t),this.setRay()}setRay(){this.camera.worldMatrix.getTranslation(this.ray.origin),this.ray.direction.set(this.pointer.x,this.pointer.y,-1).unproject(this.camera).sub(this.ray.origin).normalize()}rayIntersectsTriangle(e){const i=new f,s=new f;i.crossVectors(P(this,me).direction,P(this,ye));const r=P(this,ge).dot(i);if(Math.abs(r)<1e-6)return!1;const o=1/r,a=P(this,me).origin.clone().sub(P(this,Ce)),h=o*a.dot(i);if(h<0||h>1)return!1;s.crossVectors(a,P(this,ge));const l=o*P(this,me).direction.dot(s);if(l<0||h+l>1)return!1;const u=o*P(this,ye).dot(s);return u>1e-6?(e.copy(P(this,me).origin).add(P(this,me).direction.clone().multiplyScalar(u)),!0):!1}getBarycentricCoordinates(e){const t=e.clone().sub(P(this,Ce)),i=P(this,ge).dot(P(this,ge)),s=P(this,ge).dot(P(this,ye)),r=P(this,ye).dot(P(this,ye)),o=t.dot(P(this,ge)),a=t.dot(P(this,ye)),h=i*r-s*s,l=new f(0,(r*o-s*a)/h,(i*a-s*o)/h);return l.x=1-l.y-l.z,l}getTriangleNormal(){return new f().crossVectors(P(this,ge),P(this,ye)).normalize()}setAttributeVectorAtIndex(e,t,i,s,r){const o=i?i[e*3+t]:e*3+t;r.x=s.array[o*s.size],r.y=s.array[o*s.size+1],"z"in r&&(r.z=s.array[o*s.size+2])}intersectObject(e,t=!0,i=[]){if(!(e instanceof xe))return this.renderer.production||L(`${this.type}: object to test intersection again is not of type Object3D`),i;const s=vn(e);return s&&Go(this,zs,un).call(this,s,i),t&&e.children.forEach(r=>{this.intersectObject(r,t,i)}),i.length&&i.sort((r,o)=>this.ray.origin.distance(r.point)-this.ray.origin.distance(o.point)),i}intersectObjects(e,t=!0,i=[]){return e.forEach(s=>{this.intersectObject(s,t,i)}),i.length&&i.sort((s,r)=>this.ray.origin.distance(s.point)-this.ray.origin.distance(r.point)),i}}me=new WeakMap,Ce=new WeakMap,Qe=new WeakMap,et=new WeakMap,ge=new WeakMap,ye=new WeakMap,wt=new WeakMap,bt=new WeakMap,Bt=new WeakMap,Mt=new WeakMap,Ct=new WeakMap,St=new WeakMap,zs=new WeakSet,un=function(n,e=[]){if(!n.geometry)return e;const t=n.geometry.getAttributeByName("position");if(!t)return this.renderer.production||L(`Raycaster: can't raycast on a mesh that has no position attribute: ${n.options.label}`),e;if(!t.array)return this.renderer.production||L(`Raycaster: can't raycast on a mesh that has no position attribute array: ${n.options.label}`),e;if(n.frustumCulling&&n.domFrustum){const{clipSpaceBoundingRect:h}=n.domFrustum;if(n.domFrustum.isIntersecting){if(this.pointer.x>h.left+h.width||this.pointer.x<h.left||this.pointer.y>h.top||this.pointer.y<h.top-h.height)return e}else return e}const i=n.worldMatrix.getInverse();P(this,me).origin.copy(this.ray.origin).applyMat4(i),P(this,me).direction.copy(this.ray.direction).transformDirection(i);const s=n.geometry.getAttributeByName("uv"),r=n.geometry.getAttributeByName("normal"),o=n.geometry.indexBuffer?.array,a=o?o.length/3:t.array.length/9;for(let h=0;h<a;h++){if(this.setAttributeVectorAtIndex(h,0,o,t,P(this,Ce)),this.setAttributeVectorAtIndex(h,1,o,t,P(this,Qe)),this.setAttributeVectorAtIndex(h,2,o,t,P(this,et)),P(this,ge).copy(P(this,Qe)).sub(P(this,Ce)),P(this,ye).copy(P(this,et)).sub(P(this,Ce)),n.material.options.rendering.cullMode!=="none"){const c=this.getTriangleNormal().dot(P(this,me).direction);if(c>0&&n.material.options.rendering.cullMode==="back")continue;if(c<0&&n.material.options.rendering.cullMode==="front")continue}const l=new f;if(this.rayIntersectsTriangle(l)){const d=this.getBarycentricCoordinates(l),c=l.clone().applyMat4(n.worldMatrix),p=this.ray.origin.distance(c),g={object:n,distance:p,localPoint:l,point:c,triangle:[P(this,Ce).clone(),P(this,Qe).clone(),P(this,et).clone()],triangleIndex:h};s&&s.array&&s.array.length&&(this.setAttributeVectorAtIndex(h,0,o,s,P(this,wt)),this.setAttributeVectorAtIndex(h,1,o,s,P(this,bt)),this.setAttributeVectorAtIndex(h,2,o,s,P(this,Bt)),g.uv=P(this,wt).clone().multiplyScalar(d.x).add(P(this,bt).clone().multiplyScalar(d.y)).add(P(this,Bt).clone().multiplyScalar(d.z))),r&&r.array&&r.array.length&&(this.setAttributeVectorAtIndex(h,0,o,r,P(this,Mt)),this.setAttributeVectorAtIndex(h,1,o,r,P(this,Ct)),this.setAttributeVectorAtIndex(h,2,o,r,P(this,St)),g.normal=P(this,Mt).clone().multiplyScalar(d.x).add(P(this,Ct).clone().multiplyScalar(d.y)).add(P(this,St).clone().multiplyScalar(d.z))),e.push(g)}}return e};var dn=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},Es=(n,e,t)=>(dn(n,e,"read from private field"),t?t.call(n):e.get(n)),Fo=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},$o=(n,e,t,i)=>(dn(n,e,"write to private field"),i?i.call(n,t):e.set(n,t),t),tt;const X=WebGLRenderingContext,vi=new G,Uo=class Pe{constructor({renderer:e,gltf:t}){Fo(this,tt,void 0),e=Le(e,"GLTFScenesManager"),this.renderer=e,this.gltf=t,$o(this,tt,new Map);const i=s=>[s.node,...s.children?.map(r=>[...i(r)]).flat()].flat();this.scenesManager={node:new xe,boundingBox:new ve,samplers:[],materialsTextures:[],scenes:[],meshes:[],meshesDescriptors:[],getScenesNodes:()=>this.scenesManager.scenes.map(s=>i(s)).flat()},this.createSamplers(),this.createMaterialTextures(),this.createScenes()}static getVertexAttributeParamsFromType(e){switch(e){case"VEC2":return{type:"vec2f",bufferFormat:"float32x2",size:2};case"VEC3":return{type:"vec3f",bufferFormat:"float32x3",size:3};case"VEC4":return{type:"vec4f",bufferFormat:"float32x4",size:4};case"SCALAR":default:return{type:"f32",bufferFormat:"float32",size:1}}}static getTypedArrayConstructorFromComponentType(e){switch(e){case X.BYTE:return Int8Array;case X.UNSIGNED_BYTE:return Uint8Array;case X.SHORT:return Int16Array;case X.UNSIGNED_SHORT:return Uint16Array;case X.UNSIGNED_INT:return Uint32Array;case X.FLOAT:default:return Float32Array}}static gpuPrimitiveTopologyForMode(e){switch(e){case X.TRIANGLES:return"triangle-list";case X.TRIANGLE_STRIP:return"triangle-strip";case X.LINES:return"line-list";case X.LINE_STRIP:return"line-strip";case X.POINTS:return"point-list"}}static gpuAddressModeForWrap(e){switch(e){case X.CLAMP_TO_EDGE:return"clamp-to-edge";case X.MIRRORED_REPEAT:return"mirror-repeat";default:return"repeat"}}createSamplers(){if(this.gltf.samplers)for(const[e,t]of Object.entries(this.gltf.samplers)){const i={label:"glTF sampler "+e,name:"gltfSampler"+e,addressModeU:Pe.gpuAddressModeForWrap(t.wrapS),addressModeV:Pe.gpuAddressModeForWrap(t.wrapT)};switch((!t.magFilter||t.magFilter===X.LINEAR)&&(i.magFilter="linear"),t.minFilter){case X.NEAREST:break;case X.LINEAR:case X.LINEAR_MIPMAP_NEAREST:i.minFilter="linear";break;case X.NEAREST_MIPMAP_LINEAR:i.mipmapFilter="linear";break;case X.LINEAR_MIPMAP_LINEAR:default:i.minFilter="linear",i.mipmapFilter="linear";break}this.scenesManager.samplers.push(new Ve(this.renderer,i))}else this.scenesManager.samplers.push(new Ve(this.renderer,{label:"Default sampler",name:"defaultSampler",magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"}))}createTexture(e,t,i){const s=(()=>{switch(i){case"baseColorTexture":case"emissiveTexture":return"bgra8unorm-srgb";case"occlusionTexture":return"r8unorm";default:return"bgra8unorm"}})(),r=new re(this.renderer,{label:e.name?e.name+": "+i:i,name:i,format:s,visibility:["fragment"],generateMips:!0,fixedSize:{width:t.width,height:t.height}});return r.uploadSource({source:t}),r}createMaterialTextures(){if(this.scenesManager.materialsTextures=[],this.gltf.materials)for(const[e,t]of Object.entries(this.gltf.materials)){const i={material:e,texturesDescriptors:[]},s=r=>r.texCoord&&r.texCoord!==0?"uv"+r.texCoord:"uv";if(this.scenesManager.materialsTextures[e]=i,t.pbrMetallicRoughness){if(t.pbrMetallicRoughness.baseColorTexture&&t.pbrMetallicRoughness.baseColorTexture.index!==void 0){const r=t.pbrMetallicRoughness.baseColorTexture.index,o=this.gltf.imagesBitmaps[this.gltf.textures[r].source],a=this.createTexture(t,o,"baseColorTexture"),h=this.gltf.textures.find(l=>l.source===r)?.sampler;i.texturesDescriptors.push({texture:a,sampler:this.scenesManager.samplers[h??0],texCoordAttributeName:s(t.pbrMetallicRoughness.baseColorTexture)})}if(t.pbrMetallicRoughness.metallicRoughnessTexture&&t.pbrMetallicRoughness.metallicRoughnessTexture.index!==void 0){const r=t.pbrMetallicRoughness.metallicRoughnessTexture.index,o=this.gltf.imagesBitmaps[this.gltf.textures[r].source],a=this.createTexture(t,o,"metallicRoughnessTexture"),h=this.gltf.textures.find(l=>l.source===r)?.sampler;i.texturesDescriptors.push({texture:a,sampler:this.scenesManager.samplers[h??0],texCoordAttributeName:s(t.pbrMetallicRoughness.metallicRoughnessTexture)})}}if(t.normalTexture&&t.normalTexture.index!==void 0){const r=t.normalTexture.index,o=this.gltf.imagesBitmaps[this.gltf.textures[r].source],a=this.createTexture(t,o,"normalTexture"),h=this.gltf.textures.find(l=>l.source===r)?.sampler;i.texturesDescriptors.push({texture:a,sampler:this.scenesManager.samplers[h??0],texCoordAttributeName:s(t.normalTexture)})}if(t.occlusionTexture&&t.occlusionTexture.index!==void 0){const r=t.occlusionTexture.index,o=this.gltf.imagesBitmaps[this.gltf.textures[r].source],a=this.createTexture(t,o,"occlusionTexture"),h=this.gltf.textures.find(l=>l.source===r)?.sampler;i.texturesDescriptors.push({texture:a,sampler:this.scenesManager.samplers[h??0],texCoordAttributeName:s(t.occlusionTexture)})}if(t.emissiveTexture&&t.emissiveTexture.index!==void 0){const r=t.emissiveTexture.index,o=this.gltf.imagesBitmaps[this.gltf.textures[r].source],a=this.createTexture(t,o,"emissiveTexture"),h=this.gltf.textures.find(l=>l.source===r)?.sampler;i.texturesDescriptors.push({texture:a,sampler:this.scenesManager.samplers[h??0],texCoordAttributeName:s(t.emissiveTexture)})}}}createNode(e,t){if(t.camera!==void 0)return;const i={name:t.name,node:new xe,children:[]};e.children.push(i),i.node.parent=e.node,t.matrix?(i.node.modelMatrix.setFromArray(new Float32Array(t.matrix)),i.node.matrices.model.shouldUpdate=!1):(t.translation&&i.node.position.set(t.translation[0],t.translation[1],t.translation[2]),t.scale&&i.node.scale.set(t.scale[0],t.scale[1],t.scale[2]),t.rotation&&i.node.quaternion.setFromArray(new Float32Array(t.rotation)));const s=this.gltf.meshes[t.mesh];t.children&&t.children.forEach(r=>{const o=this.gltf.nodes[r];this.createNode(i,o)}),s&&s.primitives.forEach((r,o)=>{const a={parent:i.node,attributes:[],textures:[],parameters:{label:s.name?s.name+" "+o:"glTF mesh "+o},nodes:[]};let h=Es(this,tt).get(r);h||(h={instances:[],nodes:[],meshDescriptor:a},Es(this,tt).set(r,h)),h.instances.push(t),h.nodes.push(i.node)})}createScenes(){this.scenesManager.node.parent=this.renderer.scene,this.gltf.scenes.forEach(e=>{const t={name:e.name,children:[],node:new xe};t.node.parent=this.scenesManager.node,this.scenesManager.scenes.push(t),e.nodes.forEach(i=>{const s=this.gltf.nodes[i];this.createNode(t,s)})}),this.scenesManager.node.updateMatrixStack();for(const[e,t]of Es(this,tt)){const{instances:i,nodes:s,meshDescriptor:r}=t,o=i.length;r.nodes=s,this.scenesManager.meshesDescriptors.push(r);const a=new ve,h=[];let l=null,u=null,d=0;for(const[M,T]of Object.entries(e.attributes)){const b=this.gltf.accessors[T],S=Pe.getTypedArrayConstructorFromComponentType(b.componentType),C=this.gltf.bufferViews[b.bufferView],w=M==="TEXCOORD_0"?"uv":M.replace("_","").replace("TEXCOORD","uv").toLowerCase(),R=C.byteStride||0,E=b.byteOffset||0;R&&E&&E<R?d=Math.max(E,d):d=0,w==="position"&&(a.min.min(new f(b.min[0],b.min[1],b.min[2])),a.max.max(new f(b.max[0],b.max[1],b.max[2])),u=C);const z=Pe.getVertexAttributeParamsFromType(b.type),$={name:w,...z,array:new S(this.gltf.arrayBuffers[C.buffer],b.byteOffset+C.byteOffset,b.count*z.size)};h.push($),r.attributes.push({name:$.name,type:$.type})}if(d>0){const M=Object.values(e.attributes).map(T=>this.gltf.accessors[T].bufferView);if(M.every(T=>T===M[0]))l=new Float32Array(this.gltf.arrayBuffers[u.buffer],u.byteOffset,Math.ceil(u.byteLength/4)*4/Float32Array.BYTES_PER_ELEMENT);else{let T=0;const b={},S=Object.values(e.attributes).reduce((C,w)=>{const R=this.gltf.accessors[w],E=Pe.getVertexAttributeParamsFromType(R.type).size;return b[R.bufferView]||(b[R.bufferView]=0),b[R.bufferView]=Math.max(b[R.bufferView],R.byteOffset+E*Float32Array.BYTES_PER_ELEMENT),T+=E*Float32Array.BYTES_PER_ELEMENT,C+R.count*E},0);l=new Float32Array(Math.ceil(S/4)*4),Object.values(e.attributes).forEach(C=>{const w=this.gltf.accessors[C],R=this.gltf.bufferViews[w.bufferView],E=Pe.getVertexAttributeParamsFromType(w.type).size;for(let z=0;z<w.count;z++){const $=w.byteOffset/Float32Array.BYTES_PER_ELEMENT+z*T/Float32Array.BYTES_PER_ELEMENT;l.subarray($,$+E).set(new Float32Array(this.gltf.arrayBuffers[R.buffer],R.byteOffset+w.byteOffset+z*b[w.bufferView],E))}})}}else{const M=["position","uv","normal"];h.sort((T,b)=>{let S=M.findIndex(w=>w===T.name);S=S===-1?1/0:S;let C=M.findIndex(w=>w===b.name);return C=C===-1?1/0:C,S-C})}const c={instancesCount:o,topology:Pe.gpuPrimitiveTopologyForMode(e.mode),vertexBuffers:[{name:"attributes",stepMode:"vertex",attributes:h,...l&&{array:l}}]},p="indices"in e,g=p?nt:Di;if(r.parameters.geometry=new g(c),r.parameters.geometry.boundingBox=a,p){const M=this.gltf.accessors[e.indices],T=this.gltf.bufferViews[M.bufferView],b=Pe.getTypedArrayConstructorFromComponentType(M.componentType),S=M.byteOffset+T.byteOffset,C=this.gltf.arrayBuffers[T.buffer],w=Math.min((C.byteLength-S)/b.BYTES_PER_ELEMENT,Math.ceil(M.count/4)*4),R=b.name==="Uint8Array"?Uint16Array.from(new b(C,S,w)):new b(C,S,w);r.parameters.geometry.setIndexBuffer({bufferFormat:b.name==="Uint32Array"?"uint32":"uint16",array:R})}const m=this.scenesManager.materialsTextures[e.material];r.parameters.samplers=[],r.parameters.textures=[],m?.texturesDescriptors.forEach(M=>{r.textures.push({texture:M.texture.options.name,sampler:M.sampler.name,texCoordAttributeName:M.texCoordAttributeName}),r.parameters.samplers.find(b=>b.uuid===M.sampler.uuid)||r.parameters.samplers.push(M.sampler),r.parameters.textures.push(M.texture)});const y=this.gltf.materials&&this.gltf.materials[e.material]||{};r.parameters.cullMode=y.doubleSided?"none":"back",(y.alphaMode==="BLEND"||y.extensions&&y.extensions.KHR_materials_transmission)&&(r.parameters.transparent=!0,r.parameters.targets=[{blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one"}}}]);const v={baseColorFactor:{type:"vec4f",value:y.pbrMetallicRoughness?.baseColorFactor||[1,1,1,1]},alphaCutoff:{type:"f32",value:y.alphaCutoff!==void 0?y.alphaCutoff:y.alphaMode==="MASK"?.5:0},metallicFactor:{type:"f32",value:y.pbrMetallicRoughness?.metallicFactor===void 0?1:y.pbrMetallicRoughness.metallicFactor},roughnessFactor:{type:"f32",value:y.pbrMetallicRoughness?.roughnessFactor===void 0?1:y.pbrMetallicRoughness.roughnessFactor},normalMapScale:{type:"f32",value:y.normalTexture?.scale===void 0?1:y.normalTexture.scale},occlusionStrength:{type:"f32",value:y.occlusionTexture?.strength===void 0?1:y.occlusionTexture.strength},emissiveFactor:{type:"vec3f",value:y.emissiveFactor!==void 0?y.emissiveFactor:[1,1,1]}};if(Object.keys(v).length&&(r.parameters.uniforms={material:{visibility:["vertex","fragment"],struct:v}}),o>1){const M=new Float32Array(o*16),T=new Float32Array(o*16);for(let b=0;b<o;++b)M.set(s[b].worldMatrix.elements,b*16),vi.copy(s[b].worldMatrix).invert().transpose(),T.set(vi.elements,b*16);r.parameters.storages={instances:{visibility:["vertex","fragment"],struct:{modelMatrix:{type:"array<mat4x4f>",value:M},normalMatrix:{type:"array<mat4x4f>",value:T}}}}}for(let M=0;M<s.length;M++){const b=a.clone().applyMat4(r.nodes[M].worldMatrix);this.scenesManager.boundingBox.min.min(b.min),this.scenesManager.boundingBox.max.max(b.max)}}}addMeshes(e=t=>{}){return this.scenesManager.node.updateMatrixStack(),this.scenesManager.meshesDescriptors.map(t=>{if(t.parameters.geometry){e(t);const i=t.parameters.geometry.instancesCount>1&&t.parameters.castShadows;i&&(t.parameters.castShadows=!1);const s=new Gr(this.renderer,{...t.parameters});if(t.nodes.length>1){const r=s.updateWorldMatrix.bind(s);s.updateWorldMatrix=()=>{r(),t.nodes.forEach((o,a)=>{s.storages.instances.modelMatrix.value.set(o.worldMatrix.elements,a*16),vi.copy(o.worldMatrix).invert().transpose(),s.storages.instances.normalMatrix.value.set(vi.elements,a*16)}),s.storages.instances.modelMatrix.shouldUpdate=!0,s.storages.instances.normalMatrix.shouldUpdate=!0}}if(i){const r=s.material.inputsBindings.get("instances");this.renderer.shadowCastingLights.forEach(o=>{o.shadow.isActive&&o.shadow.addShadowCastingMesh(s,{bindings:[r]})})}return s.parent=t.parent,this.scenesManager.meshes.push(s),s}})}destroy(){this.scenesManager.meshes.forEach(t=>t.remove()),this.scenesManager.meshes=[],this.scenesManager.getScenesNodes().forEach(t=>{t.destroy()}),this.scenesManager.node.destroy()}};tt=new WeakMap;let ko=Uo;const Io=(n,e={})=>{const t=n.textures.find(F=>F.texture==="baseColorTexture"),i=n.textures.find(F=>F.texture==="normalTexture"),s=n.textures.find(F=>F.texture==="emissiveTexture"),r=n.textures.find(F=>F.texture==="occlusionTexture"),o=n.textures.find(F=>F.texture==="metallicRoughnessTexture"),a=n.attributes.filter(F=>F.name!=="position"),h=a.map((F,Qo)=>`@location(${Qo}) ${F.name}: ${F.type},`).join(`
	`);let l=`
    let worldPos = matrices.model * vec4(attributes.position, 1.0);
    vsOutput.position = camera.projection * camera.view * worldPos;
    vsOutput.worldPosition = worldPos.xyz / worldPos.w;
    vsOutput.viewDirection = camera.position - vsOutput.worldPosition.xyz;
  `,u=a.find(F=>F.name==="normal")?"vsOutput.normal = getWorldNormal(attributes.normal);":"";n.parameters.storages&&n.parameters.storages.instances&&(l=`
      let worldPos: vec4f = instances[attributes.instanceIndex].modelMatrix * vec4f(attributes.position, 1.0);
      vsOutput.position = camera.projection * camera.view * worldPos;
      vsOutput.worldPosition = worldPos.xyz;
      vsOutput.viewDirection = camera.position - vsOutput.worldPosition;
      `,u="vsOutput.normal = normalize((instances[attributes.instanceIndex].normalMatrix * vec4(attributes.normal, 0.0)).xyz);");const d=a.filter(F=>F.name!=="normal").map(F=>`vsOutput.${F.name} = attributes.${F.name};`).join(`
	`);let c=`
      @builtin(position) position: vec4f,
      @location(${a.length}) viewDirection: vec3f,
      @location(${a.length+1}) worldPosition: vec3f,
      ${h}
  `,p="";const g=a.find(F=>F.name==="tangent"),m=!!(i&&g);m&&(c+=`
      @location(${a.length+2}) bitangent: vec3f,
      `,p=`
        vsOutput.tangent = normalize(matrices.model * attributes.tangent);
        vsOutput.bitangent = cross(vsOutput.normal, vsOutput.tangent.xyz) * attributes.tangent.w;
      `);const y=`
    struct VSOutput {
      ${c}
    };`,v=`
    struct VSOutput {
      @builtin(front_facing) frontFacing: bool,
      ${c}
    };`,M=`
    ${y}
    
    @vertex fn main(
      attributes: Attributes,
    ) -> VSOutput {
      var vsOutput: VSOutput;
    
      ${l}
      ${u}
      ${d}
      
      ${p}

      return vsOutput;
    }
  `,T="var color: vec4f = vec4();",b=`
      return color;
  `,S=n.attributes.find(F=>F.name==="color0");let C=S?S.type==="vec3f"?"var baseColor: vec4f = vec4(fsInput.color0, 1.0) * material.baseColorFactor;":"var baseColor: vec4f = fsInput.color0 * material.baseColorFactor;":"var baseColor: vec4f = material.baseColorFactor;";t&&(C=`
      var baseColor: vec4f = textureSample(baseColorTexture, ${t.sampler}, fsInput.${t.texCoordAttributeName}) * material.baseColorFactor;
      
      if (baseColor.a < material.alphaCutoff) {
        discard;
      }
    `),C+=`
      color = baseColor;
  `;let w=n.attributes.find(F=>F.name==="normal")?`
      let faceDirection = select(-1.0, 1.0, fsInput.frontFacing);
      let geometryNormal: vec3f = normalize(faceDirection * fsInput.normal);
    `:"let geometryNormal: vec3f = normalize(vec3(0.0, 0.0, 1.0));";m?w+=`
      let tbn = mat3x3<f32>(normalize(fsInput.tangent.xyz), normalize(fsInput.bitangent), geometryNormal);
      let normalMap = textureSample(normalTexture, ${i.sampler}, fsInput.${i.texCoordAttributeName}).rgb;
      let normal = normalize(tbn * (2.0 * normalMap - vec3(material.normalMapScale, material.normalMapScale, 1.0)));
    `:w+=`
      let normal = geometryNormal;
    `;let R=`
      var metallic = material.metallicFactor;
      var roughness = material.roughnessFactor;
  `;o&&(R+=`
      let metallicRoughness = textureSample(metallicRoughnessTexture, ${o.sampler}, fsInput.${o.texCoordAttributeName});
      
      metallic = clamp(metallic * metallicRoughness.b, 0.0, 1.0);
      roughness = clamp(roughness * metallicRoughness.g, 0.0, 1.0);
    `);const E=`
      let f0: vec3f = mix(vec3(0.04), color.rgb, vec3(metallic));
  `;let z=`
      var emissive: vec3f = vec3(0.0);
      var occlusion: f32 = 1.0;
  `;s&&(z+=`
      emissive = textureSample(emissiveTexture, ${s.sampler}, fsInput.${s.texCoordAttributeName}).rgb;
      
      emissive *= material.emissiveFactor;
      `,r&&(z+=`
      occlusion = textureSample(occlusionTexture, ${r.sampler}, fsInput.${r.texCoordAttributeName}).r;
      `)),z+=`
      occlusion = 1.0 + material.occlusionStrength * (occlusion - 1.0);
  `;let{shadingModel:$}=e;$||($="PBR");let{chunks:D}=e||{};const{iblParameters:J}=e||{},{lutTexture:Q,envDiffuseTexture:H,envSpecularTexture:O}=J||{};H&&H.texture&&O&&O.texture&&Q&&Q.texture&&$==="IBL"?(n.parameters.uniforms={...n.parameters.uniforms,ibl:{struct:{diffuseStrength:{type:"f32",value:J?.diffuseStrength??.5},specularStrength:{type:"f32",value:J?.specularStrength??.5}}}},n.parameters.textures=[...n.parameters.textures,Q.texture,H.texture,O.texture],Q.samplerName=Q.samplerName||"defaultSampler",H.samplerName=H.samplerName||"defaultSampler",O.samplerName=O.samplerName||"defaultSampler"):$==="IBL"&&(L("IBL shading requested but one of the LUT, environment specular or diffuse texture is missing. Defaulting to PBR shading."),$="PBR");const N={toneMapping:"khronos",receiveShadows:!!n.parameters.receiveShadows,useOcclusion:!0},Z=(()=>{switch($){case"Lambert":default:return Xr(N);case"Phong":return Zr(N);case"PBR":return Kr(N);case"IBL":return Qr(N)}})(),te="",be="";D?(D.additionalFragmentHead?D.additionalFragmentHead=Z+D.additionalFragmentHead:D.additionalFragmentHead=Z,D.preliminaryColorContribution?D.preliminaryColorContribution=te+D.preliminaryColorContribution:D.preliminaryColorContribution=te,D.additionalColorContribution?D.additionalColorContribution=be+D.additionalColorContribution:D.additionalColorContribution=be):D={additionalFragmentHead:Z,preliminaryColorContribution:te,additionalColorContribution:be};const Ci=(()=>{switch($){case"Lambert":default:return`
      color = vec4(
        getLambert(
          normal,
          worldPosition,
          color.rgb,
          occlusion
        ),
        color.a
      );`;case"Phong":return`
      color = vec4(
        getPhong(
          normal,
          worldPosition,
          color.rgb,
          viewDirection,
          f0, // specular color
          metallic * (1.0 - roughness) + (1.0 - metallic) * 0.04, // specular strength
          (1.0 - roughness) * 30.0, // TODO shininess
          occlusion
        ),
        color.a
      );`;case"PBR":return`
      color = vec4(
        getPBR(
          normal,
          worldPosition,
          color.rgb,
          viewDirection,
          f0,
          metallic,
          roughness,
          occlusion
        ),
        color.a
      );`;case"IBL":return`
      color = vec4(
        getIBL(
          normal,
          worldPosition,
          color.rgb,
          viewDirection,
          f0,
          metallic,
          roughness,
          ${Q.texture.options.name},
          ${Q.samplerName},
          ${O.texture.options.name},
          ${O.samplerName},
          ${H.texture.options.name},
          ${H.samplerName},
          occlusion
        ),
        color.a
      );`}})(),Jo=`  
    ${D.additionalFragmentHead}
  
    ${v}
  
    @fragment fn main(fsInput: VSOutput) -> @location(0) vec4f {       
      ${T}
      ${C}
      
      let worldPosition: vec3f = fsInput.worldPosition;
      let viewDirection: vec3f = fsInput.viewDirection;

      ${w}
      ${R}  
      
      // user defined preliminary color contribution
      ${D.preliminaryColorContribution}
        
      ${E}
      ${z}
      
      ${Ci}
      
    color = vec4(color.rgb + emissive, color.a);
  
      
      // user defined additional color contribution
      ${D.additionalColorContribution}
      
      ${b}
    }
  `;return{vertex:{code:M,entryPoint:"main"},fragment:{code:Jo,entryPoint:"main"}}},Vo=async(n,e,t)=>{if(t.options.viewDimension!=="cube"){L("Could not compute the diffuse texture because the specular texture is not a cube map:"+t.options.viewDimension);return}const i=`    
    fn radicalInverse_VdC(inputBits: u32) -> f32 {
        var bits: u32 = inputBits;
        bits = (bits << 16u) | (bits >> 16u);
        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
        return f32(bits) * 2.3283064365386963e-10; // / 0x100000000
    }
    
    // hammersley2d describes a sequence of points in the 2d unit square [0,1)^2
    // that can be used for quasi Monte Carlo integration
    fn hammersley2d(i: u32, N: u32) -> vec2f {
        return vec2(f32(i) / f32(N), radicalInverse_VdC(i));
    }
    
    // TBN generates a tangent bitangent normal coordinate frame from the normal
    // (the normal must be normalized)
    fn generateTBN(normal: vec3f) -> mat3x3f {
      var bitangent: vec3f = vec3(0.0, 1.0, 0.0);
  
      let NdotUp: f32 = dot(normal, vec3(0.0, 1.0, 0.0));
      let epsilon: f32 = 0.0000001;
      
      if (1.0 - abs(NdotUp) <= epsilon) {
        // Sampling +Y or -Y, so we need a more robust bitangent.
        if (NdotUp > 0.0) {
          bitangent = vec3(0.0, 0.0, 1.0);
        }
        else {
          bitangent = vec3(0.0, 0.0, -1.0);
        }
      }
  
      let tangent: vec3f = normalize(cross(bitangent, normal));
      bitangent = cross(normal, tangent);
  
      return mat3x3f(tangent, bitangent, normal);
    }
    
    // Mipmap Filtered Samples (GPU Gems 3, 20.4)
    // https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling
    // https://cgg.mff.cuni.cz/~jaroslav/papers/2007-sketch-fis/Final_sap_0073.pdf
    fn computeLod(pdf: f32) -> f32 {
      // https://cgg.mff.cuni.cz/~jaroslav/papers/2007-sketch-fis/Final_sap_0073.pdf
      return 0.5 * log2( 6.0 * f32(params.faceSize) * f32(params.faceSize) / (f32(params.sampleCount) * pdf));
    }
    
    fn transformDirection(face: u32, uv: vec2f) -> vec3f {
      // Transform the direction based on the cubemap face
      switch (face) {
        case 0u {
          // +X
          return vec3f( 1.0,  uv.y, -uv.x);
        }
        case 1u {
          // -X
          return vec3f(-1.0,  uv.y,  uv.x);
        }
        case 2u {
          // +Y
          return vec3f( uv.x,  -1.0, uv.y);
        }
        case 3u {
          // -Y
          return vec3f( uv.x, 1.0,  -uv.y);
        }
        case 4u {
          // +Z
          return vec3f( uv.x,  uv.y,  1.0);
        }
        case 5u {
          // -Z
          return vec3f(-uv.x,  uv.y, -1.0);
        }
        default {
          return vec3f(0.0, 0.0, 0.0);
        }
      }
    }
    
    const PI = ${Math.PI};

    @compute @workgroup_size(8, 8, 1) fn main(
      @builtin(global_invocation_id) GlobalInvocationID: vec3u,
    ) {
      let faceSize: u32 = params.faceSize;
      let sampleCount: u32 = params.sampleCount;
      
      let face: u32 = GlobalInvocationID.z;
      let x: u32 = GlobalInvocationID.x;
      let y: u32 = GlobalInvocationID.y;
  
      if (x >= faceSize || y >= faceSize) {
          return;
      }
  
      let texelSize: f32 = 1.0 / f32(faceSize);
      let halfTexel: f32 = texelSize * 0.5;
      
      var uv: vec2f = vec2(
        (f32(x) + halfTexel) * texelSize,
        (f32(y) + halfTexel) * texelSize
      );
      
      uv = uv * 2.0 - 1.0;
  
      let normal: vec3<f32> = transformDirection(face, uv);
      
      var irradiance: vec3f = vec3f(0.0, 0.0, 0.0);
  
      for (var i: u32 = 0; i < sampleCount; i++) {
        // generate a quasi monte carlo point in the unit square [0.1)^2
        let xi: vec2f = hammersley2d(i, sampleCount);
        
        let cosTheta: f32 = sqrt(1.0 - xi.y);
        let sinTheta: f32 = sqrt(1.0 - cosTheta * cosTheta);
        let phi: f32 = 2.0 * PI * xi.x;
        let pdf: f32 = cosTheta / PI; // evaluation for solid angle, therefore drop the sinTheta

        let sampleVec: vec3f = vec3f(
            sinTheta * cos(phi),
            sinTheta * sin(phi),
            cosTheta
        );
        
        let TBN: mat3x3f = generateTBN(normalize(normal));
        
        var direction: vec3f = TBN * sampleVec;
        
        // invert along Y axis
        direction.y *= -1.0;
        
        let lod: f32 = computeLod(pdf);

        // Convert sampleVec to texture coordinates of the specular env map
        irradiance += textureSampleLevel(
          envSpecularTexture,
          specularSampler,
          direction,
          min(lod, f32(params.maxMipLevel))
        ).rgb;
      }
  
      irradiance /= f32(sampleCount);

      textureStore(diffuseEnvMap, vec2(x, y), face, vec4f(irradiance, 1.0));
    }
  `;let s=new re(n,{label:"Diffuse storage cubemap",name:"diffuseEnvMap",format:"rgba32float",visibility:["compute"],usage:["copySrc","storageBinding"],type:"storage",fixedSize:{width:t.size.width,height:t.size.height,depth:6},viewDimension:"2d-array"});const r=new Ve(n,{label:"Compute diffuse sampler",name:"specularSampler",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",minFilter:"linear",magFilter:"linear"});let o=new Qs(n,{autoRender:!1,dispatchSize:[Math.ceil(t.size.width/8),Math.ceil(t.size.height/8),6],shaders:{compute:{code:i}},uniforms:{params:{struct:{faceSize:{type:"u32",value:t.size.width},maxMipLevel:{type:"u32",value:t.texture.mipLevelCount},sampleCount:{type:"u32",value:2048}}}},samplers:[r],textures:[t,s]});await o.material.compileMaterial(),n.onBeforeRenderScene.add(a=>{n.renderSingleComputePass(a,o),a.copyTextureToTexture({texture:s.texture},{texture:e.texture},[e.texture.width,e.texture.height,e.texture.depthOrArrayLayers])},{once:!0}),n.onAfterCommandEncoderSubmission.add(()=>{o.destroy(),s.destroy(),s=null,o=null},{once:!0})},cn=WebGLRenderingContext,No=1179937895,Ls={JSON:1313821514,BIN:5130562},Wo=[0,0,0],jo=[0,0,0,1],qo=[1,1,1],Yo=typeof window<"u"&&new RegExp(`^${window.location.protocol}`,"i")||RegExp("^(http|https):","i"),Xo=/^data:/;class wi{constructor(){this.gltf=null}static resolveUri(e,t){return e.match(Yo)||e.match(Xo)?e:t+e}async loadFromUrl(e){const t=e.lastIndexOf("/"),i=t!==0?e.substring(0,t+1):"",s=await fetch(e);if(e.endsWith(".gltf"))return this.loadFromJson(await s.json(),i);if(e.endsWith(".glb"))return this.loadFromBinary(await s.arrayBuffer(),i);throw new Error("Unrecognized file extension")}async loadFromJsonBase(e,t,i=null){if(!t)throw new Error("baseUrl must be specified.");if(!e.asset)throw new Error("Missing asset description.");if(e.asset.minVersion!=="2.0"&&e.asset.version!=="2.0")throw new Error("Incompatible asset version.");for(const o of e.accessors)o.byteOffset=o.byteOffset??0,o.normalized=o.normalized??!1;for(const o of e.bufferViews)o.byteOffset=o.byteOffset??0;for(const o of e.nodes)o.matrix||(o.rotation=o.rotation??jo,o.scale=o.scale??qo,o.translation=o.translation??Wo);if(e.samplers)for(const o of e.samplers)o.wrapS=o.wrapS??cn.REPEAT,o.wrapT=o.wrapT??cn.REPEAT;const s=[];if(i)s.push(Promise.resolve(i));else for(const o in e.buffers){const a=e.buffers[o],h=wi.resolveUri(a.uri,t);s[o]=fetch(h).then(l=>l.arrayBuffer())}const r=[];for(let o=0;o<e.images?.length;++o){const a=e.images[o];if(a.uri)r[o]=fetch(wi.resolveUri(a.uri,t)).then(async h=>createImageBitmap(await h.blob()));else{const h=e.bufferViews[a.bufferView];r[o]=s[h.buffer].then(l=>{const u=new Blob([new Uint8Array(l,h.byteOffset,h.byteLength)],{type:a.mimeType});return createImageBitmap(u)})}}return{...e,arrayBuffers:await Promise.all(s),imagesBitmaps:await Promise.all(r)}}async loadFromBinary(e,t){const i=new DataView(e,0,12),s=i.getUint32(0,!0),r=i.getUint32(4,!0),o=i.getUint32(8,!0);if(s!==No)throw new Error("Invalid magic string in binary header.");if(r!==2)throw new Error("Incompatible version in binary header.");const a={};let h=12;for(;h<o;){const d=new DataView(e,h,8),c=d.getUint32(0,!0),p=d.getUint32(4,!0);a[p]=e.slice(h+8,h+8+c),h+=c+8}if(!a[Ls.JSON])throw new Error("File contained no json chunk.");const u=new TextDecoder("utf-8").decode(a[Ls.JSON]);return this.loadFromJson(JSON.parse(u),t,a[Ls.BIN])}async loadFromJson(e,t,i=null){return this.gltf=await this.loadFromJsonBase(e,t,i),this.gltf}}var Ho=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},Se=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},he=(n,e,t)=>(Ho(n,e,"access private method"),t),_s,pn,As,fn,bi,Os,Pt,Bi,Gs,mn,Ds,gn,Mi,Fs,$s,yn,Us,xn;class Zo{constructor(){Se(this,_s),Se(this,As),Se(this,bi),Se(this,Pt),Se(this,Gs),Se(this,Ds),Se(this,Mi),Se(this,$s),Se(this,Us)}async loadFromUrl(e){const t=await(await fetch(e)).arrayBuffer();return he(this,_s,pn).call(this,new DataView(t))}equirectangularToCubeMap(e){const t=Math.max(e.width/4,e.height/2),i={posX:new Float32Array(t*t*4),negX:new Float32Array(t*t*4),posY:new Float32Array(t*t*4),negY:new Float32Array(t*t*4),posZ:new Float32Array(t*t*4),negZ:new Float32Array(t*t*4)};function s(l,u){const d=Math.floor(l*e.width),p=(Math.floor(u*e.height)*e.width+d)*4;return[e.data[p],e.data[p+1],e.data[p+2],e.data[p+3]]}function r(l,u,d,c){const p=(d*t+u)*4;i[l][p]=c[0],i[l][p+1]=c[1],i[l][p+2]=c[2],i[l][p+3]=c[3]}function o(l,u,d){const c=2*(u+.5)/t-1,p=2*(d+.5)/t-1;switch(l){case"posX":return[c,-1,-p];case"negX":return[-c,1,-p];case"posY":return[-p,-c,1];case"negY":return[p,-c,-1];case"posZ":return[-1,-c,-p];case"negZ":return[1,c,-p]}}function a(l){const[u,d,c]=l,p=Math.sqrt(u*u+d*d),g=Math.atan2(d,u),m=Math.atan2(c,p),y=(g+Math.PI)/(2*Math.PI),v=(m+Math.PI/2)/Math.PI;return[y,v]}for(const l in i)for(let u=0;u<t;u++)for(let d=0;d<t;d++){const c=o(l,d,u),[p,g]=a(c),m=s(p,g);r(l,d,u,m)}return[i.posX,i.negX,i.posY,i.negY,i.posZ,i.negZ].map(l=>({data:l,width:t,height:t,exposure:e.exposure,gamma:e.gamma}))}}_s=new WeakSet,pn=function(n){const e={data:n,offset:0},t=he(this,As,fn).call(this,e);return{width:t.width,height:t.height,exposure:t.exposure,gamma:t.gamma,data:he(this,Gs,mn).call(this,e,t)}},As=new WeakSet,fn=function(n){let e=he(this,Pt,Bi).call(this,n);const t={colorCorr:[1,1,1],exposure:1,gamma:1,width:0,height:0,flipX:!1,flipY:!1};if(e!=="#?RADIANCE"&&e!=="#?RGBE")throw new Error("Incorrect file format!");for(;e!=="";){e=he(this,Pt,Bi).call(this,n);const s=e.split("=");switch(s[0]){case"GAMMA":t.gamma=parseFloat(s[1]);break;case"FORMAT":if(s[1]!=="32-bit_rle_rgbe"&&s[1]!=="32-bit_rle_xyze")throw new Error("Incorrect encoding format!");break;case"EXPOSURE":t.exposure=parseFloat(s[1]);break;case"COLORCORR":t.colorCorr=s[1].replace(/^\s+|\s+$/g,"").split(" ").map(r=>parseFloat(r));break}}e=he(this,Pt,Bi).call(this,n);const i=e.split(" ");return he(this,bi,Os).call(this,i[0],parseInt(i[1]),t),he(this,bi,Os).call(this,i[2],parseInt(i[3]),t),t},bi=new WeakSet,Os=function(n,e,t){switch(n){case"+X":t.width=e;break;case"-X":t.width=e,t.flipX=!0,console.warn("Flipping horizontal orientation not currently supported");break;case"-Y":t.height=e,t.flipY=!0;break;case"+Y":t.height=e;break}},Pt=new WeakSet,Bi=function(n){let e,t="";for(;(e=n.data.getUint8(n.offset++))!==10;)t+=String.fromCharCode(e);return t},Gs=new WeakSet,mn=function(n,e){const t=n.data.getUint16(n.offset);let i;if(t===514)i=he(this,Ds,gn).call(this,n,e),e.flipX&&he(this,$s,yn).call(this,i,e),e.flipY&&he(this,Us,xn).call(this,i,e);else throw new Error("Obsolete HDR file version!");return i},Ds=new WeakSet,gn=function(n,e){const{width:t,height:i,colorCorr:s}=e,r=new Float32Array(t*i*4);let o=0,{offset:a,data:h}=n;for(let l=0;l<i;++l){if(h.getUint16(a)!==514)throw new Error("Incorrect scanline start hash");if(h.getUint16(a+2)!==t)throw new Error("Scanline doesn't match picture dimension!");a+=4;const u=t*4,d=[];let c=0;for(;c<u;){let p=h.getUint8(a++);if(p>128){const g=p-128;p=h.getUint8(a++);for(let m=0;m<g;++m)d[c++]=p}else for(let g=0;g<p;++g)d[c++]=h.getUint8(a++)}for(c=0;c<t;++c){const p=d[c],g=d[c+t],m=d[c+t*2];let y=d[c+t*3];y=y?Math.pow(2,y-136):0,r[o++]=p*y*s[0],r[o++]=g*y*s[1],r[o++]=m*y*s[2],r[o++]=y}}return r},Mi=new WeakSet,Fs=function(n,e,t){e*=4,t*=4;for(let i=0;i<4;++i){const s=n[e+i];n[e+i]=n[t+i],n[t+i]=s}},$s=new WeakSet,yn=function(n,e){const{width:t,height:i}=e,s=t>>1;for(let r=0;r<i;++r){const o=r*t;for(let a=0;a<s;++a){const h=o+a,l=o+t-1-a;he(this,Mi,Fs).call(this,n,h,l)}}},Us=new WeakSet,xn=function(n,e){const{width:t,height:i}=e,s=i>>1;for(let r=0;r<s;++r){const o=r*t,a=(i-1-r)*t;for(let h=0;h<t;++h)he(this,Mi,Fs).call(this,n,o+h,a+h)}};const Ko=n=>{const{scene:e}=n;if(!e)return;const t=[];e.computePassEntries.forEach(i=>{t.push({command:"Render ComputePass",content:i.options.label}),i.material.bindGroups.forEach(s=>{s.bufferBindings.forEach(r=>{r.shouldCopyResult&&t.push({command:"Copy buffer to buffer",source:`${r.name} buffer`,destination:`${r.name} result buffer`})})})});for(const i in e.renderPassEntries){let s=0;e.renderPassEntries[i].forEach(r=>{if(!e.getRenderPassEntryLength(r))return;const o=r.renderPass.options.useColorAttachments?r.renderPass.options.colorAttachments.length===0&&r.renderPass.options.useDepth?`${r.renderTexture.options.label} depth pass`:r.renderPass.options.colorAttachments.length>1?`${r.renderTexture.options.label} multiple targets`:r.renderTexture?`${r.renderTexture.options.label}`:"Context current texture":void 0;let a=r.renderPass.options.label;const h={loadOp:r.renderPass.options.useColorAttachments?i==="screen"&&s>0?"load":r.renderPass.options.loadOp:void 0,depthLoadOp:void 0,sampleCount:r.renderPass.options.sampleCount,...r.renderPass.options.qualityRatio!==1&&{qualityRatio:r.renderPass.options.qualityRatio}};if(r.renderPass.options.useDepth&&(h.depthLoadOp=r.renderPass.options.depthLoadOp),s++,r.element)r.element.type==="ShaderPass"&&!(r.element.inputTarget||r.element.outputTarget)&&(t.push({command:"Copy texture to texture",source:o,destination:`${r.element.options.label} renderTexture`}),h.loadOp="clear"),a+=" "+JSON.stringify(h),t.push({command:`Render ${r.element.type}`,source:r.element.options.label,destination:o,descriptor:a}),r.element.type==="ShaderPass"&&!r.element.outputTarget&&r.element.options.copyOutputToRenderTexture?t.push({command:"Copy texture to texture",source:o,destination:`${r.element.options.label} renderTexture`}):r.element.type==="PingPongPlane"&&t.push({command:"Copy texture to texture",source:o,destination:`${r.element.renderTexture.options.label}`});else if(r.stack){a+=" "+JSON.stringify(h);for(const l in r.stack)for(const u in r.stack[l])r.stack[l][u].length&&t.push({command:`Render stack (${l} ${u} objects)`,source:r.stack[l][u],destination:o,descriptor:a})}})}console.table(t)};x.AmbientLight=kn,x.BindGroup=Et,x.Binding=Rt,x.Box3=ve,x.BoxGeometry=_o,x.Buffer=Ie,x.BufferBinding=pe,x.Camera=Ys,x.ComputeMaterial=Zs,x.ComputePass=Qs,x.ComputePipelineEntry=Dr,x.DOMElement=Ji,x.DOMFrustum=tr,x.DOMMesh=rn,x.DOMObject3D=tn,x.DOMTexture=Oe,x.DirectionalLight=Hn,x.FullscreenPlane=Hi,x.GLTFLoader=wi,x.GLTFScenesManager=ko,x.GPUCameraRenderer=ss,x.GPUCurtains=Eo,x.GPUCurtainsRenderer=hi,x.GPUDeviceManager=Vr,x.GPURenderer=ts,x.Geometry=Di,x.HDRLoader=Zo,x.IndexedGeometry=nt,x.Mat3=Be,x.Mat4=G,x.Material=Gi,x.Mesh=Gr,x.Object3D=xe,x.OrbitControls=Lo,x.PingPongPlane=Oo,x.PipelineEntry=ki,x.PipelineManager=Fr,x.Plane=nn,x.PlaneGeometry=Fi,x.PointLight=eo,x.ProjectedObject3D=Zi,x.Quat=ce,x.Raycaster=Do,x.RenderBundle=vo,x.RenderMaterial=Wi,x.RenderPass=Wt,x.RenderPipelineEntry=We,x.RenderTarget=Ui,x.Sampler=Ve,x.SamplerBinding=js,x.Scene=$r,x.ShaderPass=bo,x.SphereGeometry=Ao,x.Texture=re,x.TextureBindGroup=Oi,x.TextureBinding=Ai,x.Vec2=_,x.Vec3=f,x.WritableBufferBinding=_i,x.applyDirectionalShadows=ht,x.applyPointShadows=lt,x.buildShaders=Io,x.computeDiffuseFromSpecular=Vo,x.getDefaultPointShadowDepthFs=fr,x.getDefaultPointShadowDepthVs=pr,x.getDefaultShadowDepthVs=ur,x.getIBL=Qr,x.getIBLIndirect=Jr,x.getLambert=Xr,x.getLambertDirect=Yr,x.getPBR=Kr,x.getPBRDirect=ds,x.getPCFDirectionalShadows=cr,x.getPCFPointShadowContribution=mr,x.getPCFPointShadows=gr,x.getPCFShadowContribution=dr,x.getPCFShadows=at,x.getPhong=Zr,x.getPhongDirect=Hr,x.lambertUtils=oi,x.logSceneCommands=Ko,x.pbrUtils=us,x.toneMappingUtils=yt});
//# sourceMappingURL=gpu-curtains.umd.min.js.map
