(function(w,k){typeof exports=="object"&&typeof module<"u"?k(exports):typeof define=="function"&&define.amd?define(["exports"],k):(w=typeof globalThis<"u"?globalThis:w||self,k(w.window=w.window||{}))})(this,function(w){"use strict";const k=()=>"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,o=>{const e=Math.random()*16|0;return(o==="x"?e:e&3|8).toString(16).toUpperCase()}),ye=o=>o.replace(/(?:^\w|[A-Z]|\b\w)/g,(e,t)=>t===0?e.toLowerCase():e.toUpperCase()).replace(/\s+/g,""),Xe=o=>{const e=ye(o);return e.charAt(0).toUpperCase()+e.slice(1)};let Ke=0;const D=o=>{Ke>100||(console.warn(Ke===100?"GPUCurtains: too many warnings thrown, stop logging.":o),Ke++)},q=o=>{throw new Error(o)},Ze=(o,e="GPURenderer",t)=>{const s=t?`Unable to create ${t} because the ${e} is not defined: ${o}`:`The ${e} is not defined: ${o}`;q(s)},$=(o,e)=>{const t=o&&(o.type==="GPURenderer"||o.type==="GPUCameraRenderer"||o.type==="GPUCurtainsRenderer");return t||Ze(o,"GPURenderer",e),t},Be=(o,e)=>{const t=o&&(o.type==="GPUCameraRenderer"||o.type==="GPUCurtainsRenderer");return t||Ze(o,"GPUCameraRenderer",e),t},Qe=(o,e)=>{const t=o&&o.type==="GPUCurtainsRenderer";return t||Ze(o,"GPUCurtainsRenderer",e),t},Pt=(()=>{let o,e;const t={};return function(i,r){e||(e=i.createShaderModule({label:"textured quad shaders for mip level generation",code:`
            struct VSOutput {
              @builtin(position) position: vec4f,
              @location(0) texcoord: vec2f,
            };

            @vertex fn vs(
              @builtin(vertex_index) vertexIndex : u32
            ) -> VSOutput {
              var pos = array<vec2f, 6>(

                vec2f( 0.0,  0.0),  // center
                vec2f( 1.0,  0.0),  // right, center
                vec2f( 0.0,  1.0),  // center, top

                // 2st triangle
                vec2f( 0.0,  1.0),  // center, top
                vec2f( 1.0,  0.0),  // right, center
                vec2f( 1.0,  1.0),  // right, top
              );

              var vsOutput: VSOutput;
              let xy = pos[vertexIndex];
              vsOutput.position = vec4f(xy * 2.0 - 1.0, 0.0, 1.0);
              vsOutput.texcoord = vec2f(xy.x, 1.0 - xy.y);
              return vsOutput;
            }

            @group(0) @binding(0) var ourSampler: sampler;
            @group(0) @binding(1) var ourTexture: texture_2d<f32>;

            @fragment fn fs(fsInput: VSOutput) -> @location(0) vec4f {
              return textureSample(ourTexture, ourSampler, fsInput.texcoord);
            }
          `}),o=i.createSampler({minFilter:"linear"})),t[r.format]||(t[r.format]=i.createRenderPipeline({label:"mip level generator pipeline",layout:"auto",vertex:{module:e,entryPoint:"vs"},fragment:{module:e,entryPoint:"fs",targets:[{format:r.format}]}}));const n=t[r.format],a=i.createCommandEncoder({label:"mip gen encoder"});let h=r.width,u=r.height,l=0;for(;h>1||u>1;){h=Math.max(1,h/2|0),u=Math.max(1,u/2|0);const c=i.createBindGroup({layout:n.getBindGroupLayout(0),entries:[{binding:0,resource:o},{binding:1,resource:r.createView({baseMipLevel:l,mipLevelCount:1})}]});++l;const p={label:"our basic canvas renderPass",colorAttachments:[{view:r.createView({baseMipLevel:l,mipLevelCount:1}),loadOp:"clear",storeOp:"store"}]},g=a.beginRenderPass(p);g.setPipeline(n),g.setBindGroup(0,c),g.draw(6),g.end()}const d=a.finish();i.queue.submit([d])}})(),bs=new Map([["vertex",GPUShaderStage.VERTEX],["fragment",GPUShaderStage.FRAGMENT],["compute",GPUShaderStage.COMPUTE]]),vs=(o=[])=>o.reduce((e,t)=>e|bs.get(t),0),ws={i32:{numElements:1,align:4,size:4,type:"i32",View:Int32Array},u32:{numElements:1,align:4,size:4,type:"u32",View:Uint32Array},f32:{numElements:1,align:4,size:4,type:"f32",View:Float32Array},f16:{numElements:1,align:2,size:2,type:"u16",View:Uint16Array},vec2f:{numElements:2,align:8,size:8,type:"f32",View:Float32Array},vec2i:{numElements:2,align:8,size:8,type:"i32",View:Int32Array},vec2u:{numElements:2,align:8,size:8,type:"u32",View:Uint32Array},vec2h:{numElements:2,align:4,size:4,type:"u16",View:Uint16Array},vec3i:{numElements:3,align:16,size:12,type:"i32",View:Int32Array},vec3u:{numElements:3,align:16,size:12,type:"u32",View:Uint32Array},vec3f:{numElements:3,align:16,size:12,type:"f32",View:Float32Array},vec3h:{numElements:3,align:8,size:6,type:"u16",View:Uint16Array},vec4i:{numElements:4,align:16,size:16,type:"i32",View:Int32Array},vec4u:{numElements:4,align:16,size:16,type:"u32",View:Uint32Array},vec4f:{numElements:4,align:16,size:16,type:"f32",View:Float32Array},vec4h:{numElements:4,align:8,size:8,type:"u16",View:Uint16Array},mat2x2f:{numElements:4,align:8,size:16,type:"f32",View:Float32Array},mat2x2h:{numElements:4,align:4,size:8,type:"u16",View:Uint16Array},mat3x2f:{numElements:6,align:8,size:24,type:"f32",View:Float32Array},mat3x2h:{numElements:6,align:4,size:12,type:"u16",View:Uint16Array},mat4x2f:{numElements:8,align:8,size:32,type:"f32",View:Float32Array},mat4x2h:{numElements:8,align:4,size:16,type:"u16",View:Uint16Array},mat2x3f:{numElements:8,align:16,size:32,pad:[3,1],type:"f32",View:Float32Array},mat2x3h:{numElements:8,align:8,size:16,pad:[3,1],type:"u16",View:Uint16Array},mat3x3f:{numElements:12,align:16,size:48,pad:[3,1],type:"f32",View:Float32Array},mat3x3h:{numElements:12,align:8,size:24,pad:[3,1],type:"u16",View:Uint16Array},mat4x3f:{numElements:16,align:16,size:64,pad:[3,1],type:"f32",View:Float32Array},mat4x3h:{numElements:16,align:8,size:32,pad:[3,1],type:"u16",View:Uint16Array},mat2x4f:{numElements:8,align:16,size:32,type:"f32",View:Float32Array},mat2x4h:{numElements:8,align:8,size:16,type:"u16",View:Uint16Array},mat3x4f:{numElements:12,align:16,size:48,pad:[3,1],type:"f32",View:Float32Array},mat3x4h:{numElements:12,align:8,size:24,pad:[3,1],type:"u16",View:Uint16Array},mat4x4f:{numElements:16,align:16,size:64,type:"f32",View:Float32Array},mat4x4h:{numElements:16,align:8,size:32,type:"u16",View:Uint16Array}},Rt=o=>ws[o],Ce=o=>(()=>{switch(o.bindingType){case"storage":return`var<${o.bindingType}, ${o.options.access}>`;case"uniform":default:return"var<uniform>"}})(),Ms=o=>o.bindingType==="externalTexture"?`var ${o.name}: texture_external;`:o.bindingType==="storage"?`var ${o.name}: texture_storage_${o.options.viewDimension}<${o.options.format}, ${o.options.access}>;`:o.bindingType==="depth"?`var ${o.name}: texture_depth${o.options.multisampled?"_multisampled":""}_${o.options.viewDimension};`:`var ${o.name}: texture${o.options.multisampled?"_multisampled":""}_${o.options.viewDimension}<f32>;`,St=o=>o.bindingType==="storage"&&o.options.access==="read_write"?"storage":o.bindingType==="storage"?"read-only-storage":"uniform",Bs=o=>(()=>{switch(o.bindingType){case"externalTexture":return{externalTexture:{}};case"storage":return{storageTexture:{format:o.options.format,viewDimension:o.options.viewDimension}};case"texture":return{texture:{multisampled:o.options.multisampled,viewDimension:o.options.viewDimension,sampleType:o.options.multisampled?"unfilterable-float":"float"}};case"depth":return{texture:{multisampled:o.options.multisampled,viewDimension:o.options.viewDimension,sampleType:"depth"}};default:return null}})(),Cs=o=>(()=>{switch(o.bindingType){case"externalTexture":return`externalTexture,${o.visibility},`;case"storage":return`storageTexture,${o.options.format},${o.options.viewDimension},${o.visibility},`;case"texture":return`texture,${o.options.multisampled},${o.options.viewDimension},${o.options.multisampled?"unfilterable-float":"float"},${o.visibility},`;case"depth":return`depthTexture,${o.options.format},${o.options.viewDimension},${o.visibility},`;default:return`${o.visibility},`}})();class Te{constructor({label:e="Uniform",name:t="uniform",bindingType:s="uniform",visibility:i=["vertex","fragment","compute"]}){this.label=e,this.name=ye(t),this.bindingType=s,this.visibility=vs(i),this.options={label:e,name:t,bindingType:s,visibility:i},this.shouldResetBindGroup=!1,this.shouldResetBindGroupLayout=!1,this.cacheKey=`${s},${this.visibility},`}}class E{constructor(e=0,t=e){this.type="Vec2",this._x=e,this._y=t}get x(){return this._x}set x(e){const t=e!==this._x;this._x=e,t&&this._onChangeCallback&&this._onChangeCallback()}get y(){return this._y}set y(e){const t=e!==this._y;this._y=e,t&&this._onChangeCallback&&this._onChangeCallback()}onChange(e){return e&&(this._onChangeCallback=e),this}set(e=0,t=e){return this.x=e,this.y=t,this}add(e=new E){return this.x+=e.x,this.y+=e.y,this}addScalar(e=0){return this.x+=e,this.y+=e,this}sub(e=new E){return this.x-=e.x,this.y-=e.y,this}subScalar(e=0){return this.x-=e,this.y-=e,this}multiply(e=new E(1)){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e=1){return this.x*=e,this.y*=e,this}divide(e=new E(1)){return this.x/=e.x,this.y/=e.y,this}divideScalar(e=1){return this.x/=e,this.y/=e,this}copy(e=new E){return this.x=e.x,this.y=e.y,this}clone(){return new E(this.x,this.y)}max(e=new E){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}min(e=new E){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}clamp(e=new E,t=new E){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}equals(e=new E){return this.x===e.x&&this.y===e.y}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.lengthSq())}normalize(){let e=this.x*this.x+this.y*this.y;return e>0&&(e=1/Math.sqrt(e)),this.x*=e,this.y*=e,this}dot(e=new E){return this.x*e.x+this.y*e.y}lerp(e=new E,t=1){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}}class J{constructor(e=new Float32Array([0,0,0,1]),t="XYZ"){this.type="Quat",this.elements=e,this.axisOrder=t}setFromArray(e=new Float32Array([0,0,0,1])){return this.elements[0]=e[0],this.elements[1]=e[1],this.elements[2]=e[2],this.elements[3]=e[3],this}setAxisOrder(e="XYZ"){switch(e=e.toUpperCase(),e){case"XYZ":case"YXZ":case"ZXY":case"ZYX":case"YZX":case"XZY":this.axisOrder=e;break;default:this.axisOrder="XYZ"}return this}copy(e=new J){return this.elements=e.elements,this.axisOrder=e.axisOrder,this}clone(){return new J().copy(this)}equals(e=new J){return this.elements[0]===e.elements[0]&&this.elements[1]===e.elements[1]&&this.elements[2]===e.elements[2]&&this.elements[3]===e.elements[3]&&this.axisOrder===e.axisOrder}setFromVec3(e){const t=e.x*.5,s=e.y*.5,i=e.z*.5,r=Math.cos(t),n=Math.cos(s),a=Math.cos(i),h=Math.sin(t),u=Math.sin(s),l=Math.sin(i);return this.axisOrder==="XYZ"?(this.elements[0]=h*n*a+r*u*l,this.elements[1]=r*u*a-h*n*l,this.elements[2]=r*n*l+h*u*a,this.elements[3]=r*n*a-h*u*l):this.axisOrder==="YXZ"?(this.elements[0]=h*n*a+r*u*l,this.elements[1]=r*u*a-h*n*l,this.elements[2]=r*n*l-h*u*a,this.elements[3]=r*n*a+h*u*l):this.axisOrder==="ZXY"?(this.elements[0]=h*n*a-r*u*l,this.elements[1]=r*u*a+h*n*l,this.elements[2]=r*n*l+h*u*a,this.elements[3]=r*n*a-h*u*l):this.axisOrder==="ZYX"?(this.elements[0]=h*n*a-r*u*l,this.elements[1]=r*u*a+h*n*l,this.elements[2]=r*n*l-h*u*a,this.elements[3]=r*n*a+h*u*l):this.axisOrder==="YZX"?(this.elements[0]=h*n*a+r*u*l,this.elements[1]=r*u*a+h*n*l,this.elements[2]=r*n*l-h*u*a,this.elements[3]=r*n*a-h*u*l):this.axisOrder==="XZY"&&(this.elements[0]=h*n*a-r*u*l,this.elements[1]=r*u*a-h*n*l,this.elements[2]=r*n*l+h*u*a,this.elements[3]=r*n*a+h*u*l),this}setFromAxisAngle(e,t=0){const s=t/2,i=Math.sin(s);return this.elements[0]=e.x*i,this.elements[1]=e.y*i,this.elements[2]=e.z*i,this.elements[3]=Math.cos(s),this}setFromRotationMatrix(e){const t=e.elements,s=t[0],i=t[4],r=t[8],n=t[1],a=t[5],h=t[9],u=t[2],l=t[6],d=t[10],c=s+a+d;if(c>0){const p=.5/Math.sqrt(c+1);this.elements[3]=.25/p,this.elements[0]=(l-h)*p,this.elements[1]=(r-u)*p,this.elements[2]=(n-i)*p}else if(s>a&&s>d){const p=2*Math.sqrt(1+s-a-d);this.elements[3]=(l-h)/p,this.elements[0]=.25*p,this.elements[1]=(i+n)/p,this.elements[2]=(r+u)/p}else if(a>d){const p=2*Math.sqrt(1+a-s-d);this.elements[3]=(r-u)/p,this.elements[0]=(i+n)/p,this.elements[1]=.25*p,this.elements[2]=(h+l)/p}else{const p=2*Math.sqrt(1+d-s-a);this.elements[3]=(n-i)/p,this.elements[0]=(r+u)/p,this.elements[1]=(h+l)/p,this.elements[2]=.25*p}return this}}class f{constructor(e=0,t=e,s=e){this.type="Vec3",this._x=e,this._y=t,this._z=s}get x(){return this._x}set x(e){const t=e!==this._x;this._x=e,t&&this._onChangeCallback&&this._onChangeCallback()}get y(){return this._y}set y(e){const t=e!==this._y;this._y=e,t&&this._onChangeCallback&&this._onChangeCallback()}get z(){return this._z}set z(e){const t=e!==this._z;this._z=e,t&&this._onChangeCallback&&this._onChangeCallback()}onChange(e){return e&&(this._onChangeCallback=e),this}set(e=0,t=e,s=e){return this.x=e,this.y=t,this.z=s,this}add(e=new f){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e=0){return this.x+=e,this.y+=e,this.z+=e,this}sub(e=new f){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e=0){return this.x-=e,this.y-=e,this.z-=e,this}multiply(e=new f(1)){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e=1){return this.x*=e,this.y*=e,this.z*=e,this}divide(e=new f(1)){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e=1){return this.x/=e,this.y/=e,this.z/=e,this}copy(e=new f){return this.x=e.x,this.y=e.y,this.z=e.z,this}clone(){return new f(this.x,this.y,this.z)}max(e=new f){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}min(e=new f){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}clamp(e=new f,t=new f){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}equals(e=new f){return this.x===e.x&&this.y===e.y&&this.z===e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.lengthSq())}distance(e=new f){return Math.hypot(e.x-this.x,e.y-this.y,e.z-this.z)}normalize(){let e=this.lengthSq();return e>0&&(e=1/Math.sqrt(e)),this.x*=e,this.y*=e,this.z*=e,this}dot(e=new f){return this.x*e.x+this.y*e.y+this.z*e.z}cross(e=new f){return this.crossVectors(this,e)}crossVectors(e=new f,t=new f){const s=e.x,i=e.y,r=e.z,n=t.x,a=t.y,h=t.z;return this.x=i*h-r*a,this.y=r*n-s*h,this.z=s*a-i*n,this}lerp(e=new f,t=1){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}applyMat4(e){const t=this._x,s=this._y,i=this._z,r=e.elements;let n=r[3]*t+r[7]*s+r[11]*i+r[15];return n=n||1,this.x=(r[0]*t+r[4]*s+r[8]*i+r[12])/n,this.y=(r[1]*t+r[5]*s+r[9]*i+r[13])/n,this.z=(r[2]*t+r[6]*s+r[10]*i+r[14])/n,this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}applyQuat(e=new J){const t=this.x,s=this.y,i=this.z,r=e.elements[0],n=e.elements[1],a=e.elements[2],h=e.elements[3],u=h*t+n*i-a*s,l=h*s+a*t-r*i,d=h*i+r*s-n*t,c=-r*t-n*s-a*i;return this.x=u*h+c*-r+l*-a-d*-n,this.y=l*h+c*-n+d*-r-u*-a,this.z=d*h+c*-a+u*-n-l*-r,this}applyAxisAngle(e=new f,t=0,s=new J){return this.applyQuat(s.setFromAxisAngle(e,t))}project(e){return this.applyMat4(e.viewMatrix).applyMat4(e.projectionMatrix),this}unproject(e){return this.applyMat4(e.projectionMatrix.getInverse()).applyMat4(e.modelMatrix),this}}const Ts=4,Pe=4,j=Ts*Pe;class Je{constructor({name:e,key:t,type:s="f32"}){this.name=e,this.key=t,this.type=s,this.bufferLayout=Rt(this.type.replace("array","").replace("<","").replace(">","")),this.alignment={start:{row:0,byte:0},end:{row:0,byte:0}},this.setValue=null}get rowCount(){return this.alignment.end.row-this.alignment.start.row+1}get byteCount(){return Math.abs(this.endOffset-this.startOffset)+1}get paddedByteCount(){return(this.alignment.end.row+1)*j}get startOffset(){return this.getByteCountAtPosition(this.alignment.start)}get startOffsetToIndex(){return this.startOffset/Pe}get endOffset(){return this.getByteCountAtPosition(this.alignment.end)}get endOffsetToIndex(){return Math.floor(this.endOffset/Pe)}getPositionAtOffset(e=0){return{row:Math.floor(e/j),byte:e%j}}getByteCountAtPosition(e={row:0,byte:0}){return e.row*j+e.byte}applyOverflowToPosition(e={row:0,byte:0}){if(e.byte>j-1){const t=e.byte%j;e.row+=Math.floor(e.byte/j),e.byte=t}return e}getByteCountBetweenPositions(e={row:0,byte:0},t={row:0,byte:0}){return Math.abs(this.getByteCountAtPosition(t)-this.getByteCountAtPosition(e))}getElementAlignment(e={row:0,byte:0}){const t={start:e,end:e},{size:s,align:i}=this.bufferLayout;return e.byte%i!==0&&(e.byte+=e.byte%i),(s<=j&&e.byte+s>j||s>j&&e.byte>j)&&(e.row+=1,e.byte=0),t.end={row:e.row+Math.ceil(s/j)-1,byte:e.byte+(s%j===0?j-1:s%j-1)},t.end=this.applyOverflowToPosition(t.end),t}setAlignmentFromPosition(e={row:0,byte:0}){this.alignment=this.getElementAlignment(e)}setAlignment(e=0){this.setAlignmentFromPosition(this.getPositionAtOffset(e))}setView(e,t){this.view=new this.bufferLayout.View(e,this.startOffset,this.byteCount/this.bufferLayout.View.BYTES_PER_ELEMENT)}setValueFromFloat(e){this.view[0]=e}setValueFromVec2(e){this.view[0]=e.x??e[0]??0,this.view[1]=e.y??e[1]??0}setValueFromVec3(e){this.view[0]=e.x??e[0]??0,this.view[1]=e.y??e[1]??0,this.view[2]=e.z??e[2]??0}setValueFromMat4OrQuat(e){this.view.set(e.elements)}setValueFromMat3(e){this.setValueFromArrayWithPad(e.elements)}setValueFromArray(e){this.view.set(e)}setValueFromArrayWithPad(e){for(let t=0,s=0;t<this.view.length;t+=this.bufferLayout.pad[0]+this.bufferLayout.pad[1],s++)for(let i=0;i<this.bufferLayout.pad[0];i++)this.view[t+i]=e[t+i-s]}update(e){this.setValue||(this.setValue=(t=>{if(this.type==="f32"||this.type==="u32"||this.type==="i32")return this.setValueFromFloat;if(this.type==="vec2f")return this.setValueFromVec2;if(this.type==="vec3f")return this.setValueFromVec3;if(this.type==="mat3x3f")return t.elements?this.setValueFromMat3:this.setValueFromArrayWithPad;if(t.elements)return this.setValueFromMat4OrQuat;if(ArrayBuffer.isView(t)||Array.isArray(t))return this.bufferLayout.pad?this.setValueFromArrayWithPad:this.setValueFromArray;D(`${this.constructor.name}: value passed to ${this.name} cannot be used: ${t}`)})(e)),this.setValue(e)}extractDataFromBufferResult(e){return e.slice(this.startOffsetToIndex,this.endOffsetToIndex)}}class zt extends Je{constructor({name:e,key:t,type:s="f32",arrayLength:i=1}){super({name:e,key:t,type:s}),this.arrayLength=i,this.numElements=Math.ceil(this.arrayLength/this.bufferLayout.numElements)}get arrayStrideToIndex(){return this.arrayStride/Pe}setAlignment(e=0){super.setAlignment(e);const t=this.getElementAlignment(this.getPositionAtOffset(this.endOffset+1));this.arrayStride=this.getByteCountBetweenPositions(this.alignment.end,t.end),this.alignment.end=this.getPositionAtOffset(this.endOffset+this.arrayStride*(this.numElements-1))}setValueFromArray(e){let t=0;const s=this.byteCount/this.bufferLayout.View.BYTES_PER_ELEMENT,i=Math.ceil(s/this.numElements);for(let r=0;r<this.numElements;r++)for(let n=0;n<this.bufferLayout.numElements;n++)this.view[n+r*i]=e[t],t++}}class et extends zt{constructor({name:e,key:t,type:s="f32",arrayLength:i=1}){super({name:e,key:t,type:s,arrayLength:i}),this.arrayStride=1,this.arrayLength=i,this.numElements=Math.ceil(this.arrayLength/this.bufferLayout.numElements)}get byteCount(){return this.bufferLayout.size*this.numElements}setAlignment(e=0,t=0){this.alignment=this.getElementAlignment(this.getPositionAtOffset(e)),this.arrayStride=t,this.alignment.end=this.getPositionAtOffset(this.endOffset+t*(this.numElements-1))}setView(e,t){this.view=new this.bufferLayout.View(this.bufferLayout.numElements*this.numElements),this.viewSetFunction=(s=>{switch(this.bufferLayout.View){case Int32Array:return s.setInt32.bind(s);case Uint16Array:return s.setUint16.bind(s);case Uint32Array:return s.setUint32.bind(s);case Float32Array:default:return s.setFloat32.bind(s)}})(t)}update(e){super.update(e);for(let t=0;t<this.numElements;t++){const s=this.view.subarray(t*this.bufferLayout.numElements,t*this.bufferLayout.numElements+this.bufferLayout.numElements),i=this.startOffset+t*this.arrayStride;s.forEach((r,n)=>{this.viewSetFunction(i+n*this.bufferLayout.View.BYTES_PER_ELEMENT,r,!0)})}}extractDataFromBufferResult(e){const t=new Float32Array(this.arrayLength);for(let s=0;s<this.numElements;s++){const i=this.startOffsetToIndex+s*this.arrayStrideToIndex;for(let r=0;r<this.bufferLayout.numElements;r++)t[s*this.bufferLayout.numElements+r]=e[i+r]}return t}}const Ps=new Map([["copySrc",GPUBufferUsage.COPY_SRC],["copyDst",GPUBufferUsage.COPY_DST],["index",GPUBufferUsage.INDEX],["indirect",GPUBufferUsage.INDIRECT],["mapRead",GPUBufferUsage.MAP_READ],["mapWrite",GPUBufferUsage.MAP_WRITE],["queryResolve",GPUBufferUsage.QUERY_RESOLVE],["storage",GPUBufferUsage.STORAGE],["uniform",GPUBufferUsage.UNIFORM],["vertex",GPUBufferUsage.VERTEX]]),Et=(o=[])=>o.reduce((e,t)=>e|Ps.get(t),0);class de{constructor({label:e="Buffer",size:t=0,usage:s=["copySrc","copyDst"],mappedAtCreation:i=!1}={}){this.type="Buffer",this.reset(),this.uuid=k(),this.consumers=new Set,this.options={label:e,size:t,usage:Et(s),mappedAtCreation:i}}reset(){this.GPUBuffer=null}set size(e){this.options.size=e}createBuffer(e,t={}){const{usage:s,...i}=t;this.options={...this.options,...i,...s!==void 0&&{usage:Et(s)}},this.setBuffer(e.createBuffer(this))}setBuffer(e){this.GPUBuffer=e}copy(e,t=!1){t&&this.destroy(),this.options=e.options,this.GPUBuffer=e.GPUBuffer,this.consumers=new Set([...this.consumers,...e.consumers])}async mapBufferAsync(){if(!this.GPUBuffer||this.GPUBuffer.mapState!=="unmapped")return new Float32Array(0);await this.GPUBuffer.mapAsync(GPUMapMode.READ);const e=new Float32Array(this.GPUBuffer.getMappedRange().slice(0));return this.GPUBuffer.unmap(),e}destroy(){this.GPUBuffer?.destroy(),this.reset(),this.consumers.clear()}}class ce extends Te{constructor({label:e="Uniform",name:t="uniform",bindingType:s,visibility:i,useStruct:r=!0,access:n="read",usage:a=[],struct:h={}}){s=s??"uniform",super({label:e,name:t,bindingType:s,visibility:i}),this.options={...this.options,useStruct:r,access:n,usage:a,struct:h},this.cacheKey+=`${r},${n},`,this.arrayBufferSize=0,this.shouldUpdate=!1,this.useStruct=r,this.bufferElements=[],this.inputs={},this.buffer=new de,Object.keys(h).length&&(this.setBindings(h),this.setBufferAttributes(),this.setWGSLFragment())}get resourceLayout(){return{buffer:{type:St(this)}}}get resourceLayoutCacheKey(){return`buffer,${St(this)},${this.visibility},`}get resource(){return{buffer:this.buffer.GPUBuffer}}clone(e){const{struct:t,...s}=e,i=new this.constructor(s);return i.setBindings(t),i.options.struct=t,i.arrayBufferSize=this.arrayBufferSize,i.arrayBuffer=new ArrayBuffer(i.arrayBufferSize),i.arrayView=new DataView(i.arrayBuffer,0,i.arrayBuffer.byteLength),i.buffer.size=i.arrayBuffer.byteLength,this.bufferElements.forEach(r=>{const n=new r.constructor({name:r.name,key:r.key,type:r.type,...r.arrayLength&&{arrayLength:r.arrayLength}});n.alignment=r.alignment,r.arrayStride&&(n.arrayStride=r.arrayStride),n.setView(i.arrayBuffer,i.arrayView),i.bufferElements.push(n)}),this.name===i.name&&this.label===i.label?(i.wgslStructFragment=this.wgslStructFragment,i.wgslGroupFragment=this.wgslGroupFragment):i.setWGSLFragment(),i.shouldUpdate=i.arrayBufferSize>0,i}setBindings(e){for(const t of Object.keys(e)){const s={};for(const i in e[t])i!=="value"&&(s[i]=e[t][i]);s.name=t,Object.defineProperty(s,"value",{get(){return s._value},set(i){s._value=i,s.shouldUpdate=!0}}),s.value=e[t].value,(s.value instanceof E||s.value instanceof f)&&s.value.onChange(()=>s.shouldUpdate=!0),this.inputs[t]=s,this.cacheKey+=`${t},${e[t].type},`}}setBufferAttributes(){let e=Object.keys(this.inputs);const t=e.filter(s=>this.inputs[s].type.includes("array"));t.length&&(e.sort((s,i)=>{const r=Math.min(0,this.inputs[s].type.indexOf("array")),n=Math.min(0,this.inputs[i].type.indexOf("array"));return r-n}),t.length>1&&(e=e.filter(s=>!t.includes(s))));for(const s of e){const i=this.inputs[s],r={name:ye(i.name??s),key:s,type:i.type},n=i.type.includes("array")&&(Array.isArray(i.value)||ArrayBuffer.isView(i.value));this.bufferElements.push(n?new zt({...r,arrayLength:i.value.length}):new Je(r))}if(this.bufferElements.forEach((s,i)=>{const r=i===0?0:this.bufferElements[i-1].endOffset+1;s.setAlignment(r)}),t.length>1)if(t.map(r=>{const n=this.inputs[r],a=Rt(n.type.replace("array","").replace("<","").replace(">",""));return Math.ceil(n.value.length/a.numElements)}).every((r,n,a)=>r===a[0])){const r=t.map(h=>{const u=this.inputs[h];return new et({name:ye(u.name??h),key:h,type:u.type,arrayLength:u.value.length})}),n=t.map(h=>{const u=this.inputs[h];return new Je({name:ye(u.name??h),key:h,type:u.type.replace("array","").replace("<","").replace(">","")})});n.forEach((h,u)=>{u===0?this.bufferElements.length?h.setAlignmentFromPosition({row:this.bufferElements[this.bufferElements.length-1].alignment.end.row+1,byte:0}):h.setAlignment(0):h.setAlignment(n[u-1].endOffset+1)});const a=n[n.length-1].endOffset+1-n[0].startOffset;r.forEach((h,u)=>{h.setAlignment(n[u].startOffset,a)}),this.bufferElements=[...this.bufferElements,...r]}else D(`BufferBinding: "${this.label}" contains multiple array inputs that should use an interleaved array, but their sizes do not match. These inputs cannot be added to the BufferBinding: "${t.join(", ")}"`);this.arrayBufferSize=this.bufferElements.length?this.bufferElements[this.bufferElements.length-1].paddedByteCount:0,this.arrayBuffer=new ArrayBuffer(this.arrayBufferSize),this.arrayView=new DataView(this.arrayBuffer,0,this.arrayBuffer.byteLength),this.buffer.size=this.arrayBuffer.byteLength;for(const s of this.bufferElements)s.setView(this.arrayBuffer,this.arrayView);this.shouldUpdate=this.arrayBufferSize>0}setWGSLFragment(){if(!this.bufferElements.length)return;const e=Xe(this.label);if(this.useStruct){const t=this.bufferElements.filter(i=>!(i instanceof et)),s=this.bufferElements.filter(i=>i instanceof et);if(s.length){const i=this.bindingType==="uniform"?`, ${s[0].numElements}`:"";if(t.length){this.wgslStructFragment=`struct ${e}Element {
	${s.map(a=>a.name+": "+a.type.replace("array","").replace("<","").replace(">","")).join(`,
	`)}
};

`;const r=`${this.name}Element: array<${e}Element${i}>,`;this.wgslStructFragment+=`struct ${e} {
	${t.map(a=>a.name+": "+a.type).join(`,
	`)}
	${r}
};`;const n=Ce(this);this.wgslGroupFragment=[`${n} ${this.name}: ${e};`]}else{this.wgslStructFragment=`struct ${e} {
	${this.bufferElements.map(n=>n.name+": "+n.type.replace("array","").replace("<","").replace(">","")).join(`,
	`)}
};`;const r=Ce(this);this.wgslGroupFragment=[`${r} ${this.name}: array<${e}${i}>;`]}}else{this.wgslStructFragment=`struct ${e} {
	${this.bufferElements.map(r=>{const n=this.bindingType==="uniform"&&"numElements"in r?`array<${r.type.replace("array","").replace("<","").replace(">","")}, ${r.numElements}>`:r.type;return r.name+": "+n}).join(`,
	`)}
};`;const i=Ce(this);this.wgslGroupFragment=[`${i} ${this.name}: ${e};`]}}else this.wgslStructFragment="",this.wgslGroupFragment=this.bufferElements.map(t=>`${Ce(this)} ${t.name}: ${t.type};`)}shouldUpdateBinding(e=""){this.inputs[e]&&(this.inputs[e].shouldUpdate=!0)}update(){const e=Object.values(this.inputs);for(const t of e){const s=this.bufferElements.find(i=>i.key===t.name);t.shouldUpdate&&s&&(t.onBeforeUpdate&&t.onBeforeUpdate(),s.update(t.value),this.shouldUpdate=!0,t.shouldUpdate=!1)}}extractBufferElementDataFromBufferResult({result:e,bufferElementName:t}){const s=this.bufferElements.find(i=>i.name===t);return s?s.extractDataFromBufferResult(e):e}}class tt extends ce{constructor({label:e="Work",name:t="work",bindingType:s,visibility:i,useStruct:r=!0,access:n="read_write",usage:a=[],struct:h={},shouldCopyResult:u=!1}){s="storage",i=["compute"],super({label:e,name:t,bindingType:s,visibility:i,useStruct:r,access:n,usage:a,struct:h}),this.options={...this.options,shouldCopyResult:u},this.shouldCopyResult=u,this.cacheKey+=`${u},`,this.resultBuffer=new de}}class Re{constructor(e,{label:t="BindGroup",index:s=0,bindings:i=[],uniforms:r,storages:n}={}){this.type="BindGroup",e=e&&e.renderer||e,$(e,this.type),this.renderer=e,this.options={label:t,index:s,bindings:i,...r&&{uniforms:r},...n&&{storages:n}},this.index=s,this.uuid=k(),this.bindings=[],i.length&&this.addBindings(i),(this.options.uniforms||this.options.storages)&&this.setInputBindings(),this.layoutCacheKey="",this.pipelineCacheKey="",this.resetEntries(),this.bindGroupLayout=null,this.bindGroup=null,this.needsPipelineFlush=!1,this.consumers=new Set;for(const a of this.bufferBindings)"buffer"in a&&a.buffer.consumers.add(this.uuid),"resultBuffer"in a&&a.resultBuffer.consumers.add(this.uuid);this.renderer.addBindGroup(this)}setIndex(e){this.index=e}addBindings(e=[]){e.forEach(t=>{"buffer"in t&&(this.renderer.deviceManager.bufferBindings.set(t.cacheKey,t),t.buffer.consumers.add(this.uuid))}),this.bindings=[...this.bindings,...e]}addBinding(e){this.bindings.push(e)}createInputBindings(e="uniform",t={}){let s=[...Object.keys(t).map(i=>{const r=t[i];if(!r.struct)return;const n={label:Xe(r.label||i),name:i,bindingType:e,visibility:r.access==="read_write"?["compute"]:r.visibility,useStruct:!0,access:r.access??"read",...r.usage&&{usage:r.usage},struct:r.struct,...r.shouldCopyResult!==void 0&&{shouldCopyResult:r.shouldCopyResult}};if(r.useStruct!==!1){let h=`${e},${r.visibility===void 0?"all":r.access==="read_write"?"compute":r.visibility},true,${r.access??"read"},`;Object.keys(r.struct).forEach(l=>{h+=`${l},${r.struct[l].type},`}),r.shouldCopyResult!==void 0&&(h+=`${r.shouldCopyResult},`);const u=this.renderer.deviceManager.bufferBindings.get(h);if(u)return u.clone(n)}const a=n.access==="read_write"?tt:ce;return r.useStruct!==!1?new a(n):Object.keys(r.struct).map(h=>(n.label=Xe(r.label?r.label+h:i+h),n.name=i+h,n.useStruct=!1,n.struct={[h]:r.struct[h]},new a(n)))})].flat();return s=s.filter(Boolean),s.forEach(i=>{this.renderer.deviceManager.bufferBindings.set(i.cacheKey,i)}),s}setInputBindings(){this.addBindings([...this.createInputBindings("uniform",this.options.uniforms),...this.createInputBindings("storage",this.options.storages)])}get shouldCreateBindGroup(){return!this.bindGroup&&!!this.bindings.length}resetEntries(){this.entries={bindGroupLayout:[],bindGroup:[]}}createBindGroup(){this.fillEntries(),this.setBindGroupLayout(),this.setBindGroup()}resetBindGroup(){this.entries.bindGroup=[],this.pipelineCacheKey="";for(const e of this.bindings)this.addBindGroupEntry(e);this.setBindGroup()}addBindGroupEntry(e){this.entries.bindGroup.push({binding:this.entries.bindGroup.length,resource:e.resource}),this.pipelineCacheKey+=e.cacheKey}resetBindGroupLayout(){this.entries.bindGroupLayout=[],this.layoutCacheKey="";for(const e of this.bindings)this.addBindGroupLayoutEntry(e);this.setBindGroupLayout()}addBindGroupLayoutEntry(e){this.entries.bindGroupLayout.push({binding:this.entries.bindGroupLayout.length,...e.resourceLayout,visibility:e.visibility}),this.layoutCacheKey+=e.resourceLayoutCacheKey}loseContext(){this.resetEntries();for(const e of this.bufferBindings)e.buffer.reset(),"resultBuffer"in e&&e.resultBuffer.reset();this.bindGroup=null,this.bindGroupLayout=null,this.needsPipelineFlush=!0}restoreContext(){this.shouldCreateBindGroup&&this.createBindGroup();for(const e of this.bufferBindings)e.shouldUpdate=!0}get bufferBindings(){return this.bindings.filter(e=>e instanceof ce||e instanceof tt)}createBindingBuffer(e){e.buffer.createBuffer(this.renderer,{label:this.options.label+": "+e.bindingType+" buffer from: "+e.label,usage:["copySrc","copyDst",e.bindingType,...e.options.usage]}),"resultBuffer"in e&&e.resultBuffer.createBuffer(this.renderer,{label:this.options.label+": Result buffer from: "+e.label,size:e.arrayBuffer.byteLength,usage:["copyDst","mapRead"]})}fillEntries(){for(const e of this.bindings)e.visibility||(e.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE),"buffer"in e&&(e.buffer.GPUBuffer||this.createBindingBuffer(e)),this.addBindGroupLayoutEntry(e),this.addBindGroupEntry(e)}getBindingByName(e=""){return this.bindings.find(t=>t.name===e)}setBindGroupLayout(){const e=this.renderer.deviceManager.bindGroupLayouts.get(this.layoutCacheKey);e?this.bindGroupLayout=e:(this.bindGroupLayout=this.renderer.createBindGroupLayout({label:this.options.label+" layout",entries:this.entries.bindGroupLayout}),this.renderer.deviceManager.bindGroupLayouts.set(this.layoutCacheKey,this.bindGroupLayout))}setBindGroup(){this.bindGroup=this.renderer.createBindGroup({label:this.options.label,layout:this.bindGroupLayout,entries:this.entries.bindGroup})}updateBufferBindings(){this.bindings.forEach((e,t)=>{"buffer"in e&&(e.update(),e.shouldUpdate&&(!e.useStruct&&e.bufferElements.length>1?this.renderer.queueWriteBuffer(e.buffer.GPUBuffer,0,e.bufferElements[t].view):this.renderer.queueWriteBuffer(e.buffer.GPUBuffer,0,e.arrayBuffer)),e.shouldUpdate=!1)})}update(){this.updateBufferBindings();const e=this.bindings.some(s=>s.shouldResetBindGroup),t=this.bindings.some(s=>s.shouldResetBindGroupLayout);(e||t)&&this.renderer.onAfterCommandEncoderSubmission.add(()=>{for(const s of this.bindings)s.shouldResetBindGroup=!1,s.shouldResetBindGroupLayout=!1},{once:!0}),t&&(this.resetBindGroupLayout(),this.needsPipelineFlush=!0),e&&this.resetBindGroup()}clone({bindings:e=[],keepLayout:t=!1}={}){const s={...this.options};s.label+=" (copy)";const i=new this.constructor(this.renderer,{label:s.label});i.setIndex(this.index),i.options=s;const r=e.length?e:this.bindings;for(const n of r)i.addBinding(n),"buffer"in n&&(n.buffer.GPUBuffer||this.createBindingBuffer(n),n.buffer.consumers.add(i.uuid),"resultBuffer"in n&&n.resultBuffer.consumers.add(i.uuid)),t||i.addBindGroupLayoutEntry(n),i.addBindGroupEntry(n);return t&&(i.entries.bindGroupLayout=[...this.entries.bindGroupLayout],i.layoutCacheKey=this.layoutCacheKey),i.setBindGroupLayout(),i.setBindGroup(),i}destroy(){this.renderer.removeBindGroup(this);for(const e of this.bufferBindings)"buffer"in e&&(this.renderer.removeBuffer(e.buffer),e.buffer.consumers.delete(this.uuid),e.buffer.consumers.size||e.buffer.destroy()),"resultBuffer"in e&&(this.renderer.removeBuffer(e.resultBuffer),e.resultBuffer.consumers.delete(this.uuid),e.resultBuffer.consumers.size||e.resultBuffer.destroy());this.bindings=[],this.bindGroupLayout=null,this.bindGroup=null,this.resetEntries()}}class st extends Te{constructor({label:e="Texture",name:t="texture",bindingType:s,visibility:i,texture:r,format:n="rgba8unorm",access:a="write",viewDimension:h="2d",multisampled:u=!1}){s=s??"texture",s==="storage"&&(i=["compute"]),super({label:e,name:t,bindingType:s,visibility:i}),this.options={...this.options,texture:r,format:n,access:a,viewDimension:h,multisampled:u},this.cacheKey+=`${n},${a},${h},${u},`,this.resource=r,this.setWGSLFragment()}get resourceLayout(){return Bs(this)}get resourceLayoutCacheKey(){return Cs(this)}get resource(){return this.texture instanceof GPUTexture?this.texture.createView({label:this.options.label+" view",dimension:this.options.viewDimension}):this.texture instanceof GPUExternalTexture?this.texture:null}set resource(e){(e||this.texture)&&(this.shouldResetBindGroup=!0),this.texture=e}setBindingType(e){e!==this.bindingType&&(e&&(this.shouldResetBindGroupLayout=!0),this.bindingType=e,this.cacheKey=`${this.bindingType},${this.visibility},${this.options.format},${this.options.access},${this.options.viewDimension},${this.options.multisampled},`,this.setWGSLFragment())}setFormat(e){const t=e!==this.options.format;this.options.format=e,t&&this.bindingType==="storage"&&(this.setWGSLFragment(),this.shouldResetBindGroupLayout=!0,this.cacheKey=`${this.bindingType},${this.visibility},${this.options.format},${this.options.access},${this.options.viewDimension},${this.options.multisampled},`)}setMultisampled(e){const t=e!==this.options.multisampled;this.options.multisampled=e,t&&this.bindingType!=="storage"&&(this.setWGSLFragment(),this.shouldResetBindGroupLayout=!0,this.cacheKey=`${this.bindingType},${this.visibility},${this.options.format},${this.options.access},${this.options.viewDimension},${this.options.multisampled},`)}setWGSLFragment(){this.wgslGroupFragment=[`${Ms(this)}`]}}const I=new f,ee=new f,O=new f;class A{constructor(e=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])){this.type="Mat4",this.elements=e}set(e,t,s,i,r,n,a,h,u,l,d,c,p,g,m,y){const b=this.elements;return b[0]=e,b[1]=t,b[2]=s,b[3]=i,b[4]=r,b[5]=n,b[6]=a,b[7]=h,b[8]=u,b[9]=l,b[10]=d,b[11]=c,b[12]=p,b[13]=g,b[14]=m,b[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}setFromArray(e=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])){for(let t=0;t<this.elements.length;t++)this.elements[t]=e[t];return this}copy(e=new A){const t=e.elements;return this.elements[0]=t[0],this.elements[1]=t[1],this.elements[2]=t[2],this.elements[3]=t[3],this.elements[4]=t[4],this.elements[5]=t[5],this.elements[6]=t[6],this.elements[7]=t[7],this.elements[8]=t[8],this.elements[9]=t[9],this.elements[10]=t[10],this.elements[11]=t[11],this.elements[12]=t[12],this.elements[13]=t[13],this.elements[14]=t[14],this.elements[15]=t[15],this}clone(){return new A().copy(this)}multiply(e=new A){return this.multiplyMatrices(this,e)}premultiply(e=new A){return this.multiplyMatrices(e,this)}multiplyMatrices(e=new A,t=new A){const s=e.elements,i=t.elements,r=this.elements,n=s[0],a=s[4],h=s[8],u=s[12],l=s[1],d=s[5],c=s[9],p=s[13],g=s[2],m=s[6],y=s[10],b=s[14],M=s[3],T=s[7],v=s[11],C=s[15],B=i[0],x=i[4],R=i[8],S=i[12],z=i[1],U=i[5],K=i[9],W=i[13],Z=i[2],G=i[6],F=i[10],_=i[14],P=i[3],N=i[7],Q=i[11],ge=i[15];return r[0]=n*B+a*z+h*Z+u*P,r[4]=n*x+a*U+h*G+u*N,r[8]=n*R+a*K+h*F+u*Q,r[12]=n*S+a*W+h*_+u*ge,r[1]=l*B+d*z+c*Z+p*P,r[5]=l*x+d*U+c*G+p*N,r[9]=l*R+d*K+c*F+p*Q,r[13]=l*S+d*W+c*_+p*ge,r[2]=g*B+m*z+y*Z+b*P,r[6]=g*x+m*U+y*G+b*N,r[10]=g*R+m*K+y*F+b*Q,r[14]=g*S+m*W+y*_+b*ge,r[3]=M*B+T*z+v*Z+C*P,r[7]=M*x+T*U+v*G+C*N,r[11]=M*R+T*K+v*F+C*Q,r[15]=M*S+T*W+v*_+C*ge,this}premultiplyTranslate(e=new f){const n=e.x,a=e.y,h=e.z,u=this.elements,l=this.elements,d=u[0],c=u[4],p=u[8],g=u[12],m=u[1],y=u[5],b=u[9],M=u[13],T=u[2],v=u[6],C=u[10],B=u[14],x=u[3],R=u[7],S=u[11],z=u[15];return l[0]=1*d+n*x,l[4]=1*c+n*R,l[8]=1*p+n*S,l[12]=1*g+n*z,l[1]=1*m+a*x,l[5]=1*y+a*R,l[9]=1*b+a*S,l[13]=1*M+a*z,l[2]=1*T+h*x,l[6]=1*v+h*R,l[10]=1*C+h*S,l[14]=1*B+h*z,l[3]=1*x,l[7]=1*R,l[11]=1*S,l[15]=1*z,this}premultiplyScale(e=new f){const t=this.elements,s=this.elements,i=e.x,r=e.y,n=e.z,a=1,h=t[0],u=t[4],l=t[8],d=t[12],c=t[1],p=t[5],g=t[9],m=t[13],y=t[2],b=t[6],M=t[10],T=t[14],v=t[3],C=t[7],B=t[11],x=t[15];return s[0]=i*h,s[4]=i*u,s[8]=i*l,s[12]=i*d,s[1]=r*c,s[5]=r*p,s[9]=r*g,s[13]=r*m,s[2]=n*y,s[6]=n*b,s[10]=n*M,s[14]=n*T,s[3]=a*v,s[7]=a*C,s[11]=a*B,s[15]=a*x,this}invert(){const e=this.elements,t=e[0],s=e[1],i=e[2],r=e[3],n=e[4],a=e[5],h=e[6],u=e[7],l=e[8],d=e[9],c=e[10],p=e[11],g=e[12],m=e[13],y=e[14],b=e[15],M=d*y*u-m*c*u+m*h*p-a*y*p-d*h*b+a*c*b,T=g*c*u-l*y*u-g*h*p+n*y*p+l*h*b-n*c*b,v=l*m*u-g*d*u+g*a*p-n*m*p-l*a*b+n*d*b,C=g*d*h-l*m*h-g*a*c+n*m*c+l*a*y-n*d*y,B=t*M+s*T+i*v+r*C;if(B===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const x=1/B;return e[0]=M*x,e[1]=(m*c*r-d*y*r-m*i*p+s*y*p+d*i*b-s*c*b)*x,e[2]=(a*y*r-m*h*r+m*i*u-s*y*u-a*i*b+s*h*b)*x,e[3]=(d*h*r-a*c*r-d*i*u+s*c*u+a*i*p-s*h*p)*x,e[4]=T*x,e[5]=(l*y*r-g*c*r+g*i*p-t*y*p-l*i*b+t*c*b)*x,e[6]=(g*h*r-n*y*r-g*i*u+t*y*u+n*i*b-t*h*b)*x,e[7]=(n*c*r-l*h*r+l*i*u-t*c*u-n*i*p+t*h*p)*x,e[8]=v*x,e[9]=(g*d*r-l*m*r-g*s*p+t*m*p+l*s*b-t*d*b)*x,e[10]=(n*m*r-g*a*r+g*s*u-t*m*u-n*s*b+t*a*b)*x,e[11]=(l*a*r-n*d*r-l*s*u+t*d*u+n*s*p-t*a*p)*x,e[12]=C*x,e[13]=(l*m*i-g*d*i+g*s*c-t*m*c-l*s*y+t*d*y)*x,e[14]=(g*a*i-n*m*i-g*s*h+t*m*h+n*s*y-t*a*y)*x,e[15]=(n*d*i-l*a*i+l*s*h-t*d*h-n*s*c+t*a*c)*x,this}getInverse(){return this.clone().invert()}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}translate(e=new f){const t=this.elements;return t[12]=t[0]*e.x+t[4]*e.y+t[8]*e.z+t[12],t[13]=t[1]*e.x+t[5]*e.y+t[9]*e.z+t[13],t[14]=t[2]*e.x+t[6]*e.y+t[10]*e.z+t[14],t[15]=t[3]*e.x+t[7]*e.y+t[11]*e.z+t[15],this}getTranslation(e=new f){return e.set(this.elements[12],this.elements[13],this.elements[14])}scale(e=new f){const t=this.elements;return t[0]*=e.x,t[1]*=e.x,t[2]*=e.x,t[3]*=e.x,t[4]*=e.y,t[5]*=e.y,t[6]*=e.y,t[7]*=e.y,t[8]*=e.z,t[9]*=e.z,t[10]*=e.z,t[11]*=e.z,this}rotateFromQuaternion(e=new J){const t=this.elements,s=e.elements[0],i=e.elements[1],r=e.elements[2],n=e.elements[3],a=s+s,h=i+i,u=r+r,l=s*a,d=s*h,c=s*u,p=i*h,g=i*u,m=r*u,y=n*a,b=n*h,M=n*u;return t[0]=1-(p+m),t[4]=d-M,t[8]=c+b,t[1]=d+M,t[5]=1-(l+m),t[9]=g-y,t[2]=c-b,t[6]=g+y,t[10]=1-(l+p),this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],s=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,s,i))}compose(e=new f,t=new J,s=new f(1)){const i=this.elements,r=t.elements[0],n=t.elements[1],a=t.elements[2],h=t.elements[3],u=r+r,l=n+n,d=a+a,c=r*u,p=r*l,g=r*d,m=n*l,y=n*d,b=a*d,M=h*u,T=h*l,v=h*d,C=s.x,B=s.y,x=s.z;return i[0]=(1-(m+b))*C,i[1]=(p+v)*C,i[2]=(g-T)*C,i[3]=0,i[4]=(p-v)*B,i[5]=(1-(c+b))*B,i[6]=(y+M)*B,i[7]=0,i[8]=(g+T)*x,i[9]=(y-M)*x,i[10]=(1-(c+m))*x,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}composeFromOrigin(e=new f,t=new J,s=new f(1),i=new f){const r=this.elements,n=t.elements[0],a=t.elements[1],h=t.elements[2],u=t.elements[3],l=n+n,d=a+a,c=h+h,p=n*l,g=n*d,m=n*c,y=a*d,b=a*c,M=h*c,T=u*l,v=u*d,C=u*c,B=s.x,x=s.y,R=s.z,S=i.x,z=i.y,U=i.z,K=(1-(y+M))*B,W=(g+C)*B,Z=(m-v)*B,G=(g-C)*x,F=(1-(p+M))*x,_=(b+T)*x,P=(m+v)*R,N=(b-T)*R,Q=(1-(p+y))*R;return r[0]=K,r[1]=W,r[2]=Z,r[3]=0,r[4]=G,r[5]=F,r[6]=_,r[7]=0,r[8]=P,r[9]=N,r[10]=Q,r[11]=0,r[12]=e.x+S-(K*S+G*z+P*U),r[13]=e.y+z-(W*S+F*z+N*U),r[14]=e.z+U-(Z*S+_*z+Q*U),r[15]=1,this}lookAt(e=new f,t=new f,s=new f(0,1,0)){const i=this.elements;return O.copy(e).sub(t),O.lengthSq()===0&&(O.z=1),O.normalize(),I.crossVectors(s,O),I.lengthSq()===0&&(Math.abs(s.z)===1?O.x+=1e-4:O.z+=1e-4,O.normalize(),I.crossVectors(s,O)),I.normalize(),ee.crossVectors(O,I),i[0]=I.x,i[1]=I.y,i[2]=I.z,i[3]=0,i[4]=ee.x,i[5]=ee.y,i[6]=ee.z,i[7]=0,i[8]=O.x,i[9]=O.y,i[10]=O.z,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}makeView(e=new f,t=new f,s=new f(0,1,0)){O.copy(e).sub(t).normalize(),I.crossVectors(s,O).normalize(),ee.crossVectors(O,I).normalize();const i=this.elements;return i[0]=I.x,i[1]=ee.x,i[2]=O.x,i[3]=0,i[4]=I.y,i[5]=ee.y,i[6]=O.y,i[7]=0,i[8]=I.z,i[9]=ee.z,i[10]=O.z,i[11]=0,i[12]=-(I.x*e.x+I.y*e.y+I.z*e.z),i[13]=-(ee.x*e.x+ee.y*e.y+ee.z*e.z),i[14]=-(O.x*e.x+O.y*e.y+O.z*e.z),i[15]=1,this}makeOrthographic({left:e,right:t,bottom:s,top:i,near:r,far:n}){const a=this.elements;return a[0]=2/(t-e),a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=2/(i-s),a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=1/(r-n),a[11]=0,a[12]=(t+e)/(e-t),a[13]=(i+s)/(s-i),a[14]=r/(r-n),a[15]=1,this}makePerspective({fov:e,aspect:t,near:s,far:i}){const r=s*Math.tan(Math.PI/180*.5*e),n=2*r,a=t*n,h=-.5*a,u=h+a,l=r-n,d=2*s/(u-h),c=2*s/(r-l),p=(u+h)/(u-h),g=(r+l)/(r-l),m=-i/(i-s),y=-i*s/(i-s);return this.set(d,0,0,0,0,c,0,0,p,g,m,-1,0,0,y,0),this}}let Rs=0;const Ss=new A;class se{constructor(){this._parent=null,this.children=[],this.matricesNeedUpdate=!1,Object.defineProperty(this,"object3DIndex",{value:Rs++}),this.setMatrices(),this.setTransforms()}get parent(){return this._parent}set parent(e){this._parent&&e&&this._parent.object3DIndex===e.object3DIndex||(this._parent&&(this._parent.children=this._parent.children.filter(t=>t.object3DIndex!==this.object3DIndex)),e&&this.shouldUpdateWorldMatrix(),this._parent=e,this._parent?.children.push(this))}setTransforms(){this.transforms={origin:{model:new f},quaternion:new J,rotation:new f,position:{world:new f},scale:new f(1)},this.rotation.onChange(()=>this.applyRotation()),this.position.onChange(()=>this.applyPosition()),this.scale.onChange(()=>this.applyScale()),this.transformOrigin.onChange(()=>this.applyTransformOrigin())}get rotation(){return this.transforms.rotation}set rotation(e){this.transforms.rotation=e,this.applyRotation()}get quaternion(){return this.transforms.quaternion}set quaternion(e){this.transforms.quaternion=e}get position(){return this.transforms.position.world}set position(e){this.transforms.position.world=e}get scale(){return this.transforms.scale}set scale(e){this.transforms.scale=e,this.applyScale()}get transformOrigin(){return this.transforms.origin.model}set transformOrigin(e){this.transforms.origin.model=e}applyRotation(){this.quaternion.setFromVec3(this.rotation),this.shouldUpdateModelMatrix()}applyPosition(){this.shouldUpdateModelMatrix()}applyScale(){this.shouldUpdateModelMatrix()}applyTransformOrigin(){this.shouldUpdateModelMatrix()}setMatrices(){this.matrices={model:{matrix:new A,shouldUpdate:!0,onUpdate:()=>this.updateModelMatrix()},world:{matrix:new A,shouldUpdate:!0,onUpdate:()=>this.updateWorldMatrix()}}}get modelMatrix(){return this.matrices.model.matrix}set modelMatrix(e){this.matrices.model.matrix=e,this.shouldUpdateModelMatrix()}shouldUpdateModelMatrix(){this.matrices.model.shouldUpdate=!0,this.shouldUpdateWorldMatrix()}get worldMatrix(){return this.matrices.world.matrix}set worldMatrix(e){this.matrices.world.matrix=e,this.shouldUpdateWorldMatrix()}shouldUpdateWorldMatrix(){this.matrices.world.shouldUpdate=!0}lookAt(e=new f,t=this.position){const s=Ss.lookAt(e,t);this.quaternion.setFromRotationMatrix(s),this.shouldUpdateModelMatrix()}updateModelMatrix(){this.modelMatrix=this.modelMatrix.composeFromOrigin(this.position,this.quaternion,this.scale,this.transformOrigin),this.shouldUpdateWorldMatrix()}updateWorldMatrix(){this.parent?this.worldMatrix.multiplyMatrices(this.parent.worldMatrix,this.modelMatrix):this.worldMatrix.copy(this.modelMatrix);for(let e=0,t=this.children.length;e<t;e++)this.children[e].shouldUpdateWorldMatrix()}shouldUpdateMatrices(){this.matricesNeedUpdate=!!Object.values(this.matrices).find(e=>e.shouldUpdate)}updateMatrixStack(){if(this.shouldUpdateMatrices(),this.matricesNeedUpdate)for(const e in this.matrices)this.matrices[e].shouldUpdate&&(this.matrices[e].onUpdate(),this.matrices[e].shouldUpdate=!1);for(let e=0,t=this.children.length;e<t;e++)this.children[e].updateMatrixStack()}destroy(){for(let e=0,t=this.children.length;e<t;e++)this.children[e]&&(this.children[e].parent=null);this.parent=null}}const zs=new Map([["copySrc",GPUTextureUsage.COPY_SRC],["copyDst",GPUTextureUsage.COPY_DST],["renderAttachment",GPUTextureUsage.RENDER_ATTACHMENT],["storageBinding",GPUTextureUsage.STORAGE_BINDING],["textureBinding",GPUTextureUsage.TEXTURE_BINDING]]),Es=(o=[])=>o.reduce((e,t)=>e|zs.get(t),0),Gs=(o=[],e)=>o.length?Es(o):e!=="storage"?GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,Gt=(...o)=>{const e=Math.max(...o);return 1+Math.log2(e)|0};var Os=(o,e,t)=>{if(!e.has(o))throw TypeError("Cannot "+t)},Y=(o,e,t)=>(Os(o,e,"read from private field"),t?t.call(o):e.get(o)),Se=(o,e,t)=>{if(e.has(o))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(o):e.set(o,t)},oe,ae,ze,Ee;const Ot={name:"texture",generateMips:!1,flipY:!1,format:"rgba8unorm",premultipliedAlpha:!1,placeholderColor:[0,0,0,255],useExternalTextures:!0,fromTexture:null,viewDimension:"2d",visibility:["fragment"],cache:!0};class he extends se{constructor(e,t=Ot){super(),Se(this,oe,new f(1)),Se(this,ae,new f(1)),Se(this,ze,new f(1)),Se(this,Ee,new A),this._onSourceLoadedCallback=()=>{},this._onSourceUploadedCallback=()=>{},this.type="Texture",e=e&&e.renderer||e,$(e,t.label?t.label+" "+this.type:this.type),this.renderer=e,this.uuid=k();const s={...Ot,source:t.fromTexture?t.fromTexture.options.source:null,sourceType:t.fromTexture?t.fromTexture.options.sourceType:null};this.options={...s,...t},this.options.label=this.options.label??this.options.name,this.texture=null,this.externalTexture=null,this.source=null,this.size={width:1,height:1,depth:1},this.textureMatrix=new ce({label:this.options.label+": model matrix",name:this.options.name+"Matrix",useStruct:!1,struct:{[this.options.name+"Matrix"]:{type:"mat4x4f",value:this.modelMatrix}}}),this.renderer.deviceManager.bufferBindings.set(this.textureMatrix.cacheKey,this.textureMatrix),this.setBindings(),this._parentMesh=null,this.sourceLoaded=!1,this.sourceUploaded=!1,this.shouldUpdate=!1,this.renderer.addDOMTexture(this),this.createTexture()}setBindings(){this.bindings=[new st({label:this.options.label+": texture",name:this.options.name,bindingType:this.options.sourceType==="externalVideo"?"externalTexture":"texture",visibility:this.options.visibility,texture:this.options.sourceType==="externalVideo"?this.externalTexture:this.texture,viewDimension:this.options.viewDimension}),this.textureMatrix]}get textureBinding(){return this.bindings[0]}get parentMesh(){return this._parentMesh}set parentMesh(e){this._parentMesh=e,this.resize()}get sourceLoaded(){return this._sourceLoaded}set sourceLoaded(e){e&&!this.sourceLoaded&&this._onSourceLoadedCallback&&this._onSourceLoadedCallback(),this._sourceLoaded=e}get sourceUploaded(){return this._sourceUploaded}set sourceUploaded(e){e&&!this.sourceUploaded&&this._onSourceUploadedCallback&&this._onSourceUploadedCallback(),this._sourceUploaded=e}setTransforms(){super.setTransforms(),this.transforms.quaternion.setAxisOrder("ZXY"),this.transforms.origin.model.set(.5,.5,0)}updateModelMatrix(){if(!this.parentMesh)return;const e=this.parentMesh.scale?this.parentMesh.scale:new f(1,1,1),t=this.parentMesh.boundingRect?this.parentMesh.boundingRect.width*e.x:this.size.width,s=this.parentMesh.boundingRect?this.parentMesh.boundingRect.height*e.y:this.size.height,i=t/s,r=this.size.width/this.size.height;t>s?(Y(this,oe).set(i,1,1),Y(this,ae).set(1/r,1,1)):(Y(this,oe).set(1,1/i,1),Y(this,ae).set(1,r,1));const n=i>r!=t>s?1:t>s?Y(this,oe).x*Y(this,ae).x:Y(this,ae).y*Y(this,oe).y;Y(this,ze).set(1/(n*this.scale.x),1/(n*this.scale.y),1),Y(this,Ee).rotateFromQuaternion(this.quaternion),this.modelMatrix.identity().premultiplyTranslate(this.transformOrigin.clone().multiplyScalar(-1)).premultiplyScale(Y(this,ze)).premultiplyScale(Y(this,oe)).premultiply(Y(this,Ee)).premultiplyScale(Y(this,ae)).premultiplyTranslate(this.transformOrigin).translate(this.position)}updateMatrixStack(){super.updateMatrixStack(),this.matricesNeedUpdate&&this.textureMatrix.shouldUpdateBinding(this.options.name+"Matrix")}resize(){this.source&&this.source instanceof HTMLCanvasElement&&(this.source.width!==this.size.width||this.source.height!==this.size.height)&&(this.setSourceSize(),this.createTexture()),this.shouldUpdateModelMatrix()}uploadTexture(){this.renderer.uploadTexture(this),this.shouldUpdate=!1}uploadVideoTexture(){this.externalTexture=this.renderer.importExternalTexture(this.source),this.textureBinding.resource=this.externalTexture,this.textureBinding.setBindingType("externalTexture"),this.shouldUpdate=!1,this.sourceUploaded=!0}copy(e){if(this.options.sourceType==="externalVideo"&&e.options.sourceType!=="externalVideo"){D(`${this.options.label}: cannot copy a GPUTexture to a GPUExternalTexture`);return}else if(this.options.sourceType!=="externalVideo"&&e.options.sourceType==="externalVideo"){D(`${this.options.label}: cannot copy a GPUExternalTexture to a GPUTexture`);return}this.options.fromTexture=e,this.options.sourceType=e.options.sourceType,this.options.generateMips=e.options.generateMips,this.options.flipY=e.options.flipY,this.options.format=e.options.format,this.options.premultipliedAlpha=e.options.premultipliedAlpha,this.options.placeholderColor=e.options.placeholderColor,this.options.useExternalTextures=e.options.useExternalTextures,this.sourceLoaded=e.sourceLoaded,this.sourceUploaded=e.sourceUploaded,e.texture&&(e.sourceLoaded&&(this.size=e.size,this.source=e.source,this.resize()),e.sourceUploaded?(this.texture=e.texture,this.textureBinding.resource=this.texture):this.createTexture())}createTexture(){const e={label:this.options.label,format:this.options.format,size:[this.size.width,this.size.height,this.size.depth],dimensions:this.options.viewDimension==="1d"?"1d":this.options.viewDimension==="3d"?"3d":"2d",usage:this.source?GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST};this.options.sourceType!=="externalVideo"&&(e.mipLevelCount=this.options.generateMips?Gt(this.size.width,this.size.height):1,this.texture?.destroy(),this.texture=this.renderer.createTexture(e),this.textureBinding.resource=this.texture),this.shouldUpdate=!0}setSourceSize(){this.size={width:this.source.naturalWidth||this.source.width||this.source.videoWidth,height:this.source.naturalHeight||this.source.height||this.source.videoHeight,depth:1}}async loadImageBitmap(e){const s=await(await fetch(e)).blob();return await createImageBitmap(s,{colorSpaceConversion:"none"})}async loadImage(e){const t=typeof e=="string"?e:e.getAttribute("src");this.options.source=t,this.options.sourceType="image";const s=this.renderer.domTextures.find(i=>i.options.source===t);if(s&&s.texture&&s.sourceUploaded){this.copy(s);return}this.sourceLoaded=!1,this.sourceUploaded=!1,this.source=await this.loadImageBitmap(this.options.source),this.setSourceSize(),this.resize(),this.sourceLoaded=!0,this.createTexture()}onVideoFrameCallback(){this.videoFrameCallbackId&&(this.shouldUpdate=!0,this.source.requestVideoFrameCallback(this.onVideoFrameCallback.bind(this)))}onVideoLoaded(e){this.sourceLoaded||(this.source=e,this.setSourceSize(),this.resize(),this.options.useExternalTextures?(this.options.sourceType="externalVideo",this.texture?.destroy()):(this.options.sourceType="video",this.createTexture()),"requestVideoFrameCallback"in HTMLVideoElement.prototype&&(this.videoFrameCallbackId=this.source.requestVideoFrameCallback(this.onVideoFrameCallback.bind(this))),this.sourceLoaded=!0)}get isVideoSource(){return this.source&&(this.options.sourceType==="video"||this.options.sourceType==="externalVideo")}loadVideo(e){let t;typeof e=="string"?(t=document.createElement("video"),t.src=e):t=e,t.preload="auto",t.muted=!0,t.loop=!0,t.crossOrigin="anonymous",t.setAttribute("playsinline",""),this.options.source=t.src,this.sourceLoaded=!1,this.sourceUploaded=!1,t.readyState>=t.HAVE_ENOUGH_DATA?this.onVideoLoaded(t):t.addEventListener("canplaythrough",this.onVideoLoaded.bind(this,t),{once:!0}),isNaN(t.duration)&&t.load()}loadCanvas(e){this.options.source=e,this.options.sourceType="canvas",this.sourceLoaded=!1,this.sourceUploaded=!1,this.source=e,this.setSourceSize(),this.resize(),this.sourceLoaded=!0,this.createTexture()}onSourceLoaded(e){return e&&(this._onSourceLoadedCallback=e),this}onSourceUploaded(e){return e&&(this._onSourceUploadedCallback=e),this}render(){this.updateMatrixStack(),this.textureMatrix.update(),this.options.sourceType==="externalVideo"&&(this.shouldUpdate=!0),this.isVideoSource&&!this.videoFrameCallbackId&&this.source.readyState>=this.source.HAVE_CURRENT_DATA&&!this.source.paused&&(this.shouldUpdate=!0),this.shouldUpdate&&this.options.sourceType&&this.options.sourceType!=="externalVideo"&&this.uploadTexture()}destroy(){this.videoFrameCallbackId&&this.source.cancelVideoFrameCallback(this.videoFrameCallbackId),this.isVideoSource&&this.source.removeEventListener("canplaythrough",this.onVideoLoaded.bind(this,this.source),{once:!0}),this.renderer.removeDOMTexture(this),this.texture?.destroy(),this.texture=null}}oe=new WeakMap,ae=new WeakMap,ze=new WeakMap,Ee=new WeakMap;class it extends Re{constructor(e,{label:t,index:s=0,bindings:i=[],uniforms:r,storages:n,textures:a=[],samplers:h=[]}={}){const u="TextureBindGroup";if(e=e&&e.renderer||e,$(e,u),super(e,{label:t,index:s,bindings:i,uniforms:r,storages:n}),this.options={...this.options,textures:[],samplers:[]},a.length)for(const l of a)this.addTexture(l);if(h.length)for(const l of h)this.addSampler(l);this.type=u}addTexture(e){this.textures.push(e),this.addBindings([...e.bindings])}get textures(){return this.options.textures}addSampler(e){this.samplers.push(e),this.addBindings([e.binding])}get samplers(){return this.options.samplers}get shouldCreateBindGroup(){return!this.bindGroup&&!!this.bindings.length&&!this.textures.find(e=>!(e.texture||e.externalTexture))&&!this.samplers.find(e=>!e.sampler)}updateTextures(){for(const e of this.textures)e instanceof he&&(e.options.fromTexture&&e.options.fromTexture.sourceUploaded&&!e.sourceUploaded&&e.copy(e.options.fromTexture),e.shouldUpdate&&e.options.sourceType&&e.options.sourceType==="externalVideo"&&e.uploadVideoTexture())}update(){this.updateTextures(),super.update()}destroy(){super.destroy(),this.options.textures=[],this.options.samplers=[]}}class At extends Te{constructor({label:e="Sampler",name:t="sampler",bindingType:s,visibility:i,sampler:r,type:n="filtering"}){s=s??"sampler",super({label:e,name:t,bindingType:s,visibility:i}),this.cacheKey+=`${n},`,this.options={...this.options,sampler:r,type:n},this.resource=r,this.setWGSLFragment()}get resourceLayout(){return{sampler:{type:this.options.type}}}get resourceLayoutCacheKey(){return`sampler,${this.options.type},${this.visibility},`}get resource(){return this.sampler}set resource(e){e&&this.sampler&&(this.shouldResetBindGroup=!0),this.sampler=e}setWGSLFragment(){this.wgslGroupFragment=[`var ${this.name}: ${this.options.type==="comparison"?`${this.bindingType}_comparison`:this.bindingType};`]}}var Ut=(o,e,t)=>{if(!e.has(o))throw TypeError("Cannot "+t)},Ge=(o,e,t)=>(Ut(o,e,"read from private field"),t?t.call(o):e.get(o)),Oe=(o,e,t)=>{if(e.has(o))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(o):e.set(o,t)},Ae=(o,e,t,s)=>(Ut(o,e,"write to private field"),s?s.call(o,t):e.set(o,t),t),Ue,Fe,_e,$e;class Ft extends se{constructor({fov:e=50,near:t=.1,far:s=150,width:i=1,height:r=1,pixelRatio:n=1,onMatricesChanged:a=()=>{}}={}){super(),Oe(this,Ue,void 0),Oe(this,Fe,void 0),Oe(this,_e,void 0),Oe(this,$e,void 0),this.position.set(0,0,10),this.onMatricesChanged=a,this.size={width:1,height:1},this.setPerspective({fov:e,near:t,far:s,width:i,height:r,pixelRatio:n})}setMatrices(){super.setMatrices(),this.matrices={...this.matrices,view:{matrix:new A,shouldUpdate:!0,onUpdate:()=>{this.viewMatrix.copy(this.worldMatrix).invert()}},projection:{matrix:new A,shouldUpdate:!0,onUpdate:()=>this.updateProjectionMatrix()}}}get viewMatrix(){return this.matrices.view.matrix}set viewMatrix(e){this.matrices.view.matrix=e,this.matrices.view.shouldUpdate=!0}get projectionMatrix(){return this.matrices.projection.matrix}set projectionMatrix(e){this.matrices.projection.matrix=e,this.shouldUpdateProjectionMatrix()}shouldUpdateProjectionMatrix(){this.matrices.projection.shouldUpdate=!0}updateModelMatrix(){super.updateModelMatrix(),this.setScreenRatios(),this.matrices.view.shouldUpdate=!0}updateWorldMatrix(){super.updateWorldMatrix(),this.matrices.view.shouldUpdate=!0}updateMatrixStack(){super.updateMatrixStack(),this.matricesNeedUpdate&&this.onMatricesChanged()}get fov(){return Ge(this,Ue)}set fov(e){e=Math.max(1,Math.min(e??this.fov,179)),e!==this.fov&&(Ae(this,Ue,e),this.shouldUpdateProjectionMatrix()),this.setScreenRatios(),this.setCSSPerspective()}get near(){return Ge(this,Fe)}set near(e){e=Math.max(e??this.near,.01),e!==this.near&&(Ae(this,Fe,e),this.shouldUpdateProjectionMatrix())}get far(){return Ge(this,_e)}set far(e){e=Math.max(e??this.far,this.near+1),e!==this.far&&(Ae(this,_e,e),this.shouldUpdateProjectionMatrix())}get pixelRatio(){return Ge(this,$e)}set pixelRatio(e){Ae(this,$e,e??this.pixelRatio),this.setCSSPerspective()}setSize({width:e,height:t}){(e!==this.size.width||t!==this.size.height)&&this.shouldUpdateProjectionMatrix(),this.size.width=e,this.size.height=t,this.setScreenRatios(),this.setCSSPerspective()}setPerspective({fov:e=this.fov,near:t=this.near,far:s=this.far,width:i=this.size.width,height:r=this.size.height,pixelRatio:n=this.pixelRatio}={}){this.setSize({width:i,height:r}),this.pixelRatio=n,this.fov=e,this.near=t,this.far=s}setCSSPerspective(){this.CSSPerspective=Math.pow(Math.pow(this.size.width/(2*this.pixelRatio),2)+Math.pow(this.size.height/(2*this.pixelRatio),2),.5)/Math.tan(this.fov*.5*Math.PI/180)}getScreenRatiosAtDepth(e=0){const t=this.position.z;e<t?e-=t:e+=t;const s=this.fov*Math.PI/180,i=2*Math.tan(s/2)*Math.abs(e);return{width:i*this.size.width/this.size.height,height:i}}setScreenRatios(){this.screenRatio=this.getScreenRatiosAtDepth()}lookAt(e=new f,t=this.position){super.lookAt(t,e)}updateProjectionMatrix(){this.projectionMatrix.makePerspective({fov:this.fov,aspect:this.size.width/this.size.height,near:this.near,far:this.far})}}Ue=new WeakMap,Fe=new WeakMap,_e=new WeakMap,$e=new WeakMap;class Le{constructor(e,{label:t="Sampler",name:s,addressModeU:i="repeat",addressModeV:r="repeat",magFilter:n="linear",minFilter:a="linear",mipmapFilter:h="linear",maxAnisotropy:u=1,type:l="filtering",compare:d=null}={}){this.type="Sampler",this.uuid=k(),e=e&&e.renderer||e,$(e,t?t+" "+this.type:this.type),this.renderer=e,this.label=t,!s&&!this.renderer.production&&(s="sampler"+this.renderer.samplers.length,D(`Sampler: you are trying to create a sampler without the mandatory name parameter. A default name will be used instead: ${s}`)),this.name=s,this.options={addressModeU:i,addressModeV:r,magFilter:n,minFilter:a,mipmapFilter:h,maxAnisotropy:u,type:l,...d!==null&&{compare:d}},this.createSampler(),this.createBinding()}createSampler(){this.sampler=this.renderer.createSampler(this)}createBinding(){this.binding=new At({label:this.label,name:this.name,bindingType:"sampler",sampler:this.sampler,type:this.options.type})}}var _t=(o,e,t)=>{if(!e.has(o))throw TypeError("Cannot "+t)},As=(o,e,t)=>(_t(o,e,"read from private field"),t?t.call(o):e.get(o)),Us=(o,e,t)=>{if(e.has(o))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(o):e.set(o,t)},Fs=(o,e,t,s)=>(_t(o,e,"write to private field"),s?s.call(o,t):e.set(o,t),t),De;const $t={label:"Texture",name:"renderTexture",type:"texture",access:"write",fromTexture:null,viewDimension:"2d",sampleCount:1,qualityRatio:1,generateMips:!1,flipY:!1,premultipliedAlpha:!1};class te{constructor(e,t=$t){Us(this,De,!0),e=e&&e.renderer||e,$(e,t.label?t.label+" Texture":"Texture"),this.type="Texture",this.renderer=e,this.uuid=k(),this.options={...$t,...t},t.fromTexture&&(this.options.format=t.fromTexture.texture.format,this.options.sampleCount=t.fromTexture.texture.sampleCount,this.options.viewDimension=t.fromTexture.options.viewDimension),this.options.format||(this.options.format=this.renderer.options.preferredFormat),this.size=this.options.fixedSize?{width:this.options.fixedSize.width*this.options.qualityRatio,height:this.options.fixedSize.height*this.options.qualityRatio,depth:this.options.fixedSize.depth??this.options.viewDimension.indexOf("cube")!==-1?6:1}:{width:Math.floor(this.renderer.canvas.width*this.options.qualityRatio),height:Math.floor(this.renderer.canvas.height*this.options.qualityRatio),depth:this.options.viewDimension.indexOf("cube")!==-1?6:1},this.options.fixedSize&&Fs(this,De,!1),this.setBindings(),this.renderer.addTexture(this),this.createTexture()}copy(e){this.options.fromTexture=e,this.createTexture()}copyGPUTexture(e){this.size={width:e.width,height:e.height,depth:e.depthOrArrayLayers},this.options.format=e.format,this.options.sampleCount=e.sampleCount,this.texture=e,this.textureBinding.setFormat(this.options.format),this.textureBinding.setMultisampled(this.options.sampleCount>1),this.textureBinding.resource=this.texture}createTexture(){if(!(!this.size.width||!this.size.height)){if(this.options.fromTexture){this.copyGPUTexture(this.options.fromTexture.texture);return}this.texture?.destroy(),this.texture=this.renderer.createTexture({label:this.options.label,format:this.options.format,size:[this.size.width,this.size.height,this.size.depth??1],dimensions:this.options.viewDimension,sampleCount:this.options.sampleCount,mipLevelCount:this.options.generateMips?Gt(this.size.width,this.size.height,this.size.depth??1):1,usage:Gs(this.options.usage,this.options.type)}),this.textureBinding.resource=this.texture}}uploadSource({source:e,width:t=this.size.width,height:s=this.size.height,depth:i=this.size.depth,origin:r=[0,0,0]}){this.renderer.device.queue.copyExternalImageToTexture({source:e,flipY:this.options.flipY},{texture:this.texture,premultipliedAlpha:this.options.premultipliedAlpha,origin:r},[t,s,i]),this.texture.mipLevelCount>1&&Pt(this.renderer.device,this.texture)}setBindings(){this.bindings=[new st({label:this.options.label+": "+this.options.name+" texture",name:this.options.name,bindingType:this.options.type,visibility:this.options.visibility,texture:this.texture,format:this.options.format,viewDimension:this.options.viewDimension,multisampled:this.options.sampleCount>1})]}get textureBinding(){return this.bindings[0]}resize(e=null){As(this,De)&&(e||(e={width:Math.floor(this.renderer.canvas.width*this.options.qualityRatio),height:Math.floor(this.renderer.canvas.height*this.options.qualityRatio),depth:1}),!(e.width===this.size.width&&e.height===this.size.height&&e.depth===this.size.depth)&&(this.size=e,this.createTexture()))}destroy(){this.renderer.removeTexture(this),this.options.fromTexture||this.texture?.destroy(),this.texture=null}}De=new WeakMap;class rt{constructor(e,t){this.type="Material",e=e&&e.renderer||e,$(e,this.type),this.renderer=e,this.uuid=k();const{shaders:s,label:i,useAsyncPipeline:r,uniforms:n,storages:a,bindings:h,bindGroups:u,samplers:l,textures:d,domTextures:c}=t;this.options={shaders:s,label:i,useAsyncPipeline:r===void 0?!0:r,...n!==void 0&&{uniforms:n},...a!==void 0&&{storages:a},...h!==void 0&&{bindings:h},...u!==void 0&&{bindGroups:u},...l!==void 0&&{samplers:l},...d!==void 0&&{textures:d},...c!==void 0&&{domTextures:c}},this.bindGroups=[],this.texturesBindGroups=[],this.clonedBindGroups=[],this.setBindGroups(),this.setTextures(),this.setSamplers()}compileMaterial(){const e=this.texturesBindGroup.bindings.length?1:0;this.bindGroups.length>=this.inputsBindGroups.length+e||this.createBindGroups()}get ready(){return!!(this.renderer.ready&&this.pipelineEntry&&this.pipelineEntry.pipeline&&this.pipelineEntry.ready)}loseContext(){for(const e of this.domTextures)e.texture=null,e.sourceUploaded=!1;for(const e of this.textures)e.texture=null;[...this.bindGroups,...this.clonedBindGroups,...this.inputsBindGroups].forEach(e=>e.loseContext()),this.pipelineEntry.pipeline=null}restoreContext(){for(const e of this.samplers)e.createSampler(),e.binding.resource=e.sampler;for(const e of this.domTextures)e.createTexture(),e.resize();for(const e of this.textures)e.resize(e.size);[...this.bindGroups,...this.clonedBindGroups,...this.inputsBindGroups].forEach(e=>{e.restoreContext()})}getShaderCode(e="full"){return this.pipelineEntry?(e=(()=>{switch(e){case"vertex":case"fragment":case"compute":case"full":return e;default:return"full"}})(),this.pipelineEntry.shaders[e].code):""}getAddedShaderCode(e="vertex"){return this.pipelineEntry?(e=(()=>{switch(e){case"vertex":case"fragment":case"compute":return e;default:return"vertex"}})(),this.pipelineEntry.shaders[e].head):""}setBindGroups(){if(this.uniforms={},this.storages={},this.inputsBindGroups=[],this.inputsBindings=new Map,this.options.uniforms||this.options.storages||this.options.bindings){const e=new Re(this.renderer,{label:this.options.label+": Bindings bind group",uniforms:this.options.uniforms,storages:this.options.storages,bindings:this.options.bindings});this.processBindGroupBindings(e),this.inputsBindGroups.push(e),e.consumers.add(this.uuid)}this.options.bindGroups?.forEach(e=>{this.processBindGroupBindings(e),this.inputsBindGroups.push(e),e.consumers.add(this.uuid)})}get texturesBindGroup(){return this.texturesBindGroups[0]}processBindGroupBindings(e){for(const t of e.bindings)t.bindingType==="uniform"&&(this.uniforms={...this.uniforms,[t.name]:t.inputs}),t.bindingType==="storage"&&(this.storages={...this.storages,[t.name]:t.inputs}),this.inputsBindings.set(t.name,t)}createBindGroups(){this.texturesBindGroup.shouldCreateBindGroup&&(this.texturesBindGroup.setIndex(this.bindGroups.length),this.texturesBindGroup.createBindGroup(),this.bindGroups.push(this.texturesBindGroup));for(const e of this.inputsBindGroups)e.shouldCreateBindGroup&&(e.setIndex(this.bindGroups.length),e.createBindGroup(),this.bindGroups.push(e));this.options.bindGroups?.forEach(e=>{if(!e.shouldCreateBindGroup&&!this.bindGroups.find(t=>t.uuid===e.uuid)&&(e.setIndex(this.bindGroups.length),this.bindGroups.push(e)),e instanceof it&&!this.texturesBindGroups.find(t=>t.uuid===e.uuid)){this.texturesBindGroups.push(e);for(const t of e.textures)t instanceof he&&!this.domTextures.find(s=>s.uuid===t.uuid)?this.domTextures.push(t):t instanceof te&&!this.textures.find(s=>s.uuid===t.uuid)&&this.textures.push(t)}})}cloneBindGroup({bindGroup:e,bindings:t=[],keepLayout:s=!0}){if(!e)return null;const i=e.clone({bindings:t,keepLayout:s});return this.clonedBindGroups.push(i),i}getBindGroupByBindingName(e=""){return(this.ready?this.bindGroups:this.inputsBindGroups).find(t=>t.bindings.find(s=>s.name===e))}destroyBindGroup(e){e.consumers.delete(this.uuid),e.consumers.size||e.destroy()}destroyBindGroups(){this.bindGroups.forEach(e=>this.destroyBindGroup(e)),this.clonedBindGroups.forEach(e=>this.destroyBindGroup(e)),this.texturesBindGroups.forEach(e=>this.destroyBindGroup(e)),this.texturesBindGroups=[],this.inputsBindGroups=[],this.bindGroups=[],this.clonedBindGroups=[]}updateBindGroups(){for(const e of this.bindGroups)e.update(),e.needsPipelineFlush&&this.pipelineEntry.ready&&(this.pipelineEntry.flushPipelineEntry(this.bindGroups),e.needsPipelineFlush=!1)}getBindingByName(e=""){return this.inputsBindings.get(e)}getBufferBindingByName(e=""){const t=this.getBindingByName(e);return t&&"buffer"in t?t:void 0}shouldUpdateInputsBindings(e,t){if(!e)return;const s=this.getBindingByName(e);s&&(t?s.shouldUpdateBinding(t):Object.keys(s.inputs).forEach(i=>s.shouldUpdateBinding(i)))}setTextures(){this.domTextures=[],this.textures=[],this.texturesBindGroups.push(new it(this.renderer,{label:this.options.label+": Textures bind group"})),this.texturesBindGroup.consumers.add(this.uuid),this.options.domTextures?.forEach(e=>{this.addTexture(e)}),this.options.textures?.forEach(e=>{this.addTexture(e)})}addTexture(e){e instanceof he?this.domTextures.push(e):e instanceof te&&this.textures.push(e),(this.options.shaders.vertex&&this.options.shaders.vertex.code.indexOf(e.options.name)!==-1||this.options.shaders.fragment&&this.options.shaders.fragment.code.indexOf(e.options.name)!==-1||this.options.shaders.compute&&this.options.shaders.compute.code.indexOf(e.options.name)!==-1)&&this.texturesBindGroup.addTexture(e)}destroyTexture(e){if(e.options.cache)return;const t=this.renderer.getObjectsByTexture(e);(!t||!t.some(i=>i.material.uuid!==this.uuid))&&e.destroy()}destroyTextures(){this.domTextures?.forEach(e=>this.destroyTexture(e)),this.textures?.forEach(e=>this.destroyTexture(e)),this.domTextures=[],this.textures=[]}setSamplers(){if(this.samplers=[],this.options.samplers?.forEach(t=>{this.addSampler(t)}),!this.samplers.find(t=>t.name==="defaultSampler")){const t=new Le(this.renderer,{label:"Default sampler",name:"defaultSampler"});this.addSampler(t)}}addSampler(e){this.samplers.push(e),(this.options.shaders.vertex&&this.options.shaders.vertex.code.indexOf(e.name)!==-1||this.options.shaders.fragment&&this.options.shaders.fragment.code.indexOf(e.name)!==-1||this.options.shaders.compute&&this.options.shaders.compute.code.indexOf(e.name)!==-1)&&this.texturesBindGroup.addSampler(e)}async getBufferResult(e){return await e.mapBufferAsync()}async getBufferBindingResultByBindingName(e=""){const t=this.getBufferBindingByName(e);if(t&&"buffer"in t){const s=this.renderer.copyBufferToBuffer({srcBuffer:t.buffer});return await this.getBufferResult(s)}else return new Float32Array(0)}async getBufferElementResultByNames({bindingName:e,bufferElementName:t}){const s=await this.getBufferBindingResultByBindingName(e);if(!t||s.length)return s;{const i=this.getBufferBindingByName(e);return i?i.extractBufferElementDataFromBufferResult({result:s,bufferElementName:t}):s}}onBeforeRender(){this.compileMaterial();for(const e of this.domTextures)e.render();this.updateBindGroups()}setPipeline(e){this.renderer.pipelineManager.setCurrentPipeline(e,this.pipelineEntry)}setActiveBindGroups(e){this.renderer.pipelineManager.setActiveBindGroups(e,this.bindGroups)}render(e){this.ready&&(this.setPipeline(e),this.setActiveBindGroups(e))}destroy(){this.destroyBindGroups(),this.destroyTextures()}}class Lt extends rt{constructor(e,t){e=e&&e.renderer||e;const s="ComputeMaterial";$(e,s),super(e,t),this.type=s,this.renderer=e;let{shaders:i,dispatchSize:r}=t;(!i||!i.compute)&&(i={compute:{code:"",entryPoint:"main"}}),i.compute.code||(i.compute.code="@compute @workgroup_size(1) fn main(){}"),i.compute.entryPoint||(i.compute.entryPoint="main"),this.options={...this.options,shaders:i,...t.dispatchSize!==void 0&&{dispatchSize:t.dispatchSize}},r||(r=1),Array.isArray(r)?(r[0]=Math.ceil(r[0]??1),r[1]=Math.ceil(r[1]??1),r[2]=Math.ceil(r[2]??1)):isNaN(r)||(r=[Math.ceil(r),1,1]),this.dispatchSize=r,this.pipelineEntry=this.renderer.pipelineManager.createComputePipeline({renderer:this.renderer,label:this.options.label+" compute pipeline",shaders:this.options.shaders,useAsync:this.options.useAsyncPipeline})}setPipelineEntryProperties(){this.pipelineEntry.setPipelineEntryProperties({bindGroups:this.bindGroups})}async compilePipelineEntry(){await this.pipelineEntry.compilePipelineEntry()}async compileMaterial(){super.compileMaterial(),this.pipelineEntry&&this.pipelineEntry.canCompile&&(this.setPipelineEntryProperties(),await this.compilePipelineEntry())}getShaderCode(e="compute"){return super.getShaderCode(e)}getAddedShaderCode(e="compute"){return super.getAddedShaderCode(e)}useCustomRender(e){e&&(this._useCustomRenderCallback=e)}render(e){if(this.ready)if(this.setPipeline(e),this._useCustomRenderCallback!==void 0)this._useCustomRenderCallback(e);else{for(const t of this.bindGroups)e.setBindGroup(t.index,t.bindGroup);e.dispatchWorkgroups(this.dispatchSize[0],this.dispatchSize[1],this.dispatchSize[2])}}copyBufferToResult(e){for(const t of this.bindGroups)t.bufferBindings.forEach(s=>{s.shouldCopyResult&&this.renderer.copyBufferToBuffer({srcBuffer:s.buffer,dstBuffer:s.resultBuffer,commandEncoder:e})})}async getComputeResult({bindingName:e="",bufferElementName:t=""}){const s=this.getBufferBindingByName(e);if(s&&"resultBuffer"in s){const i=await this.getBufferResult(s.resultBuffer);return t&&i.length?s.extractBufferElementDataFromBufferResult({result:i,bufferElementName:t}):i}else return new Float32Array(0)}}var Dt=(o,e,t)=>{if(!e.has(o))throw TypeError("Cannot "+t)},kt=(o,e,t)=>(Dt(o,e,"read from private field"),t?t.call(o):e.get(o)),_s=(o,e,t)=>{if(e.has(o))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(o):e.set(o,t)},$s=(o,e,t,s)=>(Dt(o,e,"write to private field"),s?s.call(o,t):e.set(o,t),t),xe;let Ls=0;class Ds{constructor(e,t={}){_s(this,xe,!0),this._onReadyCallback=()=>{},this._onBeforeRenderCallback=()=>{},this._onRenderCallback=()=>{},this._onAfterRenderCallback=()=>{},this._onAfterResizeCallback=()=>{};const s="ComputePass";e=e&&e.renderer||e,$(e,t.label?`${t.label} ${s}`:s),t.label=t.label??"ComputePass "+e.computePasses?.length,this.renderer=e,this.type=s,this.uuid=k(),Object.defineProperty(this,"index",{value:Ls++});const{label:i,shaders:r,renderOrder:n,uniforms:a,storages:h,bindGroups:u,samplers:l,domTextures:d,textures:c,autoRender:p,useAsyncPipeline:g,texturesOptions:m,dispatchSize:y}=t;this.options={label:i,shaders:r,...p!==void 0&&{autoRender:p},...n!==void 0&&{renderOrder:n},...y!==void 0&&{dispatchSize:y},useAsyncPipeline:g===void 0?!0:g,texturesOptions:m},this.renderOrder=n??0,p!==void 0&&$s(this,xe,p),this.userData={},this.ready=!1,this.setMaterial({label:this.options.label,shaders:this.options.shaders,uniforms:a,storages:h,bindGroups:u,samplers:l,textures:c,domTextures:d,useAsyncPipeline:g,dispatchSize:y}),this.addToScene()}get ready(){return this._ready}set ready(e){e&&this._onReadyCallback&&this._onReadyCallback(),this._ready=e}addToScene(){this.renderer.computePasses.push(this),kt(this,xe)&&this.renderer.scene.addComputePass(this)}removeFromScene(){kt(this,xe)&&this.renderer.scene.removeComputePass(this),this.renderer.computePasses=this.renderer.computePasses.filter(e=>e.uuid!==this.uuid)}setMaterial(e){this.useMaterial(new Lt(this.renderer,e))}useMaterial(e){this.material=e}loseContext(){this.material.loseContext()}restoreContext(){this.material.restoreContext()}get domTextures(){return this.material?.domTextures||[]}get textures(){return this.material?.textures||[]}createDOMTexture(e){e.name||(e.name="texture"+(this.textures.length+this.domTextures.length)),e.label||(e.label=this.options.label+" "+e.name);const t=new he(this.renderer,{...e,...this.options.texturesOptions});return this.addTexture(t),t}createTexture(e){e.name||(e.name="texture"+(this.textures.length+this.domTextures.length));const t=new te(this.renderer,e);return this.addTexture(t),t}addTexture(e){this.material.addTexture(e)}get uniforms(){return this.material?.uniforms}get storages(){return this.material?.storages}resize(){this._onAfterResizeCallback&&this._onAfterResizeCallback()}onReady(e){return e&&(this._onReadyCallback=e),this}onBeforeRender(e){return e&&(this._onBeforeRenderCallback=e),this}onRender(e){return e&&(this._onRenderCallback=e),this}onAfterRender(e){return e&&(this._onAfterRenderCallback=e),this}useCustomRender(e){return this.material.useCustomRender(e),this}onAfterResize(e){return e&&(this._onAfterResizeCallback=e),this}onBeforeRenderPass(){this.renderer.ready&&(this.material&&this.material.ready&&!this.ready&&(this.ready=!0),this._onBeforeRenderCallback&&this._onBeforeRenderCallback(),this.material.onBeforeRender())}onRenderPass(e){this.material.ready&&(this._onRenderCallback&&this._onRenderCallback(),this.material.render(e))}onAfterRenderPass(){this._onAfterRenderCallback&&this._onAfterRenderCallback()}render(e){this.onBeforeRenderPass(),this.renderer.ready&&(!this.renderer.production&&e.pushDebugGroup(this.options.label),this.onRenderPass(e),!this.renderer.production&&e.popDebugGroup(),this.onAfterRenderPass())}copyBufferToResult(e){this.material?.copyBufferToResult(e)}async getComputeResult({bindingName:e,bufferElementName:t}){return await this.material?.getComputeResult({bindingName:e,bufferElementName:t})}remove(){this.removeFromScene(),this.destroy()}destroy(){this.material?.destroy()}}xe=new WeakMap;const X=[new f,new f,new f,new f,new f,new f,new f,new f];class ie{constructor(e=new f(1/0),t=new f(-1/0)){this.min=e,this.max=t}set(e=new f(1/0),t=new f(-1/0)){return this.min.copy(e),this.max.copy(t),this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}copy(e){return this.set(e.min.clone(),e.max.clone()),this}clone(){return new ie().copy(this)}get center(){return this.max.clone().add(this.min).multiplyScalar(.5)}get size(){return this.max.clone().sub(this.min)}get radius(){return this.max.distance(this.min)*.5}applyMat4(e=new A){if(this.isEmpty())return this;const t=[];this.min.z===this.max.z?(t[0]=X[0].set(this.min.x,this.min.y,this.min.z).applyMat4(e),t[1]=X[2].set(this.min.x,this.max.y,this.min.z).applyMat4(e),t[2]=X[4].set(this.max.x,this.min.y,this.min.z).applyMat4(e),t[3]=X[6].set(this.max.x,this.max.y,this.min.z).applyMat4(e)):(t[0]=X[0].set(this.min.x,this.min.y,this.min.z).applyMat4(e),t[1]=X[1].set(this.min.x,this.min.y,this.max.z).applyMat4(e),t[2]=X[2].set(this.min.x,this.max.y,this.min.z).applyMat4(e),t[3]=X[3].set(this.min.x,this.max.y,this.max.z).applyMat4(e),t[4]=X[4].set(this.max.x,this.min.y,this.min.z).applyMat4(e),t[5]=X[5].set(this.max.x,this.min.y,this.max.z).applyMat4(e),t[6]=X[6].set(this.max.x,this.max.y,this.min.z).applyMat4(e),t[7]=X[7].set(this.max.x,this.max.y,this.max.z).applyMat4(e));const s=new ie;for(let i=0,r=t.length;i<r;i++)s.min.min(t[i]),s.max.max(t[i]);return s}}const It={top:0,right:0,bottom:0,left:0};class Vt{constructor({boundingBox:e=new ie,modelViewProjectionMatrix:t=new A,containerBoundingRect:s={top:0,right:0,bottom:0,left:0,width:0,height:0,x:0,y:0},DOMFrustumMargins:i=It,onReEnterView:r=()=>{},onLeaveView:n=()=>{}}){this.boundingBox=e,this.modelViewProjectionMatrix=t,this.containerBoundingRect=s,this.DOMFrustumMargins={...It,...i},this.projectedBoundingRect={top:0,right:0,bottom:0,left:0,width:0,height:0,x:0,y:0},this.onReEnterView=r,this.onLeaveView=n,this.isIntersecting=!1}setContainerBoundingRect(e){this.containerBoundingRect=e}get DOMFrustumBoundingRect(){return{top:this.projectedBoundingRect.top-this.DOMFrustumMargins.top,right:this.projectedBoundingRect.right+this.DOMFrustumMargins.right,bottom:this.projectedBoundingRect.bottom+this.DOMFrustumMargins.bottom,left:this.projectedBoundingRect.left-this.DOMFrustumMargins.left}}computeProjectedToDocumentCoords(){const e=this.boundingBox.applyMat4(this.modelViewProjectionMatrix);e.min.x=(e.min.x+1)*.5,e.max.x=(e.max.x+1)*.5,e.min.y=1-(e.min.y+1)*.5,e.max.y=1-(e.max.y+1)*.5;const{width:t,height:s,top:i,left:r}=this.containerBoundingRect;this.projectedBoundingRect={left:e.min.x*t+r,x:e.min.x*t+r,top:e.max.y*s+i,y:e.max.y*s+i,right:e.max.x*t+r,bottom:e.min.y*s+i,width:e.max.x*t+r-(e.min.x*t+r),height:e.min.y*s+i-(e.max.y*s+i)},this.intersectsContainer()}intersectsContainer(){Math.round(this.DOMFrustumBoundingRect.right)<=this.containerBoundingRect.left||Math.round(this.DOMFrustumBoundingRect.left)>=this.containerBoundingRect.left+this.containerBoundingRect.width||Math.round(this.DOMFrustumBoundingRect.bottom)<=this.containerBoundingRect.top||Math.round(this.DOMFrustumBoundingRect.top)>=this.containerBoundingRect.top+this.containerBoundingRect.height?(this.isIntersecting&&this.onLeaveView(),this.isIntersecting=!1):(this.isIntersecting||this.onReEnterView(),this.isIntersecting=!0)}}class nt{constructor({verticesOrder:e="ccw",topology:t="triangle-list",instancesCount:s=1,vertexBuffers:i=[],mapBuffersAtCreation:r=!0}={}){this.verticesCount=0,this.verticesOrder=e,this.topology=t,this.instancesCount=s,this.ready=!1,this.boundingBox=new ie,this.type="Geometry",this.uuid=k(),this.vertexBuffers=[],this.consumers=new Set,this.options={verticesOrder:e,topology:t,instancesCount:s,vertexBuffers:i,mapBuffersAtCreation:r};const n=i.find(a=>a.name==="attributes");(!i.length||!n)&&this.addVertexBuffer({name:"attributes"});for(const a of i)this.addVertexBuffer({stepMode:a.stepMode??"vertex",name:a.name,attributes:a.attributes,...a.array&&{array:a.array},...a.buffer&&{buffer:a.buffer},...a.bufferOffset&&{bufferOffset:a.bufferOffset},...a.bufferSize&&{bufferSize:a.bufferSize}});n&&this.setWGSLFragment()}loseContext(){this.ready=!1;for(const e of this.vertexBuffers)e.buffer.destroy()}restoreContext(e){if(!this.ready){for(const t of this.vertexBuffers)!t.buffer.GPUBuffer&&t.buffer.consumers.size===0&&(t.buffer.createBuffer(e),this.uploadBuffer(e,t)),t.buffer.consumers.add(this.uuid);this.ready=!0}}addVertexBuffer({stepMode:e="vertex",name:t,attributes:s=[],buffer:i=null,array:r=null,bufferOffset:n=0,bufferSize:a=null}={}){i=i||new de;const h={name:t??"attributes"+this.vertexBuffers.length,stepMode:e,arrayStride:0,bufferLength:0,attributes:[],buffer:i,array:r,bufferOffset:n,bufferSize:a};return s?.forEach(u=>{this.setAttribute({vertexBuffer:h,...u})}),this.vertexBuffers.push(h),h}getVertexBufferByName(e=""){return this.vertexBuffers.find(t=>t.name===e)}setAttribute({vertexBuffer:e=this.vertexBuffers[0],name:t,type:s="vec3f",bufferFormat:i="float32x3",size:r=3,array:n=new Float32Array(this.verticesCount*r),verticesStride:a=1}){const h=e.attributes,u=h.length;t||(t="geometryAttribute"+u),t==="position"&&(s!=="vec3f"||i!=="float32x3"||r!==3)&&(D(`Geometry 'position' attribute must have this exact properties set:
	type: 'vec3f',
	bufferFormat: 'float32x3',
	size: 3`),s="vec3f",i="float32x3",r=3);const l=n.length/r;t==="position"&&(this.verticesCount=l),e.stepMode==="vertex"&&this.verticesCount&&this.verticesCount!==l*a?q(`Geometry vertex attribute error. Attribute array of size ${r} must be of length: ${this.verticesCount*r}, current given: ${n.length}. (${this.verticesCount} vertices).`):e.stepMode==="instance"&&l!==this.instancesCount&&q(`Geometry instance attribute error. Attribute array of size ${r} must be of length: ${this.instancesCount*r}, current given: ${n.length}. (${this.instancesCount} instances).`);const d={name:t,type:s,bufferFormat:i,size:r,bufferLength:n.length,offset:u?h.reduce((c,p)=>c+p.bufferLength,0):0,bufferOffset:u?h[u-1].bufferOffset+h[u-1].size*4:0,array:n,verticesStride:a};e.bufferLength+=d.bufferLength*a,e.arrayStride+=d.size,e.attributes.push(d)}get shouldCompute(){return this.vertexBuffers.length&&!this.vertexBuffers[0].array}getAttributeByName(e){let t;return this.vertexBuffers.forEach(s=>{t=s.attributes.find(i=>i.name===e)}),t}computeGeometry(){this.ready||(this.vertexBuffers.forEach((e,t)=>{if(t===0){const r=e.attributes.find(n=>n.name==="position");r||q("Geometry must have a 'position' attribute"),(r.type!=="vec3f"||r.bufferFormat!=="float32x3"||r.size!==3)&&(D(`Geometry 'position' attribute must have this exact properties set:
	type: 'vec3f',
	bufferFormat: 'float32x3',
	size: 3`),r.type="vec3f",r.bufferFormat="float32x3",r.size=3)}e.array=new Float32Array(e.bufferLength);let s=0,i=0;for(let r=0;r<e.bufferLength;r+=e.arrayStride){for(let n=0;n<e.attributes.length;n++){const{name:a,size:h,array:u,verticesStride:l}=e.attributes[n];for(let d=0;d<h;d++){const c=u[Math.floor(i/l)*h+d];e.array[s]=c,a==="position"&&(d%3===0?(this.boundingBox.min.x>c&&(this.boundingBox.min.x=c),this.boundingBox.max.x<c&&(this.boundingBox.max.x=c)):d%3===1?(this.boundingBox.min.y>c&&(this.boundingBox.min.y=c),this.boundingBox.max.y<c&&(this.boundingBox.max.y=c)):d%3===2&&(this.boundingBox.min.z>c&&(this.boundingBox.min.z=c),this.boundingBox.max.z<c&&(this.boundingBox.max.z=c))),s++}}i++}}),this.wgslStructFragment||this.setWGSLFragment())}setWGSLFragment(){let e=-1;this.wgslStructFragment=`struct Attributes {
	@builtin(vertex_index) vertexIndex : u32,
	@builtin(instance_index) instanceIndex : u32,${this.vertexBuffers.map(t=>t.attributes.map(s=>(e++,`
	@location(${e}) ${s.name}: ${s.type}`))).join(",")}
};`,this.layoutCacheKey=this.vertexBuffers.map(t=>t.name+","+t.attributes.map(s=>`${s.name},${s.size}`)).join(",")+","}createBuffers({renderer:e,label:t=this.type}){if(!this.ready){for(const s of this.vertexBuffers)s.bufferSize||(s.bufferSize=s.array.length*s.array.constructor.BYTES_PER_ELEMENT),!s.buffer.GPUBuffer&&!s.buffer.consumers.size&&(s.buffer.createBuffer(e,{label:t+": "+s.name+" buffer",size:s.bufferSize,usage:this.options.mapBuffersAtCreation?["vertex"]:["copyDst","vertex"],mappedAtCreation:this.options.mapBuffersAtCreation}),this.uploadBuffer(e,s)),s.buffer.consumers.add(this.uuid);this.ready=!0}}uploadBuffer(e,t){this.options.mapBuffersAtCreation?(new t.array.constructor(t.buffer.GPUBuffer.getMappedRange()).set(t.array),t.buffer.GPUBuffer.unmap()):e.queueWriteBuffer(t.buffer.GPUBuffer,0,t.array)}setGeometryBuffers(e){this.vertexBuffers.forEach((t,s)=>{e.setVertexBuffer(s,t.buffer.GPUBuffer,t.bufferOffset,t.bufferSize)})}drawGeometry(e){e.draw(this.verticesCount,this.instancesCount)}render(e){this.ready&&(this.setGeometryBuffers(e),this.drawGeometry(e))}destroy(e=null){this.ready=!1;for(const t of this.vertexBuffers)t.buffer.consumers.delete(this.uuid),t.buffer.consumers.size||t.buffer.destroy(),t.array=null,e&&e.removeBuffer(t.buffer)}}class be extends nt{constructor({verticesOrder:e="ccw",topology:t="triangle-list",instancesCount:s=1,vertexBuffers:i=[],mapBuffersAtCreation:r=!0}={}){super({verticesOrder:e,topology:t,instancesCount:s,vertexBuffers:i,mapBuffersAtCreation:r}),this.type="IndexedGeometry"}loseContext(){super.loseContext(),this.indexBuffer&&this.indexBuffer.buffer.destroy()}restoreContext(e){this.ready||(this.indexBuffer.buffer.GPUBuffer||(this.indexBuffer.buffer.createBuffer(e),this.uploadBuffer(e,this.indexBuffer),this.indexBuffer.buffer.consumers.add(this.uuid)),super.restoreContext(e))}get useUint16IndexArray(){return this.verticesCount<256*256}setIndexBuffer({bufferFormat:e="uint32",array:t=new Uint32Array(0),buffer:s=new de,bufferOffset:i=0,bufferSize:r=null}){this.indexBuffer={array:t,bufferFormat:e,bufferLength:t.length,buffer:s,bufferOffset:i,bufferSize:r!==null?r:t.length*t.constructor.BYTES_PER_ELEMENT}}createBuffers({renderer:e,label:t=this.type}){this.indexBuffer.buffer.GPUBuffer||(this.indexBuffer.buffer.createBuffer(e,{label:t+": index buffer",size:this.indexBuffer.array.byteLength,usage:this.options.mapBuffersAtCreation?["index"]:["copyDst","index"],mappedAtCreation:this.options.mapBuffersAtCreation}),this.uploadBuffer(e,this.indexBuffer)),this.indexBuffer.buffer.consumers.add(this.uuid),super.createBuffers({renderer:e,label:t})}setGeometryBuffers(e){super.setGeometryBuffers(e),e.setIndexBuffer(this.indexBuffer.buffer.GPUBuffer,this.indexBuffer.bufferFormat,this.indexBuffer.bufferOffset,this.indexBuffer.bufferSize)}drawGeometry(e){e.drawIndexed(this.indexBuffer.bufferLength,this.instancesCount)}destroy(e=null){super.destroy(e),this.indexBuffer&&(this.indexBuffer.buffer.consumers.delete(this.uuid),this.indexBuffer.buffer.destroy(),e&&e.removeBuffer(this.indexBuffer.buffer))}}class ot extends be{constructor({widthSegments:e=1,heightSegments:t=1,instancesCount:s=1,vertexBuffers:i=[],topology:r}={}){super({verticesOrder:"ccw",topology:r,instancesCount:s,vertexBuffers:i,mapBuffersAtCreation:!0}),this.type="PlaneGeometry",e=Math.floor(e),t=Math.floor(t),this.definition={id:e*t+e,width:e,height:t,count:e*t};const n=(this.definition.width+1)*(this.definition.height+1),a=this.getIndexedVerticesAndUVs(n);for(const h of Object.values(a))this.setAttribute(h);this.setIndexArray()}setIndexArray(){const e=this.useUint16IndexArray?new Uint16Array(this.definition.count*6):new Uint32Array(this.definition.count*6);let t=0;for(let s=0;s<this.definition.height;s++)for(let i=0;i<this.definition.width;i++)e[t++]=i+s*(this.definition.width+1),e[t++]=this.definition.width+i+1+s*(this.definition.width+1),e[t++]=i+1+s*(this.definition.width+1),e[t++]=i+1+s*(this.definition.width+1),e[t++]=this.definition.width+i+1+s*(this.definition.width+1),e[t++]=this.definition.width+i+2+s*(this.definition.width+1);this.setIndexBuffer({array:e,bufferFormat:this.useUint16IndexArray?"uint16":"uint32"})}getIndexedVerticesAndUVs(e){const t={name:"uv",type:"vec2f",bufferFormat:"float32x2",size:2,array:new Float32Array(e*2)},s={name:"position",type:"vec3f",bufferFormat:"float32x3",size:3,array:new Float32Array(e*3)},i={name:"normal",type:"vec3f",bufferFormat:"float32x3",size:3,array:new Float32Array(e*3)};let r=0,n=0,a=0;for(let h=0;h<=this.definition.height;h++)for(let u=0;u<=this.definition.width;u++)t.array[a++]=1-u/this.definition.width,t.array[a++]=1-h/this.definition.height,s.array[r++]=1-u*2/this.definition.width,s.array[r++]=h*2/this.definition.height-1,s.array[r++]=0,i.array[n++]=0,i.array[n++]=0,i.array[n++]=1;return{position:s,uv:t,normal:i}}}const Wt=(o={},e={})=>Object.keys(o).filter(t=>Array.isArray(o[t])?JSON.stringify(o[t])!==JSON.stringify(e[t]):o[t]!==e[t]);var at=`
struct VertexOutput {
  @builtin(position) position: vec4f,
  @location(0) uv: vec2f,
  @location(1) normal: vec3f,
};

@vertex fn main(
  attributes: Attributes,
) -> VertexOutput {
  var vsOutput: VertexOutput;

  vsOutput.position = getOutputPosition(attributes.position);
  vsOutput.uv = attributes.uv;
  vsOutput.normal = getWorldNormal(attributes.normal);
  
  return vsOutput;
}`,ht=`
struct VertexOutput {
  @builtin(position) position: vec4f,
  @location(0) uv: vec2f,
};

@vertex fn main(
  attributes: Attributes,
) -> VertexOutput {
  var vsOutput: VertexOutput;

  vsOutput.position = vec4f(attributes.position, 1.0);
  vsOutput.uv = attributes.uv;
  
  return vsOutput;
}`,ut=`
@fragment fn main() -> @location(0) vec4f {
  return vec4(0.0, 0.0, 0.0, 1.0);
}`;class Nt extends rt{constructor(e,t){e=e&&e.renderer||e;const s="RenderMaterial";$(e,s),t.shaders||(t.shaders={}),t.shaders?.vertex||(t.shaders.vertex={code:t.useProjection?at:ht,entryPoint:"main"}),t.shaders.vertex.entryPoint||(t.shaders.vertex.entryPoint="main"),t.shaders.fragment===void 0&&(t.shaders.fragment={entryPoint:"main",code:ut}),super(e,t),this.type=s,this.renderer=e;const{shaders:i}=t,{useProjection:r,transparent:n,depth:a,depthWriteEnabled:h,depthCompare:u,depthFormat:l,cullMode:d,sampleCount:c,verticesOrder:p,topology:g}=t;let{targets:m}=t;(!m||!m.length)&&(m=[{format:this.renderer.options.preferredFormat}]),m[0].format||(m[0].format=this.renderer.options.preferredFormat),this.options={...this.options,shaders:i,rendering:{useProjection:r,transparent:n,depth:a,depthWriteEnabled:h,depthCompare:u,depthFormat:l,cullMode:d,sampleCount:c,targets:m,verticesOrder:p,topology:g}},this.attributes=null,this.pipelineEntry=null}setPipelineEntry(){this.pipelineEntry=this.renderer.pipelineManager.createRenderPipeline({renderer:this.renderer,label:this.options.label+" render pipeline",shaders:this.options.shaders,useAsync:this.options.useAsyncPipeline,rendering:this.options.rendering,attributes:this.attributes,bindGroups:this.bindGroups})}async compilePipelineEntry(){await this.pipelineEntry.compilePipelineEntry()}async compileMaterial(){super.compileMaterial(),this.attributes&&!this.pipelineEntry&&this.setPipelineEntry(),this.pipelineEntry&&this.pipelineEntry.canCompile&&await this.compilePipelineEntry()}setRenderingOptions(e={}){const t=Wt(e,this.options.rendering),s={...this.options.rendering};if(this.options.rendering={...this.options.rendering,...e},this.pipelineEntry)if(this.pipelineEntry.ready&&t.length){if(!this.renderer.production){const i=t.map(n=>({[n]:Array.isArray(s[n])?s[n].map(a=>a):s[n]})),r=t.map(n=>({[n]:Array.isArray(e[n])?e[n].map(a=>a):e[n]}));D(`${this.options.label}: the change of rendering options is causing this RenderMaterial pipeline to be recompiled. This should be avoided.

Old rendering options: ${JSON.stringify(i.reduce((n,a)=>({...n,...a}),{}),null,4)}

--------

New rendering options: ${JSON.stringify(r.reduce((n,a)=>({...n,...a}),{}),null,4)}`)}this.setPipelineEntry()}else this.pipelineEntry.options.rendering={...this.pipelineEntry.options.rendering,...this.options.rendering}}setAttributesFromGeometry(e){this.attributes={wgslStructFragment:e.wgslStructFragment,vertexBuffers:e.vertexBuffers,layoutCacheKey:e.layoutCacheKey}}createBindGroups(){"cameraBindGroup"in this.renderer&&this.options.rendering.useProjection&&(this.bindGroups.push(this.renderer.cameraBindGroup),this.renderer.cameraBindGroup.consumers.add(this.uuid)),super.createBindGroups()}}var jt=(o,e,t)=>{if(!e.has(o))throw TypeError("Cannot "+t)},lt=(o,e,t)=>(jt(o,e,"read from private field"),t?t.call(o):e.get(o)),ks=(o,e,t)=>{if(e.has(o))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(o):e.set(o,t)},Is=(o,e,t,s)=>(jt(o,e,"write to private field"),s?s.call(o,t):e.set(o,t),t);let Vs=0;const qt={autoRender:!0,useProjection:!1,useAsyncPipeline:!0,cullMode:"back",depth:!0,depthWriteEnabled:!0,depthCompare:"less",depthFormat:"depth24plus",transparent:!1,visible:!0,renderOrder:0,texturesOptions:{}};function Yt(o){var e,t;return t=class extends o{constructor(...s){super(s[0],s[1],{...qt,...s[2]}),ks(this,e,!0),this._onReadyCallback=()=>{},this._onBeforeRenderCallback=()=>{},this._onRenderCallback=()=>{},this._onAfterRenderCallback=()=>{},this._onAfterResizeCallback=()=>{};let i=s[0];const r={...qt,...s[2]};this.type="MeshBase",this.uuid=k(),Object.defineProperty(this,"index",{value:Vs++}),i=i&&i.renderer||i,$(i,r.label?r.label+" "+this.type:this.type),this.renderer=i;const{label:n,shaders:a,geometry:h,visible:u,renderOrder:l,outputTarget:d,texturesOptions:c,autoRender:p,...g}=r;this.outputTarget=d??null,g.sampleCount=g.sampleCount?g.sampleCount:this.outputTarget?this.outputTarget.renderPass.options.sampleCount:this.renderer&&this.renderer.renderPass?this.renderer.renderPass.options.sampleCount:1,this.options={...this.options??{},label:n??"Mesh "+this.renderer.meshes.length,...a!==void 0?{shaders:a}:{},...d!==void 0&&{outputTarget:d},texturesOptions:c,...p!==void 0&&{autoRender:p},...g},p!==void 0&&Is(this,e,p),this.visible=u,this.renderOrder=l,this.ready=!1,this.userData={},h&&this.useGeometry(h),this.setMaterial({...this.cleanupRenderMaterialParameters({...this.options}),...h&&{verticesOrder:h.verticesOrder,topology:h.topology}}),this.addToScene(!0)}get autoRender(){return lt(this,e)}get ready(){return this._ready}set ready(s){s&&!this._ready&&this._onReadyCallback&&this._onReadyCallback(),this._ready=s}addToScene(s=!1){s&&this.renderer.meshes.push(this),this.setRenderingOptionsForRenderPass(this.outputTarget?this.outputTarget.renderPass:this.renderer.renderPass),lt(this,e)&&this.renderer.scene.addMesh(this)}removeFromScene(s=!1){lt(this,e)&&this.renderer.scene.removeMesh(this),s&&(this.renderer.meshes=this.renderer.meshes.filter(i=>i.uuid!==this.uuid))}setRenderer(s){if(s=s&&s.renderer||s,!s||!(s.type==="GPURenderer"||s.type==="GPUCameraRenderer"||s.type==="GPUCurtainsRenderer")){D(`${this.options.label}: Cannot set ${s} as a renderer because it is not of a valid Renderer type.`);return}const i=this.renderer;this.removeFromScene(!0),this.renderer=s,this.addToScene(!0),i.meshes.length||i.onBeforeRenderScene.add(r=>{i.forceClear(r)},{once:!0})}setOutputTarget(s){if(s&&s.type!=="RenderTarget"){D(`${this.options.label??this.type}: outputTarget is not a RenderTarget: ${s}`);return}this.removeFromScene(),this.outputTarget=s,this.addToScene()}loseContext(){this.ready=!1,this.geometry.loseContext(),this.material.loseContext()}restoreContext(){this.geometry.restoreContext(this.renderer),this.material.restoreContext()}setShaders(){const{shaders:s}=this.options;s?((!s.vertex||!s.vertex.code)&&(s.vertex={code:ht,entryPoint:"main"}),(s.fragment===void 0||s.fragment&&!s.fragment.code)&&(s.fragment={code:ut,entryPoint:"main"})):this.options.shaders={vertex:{code:ht,entryPoint:"main"},fragment:{code:ut,entryPoint:"main"}}}useGeometry(s){if(this.geometry&&(s.shouldCompute&&s.computeGeometry(),this.geometry.layoutCacheKey!==s.layoutCacheKey&&(D(`${this.options.label} (${this.type}): the current and new geometries do not have the same vertexBuffers layout, causing a probable pipeline recompilation. This should be avoided.

Current geometry layout:

${this.geometry.wgslStructFragment}

--------

New geometry layout:

${s.wgslStructFragment}`),this.material.setAttributesFromGeometry(s),this.material.setPipelineEntry()),this.geometry.consumers.delete(this.uuid)),this.geometry=s,this.geometry.consumers.add(this.uuid),this.computeGeometry(),this.material){const i={...this.material.options.rendering,verticesOrder:s.verticesOrder,topology:s.topology};this.material.setRenderingOptions(i)}}computeGeometry(){this.geometry.shouldCompute&&this.geometry.computeGeometry()}setGeometry(){this.geometry&&(this.geometry.ready||this.geometry.createBuffers({renderer:this.renderer,label:this.options.label+" geometry"}),this.setMaterialGeometryAttributes())}setRenderingOptionsForRenderPass(s){const i={transparent:this.transparent,sampleCount:s.options.sampleCount,...s.options.colorAttachments.length&&{targets:s.options.colorAttachments.map((r,n)=>({format:r.targetFormat,...this.options.targets?.length&&this.options.targets[n]&&this.options.targets[n].blend&&{blend:this.options.targets[n].blend}}))},depth:s.options.useDepth,...s.options.useDepth&&{depthFormat:s.options.depthFormat}};this.material?.setRenderingOptions(i)}cleanupRenderMaterialParameters(s){return delete s.texturesOptions,delete s.outputTarget,delete s.autoRender,s}useMaterial(s){this.material=s,this.transparent=this.material.options.rendering.transparent,this.material.options.domTextures?.filter(i=>i instanceof he).forEach(i=>this.onDOMTextureAdded(i))}setMaterial(s){this.setShaders(),s.shaders=this.options.shaders,s.label=s.label+" material",this.useMaterial(new Nt(this.renderer,s))}setMaterialGeometryAttributes(){this.material&&!this.material.attributes&&this.material.setAttributesFromGeometry(this.geometry)}get transparent(){return this._transparent}set transparent(s){const i=this.transparent!==void 0&&s!==this.transparent;i&&this.removeFromScene(),this._transparent=s,i&&this.addToScene()}get visible(){return this._visible}set visible(s){this._visible=s}get domTextures(){return this.material?.domTextures||[]}get textures(){return this.material?.textures||[]}createDOMTexture(s){s.name||(s.name="texture"+(this.textures.length+this.domTextures.length)),s.label||(s.label=this.options.label+" "+s.name);const i=new he(this.renderer,{...s,...this.options.texturesOptions});return this.addDOMTexture(i),i}addDOMTexture(s){this.material.addTexture(s),this.onDOMTextureAdded(s)}onDOMTextureAdded(s){s.parentMesh=this}createTexture(s){s.name||(s.name="texture"+(this.textures.length+this.domTextures.length));const i=new te(this.renderer,s);return this.addTexture(i),i}addTexture(s){this.material.addTexture(s)}get uniforms(){return this.material?.uniforms}get storages(){return this.material?.storages}resize(s){super.resize&&super.resize(s),this.textures?.forEach(i=>{i.options.fromTexture&&i.copy(i.options.fromTexture)}),this.domTextures?.forEach(i=>{i.resize()}),this._onAfterResizeCallback&&this._onAfterResizeCallback()}onReady(s){return s&&(this._onReadyCallback=s),this}onBeforeRender(s){return s&&(this._onBeforeRenderCallback=s),this}onRender(s){return s&&(this._onRenderCallback=s),this}onAfterRender(s){return s&&(this._onAfterRenderCallback=s),this}onAfterResize(s){return s&&(this._onAfterResizeCallback=s),this}onBeforeRenderScene(){!this.renderer.ready||!this.ready||!this.visible||this._onBeforeRenderCallback&&this._onBeforeRenderCallback()}onBeforeRenderPass(){this.renderer.ready&&(this.ready=this.material&&this.material.ready&&this.geometry&&this.geometry.ready,this.setGeometry(),this.material.onBeforeRender())}onRenderPass(s){this.ready&&(this._onRenderCallback&&this._onRenderCallback(),this.material.render(s),this.geometry.render(s))}onAfterRenderPass(){this._onAfterRenderCallback&&this._onAfterRenderCallback()}render(s){this.onBeforeRenderPass(),!(!this.renderer.ready||!this.visible)&&(super.render&&super.render(),!this.renderer.production&&s.pushDebugGroup(this.options.label),this.onRenderPass(s),!this.renderer.production&&s.popDebugGroup(),this.onAfterRenderPass())}remove(){this.removeFromScene(!0),this.destroy(),this.renderer.meshes.length||this.renderer.onBeforeRenderScene.add(s=>{this.renderer.forceClear(s)},{once:!0})}destroy(){super.destroy&&super.destroy(),this.material?.destroy(),this.geometry.consumers.delete(this.uuid),this.geometry.consumers.size||this.geometry?.destroy(this.renderer)}},e=new WeakMap,t}class Ws{constructor(){this.planeGeometries=[]}getPlaneGeometry(e){return this.planeGeometries.find(t=>t.definition.id===e.definition.id)}getPlaneGeometryByID(e){return this.planeGeometries.find(t=>t.definition.id===e)}addPlaneGeometry(e){this.planeGeometries.push(e)}destroy(){this.planeGeometries=[]}}const ke=new Ws;class dt extends Yt(class{}){constructor(e,t={}){e=e&&e.renderer||e,$(e,t.label?t.label+" FullscreenQuadMesh":"FullscreenQuadMesh");let s=ke.getPlaneGeometryByID(2);s||(s=new ot({widthSegments:1,heightSegments:1}),ke.addPlaneGeometry(s)),(!t.shaders||!t.shaders.vertex)&&["uniforms","storages"].forEach(i=>{Object.values(t[i]??{}).forEach(r=>r.visibility=["fragment"])}),t.depthWriteEnabled=!1,t.label||(t.label="FullscreenQuadMesh"),super(e,null,{geometry:s,...t}),this.size={document:{width:this.renderer.boundingRect.width,height:this.renderer.boundingRect.height,top:this.renderer.boundingRect.top,left:this.renderer.boundingRect.left}},this.type="FullscreenQuadMesh"}resize(e=null){this.size.document=e??this.renderer.boundingRect,super.resize(e)}mouseToPlaneCoords(e=new E){return new E((e.x-this.size.document.left)/this.size.document.width*2-1,1-(e.y-this.size.document.top)/this.size.document.height*2)}}class re{constructor(e=new Float32Array([1,0,0,0,1,0,0,0,1])){this.type="Mat3",this.elements=e}set(e,t,s,i,r,n,a,h,u){const l=this.elements;return l[0]=e,l[1]=i,l[2]=a,l[3]=t,l[4]=r,l[5]=h,l[6]=s,l[7]=n,l[8]=u,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}setFromArray(e=new Float32Array([1,0,0,0,1,0,0,0,1])){for(let t=0;t<this.elements.length;t++)this.elements[t]=e[t];return this}copy(e=new re){const t=e.elements;return this.elements[0]=t[0],this.elements[1]=t[1],this.elements[2]=t[2],this.elements[3]=t[3],this.elements[4]=t[4],this.elements[5]=t[5],this.elements[6]=t[6],this.elements[7]=t[7],this.elements[8]=t[8],this}clone(){return new re().copy(this)}setFromMat4(e=new A){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e=new re){return this.multiplyMatrices(this,e)}premultiply(e=new re){return this.multiplyMatrices(e,this)}multiplyMatrices(e=new re,t=new re){const s=e.elements,i=t.elements,r=this.elements,n=s[0],a=s[3],h=s[6],u=s[1],l=s[4],d=s[7],c=s[2],p=s[5],g=s[8],m=i[0],y=i[3],b=i[6],M=i[1],T=i[4],v=i[7],C=i[2],B=i[5],x=i[8];return r[0]=n*m+a*M+h*C,r[3]=n*y+a*T+h*B,r[6]=n*b+a*v+h*x,r[1]=u*m+l*M+d*C,r[4]=u*y+l*T+d*B,r[7]=u*b+l*v+d*x,r[2]=c*m+p*M+g*C,r[5]=c*y+p*T+g*B,r[8]=c*b+p*v+g*x,this}invert(){const e=this.elements,t=e[0],s=e[1],i=e[2],r=e[3],n=e[4],a=e[5],h=e[6],u=e[7],l=e[8],d=l*n-a*u,c=a*h-l*r,p=u*r-n*h,g=t*d+s*c+i*p;if(g===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/g;return e[0]=d*m,e[1]=(i*u-l*s)*m,e[2]=(a*s-i*n)*m,e[3]=c*m,e[4]=(l*t-i*h)*m,e[5]=(i*r-a*t)*m,e[6]=p*m,e[7]=(s*h-u*t)*m,e[8]=(n*t-s*r)*m,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e=new A){return this.setFromMat4(e).invert().transpose()}}class ct extends se{constructor(e){super(),e=e&&e.renderer||e,Be(e,"ProjectedObject3D"),this.camera=e.camera}applyPosition(){super.applyPosition(),this.shouldUpdateProjectionMatrixStack()}applyRotation(){super.applyRotation(),this.shouldUpdateProjectionMatrixStack()}applyScale(){super.applyScale(),this.shouldUpdateProjectionMatrixStack()}applyTransformOrigin(){super.applyTransformOrigin(),this.shouldUpdateProjectionMatrixStack()}setMatrices(){super.setMatrices(),this.matrices={...this.matrices,modelView:{matrix:new A,shouldUpdate:!0,onUpdate:()=>{this.modelViewMatrix.multiplyMatrices(this.viewMatrix,this.worldMatrix)}},modelViewProjection:{matrix:new A,shouldUpdate:!0,onUpdate:()=>{this.modelViewProjectionMatrix.multiplyMatrices(this.projectionMatrix,this.modelViewMatrix)}},normal:{matrix:new re,shouldUpdate:!0,onUpdate:()=>{this.normalMatrix.getNormalMatrix(this.worldMatrix)}}}}get modelViewMatrix(){return this.matrices.modelView.matrix}set modelViewMatrix(e){this.matrices.modelView.matrix=e,this.matrices.modelView.shouldUpdate=!0}get viewMatrix(){return this.camera.viewMatrix}get projectionMatrix(){return this.camera.projectionMatrix}get modelViewProjectionMatrix(){return this.matrices.modelViewProjection.matrix}set modelViewProjectionMatrix(e){this.matrices.modelViewProjection.matrix=e,this.matrices.modelViewProjection.shouldUpdate=!0}get normalMatrix(){return this.matrices.normal.matrix}set normalMatrix(e){this.matrices.normal.matrix=e,this.matrices.normal.shouldUpdate=!0}shouldUpdateProjectionMatrixStack(){this.matrices.modelView.shouldUpdate=!0,this.matrices.modelViewProjection.shouldUpdate=!0}shouldUpdateWorldMatrix(){super.shouldUpdateWorldMatrix(),this.shouldUpdateProjectionMatrixStack(),this.matrices.normal.shouldUpdate=!0}shouldUpdateMatrixStack(){this.shouldUpdateModelMatrix(),this.shouldUpdateProjectionMatrixStack()}}var Ht=`
struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) uv: vec2f,
  @location(1) normal: vec3f,
};

@fragment fn main(fsInput: VSOutput) -> @location(0) vec4f {
  // normals
  return vec4(normalize(fsInput.normal) * 0.5 + 0.5, 1.0);
}`;const Xt={frustumCulled:!0,DOMFrustumMargins:{top:0,right:0,bottom:0,left:0}};function Kt(o){return class extends Yt(o){constructor(...t){super(t[0],t[1],{...Xt,...t[2],useProjection:!0}),this._onReEnterViewCallback=()=>{},this._onLeaveViewCallback=()=>{};let s=t[0];const i={...Xt,...t[2],useProjection:!0};this.type="MeshTransformed",s=s&&s.renderer||s,Be(s,i.label?i.label+" "+this.type:this.type),this.renderer=s;const{frustumCulled:r,DOMFrustumMargins:n}=i;this.options={...this.options??{},frustumCulled:r,DOMFrustumMargins:n},this.setDOMFrustum()}setShaders(){const{shaders:t}=this.options;t?((!t.vertex||!t.vertex.code)&&(t.vertex={code:at,entryPoint:"main"}),(t.fragment===void 0||t.fragment&&!t.fragment.code)&&(t.fragment={code:Ht,entryPoint:"main"})):this.options.shaders={vertex:{code:at,entryPoint:"main"},fragment:{code:Ht,entryPoint:"main"}}}useGeometry(t){super.useGeometry(t),this.domFrustum&&(this.domFrustum.boundingBox=this.geometry.boundingBox),this.shouldUpdateMatrixStack()}setDOMFrustum(){this.domFrustum=new Vt({boundingBox:this.geometry?.boundingBox,modelViewProjectionMatrix:this.modelViewProjectionMatrix,containerBoundingRect:this.renderer.boundingRect,DOMFrustumMargins:this.options.DOMFrustumMargins,onReEnterView:()=>{this._onReEnterViewCallback&&this._onReEnterViewCallback()},onLeaveView:()=>{this._onLeaveViewCallback&&this._onLeaveViewCallback()}}),this.DOMFrustumMargins=this.domFrustum.DOMFrustumMargins,this.frustumCulled=this.options.frustumCulled}cleanupRenderMaterialParameters(t){return delete t.frustumCulled,delete t.DOMFrustumMargins,super.cleanupRenderMaterialParameters(t),t}setMaterial(t){const s={label:"Matrices",visibility:["vertex"],struct:{model:{type:"mat4x4f",value:this.worldMatrix},modelView:{type:"mat4x4f",value:this.modelViewMatrix},normal:{type:"mat3x3f",value:this.normalMatrix}}};t.uniforms||(t.uniforms={}),t.uniforms={matrices:s,...t.uniforms},super.setMaterial(t)}get visible(){return this._visible}set visible(t){this.shouldUpdateMatrixStack(),this._visible=t}resize(t){this.domFrustum&&this.domFrustum.setContainerBoundingRect(this.renderer.boundingRect),super.resize(t)}applyScale(){super.applyScale();for(const t of this.domTextures)t.resize()}get projectedBoundingRect(){return this.domFrustum?.projectedBoundingRect}onReEnterView(t){return t&&(this._onReEnterViewCallback=t),this}onLeaveView(t){return t&&(this._onLeaveViewCallback=t),this}checkFrustumCulling(){this.matricesNeedUpdate&&this.domFrustum&&this.frustumCulled&&this.domFrustum.computeProjectedToDocumentCoords()}onBeforeRenderPass(){this.material&&this.matricesNeedUpdate&&this.material.shouldUpdateInputsBindings("matrices"),super.onBeforeRenderPass()}onRenderPass(t){this.ready&&(this._onRenderCallback&&this._onRenderCallback(),(this.domFrustum&&this.domFrustum.isIntersecting||!this.frustumCulled)&&(this.material.render(t),this.geometry.render(t)))}}}class Zt extends Kt(ct){constructor(e,t={}){e=e&&e.renderer||e,Be(e,t.label?t.label+" Mesh":"Mesh"),super(e,null,t),this.type="Mesh"}}let Ns=0;class pt{constructor(e){this.type="PipelineEntry";let{renderer:t}=e;const{label:s,shaders:i,useAsync:r}=e;t=t&&t.renderer||t,$(t,s?s+" "+this.type:this.type),this.renderer=t,Object.defineProperty(this,"index",{value:Ns++}),this.layout=null,this.pipeline=null,this.status={compiling:!1,compiled:!1,error:null},this.options={label:s,shaders:i,useAsync:r!==void 0?r:!0}}get ready(){return!this.status.compiling&&this.status.compiled&&!this.status.error}get canCompile(){return!this.status.compiling&&!this.status.compiled&&!this.status.error}setPipelineEntryBindGroups(e){this.bindGroups=e}createShaderModule({code:e="",type:t="vertex"}){const s=this.renderer.createShaderModule({label:this.options.label+": "+t+" shader module",code:e});return"getCompilationInfo"in s&&!this.renderer.production&&s.getCompilationInfo().then(i=>{for(const r of i.messages){let n="";switch(r.lineNum&&(n+=`Line ${r.lineNum}:${r.linePos} - ${e.substring(r.offset,r.offset+r.length)}
`),n+=r.message,r.type){case"error":console.error(`${this.options.label} compilation error:
${n}`);break;case"warning":console.warn(`${this.options.label} compilation warning:
${n}`);break;case"info":console.log(`${this.options.label} compilation information:
${n}`);break}}}),s}createShaders(){}createPipelineLayout(){this.layout=this.renderer.createPipelineLayout({label:this.options.label+" layout",bindGroupLayouts:this.bindGroups.map(e=>e.bindGroupLayout)})}createPipelineDescriptor(){}flushPipelineEntry(e=[]){this.status.compiling=!1,this.status.compiled=!1,this.status.error=null,this.setPipelineEntryBindGroups(e),this.compilePipelineEntry()}compilePipelineEntry(){this.status.compiling=!0,this.createShaders(),this.createPipelineLayout(),this.createPipelineDescriptor()}}var js=`
fn getOutputPosition(position: vec3f) -> vec4f {
  return camera.projection * matrices.modelView * vec4f(position, 1.0);
}`,qs=`
fn getWorldNormal(normal: vec3f) -> vec3f {
  return normalize(matrices.normal * normal);
}

fn getViewNormal(normal: vec3f) -> vec3f {
  return normalize((camera.view * vec4(matrices.normal * normal, 0.0)).xyz);
}`,Qt=`
fn getUVCover(uv: vec2f, textureMatrix: mat4x4f) -> vec2f {
  return (textureMatrix * vec4f(uv, 0.0, 1.0)).xy;
}`,Ys=`
fn getVertex2DToUVCoords(vertex: vec2f) -> vec2f {
  return vec2(
    vertex.x * 0.5 + 0.5,
    0.5 - vertex.y * 0.5
  );
}

fn getVertex3DToUVCoords(vertex: vec3f) -> vec2f {
  return getVertex2DToUVCoords( vec2(vertex.x, vertex.y) );
}
`;const ue={vertex:{get_uv_cover:Qt},fragment:{get_uv_cover:Qt,get_vertex_to_uv_coords:Ys}},le={vertex:{get_output_position:js,get_normals:qs},fragment:{}};class ft extends pt{constructor(e){let{renderer:t,...s}=e;const{label:i,attributes:r,bindGroups:n,cacheKey:a,...h}=s;t=t&&t.renderer||t;const u="RenderPipelineEntry";$(t,i?i+" "+u:u),super(e),this.type=u,this.shaders={vertex:{head:"",code:"",module:null},fragment:{head:"",code:"",module:null},full:{head:"",code:"",module:null}},this.descriptor=null,this.options={...this.options,attributes:r,bindGroups:n,cacheKey:a,...h},this.setPipelineEntryProperties({attributes:r,bindGroups:n})}setPipelineEntryProperties(e){const{attributes:t,bindGroups:s}=e;this.attributes=t,this.setPipelineEntryBindGroups(s)}patchShaders(){this.shaders.vertex.head="",this.shaders.vertex.code="",this.shaders.fragment.head="",this.shaders.fragment.code="",this.shaders.full.head="",this.shaders.full.code="";for(const t in ue.vertex)this.shaders.vertex.head=`${ue.vertex[t]}
${this.shaders.vertex.head}`,this.shaders.full.head=`${ue.vertex[t]}
${this.shaders.full.head}`;if(this.options.shaders.fragment)for(const t in ue.fragment)this.shaders.fragment.head=`${ue.fragment[t]}
${this.shaders.fragment.head}`,this.shaders.full.head.indexOf(ue.fragment[t])===-1&&(this.shaders.full.head=`${ue.fragment[t]}
${this.shaders.full.head}`);if(this.options.rendering.useProjection){for(const t in le.vertex)this.shaders.vertex.head=`${le.vertex[t]}
${this.shaders.vertex.head}`,this.shaders.full.head=`${le.vertex[t]}
${this.shaders.full.head}`;if(this.options.shaders.fragment)for(const t in le.fragment)this.shaders.fragment.head=`${le.fragment[t]}
${this.shaders.fragment.head}`,this.shaders.full.head.indexOf(le.fragment[t])===-1&&(this.shaders.full.head=`${le.fragment[t]}
${this.shaders.full.head}`)}const e=[];for(const t of this.bindGroups){let s=0;t.bindings.forEach((i,r)=>{i.wgslGroupFragment.forEach((n,a)=>{e.push({groupIndex:t.index,visibility:i.options.visibility,bindIndex:s,wgslStructFragment:i.wgslStructFragment,wgslGroupFragment:n,newLine:r===t.bindings.length-1&&a===i.wgslGroupFragment.length-1}),s++})})}for(const t of e)t.visibility.includes("vertex")&&(t.wgslStructFragment&&this.shaders.vertex.head.indexOf(t.wgslStructFragment)===-1&&(this.shaders.vertex.head=`
${t.wgslStructFragment}
${this.shaders.vertex.head}`),this.shaders.vertex.head.indexOf(t.wgslGroupFragment)===-1&&(this.shaders.vertex.head=`${this.shaders.vertex.head}
@group(${t.groupIndex}) @binding(${t.bindIndex}) ${t.wgslGroupFragment}`,t.newLine&&(this.shaders.vertex.head+=`
`))),this.options.shaders.fragment&&t.visibility.includes("fragment")&&(t.wgslStructFragment&&this.shaders.fragment.head.indexOf(t.wgslStructFragment)===-1&&(this.shaders.fragment.head=`
${t.wgslStructFragment}
${this.shaders.fragment.head}`),this.shaders.fragment.head.indexOf(t.wgslGroupFragment)===-1&&(this.shaders.fragment.head=`${this.shaders.fragment.head}
@group(${t.groupIndex}) @binding(${t.bindIndex}) ${t.wgslGroupFragment}`,t.newLine&&(this.shaders.fragment.head+=`
`))),t.wgslStructFragment&&this.shaders.full.head.indexOf(t.wgslStructFragment)===-1&&(this.shaders.full.head=`
${t.wgslStructFragment}
${this.shaders.full.head}`),this.shaders.full.head.indexOf(t.wgslGroupFragment)===-1&&(this.shaders.full.head=`${this.shaders.full.head}
@group(${t.groupIndex}) @binding(${t.bindIndex}) ${t.wgslGroupFragment}`,t.newLine&&(this.shaders.full.head+=`
`));this.shaders.vertex.head=`${this.attributes.wgslStructFragment}
${this.shaders.vertex.head}`,this.shaders.full.head=`${this.attributes.wgslStructFragment}
${this.shaders.full.head}`,this.shaders.vertex.code=this.shaders.vertex.head+this.options.shaders.vertex.code,typeof this.options.shaders.fragment=="object"&&(this.shaders.fragment.code=this.shaders.fragment.head+this.options.shaders.fragment.code),typeof this.options.shaders.fragment=="object"&&(this.options.shaders.vertex.entryPoint!==this.options.shaders.fragment.entryPoint&&this.options.shaders.vertex.code.localeCompare(this.options.shaders.fragment.code)===0?this.shaders.full.code=this.shaders.full.head+this.options.shaders.vertex.code:this.shaders.full.code=this.shaders.full.head+this.options.shaders.vertex.code+this.options.shaders.fragment.code)}get shadersModulesReady(){return!(!this.shaders.vertex.module||this.options.shaders.fragment&&!this.shaders.fragment.module)}createShaders(){this.patchShaders();const e=typeof this.options.shaders.fragment=="object"&&this.options.shaders.vertex.entryPoint!==this.options.shaders.fragment.entryPoint&&this.options.shaders.vertex.code.localeCompare(this.options.shaders.fragment.code)===0;this.shaders.vertex.module=this.createShaderModule({code:this.shaders[e?"full":"vertex"].code,type:"vertex"}),this.options.shaders.fragment&&(this.shaders.fragment.module=this.createShaderModule({code:this.shaders[e?"full":"fragment"].code,type:"fragment"}))}createPipelineDescriptor(){if(!this.shadersModulesReady)return;let e=-1;this.options.rendering.targets.length?this.options.rendering.transparent&&(this.options.rendering.targets[0].blend=this.options.rendering.targets[0].blend?this.options.rendering.targets[0].blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}):this.options.rendering.targets=[{format:this.renderer.options.preferredFormat}],this.descriptor={label:this.options.label,layout:this.layout,vertex:{module:this.shaders.vertex.module,entryPoint:this.options.shaders.vertex.entryPoint,buffers:this.attributes.vertexBuffers.map(t=>({stepMode:t.stepMode,arrayStride:t.arrayStride*4,attributes:t.attributes.map(s=>(e++,{shaderLocation:e,offset:s.bufferOffset,format:s.bufferFormat}))}))},...this.options.shaders.fragment&&{fragment:{module:this.shaders.fragment.module,entryPoint:this.options.shaders.fragment.entryPoint,targets:this.options.rendering.targets}},primitive:{topology:this.options.rendering.topology,frontFace:this.options.rendering.verticesOrder,cullMode:this.options.rendering.cullMode},...this.options.rendering.depth&&{depthStencil:{depthWriteEnabled:this.options.rendering.depthWriteEnabled,depthCompare:this.options.rendering.depthCompare,format:this.options.rendering.depthFormat}},...this.options.rendering.sampleCount>1&&{multisample:{count:this.options.rendering.sampleCount}}}}createRenderPipeline(){if(this.shadersModulesReady)try{this.pipeline=this.renderer.createRenderPipeline(this.descriptor)}catch(e){this.status.error=e,q(e)}}async createRenderPipelineAsync(){if(this.shadersModulesReady)try{this.pipeline=await this.renderer.createRenderPipelineAsync(this.descriptor),this.status.compiled=!0,this.status.compiling=!1,this.status.error=null}catch(e){this.status.error=e,q(e)}}async compilePipelineEntry(){super.compilePipelineEntry(),this.options.useAsync?await this.createRenderPipelineAsync():(this.createRenderPipeline(),this.status.compiled=!0,this.status.compiling=!1,this.status.error=null)}}class Jt extends pt{constructor(e){let{renderer:t}=e;const{label:s}=e;t=t&&t.renderer||t;const i="ComputePipelineEntry";$(t,s?s+" "+i:i),super(e),this.type=i,this.shaders={compute:{head:"",code:"",module:null}},this.descriptor=null}setPipelineEntryProperties(e){const{bindGroups:t}=e;this.setPipelineEntryBindGroups(t)}patchShaders(){this.shaders.compute.head="",this.shaders.compute.code="";const e=[];for(const t of this.bindGroups){let s=0;t.bindings.forEach((i,r)=>{i.wgslGroupFragment.forEach((n,a)=>{e.push({groupIndex:t.index,bindIndex:s,wgslStructFragment:i.wgslStructFragment,wgslGroupFragment:n,newLine:r===t.bindings.length-1&&a===i.wgslGroupFragment.length-1}),s++})})}for(const t of e)t.wgslStructFragment&&this.shaders.compute.head.indexOf(t.wgslStructFragment)===-1&&(this.shaders.compute.head=`
${t.wgslStructFragment}
${this.shaders.compute.head}`),this.shaders.compute.head.indexOf(t.wgslGroupFragment)===-1&&(this.shaders.compute.head=`${this.shaders.compute.head}
@group(${t.groupIndex}) @binding(${t.bindIndex}) ${t.wgslGroupFragment}`),t.newLine&&(this.shaders.compute.head+=`
`);this.shaders.compute.code=this.shaders.compute.head+this.options.shaders.compute.code}createShaders(){this.patchShaders(),this.shaders.compute.module=this.createShaderModule({code:this.shaders.compute.code,type:"compute"})}createPipelineDescriptor(){this.shaders.compute.module&&(this.descriptor={label:this.options.label,layout:this.layout,compute:{module:this.shaders.compute.module,entryPoint:this.options.shaders.compute.entryPoint}})}createComputePipeline(){if(this.shaders.compute.module)try{this.pipeline=this.renderer.createComputePipeline(this.descriptor)}catch(e){this.status.error=e,q(e)}}async createComputePipelineAsync(){if(this.shaders.compute.module)try{this.pipeline=await this.renderer.createComputePipelineAsync(this.descriptor),this.status.compiled=!0,this.status.compiling=!1,this.status.error=null}catch(e){this.status.error=e,q(e)}}async compilePipelineEntry(){super.compilePipelineEntry(),this.options.useAsync?await this.createComputePipelineAsync():(this.createComputePipeline(),this.status.compiled=!0,this.status.compiling=!1,this.status.error=null)}}class es{constructor(){this.type="PipelineManager",this.currentPipelineIndex=null,this.pipelineEntries=[],this.activeBindGroups=[]}compareShaders(e,t){return e.code===t.code&&e.entryPoint===t.entryPoint}isSameRenderPipeline(e){return this.pipelineEntries.filter(t=>t instanceof ft).find(t=>{const{options:s}=t,{shaders:i,rendering:r,cacheKey:n}=e,a=n===s.cacheKey,h=this.compareShaders(i.vertex,s.shaders.vertex),u=!i.fragment&&!s.shaders.fragment||this.compareShaders(i.fragment,s.shaders.fragment),l=Wt(r,s.rendering);return a&&!l.length&&h&&u})}createRenderPipeline(e){const{attributes:t,bindGroups:s}=e;let i=t.layoutCacheKey;s.forEach(n=>{n.bindings.forEach(a=>{i+=a.name+","}),i+=n.pipelineCacheKey});const r=this.isSameRenderPipeline({...e,cacheKey:i});if(r)return r;{const n=new ft({...e,cacheKey:i});return this.pipelineEntries.push(n),n}}createComputePipeline(e){const t=new Jt(e);return this.pipelineEntries.push(t),t}setCurrentPipeline(e,t){t.index!==this.currentPipelineIndex&&(e.setPipeline(t.pipeline),this.currentPipelineIndex=t.index)}setActiveBindGroups(e,t){t.forEach((s,i)=>{(!this.activeBindGroups[i]||this.activeBindGroups[i].uuid!==s.uuid||this.activeBindGroups[i].index!==s.index)&&(this.activeBindGroups[i]=s,e.setBindGroup(s.index,s.bindGroup))})}resetCurrentPipeline(){this.currentPipelineIndex=null,this.activeBindGroups=[]}}class Hs{constructor(){this.shouldWatch=!0,this.entries=[],typeof window=="object"&&"ResizeObserver"in window&&(this.resizeObserver=new ResizeObserver(e=>{e.map(s=>this.entries.filter(i=>i.element.isSameNode(s.target))).flat().sort((s,i)=>i.priority-s.priority)?.forEach(s=>{s&&s.callback&&s.callback()})}))}useObserver(e=!0){this.shouldWatch=e}observe({element:e,priority:t,callback:s}){if(!e||!this.shouldWatch)return;this.resizeObserver?.observe(e);const i={element:e,priority:t,callback:s};this.entries.push(i)}unobserve(e){this.resizeObserver?.unobserve(e),this.entries=this.entries.filter(t=>!t.element.isSameNode(e))}destroy(){this.resizeObserver?.disconnect()}}const mt=new Hs;class gt{constructor({element:e=document.body,priority:t=1,onSizeChanged:s=(r=null)=>{},onPositionChanged:i=(r=null)=>{}}={}){if(typeof e=="string"){if(this.element=document.querySelector(e),!this.element){const r=typeof e=="string"?`'${e}' selector`:`${e} HTMLElement`;q(`DOMElement: corresponding ${r} not found.`)}}else this.element=e;this.priority=t,this.isResizing=!1,this.onSizeChanged=s,this.onPositionChanged=i,this.resizeManager=mt,this.resizeManager.observe({element:this.element,priority:this.priority,callback:()=>{this.setSize()}}),this.setSize()}compareBoundingRect(e,t){return!["x","y","left","top","right","bottom","width","height"].some(s=>e[s]!==t[s])}get boundingRect(){return this._boundingRect}set boundingRect(e){const t=!!this.boundingRect&&this.compareBoundingRect(e,this.boundingRect);this._boundingRect={top:e.top,right:e.right,bottom:e.bottom,left:e.left,width:e.width,height:e.height,x:e.x,y:e.y},t||this.onSizeChanged(this.boundingRect)}updateScrollPosition(e={x:0,y:0}){this.isResizing||(this._boundingRect.top+=e.y,this._boundingRect.left+=e.x,(e.x||e.y)&&this.onPositionChanged(this.boundingRect))}setSize(e=null){!this.element||this.isResizing||(this.isResizing=!0,this.boundingRect=e??this.element.getBoundingClientRect(),setTimeout(()=>{this.isResizing=!1},10))}destroy(){this.resizeManager.unobserve(this.element)}}const Xs=new f,Ks=new f,yt=new f,xt=new f;class ts extends se{constructor({renderer:e}){super(),e=e&&e.renderer||e,$(e,"Scene"),this.renderer=e,this.computePassEntries=[],this.renderPassEntries={pingPong:[],renderTarget:[],screen:[]}}setMainRenderPassEntry(){this.renderPassEntries.screen.push({renderPass:this.renderer.renderPass,renderTexture:null,onBeforeRenderPass:null,onAfterRenderPass:null,element:null,stack:{unProjected:{opaque:[],transparent:[]},projected:{opaque:[],transparent:[]}}})}getRenderPassEntryLength(e){return e?e.element?e.element.visible?1:0:e.stack.unProjected.opaque.length+e.stack.unProjected.transparent.length+e.stack.projected.opaque.length+e.stack.projected.transparent.length:0}addComputePass(e){this.computePassEntries.push(e),this.computePassEntries.sort((t,s)=>t.renderOrder!==s.renderOrder?t.renderOrder-s.renderOrder:t.index-s.index)}removeComputePass(e){this.computePassEntries=this.computePassEntries.filter(t=>t.uuid!==e.uuid)}addRenderTarget(e){this.renderPassEntries.renderTarget.find(t=>t.renderPass.uuid===e.renderPass.uuid)||this.renderPassEntries.renderTarget.push({renderPass:e.renderPass,renderTexture:e.renderTexture,onBeforeRenderPass:null,onAfterRenderPass:null,element:null,stack:{unProjected:{opaque:[],transparent:[]},projected:{opaque:[],transparent:[]}}})}removeRenderTarget(e){this.renderPassEntries.renderTarget=this.renderPassEntries.renderTarget.filter(t=>t.renderPass.uuid!==e.renderPass.uuid)}getMeshProjectionStack(e){const t=e.outputTarget?this.renderPassEntries.renderTarget.find(i=>i.renderPass.uuid===e.outputTarget.renderPass.uuid):this.renderPassEntries.screen[0],{stack:s}=t;return e.material.options.rendering.useProjection?s.projected:s.unProjected}addMesh(e){const t=this.getMeshProjectionStack(e),s=e.transparent?t.transparent:t.opaque;s.push(e),s.sort((i,r)=>i.renderOrder-r.renderOrder||i.index-r.index),"parent"in e&&!e.parent&&e.material.options.rendering.useProjection&&(e.parent=this)}removeMesh(e){const t=this.getMeshProjectionStack(e);e.transparent?t.transparent=t.transparent.filter(s=>s.uuid!==e.uuid):t.opaque=t.opaque.filter(s=>s.uuid!==e.uuid),"parent"in e&&e.parent&&e.parent.object3DIndex===this.object3DIndex&&(e.parent=null)}addShaderPass(e){const t=e.inputTarget||e.outputTarget?null:(r,n)=>{e.renderTexture&&n&&r.copyTextureToTexture({texture:n},{texture:e.renderTexture.texture},[e.renderTexture.size.width,e.renderTexture.size.height]),this.renderer.postProcessingPass.setLoadOp("clear")},s=!e.outputTarget&&e.options.copyOutputToRenderTexture?(r,n)=>{e.renderTexture&&n&&r.copyTextureToTexture({texture:n},{texture:e.renderTexture.texture},[e.renderTexture.size.width,e.renderTexture.size.height])}:null,i={renderPass:e.outputTarget?e.outputTarget.renderPass:this.renderer.postProcessingPass,renderTexture:e.outputTarget?e.outputTarget.renderTexture:null,onBeforeRenderPass:t,onAfterRenderPass:s,element:e,stack:null};this.renderPassEntries.screen.push(i),this.renderPassEntries.screen.sort((r,n)=>{const a=r.element&&!r.element.outputTarget,h=r.element?r.element.renderOrder:0,u=r.element?r.element.index:0,l=n.element&&!n.element.outputTarget,d=n.element?n.element.renderOrder:0,c=n.element?n.element.index:0;return a&&!l?1:!a&&l?-1:h!==d?h-d:u-c})}removeShaderPass(e){this.renderPassEntries.screen=this.renderPassEntries.screen.filter(t=>!t.element||t.element.uuid!==e.uuid)}addPingPongPlane(e){this.renderPassEntries.pingPong.push({renderPass:e.outputTarget.renderPass,renderTexture:e.outputTarget.renderTexture,onBeforeRenderPass:null,onAfterRenderPass:(t,s)=>{t.copyTextureToTexture({texture:s},{texture:e.renderTexture.texture},[e.renderTexture.size.width,e.renderTexture.size.height])},element:e,stack:null}),this.renderPassEntries.pingPong.sort((t,s)=>t.element.renderOrder-s.element.renderOrder)}removePingPongPlane(e){this.renderPassEntries.pingPong=this.renderPassEntries.pingPong.filter(t=>t.element.uuid!==e.uuid)}getObjectRenderPassEntry(e){if(e.type==="RenderTarget")return this.renderPassEntries.renderTarget.find(t=>t.renderPass.uuid===e.renderPass.uuid);if(e.type==="PingPongPlane")return this.renderPassEntries.pingPong.find(t=>t.element.uuid===e.uuid);if(e.type==="ShaderPass")return this.renderPassEntries.screen.find(t=>t.element?.uuid===e.uuid);{const t=e.outputTarget?"renderTarget":"screen";return this.renderPassEntries[t].find(s=>[...s.stack.unProjected.opaque,...s.stack.unProjected.transparent,...s.stack.projected.opaque,...s.stack.projected.transparent].some(i=>i.uuid===e.uuid))}}sortTransparentMeshes(e){e.sort((t,s)=>{if(t.renderOrder!==s.renderOrder)return t.renderOrder-s.renderOrder;t.geometry?yt.copy(t.geometry.boundingBox.center).applyMat4(t.worldMatrix):t.worldMatrix.getTranslation(yt),s.geometry?xt.copy(s.geometry.boundingBox.center).applyMat4(s.worldMatrix):s.worldMatrix.getTranslation(xt);const i=t.geometry?t.geometry.boundingBox.radius*t.worldMatrix.getMaxScaleOnAxis():0,r=s.geometry?s.geometry.boundingBox.radius*s.worldMatrix.getMaxScaleOnAxis():0;return s.camera.worldMatrix.getTranslation(Ks).distance(xt)-r-(t.camera.worldMatrix.getTranslation(Xs).distance(yt)-i)})}renderSinglePassEntry(e,t){const s=t.renderPass.updateView(t.renderTexture?.texture);t.onBeforeRenderPass&&t.onBeforeRenderPass(e,s);const i=e.beginRenderPass(t.renderPass.descriptor);if(!this.renderer.production&&i.pushDebugGroup(t.element?`${t.element.options.label} render pass using ${t.renderPass.options.label} descriptor`:`Render stack pass using ${t.renderPass.options.label}${t.renderTexture?" onto "+t.renderTexture.options.label:""}`),t.element)t.element.render(i);else if(t.stack){for(const r of t.stack.unProjected.opaque)r.render(i);for(const r of t.stack.unProjected.transparent)r.render(i);if(t.stack.projected.opaque.length||t.stack.projected.transparent.length){for(const r of t.stack.projected.opaque)r.render(i);this.sortTransparentMeshes(t.stack.projected.transparent);for(const r of t.stack.projected.transparent)r.render(i)}}!this.renderer.production&&i.popDebugGroup(),i.end(),t.onAfterRenderPass&&t.onAfterRenderPass(e,s),this.renderer.pipelineManager.resetCurrentPipeline()}onBeforeRender(){for(let e=0,t=this.renderer.meshes.length;e<t;e++)this.renderer.meshes[e].onBeforeRenderScene();this.updateMatrixStack();for(const e of this.renderer.meshes)"checkFrustumCulling"in e&&e.visible&&e.checkFrustumCulling()}render(e){this.onBeforeRender();for(const t of this.computePassEntries){const s=e.beginComputePass();t.render(s),s.end(),t.copyBufferToResult(e),this.renderer.pipelineManager.resetCurrentPipeline()}for(const t in this.renderPassEntries){let s=0;this.renderPassEntries[t].forEach(i=>{this.getRenderPassEntryLength(i)&&(i.renderPass.setLoadOp(t==="screen"&&s!==0?"load":"clear"),s++,this.renderSinglePassEntry(e,i))})}}}class Ie{constructor(e,{label:t="Render Pass",sampleCount:s=4,qualityRatio:i=1,useColorAttachments:r=!0,renderToSwapChain:n=!0,colorAttachments:a=[],useDepth:h=!0,depthTexture:u=null,depthLoadOp:l="clear",depthStoreOp:d="store",depthClearValue:c=1,depthFormat:p="depth24plus"}={}){if(e=e&&e.renderer||e,$(e,"RenderPass"),this.type="RenderPass",this.uuid=k(),this.renderer=e,r){const g={loadOp:"clear",storeOp:"store",clearValue:[0,0,0,0],targetFormat:this.renderer.options.preferredFormat};a.length?a=a.map(m=>({...g,...m})):a=[g]}this.options={label:t,sampleCount:s,qualityRatio:i,useColorAttachments:r,renderToSwapChain:n,colorAttachments:a,useDepth:h,...u!==void 0&&{depthTexture:u},depthLoadOp:l,depthStoreOp:d,depthClearValue:c,depthFormat:p},this.options.useDepth&&this.createDepthTexture(),this.viewTextures=[],this.resolveTargets=[],this.options.useColorAttachments&&(!this.options.renderToSwapChain||this.options.sampleCount>1)&&(this.createViewTextures(),this.createResolveTargets()),this.setRenderPassDescriptor()}createDepthTexture(){this.options.depthTexture?(this.depthTexture=this.options.depthTexture,this.options.depthFormat=this.options.depthTexture.options.format):this.depthTexture=new te(this.renderer,{label:this.options.label+" depth texture",name:"depthTexture",format:this.options.depthFormat,sampleCount:this.options.sampleCount,qualityRatio:this.options.qualityRatio,type:"depth",usage:["renderAttachment","textureBinding"]})}createViewTextures(){this.options.colorAttachments.forEach((e,t)=>{this.viewTextures.push(new te(this.renderer,{label:`${this.options.label} colorAttachment[${t}] view texture`,name:`colorAttachment${t}ViewTexture`,format:e.targetFormat,sampleCount:this.options.sampleCount,qualityRatio:this.options.qualityRatio,type:"texture",usage:["copySrc","copyDst","renderAttachment","textureBinding"]}))})}createResolveTargets(){this.options.sampleCount>1&&this.options.colorAttachments.forEach((e,t)=>{this.resolveTargets.push(this.options.renderToSwapChain&&t===0?null:new te(this.renderer,{label:`${this.options.label} resolve target[${t}] texture`,name:`resolveTarget${t}Texture`,format:e.targetFormat,sampleCount:1,qualityRatio:this.options.qualityRatio,type:"texture"}))})}get outputTextures(){return this.options.sampleCount>1?this.resolveTargets:this.viewTextures}setRenderPassDescriptor(){this.descriptor={label:this.options.label+" descriptor",colorAttachments:this.options.colorAttachments.map((e,t)=>({view:this.viewTextures[t]?.texture.createView({label:this.viewTextures[t]?.texture.label+" view"}),...this.resolveTargets.length&&{resolveTarget:this.resolveTargets[t]?.texture.createView({label:this.resolveTargets[t]?.texture.label+" view"})},clearValue:e.clearValue,loadOp:e.loadOp,storeOp:e.storeOp})),...this.options.useDepth&&{depthStencilAttachment:{view:this.depthTexture.texture.createView({label:this.depthTexture.texture.label+" view"}),depthClearValue:this.options.depthClearValue,depthLoadOp:this.options.depthLoadOp,depthStoreOp:this.options.depthStoreOp}}}}resize(){this.options.useDepth&&(this.descriptor.depthStencilAttachment.view=this.depthTexture.texture.createView({label:this.depthTexture.options.label+" view"})),this.viewTextures.forEach((e,t)=>{this.descriptor.colorAttachments[t].view=e.texture.createView({label:e.options.label+" view"})}),this.resolveTargets.forEach((e,t)=>{e&&(this.descriptor.colorAttachments[t].resolveTarget=e.texture.createView({label:e.options.label+" view"}))})}setLoadOp(e="clear",t=0){this.options.useColorAttachments&&(this.options.colorAttachments[t]&&(this.options.colorAttachments[t].loadOp=e),this.descriptor&&this.descriptor.colorAttachments&&this.descriptor.colorAttachments[t]&&(this.descriptor.colorAttachments[t].loadOp=e))}setDepthLoadOp(e="clear"){this.options.depthLoadOp=e,this.options.useDepth&&this.descriptor.depthStencilAttachment&&(this.descriptor.depthStencilAttachment.depthLoadOp=e)}setClearValue(e=[0,0,0,0],t=0){if(this.options.useColorAttachments){if(this.renderer.alphaMode==="premultiplied"){const s=e[3];e[0]=Math.min(e[0],s),e[1]=Math.min(e[1],s),e[2]=Math.min(e[2],s)}this.options.colorAttachments[t]&&(this.options.colorAttachments[t].clearValue=e),this.descriptor&&this.descriptor.colorAttachments&&this.descriptor.colorAttachments[t]&&(this.descriptor.colorAttachments[t].clearValue=e)}}updateView(e=null){return!this.options.colorAttachments.length||!this.options.renderToSwapChain||(e||(e=this.renderer.context.getCurrentTexture(),e.label=`${this.renderer.type} context current texture`),this.options.sampleCount>1?(this.descriptor.colorAttachments[0].view=this.viewTextures[0].texture.createView({label:this.viewTextures[0].options.label+" view"}),this.descriptor.colorAttachments[0].resolveTarget=e.createView({label:e.label+" resolve target view"})):this.descriptor.colorAttachments[0].view=e.createView({label:e.label+" view"})),e}destroy(){this.viewTextures.forEach(e=>e.destroy()),this.resolveTargets.forEach(e=>e?.destroy()),!this.options.depthTexture&&this.depthTexture&&this.depthTexture.destroy()}}var ss=(o,e,t)=>{if(!e.has(o))throw TypeError("Cannot "+t)},is=(o,e,t)=>(ss(o,e,"read from private field"),t?t.call(o):e.get(o)),Zs=(o,e,t)=>{if(e.has(o))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(o):e.set(o,t)},Qs=(o,e,t,s)=>(ss(o,e,"write to private field"),s?s.call(o,t):e.set(o,t),t),Js=(o,e,t,s)=>({set _(i){Qs(o,e,i,t)},get _(){return is(o,e,s)}}),Ve;class We{constructor(){Zs(this,Ve,0),this.queue=[]}add(e=i=>{},{order:t=this.queue.length,once:s=!1}={}){const i={callback:e,order:t,once:s,id:is(this,Ve)};return Js(this,Ve)._++,this.queue.push(i),this.queue.sort((r,n)=>r.order-n.order),i.id}remove(e=0){this.queue=this.queue.filter(t=>t.id!==e)}execute(e){this.queue.forEach(t=>{t.callback(e),t.once&&this.remove(t.id)})}}Ve=new WeakMap;class bt{constructor({deviceManager:e,label:t="Main renderer",container:s,pixelRatio:i=1,autoResize:r=!0,preferredFormat:n,alphaMode:a="premultiplied",renderPass:h}){this._onBeforeRenderCallback=p=>{},this._onAfterRenderCallback=p=>{},this._onAfterResizeCallback=()=>{},this.type="GPURenderer",this.uuid=k(),e||q(`GPURenderer (${t}): no device manager provided: ${e}`),this.deviceManager=e,this.deviceManager.addRenderer(this),h={useDepth:!0,sampleCount:4,clearValue:[0,0,0,0],...h},n=n??this.deviceManager.gpu?.getPreferredCanvasFormat(),this.options={deviceManager:e,label:t,container:s,pixelRatio:i,autoResize:r,preferredFormat:n,alphaMode:a,renderPass:h},this.pixelRatio=i??window.devicePixelRatio??1,this.alphaMode=a;const u=s instanceof OffscreenCanvas,l=u||s instanceof HTMLCanvasElement;this.canvas=l?s:document.createElement("canvas");const{width:d,height:c}=this.canvas;this.rectBBox={width:d,height:c,top:0,left:0},this.setScene(),this.setTasksQueues(),this.setRendererObjects(),u||(this.domElement=new gt({element:s,priority:5,onSizeChanged:()=>{this.options.autoResize&&this.resize()}}),this.resize(),l||this.domElement.element.appendChild(this.canvas)),this.deviceManager.device&&this.setContext()}setSize(e=null){e={width:this.boundingRect.width,height:this.boundingRect.height,top:this.boundingRect.top,left:this.boundingRect.left,...e},this.rectBBox=e;const t={width:this.rectBBox.width,height:this.rectBBox.height};t.width*=this.pixelRatio,t.height*=this.pixelRatio,this.clampToMaxDimension(t),this.canvas.width=Math.floor(t.width),this.canvas.height=Math.floor(t.height),this.canvas.style&&(this.canvas.style.width=this.rectBBox.width+"px",this.canvas.style.height=this.rectBBox.height+"px")}setPixelRatio(e=1){this.pixelRatio=e,this.resize(this.rectBBox)}resize(e=null){this.setSize(e),this.onResize(),this._onAfterResizeCallback&&this._onAfterResizeCallback()}onResize(){this.textures.forEach(e=>{e.resize()}),this.renderPass?.resize(),this.postProcessingPass?.resize(),this.renderTargets.forEach(e=>e.resize()),this.computePasses.forEach(e=>e.resize()),this.pingPongPlanes.forEach(e=>e.resize(this.boundingRect)),this.shaderPasses.forEach(e=>e.resize(this.boundingRect)),this.resizeMeshes()}resizeMeshes(){this.meshes.forEach(e=>{e.resize(this.boundingRect)})}get boundingRect(){if(this.domElement&&this.domElement.boundingRect)return this.domElement.boundingRect;if(this.domElement){const e=this.domElement.element?.getBoundingClientRect();return{top:e.top,right:e.right,bottom:e.bottom,left:e.left,width:e.width,height:e.height,x:e.x,y:e.y}}else return{top:this.rectBBox.top,right:this.rectBBox.left+this.rectBBox.width,bottom:this.rectBBox.top+this.rectBBox.height,left:this.rectBBox.left,width:this.rectBBox.width,height:this.rectBBox.height,x:this.rectBBox.left,y:this.rectBBox.top}}clampToMaxDimension(e){this.device&&(e.width=Math.min(this.device.limits.maxTextureDimension2D,e.width),e.height=Math.min(this.device.limits.maxTextureDimension2D,e.height))}get device(){return this.deviceManager.device}get ready(){return this.deviceManager.ready&&!!this.context&&!!this.canvas.width&&!!this.canvas.height}get production(){return this.deviceManager.production}get samplers(){return this.deviceManager.samplers}get buffers(){return this.deviceManager.buffers}get pipelineManager(){return this.deviceManager.pipelineManager}get deviceRenderedObjects(){return this.deviceManager.deviceRenderedObjects}configureContext(){this.context.configure({device:this.device,format:this.options.preferredFormat,alphaMode:this.alphaMode,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST})}setContext(){this.context=this.canvas.getContext("webgpu"),this.device&&(this.configureContext(),this.setMainRenderPasses())}loseContext(){this.renderedObjects.forEach(e=>e.loseContext())}restoreContext(){this.configureContext(),this.textures.forEach(e=>{e.createTexture()}),this.renderPass?.resize(),this.postProcessingPass?.resize(),this.renderTargets.forEach(e=>e.resize()),this.renderedObjects.forEach(e=>e.restoreContext())}setMainRenderPasses(){this.renderPass=new Ie(this,{label:this.options.label+" render pass",...this.options.renderPass}),this.scene.setMainRenderPassEntry(),this.postProcessingPass=new Ie(this,{label:this.options.label+" post processing render pass",useDepth:!1,sampleCount:1})}setScene(){this.scene=new ts({renderer:this})}createBuffer(e){const t=this.deviceManager.device?.createBuffer(e.options);return this.deviceManager.addBuffer(e),t}removeBuffer(e){this.deviceManager.removeBuffer(e)}queueWriteBuffer(e,t,s){this.deviceManager.device?.queue.writeBuffer(e,t,s)}copyBufferToBuffer({srcBuffer:e,dstBuffer:t,commandEncoder:s}){if(!e||!e.GPUBuffer)return D(`${this.type} (${this.options.label}): cannot copy to buffer because the source buffer has not been provided`),null;if(t||(t=new de),t.GPUBuffer||t.createBuffer(this,{label:`GPURenderer (${this.options.label}): destination copy buffer from: ${e.options.label}`,size:e.GPUBuffer.size,usage:["copyDst","mapRead"]}),e.GPUBuffer.mapState!=="unmapped"){D(`${this.type} (${this.options.label}): Cannot copy from ${e.GPUBuffer} because it is currently mapped`);return}if(t.GPUBuffer.mapState!=="unmapped"){D(`${this.type} (${this.options.label}): Cannot copy from ${t.GPUBuffer} because it is currently mapped`);return}const i=!!s;if(i||(s=this.deviceManager.device?.createCommandEncoder({label:`${this.type} (${this.options.label}): Copy buffer command encoder`}),!this.production&&s.pushDebugGroup(`${this.type} (${this.options.label}): Copy buffer command encoder`)),s.copyBufferToBuffer(e.GPUBuffer,0,t.GPUBuffer,0,t.GPUBuffer.size),!i){!this.production&&s.popDebugGroup();const r=s.finish();this.deviceManager.device?.queue.submit([r])}return t}get bindGroups(){return this.deviceManager.bindGroups}addBindGroup(e){this.deviceManager.addBindGroup(e)}removeBindGroup(e){this.deviceManager.removeBindGroup(e)}createBindGroupLayout(e){return this.deviceManager.device?.createBindGroupLayout(e)}createBindGroup(e){return this.deviceManager.device?.createBindGroup(e)}createShaderModule(e){return this.device?.createShaderModule(e)}createPipelineLayout(e){return this.device?.createPipelineLayout(e)}createRenderPipeline(e){return this.device?.createRenderPipeline(e)}async createRenderPipelineAsync(e){return await this.device?.createRenderPipelineAsync(e)}createComputePipeline(e){return this.device?.createComputePipeline(e)}async createComputePipelineAsync(e){return await this.device?.createComputePipelineAsync(e)}get domTextures(){return this.deviceManager.domTextures}addDOMTexture(e){this.deviceManager.addDOMTexture(e)}removeDOMTexture(e){this.deviceManager.removeDOMTexture(e)}addTexture(e){this.textures.push(e)}removeTexture(e){this.textures=this.textures.filter(t=>t.uuid!==e.uuid)}createTexture(e){return this.deviceManager.device?.createTexture(e)}uploadTexture(e){this.deviceManager.uploadTexture(e)}importExternalTexture(e){return this.deviceManager.device?.importExternalTexture({source:e})}createSampler(e){const t=this.samplers.find(s=>JSON.stringify(s.options)===JSON.stringify(e.options)&&s.sampler);if(t)return t.sampler;{const{type:s,...i}=e.options,r=this.deviceManager.device?.createSampler({label:e.label,...i});return this.deviceManager.addSampler(e),r}}removeSampler(e){this.deviceManager.removeSampler(e)}setTasksQueues(){this.onBeforeCommandEncoderCreation=new We,this.onBeforeRenderScene=new We,this.onAfterRenderScene=new We,this.onAfterCommandEncoderSubmission=new We}setRendererObjects(){this.computePasses=[],this.pingPongPlanes=[],this.shaderPasses=[],this.renderTargets=[],this.meshes=[],this.textures=[]}get renderedObjects(){return[...this.computePasses,...this.meshes,...this.shaderPasses,...this.pingPongPlanes]}getObjectsByBindGroup(e){return this.deviceRenderedObjects.filter(t=>[...t.material.bindGroups,...t.material.inputsBindGroups,...t.material.clonedBindGroups].some(s=>s.uuid===e.uuid))}getObjectsByTexture(e){return this.deviceRenderedObjects.filter(t=>[...t.material.domTextures,...t.material.textures].some(s=>s.uuid===e.uuid))}onBeforeRender(e){return e&&(this._onBeforeRenderCallback=e),this}onAfterRender(e){return e&&(this._onAfterRenderCallback=e),this}onAfterResize(e){return e&&(this._onAfterResizeCallback=e),this}renderSingleComputePass(e,t){const s=e.beginComputePass();t.render(s),s.end(),t.copyBufferToResult(e)}renderSingleMesh(e,t){const s=e.beginRenderPass(this.renderPass.descriptor);t.render(s),s.end()}renderOnce(e){const t=this.device?.createCommandEncoder({label:"Render once command encoder"});!this.production&&t.pushDebugGroup("Render once command encoder"),this.pipelineManager.resetCurrentPipeline(),e.forEach(i=>{i.type==="ComputePass"?this.renderSingleComputePass(t,i):this.renderSingleMesh(t,i)}),!this.production&&t.popDebugGroup();const s=t.finish();this.device?.queue.submit([s]),this.pipelineManager.resetCurrentPipeline()}forceClear(e){const t=!!e;if(t||(e=this.device?.createCommandEncoder({label:`${this.type} (${this.options.label}): Force clear command encoder`}),!this.production&&e.pushDebugGroup(`${this.type} (${this.options.label}): Force clear command encoder`)),this.renderPass.updateView(),e.beginRenderPass(this.renderPass.descriptor).end(),!t){!this.production&&e.popDebugGroup();const i=e.finish();this.device?.queue.submit([i])}}onBeforeCommandEncoder(){this.ready&&this.onBeforeCommandEncoderCreation.execute()}onAfterCommandEncoder(){this.ready&&this.onAfterCommandEncoderSubmission.execute()}render(e){this.ready&&(this._onBeforeRenderCallback&&this._onBeforeRenderCallback(e),this.onBeforeRenderScene.execute(e),this.scene?.render(e),this._onAfterRenderCallback&&this._onAfterRenderCallback(e),this.onAfterRenderScene.execute(e))}destroy(){this.domElement?.destroy(),this.renderPass?.destroy(),this.postProcessingPass?.destroy(),this.renderTargets.forEach(e=>e.destroy()),this.renderedObjects.forEach(e=>e.remove()),this.textures.forEach(e=>e.destroy()),this.context?.unconfigure()}}class vt extends bt{constructor({deviceManager:e,label:t,container:s,pixelRatio:i=1,autoResize:r=!0,preferredFormat:n,alphaMode:a="premultiplied",renderPass:h,camera:u={}}){super({deviceManager:e,label:t,container:s,pixelRatio:i,autoResize:r,preferredFormat:n,alphaMode:a,renderPass:h}),this.type="GPUCameraRenderer",u={fov:50,near:.1,far:1e3,...u},this.options={...this.options,camera:u},this.setCamera(u),this.setCameraBindGroupAndBinding()}loseContext(){super.loseContext(),this.cameraBindGroup.loseContext()}restoreContext(){super.restoreContext(),this.cameraBindGroup?.restoreContext(),this.updateCameraBindings()}setCamera(e){const{width:t,height:s}=this.rectBBox;this.camera=new Ft({fov:e.fov,near:e.near,far:e.far,width:t,height:s,pixelRatio:this.pixelRatio,onMatricesChanged:()=>{this.onCameraMatricesChanged()}}),this.camera.parent=this.scene}onCameraMatricesChanged(){this.updateCameraBindings();for(const e of this.meshes)"modelViewMatrix"in e&&e.shouldUpdateMatrixStack()}setCameraBindGroupAndBinding(){this.cameraBufferBinding=new ce({label:"Camera",name:"camera",visibility:["vertex"],struct:{view:{type:"mat4x4f",value:this.camera.viewMatrix},projection:{type:"mat4x4f",value:this.camera.projectionMatrix},position:{type:"vec3f",value:this.camera.position.clone().setFromMatrixPosition(this.camera.worldMatrix),onBeforeUpdate:()=>{this.cameraBufferBinding.inputs.position.value.copy(this.camera.position).setFromMatrixPosition(this.camera.worldMatrix)}}}}),this.cameraBindGroup=new Re(this,{label:"Camera Uniform bind group",bindings:[this.cameraBufferBinding]}),this.cameraBindGroup.consumers.add(this.uuid)}setCameraBindGroup(){this.cameraBindGroup&&this.cameraBindGroup.shouldCreateBindGroup&&(this.cameraBindGroup.setIndex(0),this.cameraBindGroup.createBindGroup())}updateCameraBindings(){this.cameraBufferBinding?.shouldUpdateBinding("view"),this.cameraBufferBinding?.shouldUpdateBinding("projection"),this.cameraBufferBinding?.shouldUpdateBinding("position"),this.cameraBindGroup?.update()}getObjectsByBindGroup(e){return this.deviceRenderedObjects.filter(t=>[...t.material.bindGroups,...t.material.inputsBindGroups,...t.material.clonedBindGroups,this.cameraBindGroup].some(s=>s.uuid===e.uuid))}setPerspective({fov:e,near:t,far:s}={}){this.camera?.setPerspective({fov:e,near:t,far:s,width:this.rectBBox.width,height:this.rectBBox.height,pixelRatio:this.pixelRatio})}setCameraPosition(e=new f(0,0,1)){this.camera.position.copy(e)}onResize(){this.setPerspective(),super.onResize()}render(e){this.ready&&(this.setCameraBindGroup(),super.render(e))}destroy(){this.cameraBindGroup?.destroy(),super.destroy()}}class rs{constructor({label:e,production:t=!1,adapterOptions:s={},onError:i=()=>{},onDeviceLost:r=n=>{}}={}){this.index=0,this.label=e??"GPUDeviceManager instance",this.production=t,this.ready=!1,this.adapterOptions=s,this.onError=i,this.onDeviceLost=r,this.gpu=navigator.gpu,this.setPipelineManager(),this.setDeviceObjects()}async setAdapterAndDevice({adapter:e=null,device:t=null}={}){await this.setAdapter(e),await this.setDevice(t)}async init({adapter:e=null,device:t=null}={}){if(await this.setAdapterAndDevice({adapter:e,device:t}),this.device)for(const s of this.renderers)s.context||s.setContext()}async setAdapter(e=null){this.gpu||(this.onError(),q("GPUDeviceManager: WebGPU is not supported on your browser/OS. No 'gpu' object in 'navigator'.")),e?this.adapter=e:(this.adapter=await this.gpu?.requestAdapter(this.adapterOptions),this.adapter||(this.onError(),q("GPUDeviceManager: WebGPU is not supported on your browser/OS. 'requestAdapter' failed."))),this.adapter?.requestAdapterInfo().then(t=>{this.adapterInfos=t})}async setDevice(e=null){if(e)this.device=e,this.ready=!0,this.index++;else try{this.device=await this.adapter?.requestDevice({label:this.label+" "+this.index}),this.device&&(this.ready=!0,this.index++)}catch(t){this.onError(),q(`${this.label}: WebGPU is not supported on your browser/OS. 'requestDevice' failed: ${t}`)}this.device?.lost.then(t=>{D(`${this.label}: WebGPU device was lost: ${t.message}`),this.loseDevice(),t.reason!=="destroyed"&&this.onDeviceLost(t)})}setPipelineManager(){this.pipelineManager=new es}loseDevice(){this.ready=!1,this.pipelineManager.resetCurrentPipeline(),this.samplers.forEach(e=>e.sampler=null),this.renderers.forEach(e=>e.loseContext()),this.bindGroupLayouts.clear(),this.buffers.clear()}async restoreDevice({adapter:e=null,device:t=null}={}){await this.setAdapterAndDevice({adapter:e,device:t}),this.device&&(this.samplers.forEach(s=>{const{type:i,...r}=s.options;s.sampler=this.device.createSampler({label:s.label,...r})}),this.renderers.forEach(s=>s.restoreContext()))}setDeviceObjects(){this.renderers=[],this.bindGroups=new Map,this.buffers=new Map,this.bindGroupLayouts=new Map,this.bufferBindings=new Map,this.samplers=[],this.domTextures=[],this.texturesQueue=[]}addRenderer(e){this.renderers.push(e)}removeRenderer(e){this.renderers=this.renderers.filter(t=>t.uuid!==e.uuid)}get deviceRenderedObjects(){return this.renderers.map(e=>e.renderedObjects).flat()}addBindGroup(e){this.bindGroups.set(e.uuid,e)}removeBindGroup(e){this.bindGroups.delete(e.uuid)}addBuffer(e){this.buffers.set(e.uuid,e)}removeBuffer(e){this.buffers.delete(e?.uuid)}addSampler(e){this.samplers.push(e)}removeSampler(e){this.samplers=this.samplers.filter(t=>t.uuid!==e.uuid)}addDOMTexture(e){this.domTextures.push(e)}uploadTexture(e){if(e.source)try{this.device?.queue.copyExternalImageToTexture({source:e.source,flipY:e.options.flipY},{texture:e.texture,premultipliedAlpha:e.options.premultipliedAlpha},{width:e.size.width,height:e.size.height}),e.texture.mipLevelCount>1&&Pt(this.device,e.texture),this.texturesQueue.push(e)}catch({message:t}){q(`GPUDeviceManager: could not upload texture: ${e.options.name} because: ${t}`)}else this.device?.queue.writeTexture({texture:e.texture},new Uint8Array(e.options.placeholderColor),{bytesPerRow:e.size.width*4},{width:e.size.width,height:e.size.height})}removeDOMTexture(e){this.domTextures=this.domTextures.filter(t=>t.uuid!==e.uuid)}render(){if(!this.ready)return;for(const s of this.renderers)s.onBeforeCommandEncoder();const e=this.device?.createCommandEncoder({label:this.label+" command encoder"});!this.production&&e.pushDebugGroup(this.label+" command encoder: main render loop"),this.renderers.forEach(s=>s.render(e)),!this.production&&e.popDebugGroup();const t=e.finish();this.device?.queue.submit([t]),this.domTextures.filter(s=>!s.parentMesh&&s.sourceLoaded&&!s.sourceUploaded).forEach(s=>this.uploadTexture(s));for(const s of this.texturesQueue)s.sourceUploaded=!0;this.texturesQueue=[];for(const s of this.renderers)s.onAfterCommandEncoder()}destroy(){this.device?.destroy(),this.device=null,this.renderers.forEach(e=>e.destroy()),this.bindGroups.forEach(e=>e.destroy()),this.buffers.forEach(e=>e?.destroy()),this.domTextures.forEach(e=>e.destroy()),this.setDeviceObjects()}}var ns=(o,e,t)=>{if(!e.has(o))throw TypeError("Cannot "+t)},os=(o,e,t)=>(ns(o,e,"read from private field"),t?t.call(o):e.get(o)),ei=(o,e,t)=>{if(e.has(o))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(o):e.set(o,t)},ti=(o,e,t,s)=>(ns(o,e,"write to private field"),s?s.call(o,t):e.set(o,t),t),ve;class as{constructor(e,t={}){ei(this,ve,!0),e=e&&e.renderer||e,$(e,"RenderTarget"),this.type="RenderTarget",this.renderer=e,this.uuid=k();const{label:s,colorAttachments:i,depthTexture:r,autoRender:n,...a}=t,h=r||(this.renderer.renderPass.options.sampleCount===(t.sampleCount??4)?this.renderer.renderPass.depthTexture:null);this.options={label:s,...a,...h&&{depthTexture:h},...i&&{colorAttachments:i},autoRender:n===void 0?!0:n},n!==void 0&&ti(this,ve,n),this.renderPass=new Ie(this.renderer,{label:this.options.label?`${this.options.label} Render Pass`:"Render Target Render Pass",...i&&{colorAttachments:i},depthTexture:this.options.depthTexture,...a}),a.useColorAttachments!==!1&&(this.renderTexture=new te(this.renderer,{label:this.options.label?`${this.options.label} Render Texture`:"Render Target render texture",name:"renderTexture",format:i&&i.length&&i[0].targetFormat?i[0].targetFormat:this.renderer.options.preferredFormat,...this.options.qualityRatio!==void 0&&{qualityRatio:this.options.qualityRatio},usage:["copySrc","renderAttachment","textureBinding"]})),this.addToScene()}get outputTextures(){return this.renderPass.outputTextures.length?this.renderPass.outputTextures.map((e,t)=>t===0&&this.renderPass.options.renderToSwapChain?this.renderTexture:e):this.renderTexture?[this.renderTexture]:[]}addToScene(){this.renderer.renderTargets.push(this),os(this,ve)&&this.renderer.scene.addRenderTarget(this)}removeFromScene(){os(this,ve)&&this.renderer.scene.removeRenderTarget(this),this.renderer.renderTargets=this.renderer.renderTargets.filter(e=>e.uuid!==this.uuid)}resize(){this.options.depthTexture&&(this.renderPass.options.depthTexture.texture=this.options.depthTexture.texture),this.renderPass?.resize()}remove(){this.destroy()}destroy(){this.renderer.meshes.forEach(e=>{e.outputTarget&&e.outputTarget.uuid===this.uuid&&e.setOutputTarget(null)}),this.renderer.shaderPasses.forEach(e=>{e.outputTarget&&e.outputTarget.uuid===this.uuid&&(e.outputTarget=null,e.setOutputTarget(null))}),this.removeFromScene(),this.renderPass?.destroy(),this.renderTexture?.destroy()}}ve=new WeakMap;var si=`
struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) uv: vec2f,
};

@fragment fn main(fsInput: VSOutput) -> @location(0) vec4f {
  return textureSample(renderTexture, defaultSampler, fsInput.uv);
}`;class ii extends dt{constructor(e,t={}){e=e&&e.renderer||e,$(e,t.label?t.label+" ShaderPass":"ShaderPass"),t.depth=!1,t.transparent=!0,t.label=t.label??"ShaderPass "+e.shaderPasses?.length,t.sampleCount=t.sampleCount?t.sampleCount:e&&e.postProcessingPass?e&&e.postProcessingPass.options.sampleCount:1,t.shaders||(t.shaders={}),t.shaders.fragment||(t.shaders.fragment={code:si,entryPoint:"main"}),t.depth=!1,super(e,t),t.inputTarget&&this.setInputTarget(t.inputTarget),this.outputTarget&&this.setRenderingOptionsForRenderPass(this.outputTarget.renderPass),this.type="ShaderPass",this.createTexture({label:t.label?`${t.label} render texture`:"Shader pass render texture",name:"renderTexture",fromTexture:this.inputTarget?this.inputTarget.renderTexture:null,usage:["copySrc","copyDst","textureBinding"],...this.outputTarget&&this.outputTarget.options.qualityRatio&&{qualityRatio:this.outputTarget.options.qualityRatio}})}cleanupRenderMaterialParameters(e){return delete e.copyOutputToRenderTexture,delete e.inputTarget,super.cleanupRenderMaterialParameters(e),e}get renderTexture(){return this.textures.find(e=>e.options.name==="renderTexture")}setInputTarget(e){if(e&&e.type!=="RenderTarget"){D(`${this.options.label??this.type}: inputTarget is not a RenderTarget: ${e}`);return}this.removeFromScene(),this.inputTarget=e,this.addToScene(),this.renderTexture&&(e?this.renderTexture.copy(this.inputTarget.renderTexture):(this.renderTexture.options.fromTexture=null,this.renderTexture.createTexture()))}addToScene(e=!1){e&&this.renderer.shaderPasses.push(this),this.setRenderingOptionsForRenderPass(this.outputTarget?this.outputTarget.renderPass:this.renderer.postProcessingPass),this.autoRender&&this.renderer.scene.addShaderPass(this)}removeFromScene(e=!1){this.outputTarget&&this.outputTarget.destroy(),this.autoRender&&this.renderer.scene.removeShaderPass(this),e&&(this.renderer.shaderPasses=this.renderer.shaderPasses.filter(t=>t.uuid!==this.uuid))}}var hs=(o,e,t)=>{if(!e.has(o))throw TypeError("Cannot "+t)},pe=(o,e,t)=>(hs(o,e,"read from private field"),t?t.call(o):e.get(o)),wt=(o,e,t)=>{if(e.has(o))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(o):e.set(o,t)},ri=(o,e,t,s)=>(hs(o,e,"write to private field"),s?s.call(o,t):e.set(o,t),t),we,Ne,je;class us extends ct{constructor(e,t,s={}){super(e),wt(this,we,new f),wt(this,Ne,new f(1)),wt(this,je,1),this.boundingBox=new ie(new f(-1),new f(1)),this._onAfterDOMElementResizeCallback=()=>{},e=e&&e.renderer||e,Qe(e,"DOM3DObject"),this.renderer=e,this.size={document:{width:0,height:0,top:0,left:0},normalizedWorld:{size:new E(1),position:new E},cameraWorld:{size:new E(1),position:new E},scaledWorld:{size:new f(1),position:new f}},this.watchScroll=s.watchScroll,this.camera=this.renderer.camera,this.boundingBox.min.onChange(()=>this.updateSizeAndPosition()),this.boundingBox.max.onChange(()=>this.updateSizeAndPosition()),this.setDOMElement(t),this.renderer.domObjects.push(this)}setDOMElement(e){this.domElement=new gt({element:e,onSizeChanged:t=>this.resize(t),onPositionChanged:t=>this.onPositionChanged(t)})}onPositionChanged(e){this.watchScroll&&(this.size.document=e??this.domElement.element.getBoundingClientRect(),this.updateSizeAndPosition())}resetDOMElement(e){this.domElement&&this.domElement.destroy(),this.setDOMElement(e)}updateSizeAndPosition(){this.setWorldSizes(),this.applyPosition()}resize(e=null){!e&&(!this.domElement||this.domElement?.isResizing)||(this.size.document=e??this.domElement.element.getBoundingClientRect(),this.updateSizeAndPosition(),this._onAfterDOMElementResizeCallback&&this._onAfterDOMElementResizeCallback())}get boundingRect(){return this.domElement.boundingRect}setTransforms(){super.setTransforms(),this.transforms.origin.model.set(.5,.5,0),this.transforms.origin.world=new f,this.transforms.position.document=new f,this.documentPosition.onChange(()=>this.applyPosition()),this.transformOrigin.onChange(()=>this.setWorldTransformOrigin())}get documentPosition(){return this.transforms.position.document}set documentPosition(e){this.transforms.position.document=e,this.applyPosition()}get DOMObjectWorldScale(){return pe(this,Ne).clone()}get worldScale(){return this.DOMObjectWorldScale.multiply(this.scale)}get worldPosition(){return pe(this,we).clone()}get transformOrigin(){return this.transforms.origin.model}set transformOrigin(e){this.transforms.origin.model=e,this.setWorldTransformOrigin()}get worldTransformOrigin(){return this.transforms.origin.world}set worldTransformOrigin(e){this.transforms.origin.world=e}applyPosition(){this.applyDocumentPosition(),super.applyPosition()}applyDocumentPosition(){let e=new f(0,0,0);this.documentPosition.equals(e)||(e=this.documentToWorldSpace(this.documentPosition)),pe(this,we).set(this.position.x+this.size.scaledWorld.position.x+e.x,this.position.y+this.size.scaledWorld.position.y+e.y,this.position.z+this.size.scaledWorld.position.z+this.documentPosition.z/this.camera.CSSPerspective)}applyTransformOrigin(){this.size&&(this.setWorldTransformOrigin(),super.applyTransformOrigin())}updateModelMatrix(){this.modelMatrix.composeFromOrigin(pe(this,we),this.quaternion,this.scale,this.worldTransformOrigin),this.modelMatrix.scale(this.DOMObjectWorldScale),this.shouldUpdateWorldMatrix()}documentToWorldSpace(e=new f){return new f(e.x*this.renderer.pixelRatio/this.renderer.boundingRect.width*this.camera.screenRatio.width,-(e.y*this.renderer.pixelRatio/this.renderer.boundingRect.height)*this.camera.screenRatio.height,e.z)}computeWorldSizes(){const e=this.renderer.boundingRect,t={x:this.size.document.width/2+this.size.document.left,y:this.size.document.height/2+this.size.document.top},s={x:e.width/2+e.left,y:e.height/2+e.top},{size:i,center:r}=this.boundingBox;i.x!==0&&i.y!==0&&i.z!==0&&r.divide(i),this.size.normalizedWorld.size.set(this.size.document.width/e.width,this.size.document.height/e.height),this.size.normalizedWorld.position.set((t.x-s.x)/e.width,(s.y-t.y)/e.height),this.size.cameraWorld.size.set(this.size.normalizedWorld.size.x*this.camera.screenRatio.width,this.size.normalizedWorld.size.y*this.camera.screenRatio.height),this.size.cameraWorld.position.set(this.size.normalizedWorld.position.x*this.camera.screenRatio.width,this.size.normalizedWorld.position.y*this.camera.screenRatio.height),this.size.scaledWorld.size.set(this.size.cameraWorld.size.x/i.x,this.size.cameraWorld.size.y/i.y,1),this.size.scaledWorld.size.z=this.size.scaledWorld.size.y*(i.x/i.y/(this.size.document.width/this.size.document.height)),this.size.scaledWorld.position.set(this.size.cameraWorld.position.x-r.x*this.size.scaledWorld.size.x*i.x,this.size.cameraWorld.position.y-r.y*this.size.scaledWorld.size.y*i.y,-r.z)}setWorldSizes(){this.computeWorldSizes(),this.setWorldScale(),this.setWorldTransformOrigin()}setWorldScale(){pe(this,Ne).set(this.size.scaledWorld.size.x,this.size.scaledWorld.size.y,this.size.scaledWorld.size.z*pe(this,je)),this.shouldUpdateMatrixStack()}set DOMObjectDepthScaleRatio(e){ri(this,je,e),this.setWorldScale()}setWorldTransformOrigin(){this.transforms.origin.world=new f((this.transformOrigin.x*2-1)*this.size.scaledWorld.size.x,-(this.transformOrigin.y*2-1)*this.size.scaledWorld.size.y,this.transformOrigin.z*this.size.scaledWorld.size.z),this.shouldUpdateMatrixStack()}updateScrollPosition(e={x:0,y:0}){(e.x||e.y)&&this.domElement.updateScrollPosition(e)}onAfterDOMElementResize(e){return e&&(this._onAfterDOMElementResizeCallback=e),this}destroy(){super.destroy(),this.domElement?.destroy()}}we=new WeakMap,Ne=new WeakMap,je=new WeakMap;const ls={autoloadSources:!0,watchScroll:!0};class ds extends Kt(us){constructor(e,t,s){super(e,t,{...ls,...s}),this._onLoadingCallback=r=>{},s={...ls,...s},e=e&&e.renderer||e,Qe(e,s.label?s.label+" DOMMesh":"DOMMesh"),this.type="DOMMesh";const{autoloadSources:i}=s;this.autoloadSources=i,this.sourcesReady=!1,this.setInitSources()}get ready(){return this._ready}set ready(e){e&&!this._ready&&this.sourcesReady&&this._onReadyCallback&&this._onReadyCallback(),this._ready=e}get sourcesReady(){return this._sourcesReady}set sourcesReady(e){e&&!this._sourcesReady&&this.ready&&this._onReadyCallback&&this._onReadyCallback(),this._sourcesReady=e}addToScene(e=!1){super.addToScene(e),e&&this.renderer.domMeshes.push(this)}removeFromScene(e=!1){super.removeFromScene(e),e&&(this.renderer.domMeshes=this.renderer.domMeshes.filter(t=>t.uuid!==this.uuid))}setInitSources(){let e=0,t=0;if(this.autoloadSources){const s=this.domElement.element.querySelectorAll("img"),i=this.domElement.element.querySelectorAll("video"),r=this.domElement.element.querySelectorAll("canvas");e=s.length+i.length+r.length;const n=a=>{t++,this._onLoadingCallback&&this._onLoadingCallback(a),t===e&&(this.sourcesReady=!0)};e||(this.sourcesReady=!0),s.length&&s.forEach(a=>{const h=this.createDOMTexture({name:a.getAttribute("data-texture-name")??"texture"+this.domTextures.length});h.onSourceUploaded(()=>n(h)).loadImage(a.src)}),i.length&&i.forEach(a=>{const h=this.createDOMTexture({name:a.getAttribute("data-texture-name")??"texture"+this.domTextures.length});h.onSourceUploaded(()=>n(h)).loadVideo(a)}),r.length&&r.forEach(a=>{const h=this.createDOMTexture({name:a.getAttribute("data-texture-name")??"texture"+this.domTextures.length});h.onSourceUploaded(()=>n(h)).loadCanvas(a)})}else this.sourcesReady=!0}resetDOMElement(e){e?super.resetDOMElement(e):!e&&!this.renderer.production&&D(`${this.options.label}: You are trying to reset a ${this.type} with a HTML element that does not exist. The old HTML element will be kept instead.`)}get pixelRatioBoundingRect(){const e=window.devicePixelRatio??1,t=this.renderer.pixelRatio/e;return Object.keys(this.domElement.boundingRect).reduce((s,i)=>({...s,[i]:this.domElement.boundingRect[i]*t}),{x:0,y:0,width:0,height:0,top:0,right:0,bottom:0,left:0})}computeGeometry(){super.computeGeometry(),this.boundingBox.copy(this.geometry.boundingBox)}onLoading(e){return e&&(this._onLoadingCallback=e),this}}class ni extends dt{constructor(e,t={}){e=e&&e.renderer||e,$(e,t.label?t.label+" PingPongPlane":"PingPongPlane");const s=t.targets&&t.targets.length&&t.targets.map(i=>({targetFormat:i.format}));t.outputTarget=new as(e,{label:t.label?t.label+" render target":"Ping Pong render target",useDepth:!1,...s&&{colorAttachments:s}}),t.transparent=!1,t.depth=!1,t.label=t.label??"PingPongPlane "+e.pingPongPlanes?.length,super(e,t),this.type="PingPongPlane",this.createTexture({label:t.label?`${t.label} render texture`:"PingPongPlane render texture",name:"renderTexture",...t.targets&&t.targets.length&&{format:t.targets[0].format},usage:["copyDst","textureBinding"]})}get renderTexture(){return this.textures.find(e=>e.options.name==="renderTexture")}addToScene(e=!1){e&&this.renderer.pingPongPlanes.push(this),this.autoRender&&this.renderer.scene.addPingPongPlane(this)}removeFromScene(e=!1){this.outputTarget&&this.outputTarget.destroy(),this.autoRender&&this.renderer.scene.removePingPongPlane(this),e&&(this.renderer.pingPongPlanes=this.renderer.pingPongPlanes.filter(t=>t.uuid!==this.uuid))}}const oi={label:"Plane",instancesCount:1,vertexBuffers:[]};class cs extends ds{constructor(e,t,s={}){e=e&&e.renderer||e,Qe(e,s.label?s.label+" Plane":"Plane");const i={...oi,...s};let{geometry:r,widthSegments:n,heightSegments:a,...h}=i;const{instancesCount:u,vertexBuffers:l,...d}=h;if(!r||r.type!=="PlaneGeometry"){n=n??1,a=a??1;const c=n*a+n;l.length||(r=ke.getPlaneGeometryByID(c)),r?r.instancesCount=u:(r=new ot({widthSegments:n,heightSegments:a,instancesCount:u,vertexBuffers:l}),ke.addPlaneGeometry(r))}super(e,t,{geometry:r,...d}),this.type="Plane"}mouseToPlaneCoords(e=new E){const t={x:2*(e.x/this.renderer.boundingRect.width)-1,y:2*(1-e.y/this.renderer.boundingRect.height)-1},s=this.camera.position.clone(),i=new f(t.x,t.y,-.5);i.unproject(this.camera),i.sub(s).normalize();const r=new f(0,0,1);r.applyQuat(this.quaternion).normalize();const n=new f(0,0,0),a=r.dot(i);if(Math.abs(a)>=1e-4){const h=this.worldMatrix.getInverse().premultiply(this.camera.viewMatrix),u=this.worldTransformOrigin.clone().add(this.worldPosition),l=new f(this.worldPosition.x-u.x,this.worldPosition.y-u.y,this.worldPosition.z-u.z);l.applyQuat(this.quaternion),u.add(l);const d=r.dot(u.clone().sub(s))/a;n.copy(s.add(i.multiplyScalar(d))),n.applyMat4(h)}else n.set(1/0,1/0,1/0);return new E(n.x,n.y)}}class qe extends vt{constructor({deviceManager:e,label:t,container:s,pixelRatio:i=1,autoResize:r=!0,preferredFormat:n,alphaMode:a="premultiplied",renderPass:h,camera:u}){super({deviceManager:e,label:t,container:s,pixelRatio:i,autoResize:r,preferredFormat:n,alphaMode:a,renderPass:h,camera:u}),this.type="GPUCurtainsRenderer"}setRendererObjects(){super.setRendererObjects(),this.domMeshes=[],this.domObjects=[]}onCameraMatricesChanged(){super.onCameraMatricesChanged(),this.domObjects.forEach(e=>{e.updateSizeAndPosition()})}resizeMeshes(){this.meshes.forEach(e=>{"domElement"in e||e.resize(this.boundingRect)}),this.domObjects.forEach(e=>{e.domElement.isResizing||e.domElement.setSize()})}}class ai{constructor({scroll:e={x:0,y:0},delta:t={x:0,y:0},shouldWatch:s=!0,onScroll:i=(r={x:0,y:0})=>{}}={}){this.scroll=e,this.delta=t,this.shouldWatch=s,this.onScroll=i,this.shouldWatch&&window.addEventListener("scroll",this.setScroll.bind(this),{passive:!0})}setScroll(){this.updateScrollValues({x:window.pageXOffset,y:window.pageYOffset})}updateScrollValues({x:e,y:t}){const s=this.scroll;this.scroll={x:e,y:t},this.delta={x:s.x-this.scroll.x,y:s.y-this.scroll.y},this.onScroll&&this.onScroll(this.delta)}destroy(){this.shouldWatch&&window.removeEventListener("scroll",this.setScroll.bind(this),{passive:!0})}}class hi{constructor({container:e,label:t,pixelRatio:s=window.devicePixelRatio??1,preferredFormat:i,alphaMode:r="premultiplied",production:n=!1,adapterOptions:a={},renderPass:h,camera:u,autoRender:l=!0,autoResize:d=!0,watchScroll:c=!0}={}){this._onRenderCallback=()=>{},this._onScrollCallback=()=>{},this._onErrorCallback=()=>{},this._onContextLostCallback=()=>{},this.type="CurtainsGPU",this.options={container:e,label:t,pixelRatio:s,camera:u,production:n,adapterOptions:a,preferredFormat:i,alphaMode:r,renderPass:h,autoRender:l,autoResize:d,watchScroll:c},this.setDeviceManager(),e&&this.setContainer(e)}setContainer(e){if(e)if(typeof e=="string")if(e=document.querySelector(e),e)this.options.container=e;else{const t=document.createElement("div");t.setAttribute("id","curtains-gpu-canvas"),document.body.appendChild(t),this.options.container=t}else e instanceof Element&&(this.options.container=e);else{const t=document.createElement("div");t.setAttribute("id","curtains-gpu-canvas"),document.body.appendChild(t),this.options.container=t}this.container=this.options.container,this.setCurtains()}setMainRenderer(){this.createCurtainsRenderer({deviceManager:this.deviceManager,label:this.options.label,container:this.options.container,pixelRatio:this.options.pixelRatio,autoResize:this.options.autoResize,preferredFormat:this.options.preferredFormat,alphaMode:this.options.alphaMode,renderPass:this.options.renderPass,camera:this.options.camera})}patchRendererOptions(e){return e.pixelRatio===void 0&&(e.pixelRatio=this.options.pixelRatio),e.autoResize===void 0&&(e.autoResize=this.options.autoResize),e}createRenderer(e){return e=this.patchRendererOptions(e),new bt({...e,deviceManager:this.deviceManager})}createCameraRenderer(e){return e=this.patchRendererOptions(e),new vt({...e,deviceManager:this.deviceManager})}createCurtainsRenderer(e){return e=this.patchRendererOptions(e),new qe({...e,deviceManager:this.deviceManager})}setDeviceManager(){this.deviceManager=new rs({label:"GPUCurtains default device",production:this.options.production,adapterOptions:this.options.adapterOptions,onError:()=>setTimeout(()=>{this._onErrorCallback&&this._onErrorCallback()},0),onDeviceLost:e=>this._onContextLostCallback&&this._onContextLostCallback(e)})}get renderers(){return this.deviceManager.renderers}get renderer(){return this.renderers[0]}async setDevice({adapter:e=null,device:t=null}={}){await this.deviceManager.init({adapter:e,device:t})}async restoreContext(){await this.deviceManager.restoreDevice()}setCurtains(){this.initEvents(),this.setMainRenderer(),this.options.autoRender&&this.animate()}get pingPongPlanes(){return this.renderers?.map(e=>e.pingPongPlanes).flat()}get shaderPasses(){return this.renderers?.map(e=>e.shaderPasses).flat()}get meshes(){return this.renderers?.map(e=>e.meshes).flat()}get domMeshes(){return this.renderers?.filter(e=>e instanceof qe).map(e=>e.domMeshes).flat()}get domObjects(){return this.renderers?.filter(e=>e instanceof qe).map(e=>e.domObjects).flat()}get planes(){return this.domMeshes.filter(e=>e instanceof cs)}get computePasses(){return this.renderers?.map(e=>e.computePasses).flat()}get camera(){return this.renderer?.camera}setPerspective({fov:e=50,near:t=.01,far:s=50}={}){this.renderer?.setPerspective({fov:e,near:t,far:s})}setCameraPosition(e=new f(0,0,1)){this.renderer?.setCameraPosition(e)}get boundingRect(){return this.renderer?.boundingRect}initScroll(){this.scrollManager=new ai({scroll:{x:window.pageXOffset,y:window.pageYOffset},delta:{x:0,y:0},shouldWatch:this.options.watchScroll,onScroll:e=>this.updateScroll(e)})}updateScroll(e={x:0,y:0}){this.domObjects.forEach(t=>{t.domElement&&t.updateScrollPosition(e)}),this._onScrollCallback&&this._onScrollCallback()}updateScrollValues(e={x:0,y:0}){this.scrollManager.updateScrollValues(e)}get scrollDelta(){return this.scrollManager.delta}get scrollValues(){return this.scrollManager.scroll}initEvents(){mt.useObserver(this.options.autoResize),this.initScroll()}onRender(e){return e&&(this._onRenderCallback=e),this}onScroll(e){return e&&(this._onScrollCallback=e),this}onError(e){return e&&(this._onErrorCallback=e),this}onContextLost(e){return e&&(this._onContextLostCallback=e),this}animate(){this.render(),this.animationFrameID=window.requestAnimationFrame(this.animate.bind(this))}render(){this._onRenderCallback&&this._onRenderCallback(),this.deviceManager.render()}destroy(){this.animationFrameID&&window.cancelAnimationFrame(this.animationFrameID),this.deviceManager.destroy(),this.scrollManager?.destroy(),mt.destroy()}}var ps=(o,e,t)=>{if(!e.has(o))throw TypeError("Cannot "+t)},V=(o,e,t)=>(ps(o,e,"read from private field"),t?t.call(o):e.get(o)),Mt=(o,e,t)=>{if(e.has(o))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(o):e.set(o,t)},Bt=(o,e,t,s)=>(ps(o,e,"write to private field"),s?s.call(o,t):e.set(o,t),t),fe,Me,H;class ui extends se{constructor(e,{camera:t=null,element:s=null}={}){super(),Mt(this,fe,new E),Mt(this,Me,!1),this.constrainXOrbit=!0,this.constrainYOrbit=!1,this.minOrbit=new E(-Math.PI*.5,-Math.PI),this.maxOrbit=new E(Math.PI*.5,Math.PI),this.orbitStep=new E(.025),this.constrainZoom=!0,this.minZoom=0,this.maxZoom=20,this.zoomStep=.005,Mt(this,H,null),this.renderer=e,this.parent=this.renderer.scene,this.quaternion.setAxisOrder("YXZ"),this.camera=t||this.renderer.camera,this.camera.parent=this,this.element=s??this.renderer.domElement.element}set element(e){V(this,H)&&(!e||V(this,H)!==e)&&this.removeEvents(),Bt(this,H,e),e&&this.addEvents()}get element(){return V(this,H)}addEvents(){V(this,H).addEventListener("pointerdown",this.onPointerDown.bind(this)),V(this,H).addEventListener("pointermove",this.onPointerMove.bind(this)),V(this,H).addEventListener("pointerup",this.onPointerUp.bind(this)),V(this,H).addEventListener("wheel",this.onMouseWheel.bind(this))}removeEvents(){V(this,H).removeEventListener("pointerdown",this.onPointerDown.bind(this)),V(this,H).removeEventListener("pointermove",this.onPointerMove.bind(this)),V(this,H).removeEventListener("pointerup",this.onPointerUp.bind(this)),V(this,H).removeEventListener("wheel",this.onMouseWheel.bind(this))}onPointerDown(e){e.isPrimary&&Bt(this,Me,!0),V(this,fe).set(e.pageX,e.pageY)}onPointerMove(e){let t,s;document.pointerLockElement?(t=e.movementX,s=e.movementY,this.orbit(t*this.orbitStep.x,s*this.orbitStep.y)):V(this,Me)&&(t=e.pageX-V(this,fe).x,s=e.pageY-V(this,fe).y,V(this,fe).set(e.pageX,e.pageY),this.orbit(t*this.orbitStep.x,s*this.orbitStep.y))}onPointerUp(e){e.isPrimary&&Bt(this,Me,!1)}onMouseWheel(e){this.zoom(this.position.z+e.deltaY*this.zoomStep),e.preventDefault()}reset(){this.position.set(0),this.rotation.set(0)}orbit(e,t){if(e||t){if(this.rotation.y-=e,this.constrainYOrbit)this.rotation.y=Math.min(Math.max(this.rotation.y,this.minOrbit.y),this.maxOrbit.y);else{for(;this.rotation.y<-Math.PI;)this.rotation.y+=Math.PI*2;for(;this.rotation.y>=Math.PI;)this.rotation.y-=Math.PI*2}if(this.rotation.x-=t,this.constrainXOrbit)this.rotation.x=Math.min(Math.max(this.rotation.x,this.minOrbit.x),this.maxOrbit.x);else{for(;this.rotation.x<-Math.PI;)this.rotation.x+=Math.PI*2;for(;this.rotation.x>=Math.PI;)this.rotation.x-=Math.PI*2}}}zoom(e){this.position.z=e,this.constrainZoom&&(this.position.z=Math.min(Math.max(this.position.z,this.minZoom),this.maxZoom))}updateModelMatrix(){this.modelMatrix.identity().rotateFromQuaternion(this.quaternion).translate(this.position),this.shouldUpdateWorldMatrix()}destroy(){this.camera.parent=this.renderer.scene,this.parent=null,this.element=null}}fe=new WeakMap,Me=new WeakMap,H=new WeakMap;class li extends be{constructor({instancesCount:e=1,vertexBuffers:t=[],topology:s,mapBuffersAtCreation:i=!0,widthSegments:r=1,heightSegments:n=1,depthSegments:a=1}={}){super({verticesOrder:"ccw",topology:s,instancesCount:e,vertexBuffers:t,mapBuffersAtCreation:i}),this.type="BoxGeometry",r=Math.floor(r),n=Math.floor(n),a=Math.floor(a);const h=[],u=[],l=[],d=[];let c=0;const p=(g,m,y,b,M,T,v,C,B,x)=>{const R=T/B,S=v/x,z=T/2,U=v/2,K=C/2,W=B+1,Z=x+1;let G=0;const F=new f;for(let _=0;_<Z;_++){const P=_*S-U;for(let N=0;N<W;N++){const Q=N*R-z;F[g]=Q*b,F[m]=P*M,F[y]=K,h.push(F.x,F.y,F.z),F[g]=0,F[m]=0,F[y]=C>0?1:-1,l.push(F.x,F.y,F.z),u.push(N/B),u.push(_/x),G+=1}}for(let _=0;_<x;_++)for(let P=0;P<B;P++){const N=c+P+W*_,Q=c+P+W*(_+1),ge=c+(P+1)+W*(_+1),xs=c+(P+1)+W*_;d.push(N,Q,xs),d.push(Q,ge,xs),c+=G}};p("z","y","x",-1,-1,2,2,2,a,n),p("z","y","x",1,-1,2,2,-2,a,n),p("x","z","y",1,1,2,2,2,r,a),p("x","z","y",1,-1,2,2,-2,r,a),p("x","y","z",1,-1,2,2,2,r,n),p("x","y","z",-1,-1,2,2,-2,r,n),this.setAttribute({name:"position",type:"vec3f",bufferFormat:"float32x3",size:3,array:new Float32Array(h)}),this.setAttribute({name:"uv",type:"vec2f",bufferFormat:"float32x2",size:2,array:new Float32Array(u)}),this.setAttribute({name:"normal",type:"vec3f",bufferFormat:"float32x3",size:3,array:new Float32Array(l)}),this.setIndexBuffer({array:this.useUint16IndexArray?new Uint16Array(d):new Uint32Array(d),bufferFormat:this.useUint16IndexArray?"uint16":"uint32"})}}class di extends be{constructor({topology:e,instancesCount:t=1,vertexBuffers:s=[],mapBuffersAtCreation:i=!0,widthSegments:r=32,heightSegments:n=16,phiStart:a=0,phiLength:h=Math.PI*2,thetaStart:u=0,thetaLength:l=Math.PI}={}){super({verticesOrder:"ccw",topology:e,instancesCount:t,vertexBuffers:s,mapBuffersAtCreation:i}),this.type="SphereGeometry",r=Math.max(3,Math.floor(r)),n=Math.max(2,Math.floor(n));const d=1,c=Math.min(u+l,Math.PI);let p=0;const g=[],m=new f,y=new f,b=[],M=[],T=[],v=[];for(let C=0;C<=n;C++){const B=[],x=C/n;let R=0;C===0&&u===0?R=.5/r:C===n&&c===Math.PI&&(R=-.5/r);for(let S=0;S<=r;S++){const z=S/r;m.x=-d*Math.cos(a+z*h)*Math.sin(u+x*l),m.y=d*Math.cos(u+x*l),m.z=d*Math.sin(a+z*h)*Math.sin(u+x*l),M.push(m.x,m.y,m.z),y.copy(m).normalize(),T.push(y.x,y.y,y.z),v.push(z+R,x),B.push(p++)}g.push(B)}for(let C=0;C<n;C++)for(let B=0;B<r;B++){const x=g[C][B+1],R=g[C][B],S=g[C+1][B],z=g[C+1][B+1];(C!==0||u>0)&&b.push(x,R,z),(C!==n-1||c<Math.PI)&&b.push(R,S,z)}this.setAttribute({name:"position",type:"vec3f",bufferFormat:"float32x3",size:3,array:new Float32Array(M)}),this.setAttribute({name:"uv",type:"vec2f",bufferFormat:"float32x2",size:2,array:new Float32Array(v)}),this.setAttribute({name:"normal",type:"vec3f",bufferFormat:"float32x3",size:3,array:new Float32Array(T)}),this.setIndexBuffer({array:this.useUint16IndexArray?new Uint16Array(b):new Uint32Array(b),bufferFormat:this.useUint16IndexArray?"uint16":"uint32"})}}const fs=WebGLRenderingContext,ci=1179937895,Ct={JSON:1313821514,BIN:5130562},pi=[0,0,0],fi=[0,0,0,1],mi=[1,1,1],gi=new RegExp(`^${window.location.protocol}`,"i"),yi=/^data:/;class Ye{constructor(){this.gltf=null}static resolveUri(e,t){return e.match(gi)||e.match(yi)?e:t+e}async loadFromUrl(e){const t=e.lastIndexOf("/"),s=t!==0?e.substring(0,t+1):"",i=await fetch(e);if(e.endsWith(".gltf"))return this.loadFromJson(await i.json(),s);if(e.endsWith(".glb"))return this.loadFromBinary(await i.arrayBuffer(),s);throw new Error("Unrecognized file extension")}async loadFromJsonBase(e,t,s=null){if(!t)throw new Error("baseUrl must be specified.");if(!e.asset)throw new Error("Missing asset description.");if(e.asset.minVersion!=="2.0"&&e.asset.version!=="2.0")throw new Error("Incompatible asset version.");for(const n of e.accessors)n.byteOffset=n.byteOffset??0,n.normalized=n.normalized??!1;for(const n of e.bufferViews)n.byteOffset=n.byteOffset??0;for(const n of e.nodes)n.matrix||(n.rotation=n.rotation??fi,n.scale=n.scale??mi,n.translation=n.translation??pi);if(e.samplers)for(const n of e.samplers)n.wrapS=n.wrapS??fs.REPEAT,n.wrapT=n.wrapT??fs.REPEAT;const i=[];if(s)i.push(Promise.resolve(s));else for(const n in e.buffers){const a=e.buffers[n],h=Ye.resolveUri(a.uri,t);i[n]=fetch(h).then(u=>u.arrayBuffer())}const r=[];for(let n=0;n<e.images?.length;++n){const a=e.images[n];if(a.uri)r[n]=fetch(Ye.resolveUri(a.uri,t)).then(async h=>createImageBitmap(await h.blob()));else{const h=e.bufferViews[a.bufferView];r[n]=i[h.buffer].then(u=>{const l=new Blob([new Uint8Array(u,h.byteOffset,h.byteLength)],{type:a.mimeType});return createImageBitmap(l)})}}return{...e,arrayBuffers:await Promise.all(i),imagesBitmaps:await Promise.all(r)}}async loadFromBinary(e,t){const s=new DataView(e,0,12),i=s.getUint32(0,!0),r=s.getUint32(4,!0),n=s.getUint32(8,!0);if(i!==ci)throw new Error("Invalid magic string in binary header.");if(r!==2)throw new Error("Incompatible version in binary header.");const a={};let h=12;for(;h<n;){const d=new DataView(e,h,8),c=d.getUint32(0,!0),p=d.getUint32(4,!0);a[p]=e.slice(h+8,h+8+c),h+=c+8}if(!a[Ct.JSON])throw new Error("File contained no json chunk.");const l=new TextDecoder("utf-8").decode(a[Ct.JSON]);return this.loadFromJson(JSON.parse(l),t,a[Ct.BIN])}async loadFromJson(e,t,s=null){return this.gltf=await this.loadFromJsonBase(e,t,s),this.gltf}}var ms=(o,e,t)=>{if(!e.has(o))throw TypeError("Cannot "+t)},Tt=(o,e,t)=>(ms(o,e,"read from private field"),t?t.call(o):e.get(o)),xi=(o,e,t)=>{if(e.has(o))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(o):e.set(o,t)},bi=(o,e,t,s)=>(ms(o,e,"write to private field"),s?s.call(o,t):e.set(o,t),t),me;const L=WebGLRenderingContext,He=new A,vi=class ne{constructor({renderer:e,gltf:t}){xi(this,me,void 0),e=e&&e.renderer||e,Be(e,"GLTFScenesManager"),this.renderer=e,this.gltf=t,bi(this,me,new Map);const s=i=>[i.node,...i.children?.map(r=>[...s(r)]).flat()].flat();this.scenesManager={node:new se,boundingBox:new ie,samplers:[],materialsTextures:[],scenes:[],meshes:[],meshesDescriptors:[],getScenesNodes:()=>this.scenesManager.scenes.map(i=>s(i)).flat()},this.createSamplers(),this.createMaterialTextures(),this.createScenes()}static getVertexAttributeParamsFromType(e){switch(e){case"VEC2":return{type:"vec2f",bufferFormat:"float32x2",size:2};case"VEC3":return{type:"vec3f",bufferFormat:"float32x3",size:3};case"VEC4":return{type:"vec4f",bufferFormat:"float32x4",size:4};case"SCALAR":default:return{type:"f32",bufferFormat:"float32",size:1}}}static getTypedArrayConstructorFromComponentType(e){switch(e){case L.BYTE:return Int8Array;case L.UNSIGNED_BYTE:return Uint8Array;case L.SHORT:return Int16Array;case L.UNSIGNED_SHORT:return Uint16Array;case L.UNSIGNED_INT:return Uint32Array;case L.FLOAT:default:return Float32Array}}static gpuPrimitiveTopologyForMode(e){switch(e){case L.TRIANGLES:return"triangle-list";case L.TRIANGLE_STRIP:return"triangle-strip";case L.LINES:return"line-list";case L.LINE_STRIP:return"line-strip";case L.POINTS:return"point-list"}}static gpuAddressModeForWrap(e){switch(e){case L.CLAMP_TO_EDGE:return"clamp-to-edge";case L.MIRRORED_REPEAT:return"mirror-repeat";default:return"repeat"}}createSamplers(){if(this.gltf.samplers)for(const[e,t]of Object.entries(this.gltf.samplers)){const s={label:"glTF sampler "+e,name:"gltfSampler"+e,addressModeU:ne.gpuAddressModeForWrap(t.wrapS),addressModeV:ne.gpuAddressModeForWrap(t.wrapT)};switch((!t.magFilter||t.magFilter===L.LINEAR)&&(s.magFilter="linear"),t.minFilter){case L.NEAREST:break;case L.LINEAR:case L.LINEAR_MIPMAP_NEAREST:s.minFilter="linear";break;case L.NEAREST_MIPMAP_LINEAR:s.mipmapFilter="linear";break;case L.LINEAR_MIPMAP_LINEAR:default:s.minFilter="linear",s.mipmapFilter="linear";break}this.scenesManager.samplers.push(new Le(this.renderer,s))}else this.scenesManager.samplers.push(new Le(this.renderer,{label:"Default sampler",name:"defaultSampler"}))}createTexture(e,t,s){const i=(()=>{switch(s){case"baseColorTexture":case"emissiveTexture":return"bgra8unorm-srgb";case"occlusionTexture":return"r8unorm";default:return"bgra8unorm"}})(),r=new te(this.renderer,{label:e.name?e.name+": "+s:s,name:s,format:i,visibility:["fragment"],generateMips:!0,fixedSize:{width:t.width,height:t.height}});return r.uploadSource({source:t}),r}createMaterialTextures(){if(this.scenesManager.materialsTextures=[],this.gltf.materials)for(const[e,t]of Object.entries(this.gltf.materials)){const s={material:e,texturesDescriptors:[]},i=r=>r.texCoord&&r.texCoord!==0?"uv"+r.texCoord:"uv";if(this.scenesManager.materialsTextures[e]=s,t.pbrMetallicRoughness){if(t.pbrMetallicRoughness.baseColorTexture&&t.pbrMetallicRoughness.baseColorTexture.index!==void 0){const r=t.pbrMetallicRoughness.baseColorTexture.index,n=this.gltf.imagesBitmaps[this.gltf.textures[r].source],a=this.createTexture(t,n,"baseColorTexture"),h=this.gltf.textures.find(u=>u.source===r)?.sampler;s.texturesDescriptors.push({texture:a,sampler:this.scenesManager.samplers[h??0],texCoordAttributeName:i(t.pbrMetallicRoughness.baseColorTexture)})}if(t.pbrMetallicRoughness.metallicRoughnessTexture&&t.pbrMetallicRoughness.metallicRoughnessTexture.index!==void 0){const r=t.pbrMetallicRoughness.metallicRoughnessTexture.index,n=this.gltf.imagesBitmaps[this.gltf.textures[r].source],a=this.createTexture(t,n,"metallicRoughnessTexture"),h=this.gltf.textures.find(u=>u.source===r)?.sampler;s.texturesDescriptors.push({texture:a,sampler:this.scenesManager.samplers[h??0],texCoordAttributeName:i(t.pbrMetallicRoughness.metallicRoughnessTexture)})}}if(t.normalTexture&&t.normalTexture.index!==void 0){const r=t.normalTexture.index,n=this.gltf.imagesBitmaps[this.gltf.textures[r].source],a=this.createTexture(t,n,"normalTexture"),h=this.gltf.textures.find(u=>u.source===r)?.sampler;s.texturesDescriptors.push({texture:a,sampler:this.scenesManager.samplers[h??0],texCoordAttributeName:i(t.normalTexture)})}if(t.occlusionTexture&&t.occlusionTexture.index!==void 0){const r=t.occlusionTexture.index,n=this.gltf.imagesBitmaps[this.gltf.textures[r].source],a=this.createTexture(t,n,"occlusionTexture"),h=this.gltf.textures.find(u=>u.source===r)?.sampler;s.texturesDescriptors.push({texture:a,sampler:this.scenesManager.samplers[h??0],texCoordAttributeName:i(t.occlusionTexture)})}if(t.emissiveTexture&&t.emissiveTexture.index!==void 0){const r=t.emissiveTexture.index,n=this.gltf.imagesBitmaps[this.gltf.textures[r].source],a=this.createTexture(t,n,"emissiveTexture"),h=this.gltf.textures.find(u=>u.source===r)?.sampler;s.texturesDescriptors.push({texture:a,sampler:this.scenesManager.samplers[h??0],texCoordAttributeName:i(t.emissiveTexture)})}}}createNode(e,t){if(t.camera!==void 0)return;const s={name:t.name,node:new se,children:[]};e.children.push(s),s.node.parent=e.node,t.matrix?(s.node.modelMatrix.setFromArray(new Float32Array(t.matrix)),s.node.matrices.model.shouldUpdate=!1):(t.translation&&s.node.position.set(t.translation[0],t.translation[1],t.translation[2]),t.scale&&s.node.scale.set(t.scale[0],t.scale[1],t.scale[2]),t.rotation&&s.node.quaternion.setFromArray(new Float32Array(t.rotation)));const i=this.gltf.meshes[t.mesh];t.children&&t.children.forEach(r=>{const n=this.gltf.nodes[r];this.createNode(s,n)}),i&&i.primitives.forEach((r,n)=>{const a={parent:s.node,attributes:[],textures:[],parameters:{label:i.name?i.name+" "+n:"glTF mesh "+n},nodes:[]};let h=Tt(this,me).get(r);h||(h={instances:[],nodes:[],meshDescriptor:a},Tt(this,me).set(r,h)),h.instances.push(t),h.nodes.push(s.node)})}createScenes(){this.scenesManager.node.parent=this.renderer.scene,this.gltf.scenes.forEach(e=>{const t={name:e.name,children:[],node:new se};t.node.parent=this.scenesManager.node,this.scenesManager.scenes.push(t),e.nodes.forEach(s=>{const i=this.gltf.nodes[s];this.createNode(t,i)})}),this.scenesManager.scenes.forEach(e=>{e.node.shouldUpdateModelMatrix(),e.node.updateMatrixStack()});for(const[e,t]of Tt(this,me)){const{instances:s,nodes:i,meshDescriptor:r}=t,n=s.length;r.nodes=i,this.scenesManager.meshesDescriptors.push(r);const a=new ie,h=[];let u=null,l=null,d=0;for(const[M,T]of Object.entries(e.attributes)){const v=this.gltf.accessors[T],C=ne.getTypedArrayConstructorFromComponentType(v.componentType),B=this.gltf.bufferViews[v.bufferView],x=M==="TEXCOORD_0"?"uv":M.replace("_","").replace("TEXCOORD","uv").toLowerCase(),R=B.byteStride||0,S=v.byteOffset||0;R&&S&&S<R?d=Math.max(S,d):d=0,x==="position"&&(a.min.min(new f(v.min[0],v.min[1],v.min[2])),a.max.max(new f(v.max[0],v.max[1],v.max[2])),l=B);const z=ne.getVertexAttributeParamsFromType(v.type),U={name:x,...z,array:new C(this.gltf.arrayBuffers[B.buffer],v.byteOffset+B.byteOffset,v.count*z.size)};h.push(U),r.attributes.push({name:U.name,type:U.type})}if(d>0){const M=Object.values(e.attributes).map(T=>this.gltf.accessors[T].bufferView);if(M.every(T=>T===M[0]))u=new Float32Array(this.gltf.arrayBuffers[l.buffer],l.byteOffset,Math.ceil(l.byteLength/4)*4/Float32Array.BYTES_PER_ELEMENT);else{let T=0;const v={},C=Object.values(e.attributes).reduce((B,x)=>{const R=this.gltf.accessors[x],S=ne.getVertexAttributeParamsFromType(R.type).size;return v[R.bufferView]||(v[R.bufferView]=0),v[R.bufferView]=Math.max(v[R.bufferView],R.byteOffset+S*Float32Array.BYTES_PER_ELEMENT),T+=S*Float32Array.BYTES_PER_ELEMENT,B+R.count*S},0);u=new Float32Array(Math.ceil(C/4)*4),Object.values(e.attributes).forEach(B=>{const x=this.gltf.accessors[B],R=this.gltf.bufferViews[x.bufferView],S=ne.getVertexAttributeParamsFromType(x.type).size;for(let z=0;z<x.count;z++){const U=x.byteOffset/Float32Array.BYTES_PER_ELEMENT+z*T/Float32Array.BYTES_PER_ELEMENT;u.subarray(U,U+S).set(new Float32Array(this.gltf.arrayBuffers[R.buffer],R.byteOffset+x.byteOffset+z*v[x.bufferView],S))}})}}else{const M=["position","uv","normal"];h.sort((T,v)=>{let C=M.findIndex(x=>x===T.name);C=C===-1?1/0:C;let B=M.findIndex(x=>x===v.name);return B=B===-1?1/0:B,C-B})}const c={instancesCount:n,topology:ne.gpuPrimitiveTopologyForMode(e.mode),vertexBuffers:[{name:"attributes",stepMode:"vertex",attributes:h,...u&&{array:u}}]},p="indices"in e,g=p?be:nt;if(r.parameters.geometry=new g(c),r.parameters.geometry.boundingBox=a,p){const M=this.gltf.accessors[e.indices],T=this.gltf.bufferViews[M.bufferView],v=ne.getTypedArrayConstructorFromComponentType(M.componentType),C=M.byteOffset+T.byteOffset,B=this.gltf.arrayBuffers[T.buffer],x=Math.min((B.byteLength-C)/v.BYTES_PER_ELEMENT,Math.ceil(M.count/4)*4),R=v.name==="Uint8Array"?Uint16Array.from(new v(B,C,x)):new v(B,C,x);r.parameters.geometry.setIndexBuffer({bufferFormat:v.name==="Uint32Array"?"uint32":"uint16",array:R})}const m=this.scenesManager.materialsTextures[e.material];r.parameters.samplers=[],r.parameters.textures=[],m?.texturesDescriptors.forEach(M=>{r.textures.push({texture:M.texture.options.name,sampler:M.sampler.name,texCoordAttributeName:M.texCoordAttributeName}),r.parameters.samplers.find(v=>v.uuid===M.sampler.uuid)||r.parameters.samplers.push(M.sampler),r.parameters.textures.push(M.texture)});const y=this.gltf.materials&&this.gltf.materials[e.material]||{};r.parameters.cullMode=y.doubleSided?"none":"back",(y.alphaMode==="BLEND"||y.extensions&&y.extensions.KHR_materials_transmission)&&(r.parameters.transparent=!0,r.parameters.targets=[{blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one"}}}]);const b={baseColorFactor:{type:"vec4f",value:y.pbrMetallicRoughness?.baseColorFactor||[1,1,1,1]},alphaCutoff:{type:"f32",value:y.alphaCutoff!==void 0?y.alphaCutoff:y.alphaMode==="MASK"?.5:0},metallicFactor:{type:"f32",value:y.pbrMetallicRoughness?.metallicFactor||0},roughnessFactor:{type:"f32",value:y.pbrMetallicRoughness?.roughnessFactor||1},normalMapScale:{type:"f32",value:y.normalTexture?.scale||1},occlusionStrength:{type:"f32",value:y.occlusionTexture?.strength||1},emissiveFactor:{type:"vec3f",value:y.emissiveFactor!==void 0?y.emissiveFactor:[1,1,1]}};if(Object.keys(b).length&&(r.parameters.uniforms={material:{visibility:["vertex","fragment"],struct:b}}),n>1){const M=new Float32Array(n*16),T=new Float32Array(n*16);for(let v=0;v<n;++v)M.set(i[v].worldMatrix.elements,v*16),He.copy(i[v].worldMatrix).invert().transpose(),T.set(He.elements,v*16);r.parameters.storages={instances:{visibility:["vertex","fragment"],struct:{modelMatrix:{type:"array<mat4x4f>",value:M},normalMatrix:{type:"array<mat4x4f>",value:T}}}}}for(let M=0;M<i.length;M++){const v=a.clone().applyMat4(r.nodes[M].worldMatrix);this.scenesManager.boundingBox.min.min(v.min),this.scenesManager.boundingBox.max.max(v.max)}}}addMeshes(e=t=>{}){return this.scenesManager.meshesDescriptors.map(t=>{if(t.parameters.geometry){e(t);const s=new Zt(this.renderer,{...t.parameters});if(t.nodes.length>1){const i=s.updateWorldMatrix.bind(s);s.updateWorldMatrix=()=>{i(),t.nodes.forEach((r,n)=>{s.storages.instances.modelMatrix.value.set(r.worldMatrix.elements,n*16),He.copy(r.worldMatrix).invert().transpose(),s.storages.instances.normalMatrix.value.set(He.elements,n*16)}),s.storages.instances.modelMatrix.shouldUpdate=!0,s.storages.instances.normalMatrix.shouldUpdate=!0}}return s.parent=t.parent,this.scenesManager.meshes.push(s),s}})}destroy(){this.scenesManager.meshes.forEach(t=>t.remove()),this.scenesManager.meshes=[],this.scenesManager.getScenesNodes().forEach(t=>{t.destroy()}),this.scenesManager.node.destroy()}};me=new WeakMap;let wi=vi;const gs=(o,e=null)=>{const t=o.textures.find(P=>P.texture==="baseColorTexture"),s=o.textures.find(P=>P.texture==="normalTexture"),i=o.textures.find(P=>P.texture==="emissiveTexture"),r=o.textures.find(P=>P.texture==="occlusionTexture"),n=o.textures.find(P=>P.texture==="metallicRoughnessTexture"),a=o.attributes.filter(P=>P.name!=="position"),h=a.map((P,N)=>`@location(${N}) ${P.name}: ${P.type},`).join(`
	`);let u=`
    let worldPos = matrices.model * vec4(attributes.position, 1.0);
    vsOutput.position = camera.projection * camera.view * worldPos;
    vsOutput.worldPosition = worldPos.xyz;
    vsOutput.viewDirection = camera.position - worldPos.xyz;
  `,l=a.find(P=>P.name==="normal")?"vsOutput.normal = getWorldNormal(attributes.normal);":"";o.parameters.storages&&o.parameters.storages.instances&&(u=`
      let worldPos: vec4f = instances[attributes.instanceIndex].modelMatrix * vec4f(attributes.position, 1.0);
      vsOutput.position = camera.projection * camera.view * worldPos;
      vsOutput.worldPosition = worldPos.xyz;
      vsOutput.viewDirection = camera.position - vsOutput.worldPosition;
      `,l="vsOutput.normal = normalize((instances[attributes.instanceIndex].normalMatrix * vec4(attributes.normal, 0.0)).xyz);");const d=a.filter(P=>P.name!=="normal").map(P=>`vsOutput.${P.name} = attributes.${P.name};`).join(`
	`);let c=`
      @builtin(position) position: vec4f,
      @location(${a.length}) viewDirection: vec3f,
      @location(${a.length+1}) worldPosition: vec3f,
      ${h}
  `,p="";const g=a.find(P=>P.name==="tangent"),m=!!(s&&g);m&&(c+=`
      @location(${a.length+2}) bitangent: vec3f,
      `,p=`
        vsOutput.tangent = normalize(matrices.model * attributes.tangent);
        vsOutput.bitangent = cross(vsOutput.normal, vsOutput.tangent.xyz) * attributes.tangent.w;
      `);const y=`
    struct VSOutput {
      ${c}
    };`,b=`
    ${y}
    
    @vertex fn main(
      attributes: Attributes,
    ) -> VSOutput {
      var vsOutput: VSOutput;
    
      ${u}
      ${l}
      ${d}
      
      ${p}

      return vsOutput;
    }
  `,M="var color: vec4f = vec4();",T="return color;",v=o.attributes.find(P=>P.name==="color0");let C=v?v.type==="vec3f"?"var baseColor: vec4f = vec4(fsInput.color0, 1.0) * material.baseColorFactor;":"var baseColor: vec4f = fsInput.color0 * material.baseColorFactor;":"var baseColor: vec4f = material.baseColorFactor;";t&&(C=`
      var baseColor: vec4f = textureSample(baseColorTexture, ${t.sampler}, fsInput.${t.texCoordAttributeName}) * material.baseColorFactor;
      
      // baseColor = vec4(sRGBToLinear(baseColor.rgb), baseColor.a);
      
      if (baseColor.a < material.alphaCutoff) {
        discard;
      }
    `);let B=o.attributes.find(P=>P.name==="normal")?"let normal: vec3f = normalize(fsInput.normal);":"let normal: vec3f = vec3(0.0);";m&&(B=`
      let tbn = mat3x3<f32>(normalize(fsInput.tangent.xyz), normalize(fsInput.bitangent), normalize(fsInput.normal));
      let normalMap = textureSample(normalTexture, ${s.sampler}, fsInput.${s.texCoordAttributeName}).rgb;
      let normal = normalize(tbn * (2.0 * normalMap - vec3(material.normalMapScale, material.normalMapScale, 1.0)));
    `);let x=`
      var metallic = material.metallicFactor;
      var roughness = material.roughnessFactor;
  `;n&&(x+=`
      let metallicRoughness = textureSample(metallicRoughnessTexture, ${n.sampler}, fsInput.${n.texCoordAttributeName});
      metallic = clamp(metallic * metallicRoughness.b, 0.001, 1.0);
      roughness = clamp(roughness * metallicRoughness.g, 0.001, 1.0);
    `);const R=`
      let dielectricSpec: vec3f = vec3(0.04, 0.04, 0.04);
      let f0 = mix(dielectricSpec, color.rgb, vec3(metallic));
  `;let S=`
      var emissive: vec3f = vec3(0.0);
      var occlusion: f32 = 1.0;
  `;i&&(S+=`
      emissive = textureSample(emissiveTexture, ${i.sampler}, fsInput.${i.texCoordAttributeName}).rgb;
      
      // emissive = sRGBToLinear(emissive);
      
      emissive *= material.emissiveFactor;
      `,r&&(S+=`
      occlusion = textureSample(occlusionTexture, ${r.sampler}, fsInput.${r.texCoordAttributeName}).r;
      `)),S+=`
      occlusion = 1.0 + material.occlusionStrength * (occlusion - 1.0);
  `;const z=`
      var ambientContribution: vec3f;
      var lightContribution: vec3f;
      color = baseColor;
  `,U="",K="",W=`
    ambientContribution = vec3(1.0);
  `,Z=`
    lightContribution = vec3(0.0);
  `;let{chunks:G}=e;G?(G.additionalFragmentHead||(G.additionalFragmentHead=U),G.ambientContribution||(G.ambientContribution=W),G.lightContribution||(G.lightContribution=Z),G.additionalColorContribution||(G.additionalColorContribution=K)):G={additionalFragmentHead:U,ambientContribution:W,lightContribution:Z,additionalColorContribution:K};const _=`
    // PBR
    const PI = ${Math.PI};
    
    
    // tone maping
    fn toneMapKhronosPbrNeutral( color: vec3f ) -> vec3f {
      var toneMapColor = color; 
      const startCompression: f32 = 0.8 - 0.04;
      const desaturation: f32 = 0.15;
      var x: f32 = min(toneMapColor.r, min(toneMapColor.g, toneMapColor.b));
      var offset: f32 = select(0.04, x - 6.25 * x * x, x < 0.08);
      toneMapColor = toneMapColor - offset;
      var peak: f32 = max(toneMapColor.r, max(toneMapColor.g, toneMapColor.b));
      if (peak < startCompression) {
        return toneMapColor;
      }
      const d: f32 = 1. - startCompression;
      let newPeak: f32 = 1. - d * d / (peak + d - startCompression);
      toneMapColor *= newPeak / peak;
      let g: f32 = 1. - 1. / (desaturation * (peak - newPeak) + 1.);
      return mix(toneMapColor, newPeak * vec3(1, 1, 1), g);
    }
    
  
    // linear <-> sRGB conversions
    fn linearTosRGB(linear: vec3f) -> vec3f {
      if (all(linear <= vec3(0.0031308))) {
        return linear * 12.92;
      }
      return (pow(abs(linear), vec3(1.0/2.4)) * 1.055) - vec3(0.055);
    }
  
    fn sRGBToLinear(srgb: vec3f) -> vec3f {
      if (all(srgb <= vec3(0.04045))) {
        return srgb / vec3(12.92);
      }
      return pow((srgb + vec3(0.055)) / vec3(1.055), vec3(2.4));
    }
    
    ${G.additionalFragmentHead}
  
    ${y}
  
    @fragment fn main(fsInput: VSOutput) -> @location(0) vec4f {          
      ${M}
      ${C}
      ${B}
      ${x}
      ${R}
      ${S}
      
      ${z}
      
      // user defined lightning
      ${G.ambientContribution}
      ${G.lightContribution}
      
      
      let ambient = ambientContribution * color.rgb * occlusion;
      color = vec4(linearTosRGB(lightContribution + ambient + emissive), color.a);
      //color = vec4(linearTosRGB(toneMapKhronosPbrNeutral(lightContribution + ambient + emissive)), color.a);
  
      
      ${G.additionalColorContribution}
      
      ${T}
    }
  `;return{vertex:{code:b,entryPoint:"main"},fragment:{code:_,entryPoint:"main"}}},ys=(o,e=null)=>{let{chunks:t}=e;const s=`
    fn FresnelSchlick(cosTheta: f32, F0: vec3f) -> vec3f {
      return F0 + (vec3(1.0) - F0) * pow(1.0 - cosTheta, 5.0);
    }
    
    fn DistributionGGX(NdotH: f32, roughness: f32) -> f32 {
      let a      = roughness*roughness;
      let a2     = a*a;
      let NdotH2 = NdotH*NdotH;
    
      let num    = a2;
      let denom  = (NdotH2 * (a2 - 1.0) + 1.0);
    
      return num / (PI * denom * denom);
    }
    
    fn GeometrySchlickGGX(NdotV : f32, roughness : f32) -> f32 {
      let r = (roughness + 1.0);
      let k = (r*r) / 8.0;
    
      let num   = NdotV;
      let denom = NdotV * (1.0 - k) + k;
    
      return num / denom;
    }
    
    fn GeometrySmith(NdotL: f32, NdotV: f32, roughness : f32) -> f32 {
      let ggx2  = GeometrySchlickGGX(NdotV, roughness);
      let ggx1  = GeometrySchlickGGX(NdotL, roughness);
    
      return ggx1 * ggx2;
    }
    
    fn rangeAttenuation(range: f32, distance: f32) -> f32 {
      if (range <= 0.0) {
          // Negative range means no cutoff
          return 1.0 / pow(distance, 2.0);
      }
      return clamp(1.0 - pow(distance / range, 4.0), 0.0, 1.0) / pow(distance, 2.0);
    }
  `;return t?t.additionalFragmentHead?t.additionalFragmentHead+=s:t.additionalFragmentHead=s:t={additionalFragmentHead:s},gs(o,e)},Mi=(o,e=null)=>{const{iblParameters:t}=e;o.parameters.uniforms={...o.parameters.uniforms,ibl:{struct:{diffuseStrength:{type:"f32",value:t?.diffuseStrength??.5},specularStrength:{type:"f32",value:t?.specularStrength??.5}}}};const{lutTexture:s,envDiffuseTexture:i,envSpecularTexture:r}=t,n=i&&r&&s;let a="",h="";if(n){o.parameters.textures=[...o.parameters.textures,s,i,r];const l={texture:s.options.name,sampler:"defaultSampler"},d={texture:i.options.name,sampler:"defaultSampler"},c={texture:r.options.name,sampler:"defaultSampler"};o.textures=[...o.textures,l,d,c],a=`
    const RECIPROCAL_PI = ${1/Math.PI};
    const RECIPROCAL_PI2 = ${.5/Math.PI};
    const ENV_LODS = 4.0;
    const LN2 = 0.6931472;
    
    fn rGBMToLinear(rgbm: vec4f) -> vec4f {
      let maxRange: f32 = 6.0;
      return vec4(rgbm.xyz * rgbm.w * maxRange, 1.0);
    }
    
    fn cartesianToPolar(n: vec3f) -> vec2f {
      var uv: vec2f;
      uv.x = atan2(n.z, n.x) * RECIPROCAL_PI2 + 0.5;
      uv.y = asin(n.y) * RECIPROCAL_PI + 0.5;
      return uv;
    }
    
    struct IBLContribution {
      diffuse: vec3f,
      specular: vec3f,
    };
    
    fn getIBLContribution(NdV: f32, roughness: f32, n: vec3f, reflection: vec3f, diffuseColor: vec3f, specularColor: vec3f) -> IBLContribution {
      let brdf: vec3f = sRGBToLinear(textureSample(${l.texture}, ${l.sampler}, vec2(NdV, roughness)).rgb);
      var diffuseLight: vec3f = rGBMToLinear(textureSample(${d.texture}, ${d.sampler}, cartesianToPolar(n))).rgb;      
      diffuseLight = mix(vec3(1), diffuseLight, ibl.diffuseStrength);
      var blend: f32 = roughness * ENV_LODS;
      let level0: f32 = floor(blend);
      let level1: f32 = min(ENV_LODS, level0 + 1.0);
      blend -= level0;
      var uvSpec: vec2f = cartesianToPolar(reflection);
      uvSpec.y /= 2.0;
      var uv0: vec2f = uvSpec;
      var uv1: vec2f = uvSpec;
      uv0 /= pow(2.0, level0);
      uv0.y += 1.0 - exp(-LN2 * level0);
      uv1 /= pow(2.0, level1);
      uv1.y += 1.0 - exp(-LN2 * level1);
      let specular0: vec3f = rGBMToLinear(textureSample(${c.texture}, ${c.sampler}, uv0)).rgb;
      let specular1: vec3f = rGBMToLinear(textureSample(${c.texture}, ${c.sampler}, uv1)).rgb;
      let specularLight: vec3f = mix(specular0, specular1, blend);      
      
      var iblContribution: IBLContribution;
      iblContribution.diffuse = diffuseLight * diffuseColor;
      
      let reflectivity: f32 = pow((1.0 - roughness), 2.0) * 0.05;
      iblContribution.specular = specularLight * (specularColor * brdf.x + brdf.y + reflectivity);
      iblContribution.specular *= ibl.specularStrength;
      
      return iblContribution;
    }
    `,h=`
      let reflection: vec3f = normalize(reflect(-normalize(fsInput.viewDirection), normal));
      
      let diffuseColor: vec3f = baseColor.rgb * (vec3(1.0) - f0) * (1.0 - metallic);
      let specularColor: vec3f = mix(f0, baseColor.rgb, metallic);
    
      let iblContribution = getIBLContribution(max(dot(normal, normalize(fsInput.viewDirection)), 0.0), roughness, normal, reflection, diffuseColor, specularColor);
      
      color = vec4(color.rgb + iblContribution.diffuse + iblContribution.specular, color.a);
      
      // Add IBL spec to alpha for reflections on transparent surfaces (glass)
      color.a = max(color.a, max(max(iblContribution.specular.r, iblContribution.specular.g), iblContribution.specular.b));
    `}let{chunks:u}=e;return u?(u.additionalFragmentHead?u.additionalFragmentHead+=a:u.additionalFragmentHead=a,u.additionalColorContribution?u.additionalColorContribution+=h:u.additionalColorContribution=h):u={additionalFragmentHead:a,additionalColorContribution:h},ys(o,e)},Bi=o=>{const{scene:e}=o;if(!e)return;const t=[];e.computePassEntries.forEach(s=>{t.push({command:"Render ComputePass",content:s.options.label}),s.material.bindGroups.forEach(i=>{i.bufferBindings.forEach(r=>{r.shouldCopyResult&&t.push({command:"Copy buffer to buffer",source:`${r.name} buffer`,destination:`${r.name} result buffer`})})})});for(const s in e.renderPassEntries){let i=0;e.renderPassEntries[s].forEach(r=>{if(!e.getRenderPassEntryLength(r))return;const n=r.renderPass.options.useColorAttachments?r.renderPass.options.colorAttachments.length===0&&r.renderPass.options.useDepth?`${r.renderTexture.options.label} depth pass`:r.renderPass.options.colorAttachments.length>1?`${r.renderTexture.options.label} multiple targets`:r.renderTexture?`${r.renderTexture.options.label}`:"Context current texture":void 0;let a=r.renderPass.options.label;const h={loadOp:r.renderPass.options.useColorAttachments?s==="screen"&&i>0?"load":r.renderPass.options.loadOp:void 0,depthLoadOp:void 0,sampleCount:r.renderPass.options.sampleCount,...r.renderPass.options.qualityRatio!==1&&{qualityRatio:r.renderPass.options.qualityRatio}};if(r.renderPass.options.useDepth&&(h.depthLoadOp=r.renderPass.options.depthLoadOp),i++,r.element)r.element.type==="ShaderPass"&&!(r.element.inputTarget||r.element.outputTarget)&&(t.push({command:"Copy texture to texture",source:n,destination:`${r.element.options.label} renderTexture`}),h.loadOp="clear"),a+=" "+JSON.stringify(h),t.push({command:`Render ${r.element.type}`,source:r.element.options.label,destination:n,descriptor:a}),r.element.type==="ShaderPass"&&!r.element.outputTarget&&r.element.options.copyOutputToRenderTexture?t.push({command:"Copy texture to texture",source:n,destination:`${r.element.options.label} renderTexture`}):r.element.type==="PingPongPlane"&&t.push({command:"Copy texture to texture",source:n,destination:`${r.element.renderTexture.options.label}`});else if(r.stack){a+=" "+JSON.stringify(h);for(const u in r.stack)for(const l in r.stack[u])r.stack[u][l].length&&t.push({command:`Render stack (${u} ${l} objects)`,source:r.stack[u][l],destination:n,descriptor:a})}})}console.table(t)};w.BindGroup=Re,w.Binding=Te,w.Box3=ie,w.BoxGeometry=li,w.Buffer=de,w.BufferBinding=ce,w.Camera=Ft,w.ComputeMaterial=Lt,w.ComputePass=Ds,w.ComputePipelineEntry=Jt,w.DOMElement=gt,w.DOMFrustum=Vt,w.DOMMesh=ds,w.DOMObject3D=us,w.DOMTexture=he,w.FullscreenPlane=dt,w.GLTFLoader=Ye,w.GLTFScenesManager=wi,w.GPUCameraRenderer=vt,w.GPUCurtains=hi,w.GPUCurtainsRenderer=qe,w.GPUDeviceManager=rs,w.GPURenderer=bt,w.Geometry=nt,w.IndexedGeometry=be,w.Mat3=re,w.Mat4=A,w.Material=rt,w.Mesh=Zt,w.Object3D=se,w.OrbitControls=ui,w.PingPongPlane=ni,w.PipelineEntry=pt,w.PipelineManager=es,w.Plane=cs,w.PlaneGeometry=ot,w.ProjectedObject3D=ct,w.Quat=J,w.RenderMaterial=Nt,w.RenderPass=Ie,w.RenderPipelineEntry=ft,w.RenderTarget=as,w.Sampler=Le,w.SamplerBinding=At,w.Scene=ts,w.ShaderPass=ii,w.SphereGeometry=di,w.Texture=te,w.TextureBindGroup=it,w.TextureBinding=st,w.Vec2=E,w.Vec3=f,w.WritableBufferBinding=tt,w.buildIBLShaders=Mi,w.buildPBRShaders=ys,w.buildShaders=gs,w.logSceneCommands=Bi});
//# sourceMappingURL=gpu-curtains.umd.min.js.map
