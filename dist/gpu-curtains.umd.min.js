var Ol=Object.defineProperty;var u=(M,O)=>Ol(M,"name",{value:O,configurable:!0});(function(M,O){typeof exports=="object"&&typeof module<"u"?O(exports):typeof define=="function"&&define.amd?define(["exports"],O):(M=typeof globalThis<"u"?globalThis:M||self,O(M.window=M.window||{}))})(this,function(M){"use strict";const O=u(()=>"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,r=>{const e=Math.random()*16|0;return(r==="x"?e:e&3|8).toString(16).toUpperCase()}),"generateUUID"),Dt=u(r=>r.replace(/(?:^\w|[A-Z]|\b\w)/g,(e,t)=>t===0?e.toLowerCase():e.toUpperCase()).replace(/\s+/g,""),"toCamelCase"),pt=u(r=>{const e=Dt(r);return e.charAt(0).toUpperCase()+e.slice(1)},"toKebabCase");let Ti=0;const A=u(r=>{Ti>100||(console.warn(Ti===100?"GPUCurtains: too many warnings thrown, stop logging.":r),Ti++)},"throwWarning"),ae=u(r=>{throw new Error(r)},"throwError");class ue{static{u(this,"Quat")}constructor(e=new Float32Array([0,0,0,1]),t="XYZ"){this.type="Quat",this.elements=e,this.axisOrder=t}setFromArray(e=new Float32Array([0,0,0,1])){return this.elements[0]=e[0],this.elements[1]=e[1],this.elements[2]=e[2],this.elements[3]=e[3],this}setAxisOrder(e="XYZ"){switch(e=e.toUpperCase(),e){case"XYZ":case"YXZ":case"ZXY":case"ZYX":case"YZX":case"XZY":this.axisOrder=e;break;default:this.axisOrder="XYZ"}return this}copy(e=new ue){return this.elements.set(e.elements),this.axisOrder=e.axisOrder,this}clone(){return new ue().copy(this)}equals(e=new ue){return this.elements[0]===e.elements[0]&&this.elements[1]===e.elements[1]&&this.elements[2]===e.elements[2]&&this.elements[3]===e.elements[3]&&this.axisOrder===e.axisOrder}setFromVec3(e){const t=e.x*.5,s=e.y*.5,i=e.z*.5,n=Math.cos(t),a=Math.cos(s),o=Math.cos(i),h=Math.sin(t),l=Math.sin(s),d=Math.sin(i);return this.axisOrder==="XYZ"?(this.elements[0]=h*a*o+n*l*d,this.elements[1]=n*l*o-h*a*d,this.elements[2]=n*a*d+h*l*o,this.elements[3]=n*a*o-h*l*d):this.axisOrder==="YXZ"?(this.elements[0]=h*a*o+n*l*d,this.elements[1]=n*l*o-h*a*d,this.elements[2]=n*a*d-h*l*o,this.elements[3]=n*a*o+h*l*d):this.axisOrder==="ZXY"?(this.elements[0]=h*a*o-n*l*d,this.elements[1]=n*l*o+h*a*d,this.elements[2]=n*a*d+h*l*o,this.elements[3]=n*a*o-h*l*d):this.axisOrder==="ZYX"?(this.elements[0]=h*a*o-n*l*d,this.elements[1]=n*l*o+h*a*d,this.elements[2]=n*a*d-h*l*o,this.elements[3]=n*a*o+h*l*d):this.axisOrder==="YZX"?(this.elements[0]=h*a*o+n*l*d,this.elements[1]=n*l*o+h*a*d,this.elements[2]=n*a*d-h*l*o,this.elements[3]=n*a*o-h*l*d):this.axisOrder==="XZY"&&(this.elements[0]=h*a*o-n*l*d,this.elements[1]=n*l*o-h*a*d,this.elements[2]=n*a*d+h*l*o,this.elements[3]=n*a*o+h*l*d),this}setFromAxisAngle(e,t=0){const s=t/2,i=Math.sin(s);return this.elements[0]=e.x*i,this.elements[1]=e.y*i,this.elements[2]=e.z*i,this.elements[3]=Math.cos(s),this}setFromRotationMatrix(e){const t=e.elements,s=t[0],i=t[4],n=t[8],a=t[1],o=t[5],h=t[9],l=t[2],d=t[6],c=t[10],f=s+o+c;if(f>0){const p=.5/Math.sqrt(f+1);this.elements[3]=.25/p,this.elements[0]=(d-h)*p,this.elements[1]=(n-l)*p,this.elements[2]=(a-i)*p}else if(s>o&&s>c){const p=2*Math.sqrt(1+s-o-c);this.elements[3]=(d-h)/p,this.elements[0]=.25*p,this.elements[1]=(i+a)/p,this.elements[2]=(n+l)/p}else if(o>c){const p=2*Math.sqrt(1+o-s-c);this.elements[3]=(n-l)/p,this.elements[0]=(i+a)/p,this.elements[1]=.25*p,this.elements[2]=(h+d)/p}else{const p=2*Math.sqrt(1+c-s-o);this.elements[3]=(a-i)/p,this.elements[0]=(n+l)/p,this.elements[1]=(h+d)/p,this.elements[2]=.25*p}return this}lengthSq(){return this.elements[0]*this.elements[0]+this.elements[1]*this.elements[1]+this.elements[2]*this.elements[2]+this.elements[3]*this.elements[3]}length(){return Math.sqrt(this.lengthSq())}normalize(){let e=this.length();return e===0?(this.elements[0]=0,this.elements[1]=0,this.elements[2]=0,this.elements[3]=1):(e=1/e,this.elements[0]=this.elements[0]*e,this.elements[1]=this.elements[1]*e,this.elements[2]=this.elements[2]*e,this.elements[3]=this.elements[3]*e),this}slerp(e=new ue,t=0){if(t===0)return this;if(t===1)return this.copy(e);const s=this.elements[0],i=this.elements[1],n=this.elements[2],a=this.elements[3];let o=a*e.elements[3]+s*e.elements[0]+i*e.elements[1]+n*e.elements[2];if(o<0?(this.elements[3]=-e.elements[3],this.elements[0]=-e.elements[0],this.elements[1]=-e.elements[1],this.elements[2]=-e.elements[2],o=-o):this.copy(e),o>=1)return this.elements[3]=a,this.elements[0]=s,this.elements[1]=i,this.elements[2]=n,this;const h=1-o*o;if(h<=Number.EPSILON){const p=1-t;return this.elements[3]=p*a+t*this.elements[3],this.elements[0]=p*s+t*this.elements[0],this.elements[1]=p*i+t*this.elements[1],this.elements[2]=p*n+t*this.elements[2],this.normalize(),this}const l=Math.sqrt(h),d=Math.atan2(l,o),c=Math.sin((1-t)*d)/l,f=Math.sin(t*d)/l;return this.elements[3]=a*c+this.elements[3]*f,this.elements[0]=s*c+this.elements[0]*f,this.elements[1]=i*c+this.elements[1]*f,this.elements[2]=n*c+this.elements[2]*f,this}}class y{static{u(this,"Vec3")}constructor(e=0,t=e,s=e){this.type="Vec3",this._x=e,this._y=t,this._z=s}get x(){return this._x}set x(e){const t=e!==this._x;this._x=e,t&&this._onChangeCallback&&this._onChangeCallback()}get y(){return this._y}set y(e){const t=e!==this._y;this._y=e,t&&this._onChangeCallback&&this._onChangeCallback()}get z(){return this._z}set z(e){const t=e!==this._z;this._z=e,t&&this._onChangeCallback&&this._onChangeCallback()}onChange(e){return e&&(this._onChangeCallback=e),this}set(e=0,t=e,s=e){return this.x=e,this.y=t,this.z=s,this}add(e=new y){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e=0){return this.x+=e,this.y+=e,this.z+=e,this}sub(e=new y){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e=0){return this.x-=e,this.y-=e,this.z-=e,this}multiply(e=new y(1)){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e=1){return this.x*=e,this.y*=e,this.z*=e,this}divide(e=new y(1)){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e=1){return this.x/=e,this.y/=e,this.z/=e,this}copy(e=new y){return this.x=e.x,this.y=e.y,this.z=e.z,this}clone(){return new y(this.x,this.y,this.z)}max(e=new y){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}min(e=new y){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}clamp(e=new y,t=new y){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}equals(e=new y){return this.x===e.x&&this.y===e.y&&this.z===e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.lengthSq())}distance(e=new y){return Math.hypot(e.x-this.x,e.y-this.y,e.z-this.z)}normalize(){let e=this.lengthSq();return e>0&&(e=1/Math.sqrt(e)),this.x*=e,this.y*=e,this.z*=e,this}dot(e=new y){return this.x*e.x+this.y*e.y+this.z*e.z}cross(e=new y){return this.crossVectors(this,e)}crossVectors(e=new y,t=new y){const s=e.x,i=e.y,n=e.z,a=t.x,o=t.y,h=t.z;return this.x=i*h-n*o,this.y=n*a-s*h,this.z=s*o-i*a,this}lerp(e=new y,t=1){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}applyMat4(e){const t=this._x,s=this._y,i=this._z,n=e.elements;let a=n[3]*t+n[7]*s+n[11]*i+n[15];return a=a||1,this.x=(n[0]*t+n[4]*s+n[8]*i+n[12])/a,this.y=(n[1]*t+n[5]*s+n[9]*i+n[13])/a,this.z=(n[2]*t+n[6]*s+n[10]*i+n[14])/a,this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}applyQuat(e=new ue){const t=this.x,s=this.y,i=this.z,n=e.elements[0],a=e.elements[1],o=e.elements[2],h=e.elements[3],l=2*(a*i-o*s),d=2*(o*t-n*i),c=2*(n*s-a*t);return this.x=t+h*l+a*c-o*d,this.y=s+h*d+o*l-n*c,this.z=i+h*c+n*d-a*l,this}applyAxisAngle(e=new y,t=0,s=new ue){return this.applyQuat(s.setFromAxisAngle(e,t))}transformDirection(e){const t=this.x,s=this.y,i=this.z,n=e.elements;return this.x=n[0]*t+n[4]*s+n[8]*i,this.y=n[1]*t+n[5]*s+n[9]*i,this.z=n[2]*t+n[6]*s+n[10]*i,this.normalize()}project(e){return this.applyMat4(e.viewMatrix).applyMat4(e.projectionMatrix),this}unproject(e){return this.applyMat4(e.projectionMatrix.getInverse()).applyMat4(e.modelMatrix),this}}const se=new y,Ce=new y,V=new y;class D{static{u(this,"Mat4")}constructor(e=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])){this.type="Mat4",this.elements=e}set(e,t,s,i,n,a,o,h,l,d,c,f,p,m,g,v){const x=this.elements;return x[0]=e,x[1]=t,x[2]=s,x[3]=i,x[4]=n,x[5]=a,x[6]=o,x[7]=h,x[8]=l,x[9]=d,x[10]=c,x[11]=f,x[12]=p,x[13]=m,x[14]=g,x[15]=v,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}setFromArray(e=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),t=0){for(let s=0;s<this.elements.length;s++)this.elements[s]=e[s+t];return this}copy(e=new D){const t=e.elements;return this.elements[0]=t[0],this.elements[1]=t[1],this.elements[2]=t[2],this.elements[3]=t[3],this.elements[4]=t[4],this.elements[5]=t[5],this.elements[6]=t[6],this.elements[7]=t[7],this.elements[8]=t[8],this.elements[9]=t[9],this.elements[10]=t[10],this.elements[11]=t[11],this.elements[12]=t[12],this.elements[13]=t[13],this.elements[14]=t[14],this.elements[15]=t[15],this}clone(){return new D().copy(this)}multiply(e=new D){return this.multiplyMatrices(this,e)}premultiply(e=new D){return this.multiplyMatrices(e,this)}multiplyMatrices(e=new D,t=new D){const s=e.elements,i=t.elements,n=this.elements,a=s[0],o=s[4],h=s[8],l=s[12],d=s[1],c=s[5],f=s[9],p=s[13],m=s[2],g=s[6],v=s[10],x=s[14],b=s[3],S=s[7],B=s[11],C=s[15],P=i[0],w=i[4],z=i[8],R=i[12],L=i[1],U=i[5],K=i[9],G=i[13],Q=i[2],ee=i[6],k=i[10],W=i[14],X=i[3],te=i[7],he=i[11],Ie=i[15];return n[0]=a*P+o*L+h*Q+l*X,n[4]=a*w+o*U+h*ee+l*te,n[8]=a*z+o*K+h*k+l*he,n[12]=a*R+o*G+h*W+l*Ie,n[1]=d*P+c*L+f*Q+p*X,n[5]=d*w+c*U+f*ee+p*te,n[9]=d*z+c*K+f*k+p*he,n[13]=d*R+c*G+f*W+p*Ie,n[2]=m*P+g*L+v*Q+x*X,n[6]=m*w+g*U+v*ee+x*te,n[10]=m*z+g*K+v*k+x*he,n[14]=m*R+g*G+v*W+x*Ie,n[3]=b*P+S*L+B*Q+C*X,n[7]=b*w+S*U+B*ee+C*te,n[11]=b*z+S*K+B*k+C*he,n[15]=b*R+S*G+B*W+C*Ie,this}premultiplyTranslate(e=new y){const a=e.x,o=e.y,h=e.z,l=this.elements,d=this.elements,c=l[0],f=l[4],p=l[8],m=l[12],g=l[1],v=l[5],x=l[9],b=l[13],S=l[2],B=l[6],C=l[10],P=l[14],w=l[3],z=l[7],R=l[11],L=l[15];return d[0]=1*c+a*w,d[4]=1*f+a*z,d[8]=1*p+a*R,d[12]=1*m+a*L,d[1]=1*g+o*w,d[5]=1*v+o*z,d[9]=1*x+o*R,d[13]=1*b+o*L,d[2]=1*S+h*w,d[6]=1*B+h*z,d[10]=1*C+h*R,d[14]=1*P+h*L,d[3]=1*w,d[7]=1*z,d[11]=1*R,d[15]=1*L,this}premultiplyScale(e=new y){const t=this.elements,s=this.elements,i=e.x,n=e.y,a=e.z,o=1,h=t[0],l=t[4],d=t[8],c=t[12],f=t[1],p=t[5],m=t[9],g=t[13],v=t[2],x=t[6],b=t[10],S=t[14],B=t[3],C=t[7],P=t[11],w=t[15];return s[0]=i*h,s[4]=i*l,s[8]=i*d,s[12]=i*c,s[1]=n*f,s[5]=n*p,s[9]=n*m,s[13]=n*g,s[2]=a*v,s[6]=a*x,s[10]=a*b,s[14]=a*S,s[3]=o*B,s[7]=o*C,s[11]=o*P,s[15]=o*w,this}invert(){const e=this.elements,t=e[0],s=e[1],i=e[2],n=e[3],a=e[4],o=e[5],h=e[6],l=e[7],d=e[8],c=e[9],f=e[10],p=e[11],m=e[12],g=e[13],v=e[14],x=e[15],b=c*v*l-g*f*l+g*h*p-o*v*p-c*h*x+o*f*x,S=m*f*l-d*v*l-m*h*p+a*v*p+d*h*x-a*f*x,B=d*g*l-m*c*l+m*o*p-a*g*p-d*o*x+a*c*x,C=m*c*h-d*g*h-m*o*f+a*g*f+d*o*v-a*c*v,P=t*b+s*S+i*B+n*C;if(P===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const w=1/P;return e[0]=b*w,e[1]=(g*f*n-c*v*n-g*i*p+s*v*p+c*i*x-s*f*x)*w,e[2]=(o*v*n-g*h*n+g*i*l-s*v*l-o*i*x+s*h*x)*w,e[3]=(c*h*n-o*f*n-c*i*l+s*f*l+o*i*p-s*h*p)*w,e[4]=S*w,e[5]=(d*v*n-m*f*n+m*i*p-t*v*p-d*i*x+t*f*x)*w,e[6]=(m*h*n-a*v*n-m*i*l+t*v*l+a*i*x-t*h*x)*w,e[7]=(a*f*n-d*h*n+d*i*l-t*f*l-a*i*p+t*h*p)*w,e[8]=B*w,e[9]=(m*c*n-d*g*n-m*s*p+t*g*p+d*s*x-t*c*x)*w,e[10]=(a*g*n-m*o*n+m*s*l-t*g*l-a*s*x+t*o*x)*w,e[11]=(d*o*n-a*c*n-d*s*l+t*c*l+a*s*p-t*o*p)*w,e[12]=C*w,e[13]=(d*g*i-m*c*i+m*s*f-t*g*f-d*s*v+t*c*v)*w,e[14]=(m*o*i-a*g*i-m*s*h+t*g*h+a*s*v-t*o*v)*w,e[15]=(a*c*i-d*o*i+d*s*h-t*c*h-a*s*f+t*o*f)*w,this}getInverse(){return this.clone().invert()}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}translate(e=new y){const t=this.elements;return t[12]=t[0]*e.x+t[4]*e.y+t[8]*e.z+t[12],t[13]=t[1]*e.x+t[5]*e.y+t[9]*e.z+t[13],t[14]=t[2]*e.x+t[6]*e.y+t[10]*e.z+t[14],t[15]=t[3]*e.x+t[7]*e.y+t[11]*e.z+t[15],this}getTranslation(e=new y){return e.set(this.elements[12],this.elements[13],this.elements[14])}scale(e=new y){const t=this.elements;return t[0]*=e.x,t[1]*=e.x,t[2]*=e.x,t[3]*=e.x,t[4]*=e.y,t[5]*=e.y,t[6]*=e.y,t[7]*=e.y,t[8]*=e.z,t[9]*=e.z,t[10]*=e.z,t[11]*=e.z,this}rotateFromQuaternion(e=new ue){const t=this.elements,s=e.elements[0],i=e.elements[1],n=e.elements[2],a=e.elements[3],o=s+s,h=i+i,l=n+n,d=s*o,c=s*h,f=s*l,p=i*h,m=i*l,g=n*l,v=a*o,x=a*h,b=a*l;return t[0]=1-(p+g),t[4]=c-b,t[8]=f+x,t[1]=c+b,t[5]=1-(d+g),t[9]=m-v,t[2]=f-x,t[6]=m+v,t[10]=1-(d+p),this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],s=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,s,i))}compose(e=new y,t=new ue,s=new y(1)){const i=this.elements,n=t.elements[0],a=t.elements[1],o=t.elements[2],h=t.elements[3],l=n+n,d=a+a,c=o+o,f=n*l,p=n*d,m=n*c,g=a*d,v=a*c,x=o*c,b=h*l,S=h*d,B=h*c,C=s.x,P=s.y,w=s.z;return i[0]=(1-(g+x))*C,i[1]=(p+B)*C,i[2]=(m-S)*C,i[3]=0,i[4]=(p-B)*P,i[5]=(1-(f+x))*P,i[6]=(v+b)*P,i[7]=0,i[8]=(m+S)*w,i[9]=(v-b)*w,i[10]=(1-(f+g))*w,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}composeFromOrigin(e=new y,t=new ue,s=new y(1),i=new y){const n=this.elements,a=t.elements[0],o=t.elements[1],h=t.elements[2],l=t.elements[3],d=a+a,c=o+o,f=h+h,p=a*d,m=a*c,g=a*f,v=o*c,x=o*f,b=h*f,S=l*d,B=l*c,C=l*f,P=s.x,w=s.y,z=s.z,R=i.x,L=i.y,U=i.z,K=(1-(v+b))*P,G=(m+C)*P,Q=(g-B)*P,ee=(m-C)*w,k=(1-(p+b))*w,W=(x+S)*w,X=(g+B)*z,te=(x-S)*z,he=(1-(p+v))*z;return n[0]=K,n[1]=G,n[2]=Q,n[3]=0,n[4]=ee,n[5]=k,n[6]=W,n[7]=0,n[8]=X,n[9]=te,n[10]=he,n[11]=0,n[12]=e.x+R-(K*R+ee*L+X*U),n[13]=e.y+L-(G*R+k*L+te*U),n[14]=e.z+U-(Q*R+W*L+he*U),n[15]=1,this}lookAt(e=new y,t=new y,s=new y(0,1,0)){const i=this.elements;return V.copy(e).sub(t),V.lengthSq()===0&&(V.z=1),V.normalize(),se.crossVectors(s,V),se.lengthSq()===0&&(Math.abs(s.z)===1?V.x+=1e-4:V.z+=1e-4,V.normalize(),se.crossVectors(s,V)),se.normalize(),Ce.crossVectors(V,se),i[0]=se.x,i[1]=se.y,i[2]=se.z,i[3]=0,i[4]=Ce.x,i[5]=Ce.y,i[6]=Ce.z,i[7]=0,i[8]=V.x,i[9]=V.y,i[10]=V.z,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}makeView(e=new y,t=new y,s=new y(0,1,0)){const i=this.elements;return V.copy(e).sub(t).normalize(),se.crossVectors(s,V).normalize(),Ce.crossVectors(V,se).normalize(),i[0]=se.x,i[1]=Ce.x,i[2]=V.x,i[3]=0,i[4]=se.y,i[5]=Ce.y,i[6]=V.y,i[7]=0,i[8]=se.z,i[9]=Ce.z,i[10]=V.z,i[11]=0,i[12]=-(se.x*e.x+se.y*e.y+se.z*e.z),i[13]=-(Ce.x*e.x+Ce.y*e.y+Ce.z*e.z),i[14]=-(V.x*e.x+V.y*e.y+V.z*e.z),i[15]=1,this}makeOrthographic({left:e=-5,right:t=5,bottom:s=-5,top:i=5,near:n=.1,far:a=50}){const o=this.elements;return o[0]=2/(t-e),o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2/(i-s),o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=1/(n-a),o[11]=0,o[12]=(t+e)/(e-t),o[13]=(i+s)/(s-i),o[14]=n/(n-a),o[15]=1,this}makePerspective({fov:e=90,aspect:t=1,near:s=.1,far:i=150}){const n=s*Math.tan(Math.PI/180*.5*e),a=2*n,o=t*a,h=-.5*o,l=h+o,d=n-a,c=2*s/(l-h),f=2*s/(n-d),p=(l+h)/(l-h),m=(n+d)/(n-d),g=-i/(i-s),v=-i*s/(i-s);return this.set(c,0,0,0,0,f,0,0,p,m,g,-1,0,0,v,0),this}}let So=0;const To=new D;class Me{static{u(this,"Object3D")}constructor(){this._parent=null,this.children=[],this.matricesNeedUpdate=!1,Object.defineProperty(this,"object3DIndex",{value:So++}),this.setMatrices(),this.setTransforms()}get parent(){return this._parent}set parent(e){this._parent&&e&&this._parent.object3DIndex===e.object3DIndex||(this._parent&&(this._parent.children=this._parent.children.filter(t=>t.object3DIndex!==this.object3DIndex)),e&&this.shouldUpdateWorldMatrix(),this._parent=e,this._parent?.children.push(this))}setTransforms(){this.transforms={origin:{model:new y},quaternion:new ue,rotation:new y,position:{world:new y},scale:new y(1)},this.rotation.onChange(()=>this.applyRotation()),this.position.onChange(()=>this.applyPosition()),this.scale.onChange(()=>this.applyScale()),this.transformOrigin.onChange(()=>this.applyTransformOrigin())}get rotation(){return this.transforms.rotation}set rotation(e){this.transforms.rotation=e,this.applyRotation()}get quaternion(){return this.transforms.quaternion}set quaternion(e){this.transforms.quaternion=e}get position(){return this.transforms.position.world}set position(e){this.transforms.position.world=e}get scale(){return this.transforms.scale}set scale(e){this.transforms.scale=e,this.applyScale()}get transformOrigin(){return this.transforms.origin.model}set transformOrigin(e){this.transforms.origin.model=e}applyRotation(){this.quaternion.setFromVec3(this.rotation),this.shouldUpdateModelMatrix()}applyPosition(){this.shouldUpdateModelMatrix()}applyScale(){this.shouldUpdateModelMatrix()}applyTransformOrigin(){this.shouldUpdateModelMatrix()}setMatrices(){this.matrices={model:{matrix:new D,shouldUpdate:!0,onUpdate:u(()=>this.updateModelMatrix(),"onUpdate")},world:{matrix:new D,shouldUpdate:!0,onUpdate:u(()=>this.updateWorldMatrix(),"onUpdate")}}}get modelMatrix(){return this.matrices.model.matrix}set modelMatrix(e){this.matrices.model.matrix=e,this.shouldUpdateModelMatrix()}shouldUpdateModelMatrix(){this.matrices.model.shouldUpdate=!0,this.shouldUpdateWorldMatrix()}get worldMatrix(){return this.matrices.world.matrix}set worldMatrix(e){this.matrices.world.matrix=e,this.shouldUpdateWorldMatrix()}shouldUpdateWorldMatrix(){this.matrices.world.shouldUpdate=!0}lookAt(e=new y,t=this.position,s=new y(0,1,0)){const i=To.lookAt(e,t,s);this.quaternion.setFromRotationMatrix(i),this.shouldUpdateModelMatrix()}updateModelMatrix(){this.modelMatrix=this.modelMatrix.composeFromOrigin(this.position,this.quaternion,this.scale,this.transformOrigin),this.shouldUpdateWorldMatrix()}updateWorldMatrix(){this.parent?this.worldMatrix.multiplyMatrices(this.parent.worldMatrix,this.modelMatrix):this.worldMatrix.copy(this.modelMatrix);for(let e=0,t=this.children.length;e<t;e++)this.children[e].shouldUpdateWorldMatrix()}shouldUpdateMatrices(){this.matricesNeedUpdate=!!Object.values(this.matrices).find(e=>e.shouldUpdate)}updateMatrixStack(){if(this.shouldUpdateMatrices(),this.matricesNeedUpdate)for(const e in this.matrices)this.matrices[e].shouldUpdate&&(this.matrices[e].onUpdate(),this.matrices[e].shouldUpdate=!1);for(let e=0,t=this.children.length;e<t;e++)this.children[e].updateMatrixStack()}destroy(){for(let e=0,t=this.children.length;e<t;e++)this.children[e]&&(this.children[e].parent=null);this.parent=null}}const Pi=u((r,e="GPURenderer",t)=>{const s=t?`Unable to create ${t} because the ${e} is not defined: ${r}`:`The ${e} is not defined: ${r}`;ae(s)},"formatRendererError"),$=u((r,e)=>(r=r&&r.renderer||r,r&&(r.type==="GPURenderer"||r.type==="GPUCameraRenderer"||r.type==="GPUCurtainsRenderer")||Pi(r,"GPURenderer",e),r),"isRenderer"),Ae=u((r,e)=>(r=r&&r.renderer||r,r&&(r.type==="GPUCameraRenderer"||r.type==="GPUCurtainsRenderer")||Pi(r,"GPUCameraRenderer",e),r),"isCameraRenderer"),ft=u((r,e)=>(r=r&&r.renderer||r,r&&r.type==="GPUCurtainsRenderer"||Pi(r,"GPUCurtainsRenderer",e),r),"isCurtainsRenderer"),Po=u(r=>"geometry"in r&&"material"in r&&r instanceof Me?r:!1,"isProjectedMesh"),Ri=typeof GPUShaderStage<"u"?GPUShaderStage:{VERTEX:1,FRAGMENT:2,COMPUTE:4},Re=typeof GPUBufferUsage<"u"?GPUBufferUsage:{MAP_READ:1,MAP_WRITE:2,COPY_SRC:4,COPY_DST:8,INDEX:16,VERTEX:32,UNIFORM:64,STORAGE:128,INDIRECT:256,QUERY_RESOLVE:512},$t=typeof GPUTextureUsage<"u"?GPUTextureUsage:{COPY_SRC:1,COPY_DST:2,TEXTURE_BINDING:4,STORAGE_BINDING:8,RENDER_ATTACHMENT:16},Ro=new Map([["vertex",Ri.VERTEX],["fragment",Ri.FRAGMENT],["compute",Ri.COMPUTE]]),Eo=u((r=[])=>r.reduce((e,t)=>e|Ro.get(t),0),"getBindingVisibility"),zo={i32:{numElements:1,align:4,size:4,type:"i32",View:Int32Array},u32:{numElements:1,align:4,size:4,type:"u32",View:Uint32Array},f32:{numElements:1,align:4,size:4,type:"f32",View:Float32Array},f16:{numElements:1,align:2,size:2,type:"u16",View:Uint16Array},vec2f:{numElements:2,align:8,size:8,type:"f32",View:Float32Array},vec2i:{numElements:2,align:8,size:8,type:"i32",View:Int32Array},vec2u:{numElements:2,align:8,size:8,type:"u32",View:Uint32Array},vec2h:{numElements:2,align:4,size:4,type:"u16",View:Uint16Array},vec3i:{numElements:3,align:16,size:12,type:"i32",View:Int32Array},vec3u:{numElements:3,align:16,size:12,type:"u32",View:Uint32Array},vec3f:{numElements:3,align:16,size:12,type:"f32",View:Float32Array},vec3h:{numElements:3,align:8,size:6,type:"u16",View:Uint16Array},vec4i:{numElements:4,align:16,size:16,type:"i32",View:Int32Array},vec4u:{numElements:4,align:16,size:16,type:"u32",View:Uint32Array},vec4f:{numElements:4,align:16,size:16,type:"f32",View:Float32Array},vec4h:{numElements:4,align:8,size:8,type:"u16",View:Uint16Array},mat2x2f:{numElements:4,align:8,size:16,type:"f32",View:Float32Array},mat2x2h:{numElements:4,align:4,size:8,type:"u16",View:Uint16Array},mat3x2f:{numElements:6,align:8,size:24,type:"f32",View:Float32Array},mat3x2h:{numElements:6,align:4,size:12,type:"u16",View:Uint16Array},mat4x2f:{numElements:8,align:8,size:32,type:"f32",View:Float32Array},mat4x2h:{numElements:8,align:4,size:16,type:"u16",View:Uint16Array},mat2x3f:{numElements:8,align:16,size:32,pad:[3,1],type:"f32",View:Float32Array},mat2x3h:{numElements:8,align:8,size:16,pad:[3,1],type:"u16",View:Uint16Array},mat3x3f:{numElements:12,align:16,size:48,pad:[3,1],type:"f32",View:Float32Array},mat3x3h:{numElements:12,align:8,size:24,pad:[3,1],type:"u16",View:Uint16Array},mat4x3f:{numElements:16,align:16,size:64,pad:[3,1],type:"f32",View:Float32Array},mat4x3h:{numElements:16,align:8,size:32,pad:[3,1],type:"u16",View:Uint16Array},mat2x4f:{numElements:8,align:16,size:32,type:"f32",View:Float32Array},mat2x4h:{numElements:8,align:8,size:16,type:"u16",View:Uint16Array},mat3x4f:{numElements:12,align:16,size:48,pad:[3,1],type:"f32",View:Float32Array},mat3x4h:{numElements:12,align:8,size:24,pad:[3,1],type:"u16",View:Uint16Array},mat4x4f:{numElements:16,align:16,size:64,type:"f32",View:Float32Array},mat4x4h:{numElements:16,align:8,size:32,type:"u16",View:Uint16Array}},kr=u(r=>zo[r],"getBufferLayout"),Cs=u(r=>(()=>{switch(r.bindingType){case"storage":return`var<${r.bindingType}, ${r.options.access}>`;case"uniform":default:return"var<uniform>"}})(),"getBindingWGSLVarType"),_o=u(r=>r.bindingType==="externalTexture"?`var ${r.name}: texture_external;`:r.bindingType==="storage"?`var ${r.name}: texture_storage_${r.options.viewDimension.replace("-","_")}<${r.options.format}, ${r.options.access}>;`:r.bindingType==="depth"?`var ${r.name}: texture_depth${r.options.multisampled?"_multisampled":""}_${r.options.viewDimension.replace("-","_")};`:`var ${r.name}: texture${r.options.multisampled?"_multisampled":""}_${r.options.viewDimension.replace("-","_")}<f32>;`,"getTextureBindingWGSLVarType"),Vr=u(r=>r.bindingType==="storage"&&r.options.access==="read_write"?"storage":r.bindingType==="storage"?"read-only-storage":"uniform","getBindGroupLayoutBindingType"),Lo=u(r=>(()=>{switch(r.bindingType){case"externalTexture":return{externalTexture:{}};case"storage":return{storageTexture:{format:r.options.format,viewDimension:r.options.viewDimension}};case"texture":return{texture:{multisampled:r.options.multisampled,viewDimension:r.options.viewDimension,sampleType:r.options.multisampled?"unfilterable-float":"float"}};case"depth":return{texture:{multisampled:r.options.multisampled,viewDimension:r.options.viewDimension,sampleType:"depth"}};default:return null}})(),"getBindGroupLayoutTextureBindingType"),Ao=u(r=>(()=>{switch(r.bindingType){case"externalTexture":return`externalTexture,${r.visibility},`;case"storage":return`storageTexture,${r.options.format},${r.options.viewDimension},${r.visibility},`;case"texture":return`texture,${r.options.multisampled},${r.options.viewDimension},${r.options.multisampled?"unfilterable-float":"float"},${r.visibility},`;case"depth":return`depthTexture,${r.options.format},${r.options.viewDimension},${r.visibility},`;default:return`${r.visibility},`}})(),"getBindGroupLayoutTextureBindingCacheKey");class Ms{static{u(this,"Binding")}constructor({label:e="Uniform",name:t="uniform",bindingType:s="uniform",visibility:i=["vertex","fragment","compute"]}){this.label=e,this.name=Dt(t),this.bindingType=s,this.visibility=Eo(i),this.options={label:e,name:t,bindingType:s,visibility:i},this.shouldResetBindGroup=!1,this.shouldResetBindGroupLayout=!1,this.cacheKey=`${s},${this.visibility},`}}class _{static{u(this,"Vec2")}constructor(e=0,t=e){this.type="Vec2",this._x=e,this._y=t}get x(){return this._x}set x(e){const t=e!==this._x;this._x=e,t&&this._onChangeCallback&&this._onChangeCallback()}get y(){return this._y}set y(e){const t=e!==this._y;this._y=e,t&&this._onChangeCallback&&this._onChangeCallback()}onChange(e){return e&&(this._onChangeCallback=e),this}set(e=0,t=e){return this.x=e,this.y=t,this}add(e=new _){return this.x+=e.x,this.y+=e.y,this}addScalar(e=0){return this.x+=e,this.y+=e,this}sub(e=new _){return this.x-=e.x,this.y-=e.y,this}subScalar(e=0){return this.x-=e,this.y-=e,this}multiply(e=new _(1)){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e=1){return this.x*=e,this.y*=e,this}divide(e=new _(1)){return this.x/=e.x,this.y/=e.y,this}divideScalar(e=1){return this.x/=e,this.y/=e,this}copy(e=new _){return this.x=e.x,this.y=e.y,this}clone(){return new _(this.x,this.y)}max(e=new _){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}min(e=new _){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}clamp(e=new _,t=new _){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}equals(e=new _){return this.x===e.x&&this.y===e.y}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.lengthSq())}normalize(){let e=this.x*this.x+this.y*this.y;return e>0&&(e=1/Math.sqrt(e)),this.x*=e,this.y*=e,this}dot(e=new _){return this.x*e.x+this.y*e.y}lerp(e=new _,t=1){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}}const Do=4,Bs=4,J=Do*Bs;class xe{static{u(this,"BufferElement")}constructor({name:e,key:t,type:s="f32"}){this.name=e,this.key=t,this.type=s,this.baseType=xe.getBaseType(this.type),this.bufferLayout=kr(this.baseType),this.alignment={start:{row:0,byte:0},end:{row:0,byte:0}},this.setValue=null}static getType(e){return e.replace("array","").replace("<","").replace(">","")}static getBaseType(e){return xe.getType(e.replace("atomic","").replace("array","").replaceAll("<","").replaceAll(">",""))}get rowCount(){return this.alignment.end.row-this.alignment.start.row+1}get byteCount(){return Math.abs(this.endOffset-this.startOffset)+1}get paddedByteCount(){return(this.alignment.end.row+1)*J}get startOffset(){return this.getByteCountAtPosition(this.alignment.start)}get startOffsetToIndex(){return this.startOffset/Bs}get endOffset(){return this.getByteCountAtPosition(this.alignment.end)}get endOffsetToIndex(){return Math.floor(this.endOffset/Bs)}getPositionAtOffset(e=0){return{row:Math.floor(e/J),byte:e%J}}getByteCountAtPosition(e={row:0,byte:0}){return e.row*J+e.byte}applyOverflowToPosition(e={row:0,byte:0}){if(e.byte>J-1){const t=e.byte%J;e.row+=Math.floor(e.byte/J),e.byte=t}return e}getByteCountBetweenPositions(e={row:0,byte:0},t={row:0,byte:0}){return Math.abs(this.getByteCountAtPosition(t)-this.getByteCountAtPosition(e))}getElementAlignment(e={row:0,byte:0}){const t={start:e,end:e},{size:s,align:i}=this.bufferLayout;return e.byte%i!==0&&(e.byte+=e.byte%i),(s<=J&&e.byte+s>J||s>J&&(e.byte>J||e.byte>0))&&(e.row+=1,e.byte=0),t.end={row:e.row+Math.ceil(s/J)-1,byte:e.byte+(s%J===0?J-1:s%J-1)},t.end=this.applyOverflowToPosition(t.end),t}setAlignmentFromPosition(e={row:0,byte:0}){this.alignment=this.getElementAlignment(e)}setAlignment(e=0){this.setAlignmentFromPosition(this.getPositionAtOffset(e))}setView(e,t){this.view=new this.bufferLayout.View(e,this.startOffset,this.byteCount/this.bufferLayout.View.BYTES_PER_ELEMENT)}setValueFromNumber(e){this.view[0]=e}setValueFromVec2(e){this.view[0]=e.x??e[0]??0,this.view[1]=e.y??e[1]??0}setValueFromVec3(e){this.view[0]=e.x??e[0]??0,this.view[1]=e.y??e[1]??0,this.view[2]=e.z??e[2]??0}setValueFromMat4OrQuat(e){this.view.set(e.elements)}setValueFromMat3(e){this.setValueFromArrayWithPad(e.elements)}setValueFromArray(e){this.view.set(e)}setValueFromArrayWithPad(e){for(let t=0,s=0;t<this.view.length;t+=this.bufferLayout.pad[0]+this.bufferLayout.pad[1],s++)for(let i=0;i<this.bufferLayout.pad[0];i++)this.view[t+i]=e[t+i-s]}update(e){this.setValue||(this.setValue=(t=>{if(typeof t=="number")return this.setValueFromNumber;if(this.type==="vec2f")return this.setValueFromVec2;if(this.type==="vec3f")return this.setValueFromVec3;if(this.type==="mat3x3f")return t.elements?this.setValueFromMat3:this.setValueFromArrayWithPad;if(t.elements)return this.setValueFromMat4OrQuat;if(ArrayBuffer.isView(t)||Array.isArray(t))return this.bufferLayout.pad?this.setValueFromArrayWithPad:this.setValueFromArray;A(`${this.constructor.name}: value passed to ${this.name} cannot be used: ${t}`)})(e)),this.setValue(e)}extractDataFromBufferResult(e){return e.slice(this.startOffsetToIndex,this.endOffsetToIndex)}}class Nr extends xe{static{u(this,"BufferArrayElement")}constructor({name:e,key:t,type:s="f32",arrayLength:i=1}){super({name:e,key:t,type:s}),this.arrayLength=i,this.numElements=Math.ceil(this.arrayLength/this.bufferLayout.numElements)}get arrayStrideToIndex(){return this.arrayStride/Bs}setAlignment(e=0){super.setAlignment(e);const t=this.getElementAlignment(this.getPositionAtOffset(this.endOffset+1));this.arrayStride=this.getByteCountBetweenPositions(this.alignment.end,t.end),this.alignment.end=this.getPositionAtOffset(this.endOffset+this.arrayStride*(this.numElements-1))}setValueFromArray(e){let t=0;const s=this.byteCount/this.bufferLayout.View.BYTES_PER_ELEMENT,i=Math.ceil(s/this.numElements);for(let n=0;n<this.numElements;n++)for(let a=0;a<this.bufferLayout.numElements;a++)this.view[a+n*i]=e[t],t++}}class Ei extends Nr{static{u(this,"BufferInterleavedArrayElement")}constructor({name:e,key:t,type:s="f32",arrayLength:i=1}){super({name:e,key:t,type:s,arrayLength:i}),this.arrayStride=1,this.arrayLength=i,this.numElements=Math.ceil(this.arrayLength/this.bufferLayout.numElements)}get byteCount(){return this.bufferLayout.size*this.numElements}setAlignment(e=0,t=0){this.alignment=this.getElementAlignment(this.getPositionAtOffset(e)),this.arrayStride=t,this.alignment.end=this.getPositionAtOffset(this.endOffset+t*(this.numElements-1))}setView(e,t){this.view=new this.bufferLayout.View(this.bufferLayout.numElements*this.numElements),this.viewSetFunction=(s=>{switch(this.bufferLayout.View){case Int32Array:return s.setInt32.bind(s);case Uint16Array:return s.setUint16.bind(s);case Uint32Array:return s.setUint32.bind(s);case Float32Array:default:return s.setFloat32.bind(s)}})(t)}update(e){super.update(e);for(let t=0;t<this.numElements;t++){const s=this.view.subarray(t*this.bufferLayout.numElements,t*this.bufferLayout.numElements+this.bufferLayout.numElements),i=this.startOffset+t*this.arrayStride;s.forEach((n,a)=>{this.viewSetFunction(i+a*this.bufferLayout.View.BYTES_PER_ELEMENT,n,!0)})}}extractDataFromBufferResult(e){const t=new Float32Array(this.arrayLength);for(let s=0;s<this.numElements;s++){const i=this.startOffsetToIndex+s*this.arrayStrideToIndex;for(let n=0;n<this.bufferLayout.numElements;n++)t[s*this.bufferLayout.numElements+n]=e[i+n]}return t}}const $o=new Map([["copySrc",Re.COPY_SRC],["copyDst",Re.COPY_DST],["index",Re.INDEX],["indirect",Re.INDIRECT],["mapRead",Re.MAP_READ],["mapWrite",Re.MAP_WRITE],["queryResolve",Re.QUERY_RESOLVE],["storage",Re.STORAGE],["uniform",Re.UNIFORM],["vertex",Re.VERTEX]]),Wr=u((r=[])=>r.reduce((e,t)=>e|$o.get(t),0),"getBufferUsages");class Je{static{u(this,"Buffer")}constructor({label:e="Buffer",size:t=0,usage:s=["copySrc","copyDst"],mappedAtCreation:i=!1}={}){this.type="Buffer",this.reset(),this.uuid=O(),this.consumers=new Set,this.options={label:e,size:t,usage:Wr(s),mappedAtCreation:i}}reset(){this.GPUBuffer=null}set size(e){this.options.size=e}createBuffer(e,t={}){const{usage:s,...i}=t;this.options={...this.options,...i,...s!==void 0&&{usage:Wr(s)}},this.setBuffer(e.createBuffer(this))}setBuffer(e){this.GPUBuffer=e}copy(e,t=!1){t&&this.destroy(),this.options=e.options,this.GPUBuffer=e.GPUBuffer,this.consumers=new Set([...this.consumers,...e.consumers])}async mapBufferAsync(){if(!this.GPUBuffer||this.GPUBuffer.mapState!=="unmapped")return new Float32Array(0);await this.GPUBuffer.mapAsync(GPUMapMode.READ);const e=new Float32Array(this.GPUBuffer.getMappedRange().slice(0));return this.GPUBuffer.unmap(),e}destroy(){this.GPUBuffer?.destroy(),this.reset(),this.consumers.clear()}}var jr=u(r=>{throw TypeError(r)},"__typeError$r"),qr=u((r,e,t)=>e.has(r)||jr("Cannot "+t),"__accessCheck$r"),Go=u((r,e,t)=>(qr(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet$p"),Fo=u((r,e,t)=>e.has(r)?jr("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$r"),Oo=u((r,e,t,s)=>(qr(r,e,"write to private field"),e.set(r,t),t),"__privateSet$o"),Ss;const Uo=class Si extends Ms{static{u(this,"_BufferBinding")}constructor({label:e="Uniform",name:t="uniform",bindingType:s,visibility:i,useStruct:n=!0,access:a="read",usage:o=[],struct:h={},childrenBindings:l=[],buffer:d=null,parent:c=null,minOffset:f=256,offset:p=0}){s=s??"uniform",super({label:e,name:t,bindingType:s,visibility:i}),Fo(this,Ss),this.options={...this.options,useStruct:n,access:a,usage:o,struct:h,childrenBindings:l,buffer:d,parent:c,minOffset:f,offset:p},this.cacheKey+=`${n},${a},`,this.arrayBufferSize=0,this.shouldUpdate=!1,this.useStruct=n,this.bufferElements=[],this.inputs={},this.buffer=this.options.buffer??new Je,Object.keys(h).length&&(this.setBindings(h),this.setInputsAlignment()),this.setChildrenBindings(l),(Object.keys(h).length||this.childrenBindings.length)&&(this.setBufferAttributes(),this.setWGSLFragment()),this.parent=c}static cloneStruct(e){return Object.keys(e).reduce((t,s)=>{const i=e[s];let n;return Array.isArray(i.value)||ArrayBuffer.isView(i.value)?n=new i.value.constructor(i.value.length):typeof i.value=="number"?n=0:n=new i.value.constructor,{...t,[s]:{type:i.type,value:n}}},{})}get parent(){return Go(this,Ss)}set parent(e){if(e){this.parentView=new DataView(e.arrayBuffer,this.offset,this.getMinOffsetSize(this.arrayBufferSize));const t=u(i=>[...u(a=>a.bufferElements,"getBufferElements")(i),i.childrenBindings.map(a=>t(a)).flat()].flat(),"getAllBufferElements"),s=t(this);this.parentViewSetBufferEls=s.map(i=>{switch(i.bufferLayout.View){case Int32Array:return{bufferElement:i,viewSetFunction:this.parentView.setInt32.bind(this.parentView)};case Uint16Array:return{bufferElement:i,viewSetFunction:this.parentView.setUint16.bind(this.parentView)};case Uint32Array:return{bufferElement:i,viewSetFunction:this.parentView.setUint32.bind(this.parentView)};case Float32Array:default:return{bufferElement:i,viewSetFunction:this.parentView.setFloat32.bind(this.parentView)}}}),!this.parent&&this.buffer.GPUBuffer&&!this.options.buffer&&this.buffer.destroy()}else this.parentView=null,this.parentViewSetBufferEls=null;Oo(this,Ss,e)}getMinOffsetSize(e){return Math.ceil(e/this.options.minOffset)*this.options.minOffset}get offset(){return this.getMinOffsetSize(this.options.offset*this.getMinOffsetSize(this.arrayBufferSize))}get resourceLayout(){return{buffer:{type:Vr(this)},...this.parent&&{offset:this.offset,size:this.arrayBufferSize}}}get resourceLayoutCacheKey(){return`buffer,${Vr(this)},${this.visibility},`}get resource(){return{buffer:this.parent?this.parent.buffer.GPUBuffer:this.buffer.GPUBuffer,...this.parent&&{offset:this.offset,size:this.arrayBufferSize}}}clone(e={}){let{struct:t,childrenBindings:s,parent:i,...n}=e;const{label:a,name:o,bindingType:h,visibility:l,useStruct:d,access:c,usage:f}=this.options;n={label:a,name:o,bindingType:h,visibility:l,useStruct:d,access:c,usage:f,...n};const p=new this.constructor(n);return t=t||Si.cloneStruct(this.options.struct),p.options.struct=t,p.setBindings(t),p.arrayBufferSize=this.arrayBufferSize,p.arrayBuffer=new ArrayBuffer(p.arrayBufferSize),p.arrayView=new DataView(p.arrayBuffer,0,p.arrayBuffer.byteLength),p.options.buffer||(p.buffer.size=p.arrayBuffer.byteLength),this.bufferElements.forEach(m=>{const g=new m.constructor({name:m.name,key:m.key,type:m.type,...m.arrayLength&&{arrayLength:m.arrayLength}});g.alignment=JSON.parse(JSON.stringify(m.alignment)),m.arrayStride&&(g.arrayStride=m.arrayStride),g.setView(p.arrayBuffer,p.arrayView),p.bufferElements.push(g)}),this.options.childrenBindings&&(p.options.childrenBindings=this.options.childrenBindings,p.options.childrenBindings.forEach(m=>{const g=m.count?Math.max(1,m.count):1;p.cacheKey+=`child(count:${g}):${m.binding.cacheKey}`}),p.options.childrenBindings.forEach(m=>{p.childrenBindings=[...p.childrenBindings,Array.from(Array(Math.max(1,m.count||1)).keys()).map(g=>m.binding.clone({...m.binding.options,struct:Si.cloneStruct(m.binding.options.struct)}))].flat()}),p.childrenBindings.forEach((m,g)=>{let v=this.arrayView.byteLength;for(let x=0;x<g;x++)v+=this.childrenBindings[x].arrayBuffer.byteLength;m.bufferElements.forEach((x,b)=>{x.alignment.start.row=this.childrenBindings[g].bufferElements[b].alignment.start.row,x.alignment.end.row=this.childrenBindings[g].bufferElements[b].alignment.end.row}),m.arrayView=new DataView(p.arrayBuffer,v,m.arrayBuffer.byteLength);for(const x of m.bufferElements)x.setView(p.arrayBuffer,m.arrayView)})),p.setWGSLFragment(),i&&(p.parent=i),p.shouldUpdate=p.arrayBufferSize>0,p}setBindings(e){for(const t of Object.keys(e)){const s={};for(const i in e[t])i!=="value"&&(s[i]=e[t][i]);if(s.name=t,Object.defineProperty(s,"value",{get(){return s._value},set(i){s._value=i,s.shouldUpdate=!0}}),s.value=e[t].value,s.value instanceof _||s.value instanceof y){const i=s.value._onChangeCallback;s.value._onChangeCallback=()=>{i&&i(),s.shouldUpdate=!0}}this.inputs[t]=s,this.cacheKey+=`${t},${e[t].type},`}}setChildrenBindings(e){if(this.childrenBindings=[],e&&e.length){const t=[];e.sort((s,i)=>{const n=s.count?Math.max(s.count):s.forceArray?1:0,a=i.count?Math.max(i.count):i.forceArray?1:0;return n-a}).forEach(s=>{(s.count&&s.count>1||s.forceArray)&&t.push(s.binding)}),t.length>1&&(t.shift(),A(`BufferBinding: "${this.label}" contains multiple children bindings arrays. These children bindings cannot be added to the BufferBinding: "${t.map(s=>s.label).join(", ")}"`),t.forEach(s=>{e=e.filter(i=>i.binding.name!==s.name)})),this.options.childrenBindings=e,e.forEach(s=>{const i=s.count?Math.max(1,s.count):1;this.cacheKey+=`child(count:${i}):${s.binding.cacheKey}`,this.childrenBindings=[...this.childrenBindings,Array.from(Array(i).keys()).map(n=>s.binding.clone({...s.binding.options,struct:Si.cloneStruct(s.binding.options.struct)}))].flat()})}}setInputsAlignment(){let e=Object.keys(this.inputs);const t=e.filter(s=>this.inputs[s].type.includes("array"));t.length&&(e.sort((s,i)=>{const n=Math.min(0,this.inputs[s].type.indexOf("array")),a=Math.min(0,this.inputs[i].type.indexOf("array"));return n-a}),t.length>1&&(e=e.filter(s=>!t.includes(s))));for(const s of e){const i=this.inputs[s],n={name:Dt(i.name??s),key:s,type:i.type},a=i.type.includes("array")&&(Array.isArray(i.value)||ArrayBuffer.isView(i.value));this.bufferElements.push(a?new Nr({...n,arrayLength:i.value.length}):new xe(n))}if(this.bufferElements.forEach((s,i)=>{const n=i===0?0:this.bufferElements[i-1].endOffset+1;s.setAlignment(n)}),t.length>1)if(t.map(n=>{const a=this.inputs[n],o=kr(xe.getBaseType(a.type));return Math.ceil(a.value.length/o.numElements)}).every((n,a,o)=>n===o[0])){const n=t.map(h=>{const l=this.inputs[h];return new Ei({name:Dt(l.name??h),key:h,type:l.type,arrayLength:l.value.length})}),a=t.map(h=>{const l=this.inputs[h];return new xe({name:Dt(l.name??h),key:h,type:xe.getType(l.type)})});a.forEach((h,l)=>{l===0?this.bufferElements.length?h.setAlignmentFromPosition({row:this.bufferElements[this.bufferElements.length-1].alignment.end.row+1,byte:0}):h.setAlignment(0):h.setAlignment(a[l-1].endOffset+1)});const o=a[a.length-1].endOffset+1-a[0].startOffset;n.forEach((h,l)=>{h.setAlignment(a[l].startOffset,Math.ceil(o/J)*J)}),this.bufferElements=[...this.bufferElements,...n]}else A(`BufferBinding: "${this.label}" contains multiple array inputs that should use an interleaved array, but their sizes do not match. These inputs cannot be added to the BufferBinding: "${t.join(", ")}"`)}setBufferAttributes(){const e=this.bufferElements.length?this.bufferElements[this.bufferElements.length-1].paddedByteCount:0;this.arrayBufferSize=e,this.childrenBindings.forEach(t=>{this.arrayBufferSize+=t.arrayBufferSize}),this.arrayBuffer=new ArrayBuffer(this.arrayBufferSize),this.arrayView=new DataView(this.arrayBuffer,0,e),this.childrenBindings.forEach((t,s)=>{let i=e;for(let o=0;o<s;o++)i+=this.childrenBindings[o].arrayBuffer.byteLength;const n=this.bufferElements.length?this.bufferElements[this.bufferElements.length-1].alignment.end.row+1:0,a=s>0&&this.childrenBindings[s-1].bufferElements.length?this.childrenBindings[s-1].bufferElements[this.childrenBindings[s-1].bufferElements.length-1].alignment.end.row+1:0;t.bufferElements.forEach(o=>{const h=s===0?n+a:a;o.alignment.start.row+=h,o.alignment.end.row+=h}),t.arrayView=new DataView(this.arrayBuffer,i,t.arrayBuffer.byteLength);for(const o of t.bufferElements)o.setView(this.arrayBuffer,t.arrayView)}),this.options.buffer||(this.buffer.size=this.arrayBuffer.byteLength);for(const t of this.bufferElements)t.setView(this.arrayBuffer,this.arrayView);this.shouldUpdate=this.arrayBufferSize>0}setWGSLFragment(){if(!this.bufferElements.length&&!this.childrenBindings.length)return;const e=pt(this.label);if(this.useStruct){const t={};t[e]={};const s=this.bufferElements.filter(a=>!(a instanceof Ei)),i=this.bufferElements.filter(a=>a instanceof Ei);if(i.length){const a=this.bindingType==="uniform"?`, ${i[0].numElements}`:"";if(s.length){t[`${e}Element`]={},i.forEach(l=>{t[`${e}Element`][l.name]=xe.getType(l.type)}),s.forEach(l=>{t[e][l.name]=l.type});const o=this.bufferElements.find(l=>l.name==="elements")?`${this.name}Elements`:"elements";t[e][o]=`array<${e}Element${a}>`;const h=Cs(this);this.wgslGroupFragment=[`${h} ${this.name}: ${e};`]}else{this.bufferElements.forEach(h=>{t[e][h.name]=xe.getType(h.type)});const o=Cs(this);this.wgslGroupFragment=[`${o} ${this.name}: array<${e}${a}>;`]}}else{s.forEach(o=>{const h=this.bindingType==="uniform"&&"numElements"in o?`array<${xe.getType(o.type)}, ${o.numElements}>`:o.type;t[e][o.name]=h});const a=Cs(this);this.wgslGroupFragment=[`${a} ${this.name}: ${e};`]}this.childrenBindings.length&&this.options.childrenBindings.forEach(a=>{t[e][a.binding.name]=a.count&&a.count>1||a.forceArray?`array<${pt(a.binding.label)}>`:pt(a.binding.label)});const n=this.childrenBindings.length?this.options.childrenBindings.map(a=>a.binding.wgslStructFragment).join(`

`)+`

`:"";this.wgslStructFragment=n+Object.keys(t).reverse().map(a=>`struct ${a} {
	${Object.keys(t[a]).map(o=>`${o}: ${t[a][o]}`).join(`,
	`)}
};`).join(`

`)}else this.wgslStructFragment="",this.wgslGroupFragment=this.bufferElements.map(t=>`${Cs(this)} ${t.name}: ${t.type};`)}shouldUpdateBinding(e=""){this.inputs[e]&&(this.inputs[e].shouldUpdate=!0)}update(){if(this.options.buffer){this.shouldUpdate=!1;return}const e=Object.values(this.inputs);for(const t of e){const s=this.bufferElements.find(i=>i.key===t.name);t.shouldUpdate&&s&&(t.onBeforeUpdate&&t.onBeforeUpdate(),s.update(t.value),this.shouldUpdate=!0,t.shouldUpdate=!1)}if(this.childrenBindings.forEach(t=>{t.update(),t.shouldUpdate&&(this.shouldUpdate=!0),t.shouldUpdate=!1}),this.shouldUpdate&&this.parent&&this.parentViewSetBufferEls){let t=0;this.parentViewSetBufferEls.forEach((s,i)=>{const{bufferElement:n,viewSetFunction:a}=s;n.view.forEach(o=>{a(t*n.view.BYTES_PER_ELEMENT,o,!0),t++})}),this.parent.shouldUpdate=!0,this.shouldUpdate=!1}}extractBufferElementDataFromBufferResult({result:e,bufferElementName:t}){const s=this.bufferElements.find(i=>i.name===t);return s?s.extractDataFromBufferResult(e):e}};Ss=new WeakMap;let Y=Uo;class zi extends Y{static{u(this,"WritableBufferBinding")}constructor({label:e="Work",name:t="work",bindingType:s,visibility:i,useStruct:n=!0,access:a="read_write",usage:o=[],struct:h={},childrenBindings:l=[],buffer:d=null,parent:c=null,minOffset:f=256,offset:p=0,shouldCopyResult:m=!1}){s="storage",i=["compute"],super({label:e,name:t,bindingType:s,visibility:i,useStruct:n,access:a,usage:o,struct:h,childrenBindings:l,buffer:d,parent:c,minOffset:f,offset:p}),this.options={...this.options,shouldCopyResult:m},this.shouldCopyResult=m,this.cacheKey+=`${m},`,this.resultBuffer=new Je}}class Gt{static{u(this,"BindGroup")}constructor(e,{label:t="BindGroup",index:s=0,bindings:i=[],uniforms:n,storages:a}={}){this.type="BindGroup",this.setRenderer(e),this.options={label:t,index:s,bindings:i,...n&&{uniforms:n},...a&&{storages:a}},this.index=s,this.uuid=O(),this.bindings=[],i.length&&this.addBindings(i),(this.options.uniforms||this.options.storages)&&this.setInputBindings(),this.layoutCacheKey="",this.pipelineCacheKey="",this.resetEntries(),this.bindGroupLayout=null,this.bindGroup=null,this.needsPipelineFlush=!1,this.consumers=new Set;for(const o of this.bufferBindings)"buffer"in o&&(o.parent?o.parent.buffer.consumers.add(this.uuid):o.buffer.consumers.add(this.uuid)),"resultBuffer"in o&&o.resultBuffer.consumers.add(this.uuid);this.renderer.addBindGroup(this)}setRenderer(e){e=$(e,this.type),this.renderer=e}setIndex(e){this.index=e}addBindings(e=[]){e.forEach(t=>{"buffer"in t&&(t.parent?(this.renderer.deviceManager.bufferBindings.set(t.parent.cacheKey,t.parent),t.parent.buffer.consumers.add(this.uuid)):(this.renderer.deviceManager.bufferBindings.set(t.cacheKey,t),t.buffer.consumers.add(this.uuid)))}),this.bindings=[...this.bindings,...e]}addBinding(e){this.bindings.push(e)}destroyBufferBinding(e){"buffer"in e&&(this.renderer.removeBuffer(e.buffer),e.buffer.consumers.delete(this.uuid),e.buffer.consumers.size||e.buffer.destroy(),e.parent&&(e.parent.buffer.consumers.delete(this.uuid),e.parent.buffer.consumers.size||(this.renderer.removeBuffer(e.parent.buffer),e.parent.buffer.destroy()))),"resultBuffer"in e&&(this.renderer.removeBuffer(e.resultBuffer),e.resultBuffer.consumers.delete(this.uuid),e.resultBuffer.consumers.size||e.resultBuffer.destroy())}createInputBindings(e="uniform",t={}){let s=[...Object.keys(t).map(i=>{const n=t[i];if(!n.struct)return;const a={label:pt(n.label||i),name:i,bindingType:e,visibility:n.access==="read_write"?["compute"]:n.visibility,useStruct:!0,access:n.access??"read",...n.usage&&{usage:n.usage},struct:n.struct,...n.shouldCopyResult!==void 0&&{shouldCopyResult:n.shouldCopyResult}};if(n.useStruct!==!1){let h=`${e},${n.visibility===void 0?"all":n.access==="read_write"?"compute":n.visibility},true,${n.access??"read"},`;Object.keys(n.struct).forEach(d=>{h+=`${d},${n.struct[d].type},`}),n.shouldCopyResult!==void 0&&(h+=`${n.shouldCopyResult},`);const l=this.renderer.deviceManager.bufferBindings.get(h);if(l)return l.clone(a)}const o=a.access==="read_write"?zi:Y;return n.useStruct!==!1?new o(a):Object.keys(n.struct).map(h=>(a.label=pt(n.label?n.label+h:i+h),a.name=i+h,a.useStruct=!1,a.struct={[h]:n.struct[h]},new o(a)))})].flat();return s=s.filter(Boolean),s.forEach(i=>{this.renderer.deviceManager.bufferBindings.set(i.cacheKey,i)}),s}setInputBindings(){this.addBindings([...this.createInputBindings("uniform",this.options.uniforms),...this.createInputBindings("storage",this.options.storages)])}get shouldCreateBindGroup(){return!this.bindGroup&&!!this.bindings.length}resetEntries(){this.entries={bindGroupLayout:[],bindGroup:[]}}createBindGroup(){this.fillEntries(),this.setBindGroupLayout(),this.setBindGroup()}resetBindGroup(){this.entries.bindGroup=[],this.pipelineCacheKey="";for(const e of this.bindings)this.addBindGroupEntry(e);this.setBindGroup()}addBindGroupEntry(e){this.entries.bindGroup.push({binding:this.entries.bindGroup.length,resource:e.resource}),this.pipelineCacheKey+=e.cacheKey}resetBindGroupLayout(){this.entries.bindGroupLayout=[],this.layoutCacheKey="";for(const e of this.bindings)this.addBindGroupLayoutEntry(e);this.setBindGroupLayout()}addBindGroupLayoutEntry(e){this.entries.bindGroupLayout.push({binding:this.entries.bindGroupLayout.length,...e.resourceLayout,visibility:e.visibility}),this.layoutCacheKey+=e.resourceLayoutCacheKey}loseContext(){this.resetEntries();for(const e of this.bufferBindings)e.buffer.reset(),e.parent&&e.parent.buffer.reset(),"resultBuffer"in e&&e.resultBuffer.reset();this.bindGroup=null,this.bindGroupLayout=null,this.needsPipelineFlush=!0}restoreContext(){this.shouldCreateBindGroup&&this.createBindGroup();for(const e of this.bufferBindings)e.shouldUpdate=!0}get bufferBindings(){return this.bindings.filter(e=>e instanceof Y||e instanceof zi)}createBindingBuffer(e,t=null){e.buffer.createBuffer(this.renderer,{label:t||this.options.label+": "+e.bindingType+" buffer from: "+e.label,usage:["copySrc","copyDst",e.bindingType,...e.options.usage]}),"resultBuffer"in e&&e.resultBuffer.createBuffer(this.renderer,{label:this.options.label+": Result buffer from: "+e.label,size:e.arrayBuffer.byteLength,usage:["copyDst","mapRead"]}),this.renderer.deviceManager.bufferBindings.set(e.cacheKey,e)}fillEntries(){for(const e of this.bindings)e.visibility||(e.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE),"buffer"in e&&(e.parent&&!e.parent.buffer.GPUBuffer?this.createBindingBuffer(e.parent,e.parent.options.label):!e.buffer.GPUBuffer&&!e.parent&&this.createBindingBuffer(e)),this.addBindGroupLayoutEntry(e),this.addBindGroupEntry(e)}getBindingByName(e=""){return this.bindings.find(t=>t.name===e)}setBindGroupLayout(){const e=this.renderer.deviceManager.bindGroupLayouts.get(this.layoutCacheKey);e?this.bindGroupLayout=e:(this.bindGroupLayout=this.renderer.createBindGroupLayout({label:this.options.label+" layout",entries:this.entries.bindGroupLayout}),this.renderer.deviceManager.bindGroupLayouts.set(this.layoutCacheKey,this.bindGroupLayout))}setBindGroup(){this.bindGroup=this.renderer.createBindGroup({label:this.options.label,layout:this.bindGroupLayout,entries:this.entries.bindGroup})}updateBufferBindings(){this.bindings.forEach((e,t)=>{"buffer"in e&&(e.update(),e.shouldUpdate&&e.buffer.GPUBuffer&&(!e.useStruct&&e.bufferElements.length>1?this.renderer.queueWriteBuffer(e.buffer.GPUBuffer,0,e.bufferElements[t].view):this.renderer.queueWriteBuffer(e.buffer.GPUBuffer,0,e.arrayBuffer),e.shouldUpdate=!1))})}update(){this.updateBufferBindings();const e=this.bindings.some(s=>s.shouldResetBindGroup),t=this.bindings.some(s=>s.shouldResetBindGroupLayout);(e||t)&&this.renderer.onAfterCommandEncoderSubmission.add(()=>{for(const s of this.bindings)s.shouldResetBindGroup=!1,s.shouldResetBindGroupLayout=!1},{once:!0}),t&&(this.resetBindGroupLayout(),this.needsPipelineFlush=!0),e&&this.resetBindGroup()}clone({bindings:e=[],keepLayout:t=!1}={}){const s={...this.options};s.label+=" (copy)";const i=new this.constructor(this.renderer,{label:s.label});i.setIndex(this.index),i.options=s;const n=e.length?e:this.bindings;for(const a of n)i.addBinding(a),"buffer"in a&&(a.parent&&!a.parent.buffer.GPUBuffer?(this.createBindingBuffer(a.parent,a.parent.options.label),a.parent.buffer.consumers.add(i.uuid)):!a.buffer.GPUBuffer&&!a.parent&&this.createBindingBuffer(a),"resultBuffer"in a&&a.resultBuffer.consumers.add(i.uuid)),t||i.addBindGroupLayoutEntry(a),i.addBindGroupEntry(a);return t&&(i.entries.bindGroupLayout=[...this.entries.bindGroupLayout],i.layoutCacheKey=this.layoutCacheKey),i.setBindGroupLayout(),i.setBindGroup(),i}destroy(){this.renderer.removeBindGroup(this);for(const e of this.bufferBindings)this.destroyBufferBinding(e);this.bindings=[],this.bindGroupLayout=null,this.bindGroup=null,this.resetEntries()}}class _i extends Ms{static{u(this,"TextureBinding")}constructor({label:e="Texture",name:t="texture",bindingType:s,visibility:i,texture:n,format:a="rgba8unorm",access:o="write",viewDimension:h="2d",multisampled:l=!1}){s=s??"texture",s==="storage"&&(i=["compute"]),super({label:e,name:t,bindingType:s,visibility:i}),this.options={...this.options,texture:n,format:a,access:o,viewDimension:h,multisampled:l},this.cacheKey+=`${a},${o},${h},${l},`,this.resource=n,this.setWGSLFragment()}get resourceLayout(){return Lo(this)}get resourceLayoutCacheKey(){return Ao(this)}get resource(){return this.texture instanceof GPUTexture?this.texture.createView({label:this.options.label+" view",dimension:this.options.viewDimension}):this.texture instanceof GPUExternalTexture?this.texture:null}set resource(e){(e||this.texture)&&(this.shouldResetBindGroup=!0),this.texture=e}setBindingType(e){e!==this.bindingType&&(e&&(this.shouldResetBindGroupLayout=!0),this.bindingType=e,this.cacheKey=`${this.bindingType},${this.visibility},${this.options.format},${this.options.access},${this.options.viewDimension},${this.options.multisampled},`,this.setWGSLFragment())}setFormat(e){const t=e!==this.options.format;this.options.format=e,t&&this.bindingType==="storage"&&(this.setWGSLFragment(),this.shouldResetBindGroupLayout=!0,this.cacheKey=`${this.bindingType},${this.visibility},${this.options.format},${this.options.access},${this.options.viewDimension},${this.options.multisampled},`)}setMultisampled(e){const t=e!==this.options.multisampled;this.options.multisampled=e,t&&this.bindingType!=="storage"&&(this.setWGSLFragment(),this.shouldResetBindGroupLayout=!0,this.cacheKey=`${this.bindingType},${this.visibility},${this.options.format},${this.options.access},${this.options.viewDimension},${this.options.multisampled},`)}setWGSLFragment(){this.wgslGroupFragment=[`${_o(this)}`]}}const Io=new Map([["copySrc",$t.COPY_SRC],["copyDst",$t.COPY_DST],["renderAttachment",$t.RENDER_ATTACHMENT],["storageBinding",$t.STORAGE_BINDING],["textureBinding",$t.TEXTURE_BINDING]]),ko=u((r=[])=>r.reduce((e,t)=>e|Io.get(t),0),"getTextureUsages"),Hr=u((r=[],e)=>r.length?ko(r):e!=="storage"?GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT:GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,"getDefaultTextureUsage"),Vo=u((r=[])=>Hr(r,"texture"),"getDefaultMediaTextureUsage"),Xr=u((...r)=>{const e=Math.max(...r);return 1+Math.log2(e)|0},"getNumMipLevels");var Yr=u(r=>{throw TypeError(r)},"__typeError$q"),Kr=u((r,e,t)=>e.has(r)||Yr("Cannot "+t),"__accessCheck$q"),Jr=u((r,e,t)=>(Kr(r,e,"read from private field"),e.get(r)),"__privateGet$o"),No=u((r,e,t)=>e.has(r)?Yr("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$q"),Wo=u((r,e,t,s)=>(Kr(r,e,"write to private field"),e.set(r,t),t),"__privateSet$n"),Ft;const Zr={label:"Texture",name:"renderTexture",type:"texture",access:"write",fromTexture:null,viewDimension:"2d",sampleCount:1,qualityRatio:1,generateMips:!1,flipY:!1,premultipliedAlpha:!1,aspect:"all",colorSpace:"srgb",autoDestroy:!0};class q{static{u(this,"Texture")}constructor(e,t=Zr){No(this,Ft,!0),e=$(e,t.label?t.label+" Texture":"Texture"),this.type="Texture",this.renderer=e,this.uuid=O(),this.options={...Zr,...t},this.options.format==="rgba32float"&&!this.renderer.deviceManager.adapter.features.has("float32-filterable")&&(this.options.format="rgba16float"),t.fromTexture&&(this.options.format=t.fromTexture.texture.format,this.options.sampleCount=t.fromTexture.texture.sampleCount,this.options.viewDimension=t.fromTexture.options.viewDimension),this.options.format||(this.options.format=this.renderer.options.context.format),this.size=this.options.fixedSize?{width:this.options.fixedSize.width*this.options.qualityRatio,height:this.options.fixedSize.height*this.options.qualityRatio,depth:this.options.fixedSize.depth??this.options.viewDimension.indexOf("cube")!==-1?6:1}:{width:Math.floor(this.renderer.canvas.width*this.options.qualityRatio),height:Math.floor(this.renderer.canvas.height*this.options.qualityRatio),depth:this.options.viewDimension.indexOf("cube")!==-1?6:1},this.options.fixedSize&&Wo(this,Ft,!1),this.setBindings(),this.renderer.addTexture(this),this.createTexture()}setRenderer(e){this.renderer&&this.renderer.removeTexture(this),e=$(e,this.options.label+" Texture"),this.renderer=e,this.renderer.addTexture(this),Jr(this,Ft)&&(this.size.width!==this.renderer.canvas.width*this.options.qualityRatio||this.size.height!==this.renderer.canvas.height*this.options.qualityRatio)&&this.resize()}setBindings(){this.bindings=[new _i({label:this.options.label+": "+this.options.name+" texture",name:this.options.name,bindingType:this.options.type,visibility:this.options.visibility,texture:this.texture,format:this.options.format,viewDimension:this.options.viewDimension,multisampled:this.options.sampleCount>1})]}get textureBinding(){return this.bindings[0]}copy(e){this.options.fromTexture=e,this.createTexture()}copyGPUTexture(e){this.size={width:e.width,height:e.height,depth:e.depthOrArrayLayers},this.options.format=e.format,this.options.sampleCount=e.sampleCount,this.texture=e,this.textureBinding.setFormat(this.options.format),this.textureBinding.setMultisampled(this.options.sampleCount>1),this.textureBinding.resource=this.texture}createTexture(){if(!(!this.size.width||!this.size.height)){if(this.options.fromTexture){this.copyGPUTexture(this.options.fromTexture.texture);return}this.texture?.destroy(),this.texture=this.renderer.createTexture({label:this.options.label,format:this.options.format,size:[this.size.width,this.size.height,this.size.depth??1],dimensions:this.options.viewDimension,sampleCount:this.options.sampleCount,mipLevelCount:this.options.generateMips?Xr(this.size.width,this.size.height,this.size.depth??1):1,usage:Hr(this.options.usage,this.options.type)}),this.textureBinding.resource=this.texture}}uploadSource({source:e,width:t=this.size.width,height:s=this.size.height,depth:i=this.size.depth,origin:n=[0,0,0],colorSpace:a="srgb"}){this.renderer.deviceManager.copyExternalImageToTexture({source:e,flipY:this.options.flipY},{texture:this.texture,premultipliedAlpha:this.options.premultipliedAlpha,origin:n,colorSpace:a},[t,s,i]),this.texture.mipLevelCount>1&&this.renderer.generateMips(this)}uploadData({width:e=this.size.width,height:t=this.size.height,depth:s=this.size.depth,origin:i=[0,0,0],data:n=new Float32Array(e*t*4)}){this.renderer.device.queue.writeTexture({texture:this.texture,origin:i},n,{bytesPerRow:e*n.BYTES_PER_ELEMENT*4,rowsPerImage:t},[e,t,s]),this.texture.mipLevelCount>1&&this.renderer.generateMips(this)}resize(e=null){Jr(this,Ft)&&(e||(e={width:Math.floor(this.renderer.canvas.width*this.options.qualityRatio),height:Math.floor(this.renderer.canvas.height*this.options.qualityRatio),depth:1}),!(e.width===this.size.width&&e.height===this.size.height&&e.depth===this.size.depth)&&(this.size=e,this.createTexture()))}destroy(){this.renderer.removeTexture(this),this.options.fromTexture||this.texture?.destroy(),this.texture=null}}Ft=new WeakMap;class de{static{u(this,"Mat3")}constructor(e=new Float32Array([1,0,0,0,1,0,0,0,1])){this.type="Mat3",this.elements=e}set(e,t,s,i,n,a,o,h,l){const d=this.elements;return d[0]=e,d[1]=i,d[2]=o,d[3]=t,d[4]=n,d[5]=h,d[6]=s,d[7]=a,d[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}setFromArray(e=new Float32Array([1,0,0,0,1,0,0,0,1]),t=0){for(let s=0;s<this.elements.length;s++)this.elements[s]=e[s+t];return this}copy(e=new de){const t=e.elements;return this.elements[0]=t[0],this.elements[1]=t[1],this.elements[2]=t[2],this.elements[3]=t[3],this.elements[4]=t[4],this.elements[5]=t[5],this.elements[6]=t[6],this.elements[7]=t[7],this.elements[8]=t[8],this}clone(){return new de().copy(this)}setFromMat4(e=new D){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e=new de){return this.multiplyMatrices(this,e)}premultiply(e=new de){return this.multiplyMatrices(e,this)}multiplyMatrices(e=new de,t=new de){const s=e.elements,i=t.elements,n=this.elements,a=s[0],o=s[3],h=s[6],l=s[1],d=s[4],c=s[7],f=s[2],p=s[5],m=s[8],g=i[0],v=i[3],x=i[6],b=i[1],S=i[4],B=i[7],C=i[2],P=i[5],w=i[8];return n[0]=a*g+o*b+h*C,n[3]=a*v+o*S+h*P,n[6]=a*x+o*B+h*w,n[1]=l*g+d*b+c*C,n[4]=l*v+d*S+c*P,n[7]=l*x+d*B+c*w,n[2]=f*g+p*b+m*C,n[5]=f*v+p*S+m*P,n[8]=f*x+p*B+m*w,this}invert(){const e=this.elements,t=e[0],s=e[1],i=e[2],n=e[3],a=e[4],o=e[5],h=e[6],l=e[7],d=e[8],c=d*a-o*l,f=o*h-d*n,p=l*n-a*h,m=t*c+s*f+i*p;if(m===0)return this.set(0,0,0,0,0,0,0,0,0);const g=1/m;return e[0]=c*g,e[1]=(i*l-d*s)*g,e[2]=(o*s-i*a)*g,e[3]=f*g,e[4]=(d*t-i*h)*g,e[5]=(i*n-o*t)*g,e[6]=p*g,e[7]=(s*h-l*t)*g,e[8]=(a*t-s*n)*g,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e=new D){return this.setFromMat4(e).invert().transpose()}setUVTransform(e=0,t=0,s=1,i=1,n=0,a=0,o=0){const h=Math.cos(n),l=Math.sin(n);return this.set(s*h,s*l,-s*(h*a+l*o)+a+e,-i*l,i*h,-i*(-l*a+h*o)+o+t,0,0,1),this}rotateByAngleX(e=0){const t=Math.cos(e),s=Math.sin(e);return this.set(1,0,0,0,t,s,0,-s,t),this}rotateByAngleY(e=0){const t=Math.cos(e),s=Math.sin(e);return this.set(t,0,s,0,1,0,-s,0,t),this}rotateByAngleZ(e=0){const t=Math.cos(e),s=Math.sin(e);return this.set(t,-s,0,s,t,0,0,0,1),this}premultiplyTranslate(e=new _){const n=e.x,a=e.y,o=this.elements,h=this.elements,l=o[0],d=o[3],c=o[6],f=o[1],p=o[4],m=o[7],g=o[2],v=o[5],x=o[8];return h[0]=1*l+n*g,h[3]=1*d+n*v,h[6]=1*c+n*x,h[1]=1*f+a*g,h[4]=1*p+a*v,h[7]=1*m+a*x,h[2]=1*g,h[5]=1*v,h[8]=1*x,this}premultiplyScale(e=new _){const t=e.x,s=e.y,i=1,n=this.elements,a=this.elements,o=n[0],h=n[3],l=n[6],d=n[1],c=n[4],f=n[7],p=n[2],m=n[5],g=n[8];return a[0]=t*o,a[3]=t*h,a[6]=t*l,a[1]=s*d,a[4]=s*c,a[7]=s*f,a[2]=i*p,a[5]=i*m,a[8]=i*g,this}translate(e=new _){const t=e.x,s=e.y,i=this.elements,n=this.elements,a=i[0],o=i[3],h=i[6],l=i[1],d=i[4],c=i[7],f=i[2],p=i[5],m=i[8];return n[6]=a*t+o*s+h,n[7]=l*t+d*s+c,n[8]=f*t+p*s+m,this}}var Qr=u(r=>{throw TypeError(r)},"__typeError$p"),Li=u((r,e,t)=>e.has(r)||Qr("Cannot "+t),"__accessCheck$p"),Ai=u((r,e,t)=>(Li(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet$n"),Ts=u((r,e,t)=>e.has(r)?Qr("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$p"),Ps=u((r,e,t,s)=>(Li(r,e,"write to private field"),e.set(r,t),t),"__privateSet$m"),Di=u((r,e,t)=>(Li(r,e,"access private method"),t),"__privateMethod$a"),Rs,Es,Ot,Ut,zs;const en={label:"Texture",name:"texture",useExternalTextures:!0,fromTexture:null,viewDimension:"2d",format:"rgba8unorm",generateMips:!1,flipY:!1,premultipliedAlpha:!1,colorSpace:"srgb",autoDestroy:!0,useTransform:!1,placeholderColor:[0,0,0,255],cache:!0},jo=class ws extends q{static{u(this,"_MediaTexture")}constructor(e,t=en){e=$(e,t.label?t.label+" MediaTexture":"MediaTexture");const s={...en,...t},{useTransform:i,placeholderColor:n,useExternalTextures:a,cache:o,...h}=s;super(e,{...h,sampleCount:1,type:"texture",access:"write",qualityRatio:1,aspect:"all",fixedSize:{width:t.fixedSize?.width??1,height:t.fixedSize?.height??1}}),Ts(this,Ut),Ts(this,Rs),Ts(this,Es),Ts(this,Ot),this._onSourceLoadedCallback=l=>{},this._onAllSourcesLoadedCallback=()=>{},this._onSourceUploadedCallback=l=>{},this._onAllSourcesUploadedCallback=()=>{},this.type="MediaTexture",this.options={...this.options,useTransform:i,placeholderColor:n,cache:o,useExternalTextures:!!a,sources:[],sourcesTypes:[]},t.fromTexture&&t.fromTexture instanceof ws&&(this.options.sources=t.fromTexture.options.sources,this.options.sourcesTypes=t.fromTexture.options.sourcesTypes,this.sources=t.fromTexture.sources),Ps(this,Ot,0),this.offset=new _().onChange(()=>this.updateModelMatrix()),this.scale=new _(1).onChange(()=>this.updateModelMatrix()),this.transformOrigin=new _().onChange(()=>this.updateModelMatrix()),this.modelMatrix=new de,this.transformBinding=null,this.options.useTransform&&(this.transformBinding=new Y({label:pt(this.options.name),name:this.options.name,struct:{matrix:{type:"mat3x3f",value:this.modelMatrix}}}),this.updateModelMatrix()),this.externalTexture=null,this.sources=[],this.videoFrameCallbackIds=new Map,this.sourcesLoaded=!1,this.sourcesUploaded=!1,this.renderer.uploadTexture(this)}get sourcesLoaded(){return Ai(this,Rs)}set sourcesLoaded(e){e&&!this.sourcesLoaded&&this._onAllSourcesLoadedCallback&&this._onAllSourcesLoadedCallback(),Ps(this,Rs,e)}get sourcesUploaded(){return Ai(this,Es)}set sourcesUploaded(e){e&&!this.sourcesUploaded&&this._onAllSourcesUploadedCallback&&this._onAllSourcesUploadedCallback(),Ps(this,Es,e)}get rotation(){return Ai(this,Ot)}set rotation(e){Ps(this,Ot,e),this.updateModelMatrix()}updateModelMatrix(){this.options.useTransform?(this.modelMatrix.setUVTransform(this.offset.x,this.offset.y,this.scale.x,this.scale.y,this.rotation,this.transformOrigin.x,this.transformOrigin.y),this.transformBinding.shouldUpdate=!0):A(`Texture: Cannot update ${this.options.name} transformation since its useTransform property has been set to false. You should set it to true when creating the Texture.`)}setBindings(){this.bindings=[new _i({label:this.options.label+": "+this.options.name+" texture",name:this.options.name,bindingType:this.options.type,visibility:this.options.visibility,texture:this.texture,format:this.options.format,viewDimension:this.options.viewDimension,multisampled:!1})]}copy(e){if(this.size.depth!==e.size.depth){A(`${this.options.label}: cannot copy a ${e.options.label} because the depth sizes differ: ${this.size.depth} vs ${e.size.depth}.`);return}if(e instanceof ws){if(this.options.sourcesTypes[0]==="externalVideo"&&e.options.sourcesTypes[0]!=="externalVideo"){A(`${this.options.label}: cannot copy a GPUTexture to a GPUExternalTexture`);return}else if(this.options.sourcesTypes[0]!=="externalVideo"&&e.options.sourcesTypes[0]==="externalVideo"){A(`${this.options.label}: cannot copy a GPUExternalTexture to a GPUTexture`);return}this.options.fixedSize=e.options.fixedSize,this.sources=e.sources,this.options.sources=e.options.sources,this.options.sourcesTypes=e.options.sourcesTypes,this.sourcesLoaded=e.sourcesLoaded,this.sourcesUploaded=e.sourcesUploaded}super.copy(e)}createTexture(){if(!this.size.width||!this.size.height)return;if(this.options.fromTexture&&(!(this.options.fromTexture instanceof ws)||this.options.fromTexture.sourcesUploaded)){this.copyGPUTexture(this.options.fromTexture.texture);return}const e={label:this.options.label,format:this.options.format,size:[this.size.width,this.size.height,this.size.depth??1],dimensions:this.options.viewDimension,sampleCount:this.options.sampleCount,usage:Vo(this.options.usage)};this.sources?.length?this.options.sourcesTypes.includes("externalVideo")||(e.mipLevelCount=this.options.generateMips?Xr(this.size.width,this.size.height,this.size.depth??1):1,this.texture?.destroy(),this.texture=this.renderer.createTexture(e),this.textureBinding.resource=this.texture):(e.mipLevelCount=1,this.texture?.destroy(),this.texture=this.renderer.createTexture(e),this.textureBinding.resource=this.texture)}uploadVideoTexture(){const e=this.sources[0];e&&e.source&&(this.externalTexture=this.renderer.importExternalTexture(e.source,this.options.label),this.textureBinding.resource=this.externalTexture,this.textureBinding.setBindingType("externalTexture"),e.shouldUpdate=!1,this.setSourceUploaded(0))}setSourceSize(){const e=this.sources.filter(Boolean).find(t=>!!t.sourceLoaded);this.options.fixedSize.width=Math.max(1,e.source.naturalWidth||e.source.width||e.source.videoWidth),this.options.fixedSize.height=Math.max(1,e.source.naturalHeight||e.source.height||e.source.videoHeight),this.size.width=this.options.fixedSize.width,this.size.height=this.options.fixedSize.height}async loadImageBitmap(e){if(e.includes(".webp"))return new Promise((t,s)=>{const i=new Image;i.crossOrigin="anonymous",i.onload=()=>{createImageBitmap(i,{colorSpaceConversion:"none"}).then(t).catch(s)},i.onerror=s,i.src=e});{const s=await(await fetch(e)).blob();return await createImageBitmap(s,{colorSpaceConversion:"none"})}}async loadImage(e){const t=typeof e=="string"?e:e.getAttribute("src"),s=this.options.sources.length;if(this.size.depth>1?(this.options.sources.push(t),this.options.sourcesTypes.push("image")):(this.options.sources=[t],this.options.sourcesTypes=["image"]),this.options.cache){const n=this.renderer.textures.filter(a=>a instanceof ws&&a.uuid!==this.uuid).find(a=>{const o=a.options.sources.findIndex(h=>h===t);return o===-1?null:a.sources[o]?.sourceLoaded&&a.texture&&a.size.depth===this.size.depth});if(n){this.copy(n);return}}const i=await this.loadImageBitmap(t);this.useImageBitmap(i,s)}useImageBitmap(e,t=0){this.size.depth>1?this.sources[t]={source:e,sourceLoaded:!0,sourceUploaded:!1,shouldUpdate:!0}:this.sources=[{source:e,sourceLoaded:!0,sourceUploaded:!1,shouldUpdate:!0}],this.setSourceSize(),Di(this,Ut,zs).call(this,e)}async loadImages(e){for(let t=0;t<Math.min(this.size.depth,e.length);t++)this.loadImage(e[t])}onVideoFrameCallback(e=0){this.videoFrameCallbackIds.get(e)&&(this.sources[e].shouldUpdate=!0,this.sources[e].source.requestVideoFrameCallback(this.onVideoFrameCallback.bind(this,e)))}onVideoLoaded(e,t=0){if(!this.sources[t].sourceLoaded){if(this.sources[t].sourceLoaded=!0,this.sources[t].shouldUpdate=!0,this.setSourceSize(),this.options.sourcesTypes[t]==="externalVideo"&&this.texture?.destroy(),"requestVideoFrameCallback"in HTMLVideoElement.prototype){const s=this.sources[t].source.requestVideoFrameCallback(this.onVideoFrameCallback.bind(this,t));this.videoFrameCallbackIds.set(t,s)}Di(this,Ut,zs).call(this,e)}}isVideoSource(e){return e instanceof HTMLVideoElement}isVideoSourceReady(e){return this.isVideoSource(e)?e.readyState>=e.HAVE_CURRENT_DATA:!1}shouldUpdateVideoSource(e){return this.isVideoSource(e)?this.isVideoSourceReady(e)&&!e.paused:!1}loadVideo(e){let t;if(typeof e=="string"?(t=document.createElement("video"),t.src=e):t=e,t.preload="auto",t.muted=!0,t.loop=!0,t.crossOrigin="anonymous",t.setAttribute("playsinline",""),this.size.depth>1){const s=this.options.sources.length;this.options.sources.push(t.src),this.options.sourcesTypes.push("video"),this.sources[s]={source:t,sourceLoaded:!1,sourceUploaded:!1,shouldUpdate:!1}}else this.options.sources=[t.src],this.options.sourcesTypes=[this.options.useExternalTextures?"externalVideo":"video"],this.sources=[{source:t,sourceLoaded:!1,sourceUploaded:!1,shouldUpdate:!1}];t.readyState>=t.HAVE_ENOUGH_DATA?this.onVideoLoaded(t,this.sources.length-1):t.addEventListener("canplaythrough",this.onVideoLoaded.bind(this,t,this.sources.length-1),{once:!0}),isNaN(t.duration)&&t.load()}loadVideos(e){for(let t=0;t<Math.min(this.size.depth,e.length);t++)this.loadVideo(e[t])}loadCanvas(e){if(this.size.depth>1){const t=this.options.sources.length;this.options.sources.push(e),this.options.sourcesTypes.push("canvas"),this.sources[t]={source:e,sourceLoaded:!0,sourceUploaded:!1,shouldUpdate:!0}}else this.options.sources=[e],this.options.sourcesTypes=["canvas"],this.sources=[{source:e,sourceLoaded:!0,sourceUploaded:!1,shouldUpdate:!0}];this.setSourceSize(),Di(this,Ut,zs).call(this,e)}loadCanvases(e){for(let t=0;t<Math.min(this.size.depth,e.length);t++)this.loadCanvas(e[t])}setSourceUploaded(e=0){this.sources[e].sourceUploaded=!0,this._onSourceUploadedCallback&&this._onSourceUploadedCallback(this.sources[e].source),(this.sources.filter(s=>s.sourceUploaded)?.length||0)===this.size.depth&&(this.sourcesUploaded=!0)}onSourceLoaded(e){return e&&(this._onSourceLoadedCallback=e),this}onAllSourcesLoaded(e){return e&&(this._onAllSourcesLoadedCallback=e),this}onSourceUploaded(e){return e&&(this._onSourceUploadedCallback=e),this}onAllSourcesUploaded(e){return e&&(this._onAllSourcesUploadedCallback=e),this}update(){this.sources?.forEach((e,t)=>{const s=this.options.sourcesTypes[t];s==="externalVideo"&&this.isVideoSourceReady(e.source)&&(e.shouldUpdate=!0),this.isVideoSource(e.source)&&!this.videoFrameCallbackIds.size&&this.shouldUpdateVideoSource(e.source)&&(e.shouldUpdate=!0),e.shouldUpdate&&s!=="externalVideo"&&((this.size.width!==this.texture.width||this.size.height!==this.texture.height||this.options.generateMips&&this.texture&&this.texture.mipLevelCount<=1)&&this.createTexture(),this.renderer.uploadTexture(this,t),e.shouldUpdate=!1)})}destroy(){if(this.videoFrameCallbackIds.size)for(const[e,t]of this.videoFrameCallbackIds)this.sources[e].source.cancelVideoFrameCallback(t);this.sources.forEach(e=>{this.isVideoSource(e.source)&&e.source.removeEventListener("canplaythrough",this.onVideoLoaded.bind(this,e.source),{once:!0})}),super.destroy()}};Rs=new WeakMap,Es=new WeakMap,Ot=new WeakMap,Ut=new WeakSet,zs=u(function(r){this._onSourceLoadedCallback&&this._onSourceLoadedCallback(r),(this.sources.filter(t=>t.sourceLoaded)?.length||0)===this.size.depth&&(this.sourcesLoaded=!0)},"setSourceLoaded_fn");let ce=jo;var tn=u(r=>{throw TypeError(r)},"__typeError$o"),qo=u((r,e,t)=>e.has(r)||tn("Cannot "+t),"__accessCheck$o"),ie=u((r,e,t)=>(qo(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet$m"),It=u((r,e,t)=>e.has(r)?tn("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$o"),Ze,Qe,_s,Ls,As;const Ho={name:"texture",generateMips:!1,flipY:!1,format:"rgba8unorm",premultipliedAlpha:!1,placeholderColor:[0,0,0,255],useExternalTextures:!0,fromTexture:null,visibility:["fragment"],cache:!0};class $i extends ce{static{u(this,"DOMTexture")}constructor(e,t=Ho){e=ft(e,"DOMTexture"),super(e,{...t,useTransform:!0,viewDimension:"2d"}),this._mesh=null,It(this,Ze,new _(1)),It(this,Qe,new _(1)),It(this,_s,new _(1)),It(this,Ls,new _),It(this,As,new de),this.transformOrigin.set(.5,.5),this.type="DOMTexture",this.renderer.addDOMTexture(this)}get mesh(){return this._mesh}set mesh(e){this._mesh=e,this.resize()}updateModelMatrix(){if(!this.mesh){super.updateModelMatrix();return}const e=this.mesh.scale,t=this.mesh.boundingRect.width*e.x,s=this.mesh.boundingRect.height*e.y,i=t/s,n=this.size.width/this.size.height;t>s?(ie(this,Ze).set(i,1),ie(this,Qe).set(1/n,1)):(ie(this,Ze).set(1,1/i),ie(this,Qe).set(1,n));const a=i>n!=t>s?1:t>s?ie(this,Ze).x*ie(this,Qe).x:ie(this,Qe).y*ie(this,Ze).y;ie(this,_s).set(1/(a*this.scale.x),1/(a*this.scale.y)),ie(this,Ls).copy(this.transformOrigin).multiplyScalar(-1),ie(this,As).rotateByAngleZ(this.rotation),this.modelMatrix.identity().premultiplyTranslate(ie(this,Ls)).premultiplyScale(ie(this,_s)).premultiplyScale(ie(this,Ze)).premultiply(ie(this,As)).premultiplyScale(ie(this,Qe)).premultiplyTranslate(this.transformOrigin).translate(this.offset),this.transformBinding.inputs.matrix.shouldUpdate=!0}setSourceSize(){super.setSourceSize(),this.updateModelMatrix()}resize(){this.source&&this.source instanceof HTMLCanvasElement&&(this.source.width!==this.size.width||this.source.height!==this.size.height)?(this.setSourceSize(),this.sources[0].shouldUpdate=!0):super.resize(),this.updateModelMatrix()}get source(){return this.sources.length?this.sources[0].source:null}copy(e){super.copy(e),this.updateModelMatrix()}destroy(){this.renderer.removeDOMTexture(this),super.destroy()}}Ze=new WeakMap,Qe=new WeakMap,_s=new WeakMap,Ls=new WeakMap,As=new WeakMap;var sn=u(r=>{throw TypeError(r)},"__typeError$n"),rn=u((r,e,t)=>e.has(r)||sn("Cannot "+t),"__accessCheck$n"),nn=u((r,e,t)=>(rn(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet$l"),Xo=u((r,e,t)=>e.has(r)?sn("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$n"),Yo=u((r,e,t,s)=>(rn(r,e,"write to private field"),e.set(r,t),t),"__privateSet$l"),kt;class Gi extends Gt{static{u(this,"TextureBindGroup")}constructor(e,{label:t,index:s=0,bindings:i=[],uniforms:n,storages:a,textures:o=[],samplers:h=[]}={}){const l="TextureBindGroup";if(e=$(e,l),super(e,{label:t,index:s,bindings:i,uniforms:n,storages:a}),Xo(this,kt),this.options={...this.options,textures:[],samplers:[]},o.length)for(const d of o)this.addTexture(d);if(h.length)for(const d of h)this.addSampler(d);this.type=l,this.texturesMatricesBinding=null}setRenderer(e){const t=new Set;this.renderer&&"shadowCastingLights"in this.renderer&&this.renderer.shadowCastingLights.forEach(s=>{s.shadow.isActive&&s.shadow.depthTexture&&t.add(s.shadow.depthTexture.uuid)}),super.setRenderer(e),this.options&&this.samplers&&this.samplers.forEach(s=>{s.setRenderer(this.renderer)}),this.options&&this.textures&&this.textures.forEach(s=>{t.has(s.uuid)||s.setRenderer(this.renderer)})}addTexture(e){this.textures.push(e),this.addBindings([...e.bindings])}get textures(){return this.options.textures}addSampler(e){this.samplers.push(e),this.addBindings([e.binding])}get samplers(){return this.options.samplers}get shouldCreateBindGroup(){return!this.bindGroup&&!!this.bindings.length&&!this.textures.find(e=>!(e.texture||e.externalTexture))&&!this.samplers.find(e=>!e.sampler)}setTexturesMatricesBinding(){Yo(this,kt,this.textures.filter(t=>(t instanceof ce||t instanceof $i)&&!!t.transformBinding));const e=nn(this,kt).map(t=>t.transformBinding);if(e.length){const t="Textures matrices",s="texturesMatrices";this.texturesMatricesBinding=new Y({label:t,name:s,childrenBindings:e.map(n=>({binding:n,count:1,forceArray:!1}))}),this.texturesMatricesBinding.childrenBindings.forEach((n,a)=>{n.inputs.matrix.value=e[a].inputs.matrix.value,e[a].inputs.matrix.shouldUpdate=!0}),this.texturesMatricesBinding.buffer.consumers.add(this.uuid),this.bindings.find(n=>n.name===s)||this.addBinding(this.texturesMatricesBinding)}}createBindGroup(){this.setTexturesMatricesBinding(),super.createBindGroup()}updateTextures(){for(const e of this.textures)if(e instanceof ce){e.options.fromTexture&&e.options.fromTexture instanceof ce&&e.options.fromTexture.sourcesUploaded&&!e.sourcesUploaded&&e.copy(e.options.fromTexture);const t=e.sources.length&&e.sources[0];t&&t.shouldUpdate&&e.options.sourcesTypes[0]&&e.options.sourcesTypes[0]==="externalVideo"&&e.uploadVideoTexture()}this.texturesMatricesBinding&&nn(this,kt).forEach((e,t)=>{this.texturesMatricesBinding.childrenBindings[t].inputs.matrix.shouldUpdate=!!e.transformBinding.inputs.matrix.shouldUpdate,e.transformBinding.inputs.matrix.shouldUpdate&&this.renderer.onAfterCommandEncoderSubmission.add(()=>{e.transformBinding.inputs.matrix.shouldUpdate=!1},{once:!0})})}update(){this.updateTextures(),super.update()}destroy(){super.destroy(),this.options.textures=[],this.options.samplers=[]}}kt=new WeakMap;class an extends Ms{static{u(this,"SamplerBinding")}constructor({label:e="Sampler",name:t="sampler",bindingType:s,visibility:i,sampler:n,type:a="filtering"}){s=s??"sampler",super({label:e,name:t,bindingType:s,visibility:i}),this.cacheKey+=`${a},`,this.options={...this.options,sampler:n,type:a},this.resource=n,this.setWGSLFragment()}get resourceLayout(){return{sampler:{type:this.options.type}}}get resourceLayoutCacheKey(){return`sampler,${this.options.type},${this.visibility},`}get resource(){return this.sampler}set resource(e){e&&this.sampler&&(this.shouldResetBindGroup=!0),this.sampler=e}setWGSLFragment(){this.wgslGroupFragment=[`var ${this.name}: ${this.options.type==="comparison"?`${this.bindingType}_comparison`:this.bindingType};`]}}var on=u(r=>{throw TypeError(r)},"__typeError$m"),hn=u((r,e,t)=>e.has(r)||on("Cannot "+t),"__accessCheck$m"),Ds=u((r,e,t)=>(hn(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet$k"),$s=u((r,e,t)=>e.has(r)?on("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$m"),Gs=u((r,e,t,s)=>(hn(r,e,"write to private field"),e.set(r,t),t),"__privateSet$k"),Fs,Os,Us,Is;class ks extends Me{static{u(this,"Camera")}constructor({fov:e=50,near:t=.1,far:s=150,width:i=1,height:n=1,pixelRatio:a=1,onMatricesChanged:o=u(()=>{},"onMatricesChanged")}={}){super(),$s(this,Fs),$s(this,Os),$s(this,Us),$s(this,Is),this.uuid=O(),this.position.set(0,0,10),this.up=new y(0,1,0),this.onMatricesChanged=o,this.size={width:1,height:1},this.setPerspective({fov:e,near:t,far:s,width:i,height:n,pixelRatio:a})}setMatrices(){super.setMatrices(),this.matrices={...this.matrices,view:{matrix:new D,shouldUpdate:!0,onUpdate:u(()=>{this.viewMatrix.copy(this.worldMatrix).invert()},"onUpdate")},projection:{matrix:new D,shouldUpdate:!0,onUpdate:u(()=>this.updateProjectionMatrix(),"onUpdate")},viewProjection:{matrix:new D,shouldUpdate:!0,onUpdate:u(()=>this.viewProjectionMatrix.multiplyMatrices(this.projectionMatrix,this.viewMatrix),"onUpdate")}}}get viewMatrix(){return this.matrices.view.matrix}set viewMatrix(e){this.matrices.view.matrix=e,this.shouldUpdateViewMatrices()}get projectionMatrix(){return this.matrices.projection.matrix}set projectionMatrix(e){this.matrices.projection.matrix=e,this.shouldUpdateProjectionMatrices()}get viewProjectionMatrix(){return this.matrices.viewProjection.matrix}shouldUpdateViewMatrices(){this.matrices.view.shouldUpdate=!0,this.matrices.viewProjection.shouldUpdate=!0}shouldUpdateProjectionMatrices(){this.matrices.projection.shouldUpdate=!0,this.matrices.viewProjection.shouldUpdate=!0}updateModelMatrix(){super.updateModelMatrix(),this.setVisibleSize(),this.shouldUpdateViewMatrices()}updateWorldMatrix(){super.updateWorldMatrix(),this.shouldUpdateViewMatrices()}updateMatrixStack(){super.updateMatrixStack(),this.matricesNeedUpdate&&this.onMatricesChanged()}get fov(){return Ds(this,Fs)}set fov(e){e=Math.max(1,Math.min(e??this.fov,179)),e!==this.fov&&(Gs(this,Fs,e),this.shouldUpdateProjectionMatrices()),this.setVisibleSize(),this.setCSSPerspective()}get near(){return Ds(this,Os)}set near(e){e=Math.max(e??this.near,1e-4),e!==this.near&&(Gs(this,Os,e),this.shouldUpdateProjectionMatrices())}get far(){return Ds(this,Us)}set far(e){e=Math.max(e??this.far,this.near+1),e!==this.far&&(Gs(this,Us,e),this.shouldUpdateProjectionMatrices())}get pixelRatio(){return Ds(this,Is)}set pixelRatio(e){Gs(this,Is,e??this.pixelRatio),this.setCSSPerspective()}setSize({width:e,height:t}){(e!==this.size.width||t!==this.size.height)&&this.shouldUpdateProjectionMatrices(),this.size.width=e,this.size.height=t,this.setVisibleSize(),this.setCSSPerspective()}setPerspective({fov:e=this.fov,near:t=this.near,far:s=this.far,width:i=this.size.width,height:n=this.size.height,pixelRatio:a=this.pixelRatio}={}){this.setSize({width:i,height:n}),this.pixelRatio=a,this.fov=e,this.near=t,this.far=s}setCSSPerspective(){this.CSSPerspective=Math.pow(Math.pow(this.size.width/(2*this.pixelRatio),2)+Math.pow(this.size.height/(2*this.pixelRatio),2),.5)/Math.tan(this.fov*.5*Math.PI/180)}getVisibleSizeAtDepth(e=0){const t=this.position.z;e<t?e-=t:e+=t;const s=this.fov*Math.PI/180,i=2*Math.tan(s/2)*Math.abs(e);return{width:i*this.size.width/this.size.height,height:i}}setVisibleSize(){this.visibleSize=this.getVisibleSizeAtDepth()}lookAt(e=new y,t=this.position){super.lookAt(t,e,this.up)}updateProjectionMatrix(){this.projectionMatrix.makePerspective({fov:this.fov,aspect:this.size.width/this.size.height,near:this.near,far:this.far})}get frustumPlanes(){const e=new D,t=new y;e.copy(this.projectionMatrix).multiply(this.viewMatrix);const{elements:s}=e,i=[new Float32Array(4),new Float32Array(4),new Float32Array(4),new Float32Array(4),new Float32Array(4),new Float32Array(4)];t.set(s[3]+s[0],s[7]+s[4],s[11]+s[8]);let n=t.length();return i[0][0]=t.x/n,i[0][1]=t.y/n,i[0][2]=t.z/n,i[0][3]=(s[15]+s[12])/n,t.set(s[3]-s[0],s[7]-s[4],s[11]-s[8]),n=t.length(),i[1][0]=t.x/n,i[1][1]=t.y/n,i[1][2]=t.z/n,i[1][3]=(s[15]-s[12])/n,t.set(s[3]-s[1],s[7]-s[5],s[11]-s[9]),n=t.length(),i[2][0]=t.x/n,i[2][1]=t.y/n,i[2][2]=t.z/n,i[2][3]=(s[15]-s[13])/n,t.set(s[3]+s[1],s[7]+s[5],s[11]+s[9]),n=t.length(),i[3][0]=t.x/n,i[3][1]=t.y/n,i[3][2]=t.z/n,i[3][3]=(s[15]+s[13])/n,t.set(s[2],s[6],s[10]),n=t.length(),i[4][0]=t.x/n,i[4][1]=t.y/n,i[4][2]=t.z/n,i[4][3]=s[14]/n,t.set(s[3]-s[2],s[7]-s[6],s[11]-s[10]),n=t.length(),i[5][0]=t.x/n,i[5][1]=t.y/n,i[5][2]=t.z/n,i[5][3]=(s[15]-s[14])/n,i}}Fs=new WeakMap,Os=new WeakMap,Us=new WeakMap,Is=new WeakMap;class et{static{u(this,"Sampler")}constructor(e,{label:t="Sampler",name:s,addressModeU:i="repeat",addressModeV:n="repeat",magFilter:a="linear",minFilter:o="linear",mipmapFilter:h="linear",maxAnisotropy:l=1,type:d="filtering",compare:c=null}={}){this.type="Sampler",this.uuid=O(),this.label=t,this.setRenderer(e),!s&&!this.renderer.production&&(s="sampler"+this.renderer.samplers.length,A(`Sampler: you are trying to create a sampler without the mandatory name parameter. A default name will be used instead: ${s}`)),this.name=s,this.options={addressModeU:i,addressModeV:n,magFilter:a,minFilter:o,mipmapFilter:h,maxAnisotropy:l,type:d,...c!==null&&{compare:c}},this.createSampler(),this.createBinding()}setRenderer(e){e=$(e,this.label+" "+this.type),this.renderer=e}createSampler(){this.sampler=this.renderer.createSampler(this)}createBinding(){this.binding=new an({label:this.label,name:this.name,bindingType:"sampler",sampler:this.sampler,type:this.options.type})}}class Fi{static{u(this,"Material")}constructor(e,t){this.type="Material",e=$(e,this.type),this.renderer=e,this.uuid=O();const{shaders:s,label:i,useAsyncPipeline:n,uniforms:a,storages:o,bindings:h,bindGroups:l,samplers:d,textures:c}=t;this.options={shaders:s,label:i||this.constructor.name,useAsyncPipeline:n===void 0?!0:n,...a!==void 0&&{uniforms:a},...o!==void 0&&{storages:o},...h!==void 0&&{bindings:h},...l!==void 0&&{bindGroups:l},...d!==void 0&&{samplers:d},...c!==void 0&&{textures:c}},this.bindGroups=[],this.texturesBindGroups=[],this.clonedBindGroups=[],this.setBindGroups(),this.setTextures(),this.setSamplers()}setRenderer(e){e=$(e,this.type),this.renderer=e,this.bindGroups.forEach(t=>{t.setRenderer(this.renderer)}),this.pipelineEntry&&this.pipelineEntry.setRenderer(this.renderer)}compileMaterial(){const e=this.texturesBindGroup.bindings.length?1:0;this.bindGroups.length>=this.inputsBindGroups.length+e||this.createBindGroups()}get ready(){return!!(this.renderer.ready&&this.pipelineEntry&&this.pipelineEntry.pipeline&&this.pipelineEntry.ready)}get cacheKey(){let e="";return this.bindGroups.forEach(t=>{t.bindings.forEach(s=>{e+=s.name+","}),e+=t.pipelineCacheKey}),e}loseContext(){for(const e of this.textures)e.texture=null,e instanceof ce&&(e.sources.forEach(t=>t.sourceUploaded=!1),e.sourcesUploaded=!1);[...this.bindGroups,...this.clonedBindGroups,...this.inputsBindGroups].forEach(e=>e.loseContext()),this.pipelineEntry.pipeline=null}restoreContext(){for(const e of this.samplers)e.createSampler(),e.binding.resource=e.sampler;for(const e of this.textures)e instanceof ce&&e.sources.forEach(t=>{t.sourceLoaded&&(t.shouldUpdate=!0)}),e.resize(e.size);[...this.bindGroups,...this.clonedBindGroups,...this.inputsBindGroups].forEach(e=>{e.restoreContext()})}getShaderCode(e="full"){return this.pipelineEntry?(e=(()=>{switch(e){case"vertex":case"fragment":case"compute":case"full":return e;default:return"full"}})(),this.pipelineEntry.shaders[e].code):""}getAddedShaderCode(e="vertex"){return this.pipelineEntry?(e=(()=>{switch(e){case"vertex":case"fragment":case"compute":return e;default:return"vertex"}})(),this.pipelineEntry.shaders[e].head):""}setBindGroups(){if(this.uniforms={},this.storages={},this.inputsBindGroups=[],this.inputsBindings=new Map,this.options.uniforms||this.options.storages||this.options.bindings){const e=new Gt(this.renderer,{label:this.options.label+": Bindings bind group",uniforms:this.options.uniforms,storages:this.options.storages,bindings:this.options.bindings});this.processBindGroupBindings(e),this.inputsBindGroups.push(e),e.consumers.add(this.uuid)}this.options.bindGroups?.forEach(e=>{this.processBindGroupBindings(e),this.inputsBindGroups.push(e),e.consumers.add(this.uuid)})}get texturesBindGroup(){return this.texturesBindGroups[0]}processBindGroupBindings(e){for(const t of e.bindings)t.bindingType==="uniform"&&(this.uniforms={...this.uniforms,[t.name]:t.inputs}),t.bindingType==="storage"&&(this.storages={...this.storages,[t.name]:t.inputs}),this.inputsBindings.set(t.name,t)}createBindGroups(){this.texturesBindGroup.shouldCreateBindGroup&&(this.texturesBindGroup.setIndex(this.bindGroups.length),this.texturesBindGroup.createBindGroup(),this.bindGroups.push(this.texturesBindGroup));for(const e of this.inputsBindGroups)e.shouldCreateBindGroup&&(e.setIndex(this.bindGroups.length),e.createBindGroup(),this.bindGroups.push(e));this.options.bindGroups?.forEach(e=>{if(!e.shouldCreateBindGroup&&!this.bindGroups.find(t=>t.uuid===e.uuid)&&(e.setIndex(this.bindGroups.length),this.bindGroups.push(e)),e instanceof Gi&&!this.texturesBindGroups.find(t=>t.uuid===e.uuid)){this.texturesBindGroups.push(e);for(const t of e.textures)this.textures.find(s=>s.uuid!==t.uuid)||this.textures.push(t)}})}cloneBindGroup({bindGroup:e,bindings:t=[],keepLayout:s=!0}){if(!e)return null;const i=e.clone({bindings:t,keepLayout:s});return this.clonedBindGroups.push(i),i}getBindGroupByBindingName(e=""){return(this.ready?this.bindGroups:this.inputsBindGroups).find(t=>t.bindings.find(s=>s.name===e))}destroyBindGroup(e){e.consumers.delete(this.uuid),e.consumers.size||e.destroy()}destroyBindGroups(){this.bindGroups.forEach(e=>this.destroyBindGroup(e)),this.clonedBindGroups.forEach(e=>this.destroyBindGroup(e)),this.texturesBindGroups.forEach(e=>this.destroyBindGroup(e)),this.texturesBindGroups=[],this.inputsBindGroups=[],this.bindGroups=[],this.clonedBindGroups=[]}updateBindGroups(){for(const e of this.bindGroups)this.updateBindGroup(e)}updateBindGroup(e){e.update(),e.needsPipelineFlush&&this.pipelineEntry.ready&&(this.pipelineEntry.flushPipelineEntry(this.bindGroups),e.needsPipelineFlush=!1)}getBindingByName(e=""){return this.inputsBindings.get(e)}getBufferBindingByName(e=""){const t=this.getBindingByName(e);return t&&"buffer"in t?t:void 0}shouldUpdateInputsBindings(e,t){if(!e)return;const s=this.getBindingByName(e);s&&(t?s.shouldUpdateBinding(t):Object.keys(s.inputs).forEach(i=>s.shouldUpdateBinding(i)))}setTextures(){this.textures=[],this.texturesBindGroups.push(new Gi(this.renderer,{label:this.options.label+": Textures bind group"})),this.texturesBindGroup.consumers.add(this.uuid),this.options.textures?.forEach(e=>{this.addTexture(e)})}addTexture(e){this.textures.push(e),(this.options.shaders.vertex&&this.options.shaders.vertex.code.indexOf(e.options.name)!==-1||this.options.shaders.fragment&&this.options.shaders.fragment.code.indexOf(e.options.name)!==-1||this.options.shaders.compute&&this.options.shaders.compute.code.indexOf(e.options.name)!==-1)&&this.texturesBindGroup.addTexture(e)}destroyTexture(e){if(e.options.cache||!e.options.autoDestroy)return;const t=this.renderer.getObjectsByTexture(e);(!t||!t.some(i=>i.material.uuid!==this.uuid))&&e.destroy()}destroyTextures(){this.textures?.forEach(e=>this.destroyTexture(e)),this.textures=[]}setSamplers(){if(this.samplers=[],this.options.samplers?.forEach(t=>{this.addSampler(t)}),!this.samplers.find(t=>t.name==="defaultSampler")){const t=new et(this.renderer,{label:"Default sampler",name:"defaultSampler"});this.addSampler(t)}}addSampler(e){this.samplers.push(e),(this.options.shaders.vertex&&this.options.shaders.vertex.code.indexOf(e.name)!==-1||this.options.shaders.fragment&&this.options.shaders.fragment.code.indexOf(e.name)!==-1||this.options.shaders.compute&&this.options.shaders.compute.code.indexOf(e.name)!==-1)&&this.texturesBindGroup.addSampler(e)}async getBufferResult(e){return await e.mapBufferAsync()}async getBufferBindingResultByBindingName(e=""){const t=this.getBufferBindingByName(e);if(t&&"buffer"in t){const s=this.renderer.copyBufferToBuffer({srcBuffer:t.buffer});return await this.getBufferResult(s)}else return new Float32Array(0)}async getBufferElementResultByNames({bindingName:e,bufferElementName:t}){const s=await this.getBufferBindingResultByBindingName(e);if(!t||s.length)return s;{const i=this.getBufferBindingByName(e);return i?i.extractBufferElementDataFromBufferResult({result:s,bufferElementName:t}):s}}onBeforeRender(){this.compileMaterial(),this.updateBindGroups()}setPipeline(e){this.renderer.pipelineManager.setCurrentPipeline(e,this.pipelineEntry)}setActiveBindGroups(e){this.renderer.pipelineManager.setActiveBindGroups(e,this.bindGroups)}render(e){this.ready&&(this.setPipeline(e),this.setActiveBindGroups(e))}destroy(){this.destroyBindGroups(),this.destroyTextures()}}class ln extends Fi{static{u(this,"ComputeMaterial")}constructor(e,t){const s="ComputeMaterial";e=$(e,s),super(e,t),this.type=s,this.renderer=e;let{shaders:i,dispatchSize:n}=t;(!i||!i.compute)&&(i={compute:{code:"",entryPoint:"main"}}),i.compute.code||(i.compute.code="@compute @workgroup_size(1) fn main(){}"),i.compute.entryPoint||(i.compute.entryPoint="main"),this.options={...this.options,shaders:i,...t.dispatchSize!==void 0&&{dispatchSize:t.dispatchSize}},n||(n=1),Array.isArray(n)?(n[0]=Math.ceil(n[0]??1),n[1]=Math.ceil(n[1]??1),n[2]=Math.ceil(n[2]??1)):isNaN(n)||(n=[Math.ceil(n),1,1]),this.dispatchSize=n}setPipelineEntry(){this.pipelineEntry=this.renderer.pipelineManager.createComputePipeline(this)}async compilePipelineEntry(){await this.pipelineEntry.compilePipelineEntry()}async compileMaterial(){this.ready||(super.compileMaterial(),this.pipelineEntry||this.setPipelineEntry(),this.pipelineEntry&&this.pipelineEntry.canCompile&&await this.compilePipelineEntry())}getShaderCode(e="compute"){return super.getShaderCode(e)}getAddedShaderCode(e="compute"){return super.getAddedShaderCode(e)}useCustomRender(e){e&&(this._useCustomRenderCallback=e)}render(e){if(this.ready)if(this.setPipeline(e),this._useCustomRenderCallback!==void 0)this._useCustomRenderCallback(e);else{for(const t of this.bindGroups)e.setBindGroup(t.index,t.bindGroup);e.dispatchWorkgroups(this.dispatchSize[0],this.dispatchSize[1],this.dispatchSize[2])}}copyBufferToResult(e){for(const t of this.bindGroups)t.bufferBindings.forEach(s=>{s.shouldCopyResult&&this.renderer.copyBufferToBuffer({srcBuffer:s.buffer,dstBuffer:s.resultBuffer,commandEncoder:e})})}async getComputeResult({bindingName:e="",bufferElementName:t=""}){const s=this.getBufferBindingByName(e);if(s&&"resultBuffer"in s){const i=await this.getBufferResult(s.resultBuffer);return t&&i.length?s.extractBufferElementDataFromBufferResult({result:i,bufferElementName:t}):i}else return new Float32Array(0)}}var un=u(r=>{throw TypeError(r)},"__typeError$l"),dn=u((r,e,t)=>e.has(r)||un("Cannot "+t),"__accessCheck$l"),cn=u((r,e,t)=>(dn(r,e,"read from private field"),e.get(r)),"__privateGet$j"),Ko=u((r,e,t)=>e.has(r)?un("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$l"),Jo=u((r,e,t,s)=>(dn(r,e,"write to private field"),e.set(r,t),t),"__privateSet$j"),Vt;let Zo=0;class Vs{static{u(this,"ComputePass")}constructor(e,t={}){Ko(this,Vt,!0),this._onReadyCallback=()=>{},this._onBeforeRenderCallback=()=>{},this._onRenderCallback=()=>{},this._onAfterRenderCallback=()=>{},this._onAfterResizeCallback=()=>{};const s="ComputePass";e=$(e,t.label?`${t.label} ${s}`:s),t.label=t.label??"ComputePass "+e.computePasses?.length,this.renderer=e,this.type=s,this.uuid=O(),Object.defineProperty(this,"index",{value:Zo++});const{label:i,shaders:n,renderOrder:a,uniforms:o,storages:h,bindings:l,bindGroups:d,samplers:c,textures:f,autoRender:p,useAsyncPipeline:m,texturesOptions:g,dispatchSize:v}=t;this.options={label:i,shaders:n,...p!==void 0&&{autoRender:p},...a!==void 0&&{renderOrder:a},...v!==void 0&&{dispatchSize:v},useAsyncPipeline:m===void 0?!0:m,texturesOptions:g},this.renderOrder=a??0,p!==void 0&&Jo(this,Vt,p),this.userData={},this.ready=!1,this.setMaterial({label:this.options.label,shaders:this.options.shaders,uniforms:o,storages:h,bindings:l,bindGroups:d,samplers:c,textures:f,useAsyncPipeline:m,dispatchSize:v}),this.addToScene(!0)}get ready(){return this._ready}set ready(e){e&&this._onReadyCallback&&this._onReadyCallback(),this._ready=e}addToScene(e=!1){e&&this.renderer.computePasses.push(this),cn(this,Vt)&&this.renderer.scene.addComputePass(this)}removeFromScene(e=!1){cn(this,Vt)&&this.renderer.scene.removeComputePass(this),e&&(this.renderer.computePasses=this.renderer.computePasses.filter(t=>t.uuid!==this.uuid))}setRenderer(e){e=$(e,this.options.label+" ComputePass"),this.material?.setRenderer(e),this.removeFromScene(!0),this.renderer=e,this.addToScene(!0)}setMaterial(e){this.useMaterial(new ln(this.renderer,e))}useMaterial(e){this.material=e}loseContext(){this.material.loseContext()}restoreContext(){this.material.restoreContext()}get textures(){return this.material?.textures||[]}createMediaTexture(e){e.name||(e.name="texture"+this.textures.length),e.label||(e.label=this.options.label+" "+e.name);const t=new ce(this.renderer,{...e,...this.options.texturesOptions});return this.addTexture(t),t}createTexture(e){e.name||(e.name="texture"+this.textures.length);const t=new q(this.renderer,e);return this.addTexture(t),t}addTexture(e){this.material.addTexture(e)}get uniforms(){return this.material?.uniforms}get storages(){return this.material?.storages}resize(){this._onAfterResizeCallback&&this._onAfterResizeCallback()}onReady(e){return e&&(this._onReadyCallback=e),this}onBeforeRender(e){return e&&(this._onBeforeRenderCallback=e),this}onRender(e){return e&&(this._onRenderCallback=e),this}onAfterRender(e){return e&&(this._onAfterRenderCallback=e),this}useCustomRender(e){return this.material.useCustomRender(e),this}onAfterResize(e){return e&&(this._onAfterResizeCallback=e),this}onBeforeRenderPass(){this.renderer.ready&&(this._onBeforeRenderCallback&&this._onBeforeRenderCallback(),this.material.onBeforeRender(),this.material&&this.material.ready&&!this.ready&&(this.ready=!0))}onRenderPass(e){this.material.ready&&(this._onRenderCallback&&this._onRenderCallback(),this.material.render(e))}onAfterRenderPass(){this._onAfterRenderCallback&&this._onAfterRenderCallback()}render(e){this.onBeforeRenderPass(),this.renderer.ready&&(!this.renderer.production&&e.pushDebugGroup(this.options.label),this.onRenderPass(e),!this.renderer.production&&e.popDebugGroup(),this.onAfterRenderPass())}copyBufferToResult(e){this.material?.copyBufferToResult(e)}async getComputeResult({bindingName:e,bufferElementName:t}){return await this.material?.getComputeResult({bindingName:e,bufferElementName:t})}remove(){this.removeFromScene(!0),this.destroy()}destroy(){this.material?.destroy()}}Vt=new WeakMap;const ve=[new y,new y,new y,new y,new y,new y,new y,new y];class Ee{static{u(this,"Box3")}constructor(e=new y(1/0),t=new y(-1/0)){this.min=e,this.max=t}set(e=new y(1/0),t=new y(-1/0)){return this.min.copy(e),this.max.copy(t),this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}copy(e){return this.set(e.min.clone(),e.max.clone()),this}clone(){return new Ee().copy(this)}get center(){return this.max.clone().add(this.min).multiplyScalar(.5)}get size(){return this.max.clone().sub(this.min)}get radius(){return this.max.distance(this.min)*.5}applyMat4(e=new D,t=new Ee){if(this.isEmpty())return this;const s=[];this.min.z===this.max.z?(s[0]=ve[0].set(this.min.x,this.min.y,this.min.z).applyMat4(e),s[1]=ve[2].set(this.min.x,this.max.y,this.min.z).applyMat4(e),s[2]=ve[4].set(this.max.x,this.min.y,this.min.z).applyMat4(e),s[3]=ve[6].set(this.max.x,this.max.y,this.min.z).applyMat4(e)):(s[0]=ve[0].set(this.min.x,this.min.y,this.min.z).applyMat4(e),s[1]=ve[1].set(this.min.x,this.min.y,this.max.z).applyMat4(e),s[2]=ve[2].set(this.min.x,this.max.y,this.min.z).applyMat4(e),s[3]=ve[3].set(this.min.x,this.max.y,this.max.z).applyMat4(e),s[4]=ve[4].set(this.max.x,this.min.y,this.min.z).applyMat4(e),s[5]=ve[5].set(this.max.x,this.min.y,this.max.z).applyMat4(e),s[6]=ve[6].set(this.max.x,this.max.y,this.min.z).applyMat4(e),s[7]=ve[7].set(this.max.x,this.max.y,this.max.z).applyMat4(e));for(let i=0,n=s.length;i<n;i++)t.min.min(s[i]),t.max.max(s[i]);return t}}const pn={top:0,right:0,bottom:0,left:0};class fn{static{u(this,"DOMFrustum")}constructor({boundingBox:e=new Ee,modelViewProjectionMatrix:t=new D,containerBoundingRect:s={top:0,right:0,bottom:0,left:0,width:0,height:0,x:0,y:0},DOMFrustumMargins:i=pn,onReEnterView:n=u(()=>{},"onReEnterView"),onLeaveView:a=u(()=>{},"onLeaveView")}){this.boundingBox=e,this.clipSpaceOBB=new Ee,this.modelViewProjectionMatrix=t,this.containerBoundingRect=s,this.DOMFrustumMargins={...pn,...i},this.clipSpaceBoundingRect={top:0,left:0,width:0,height:0},this.projectedBoundingRect={top:0,right:0,bottom:0,left:0,width:0,height:0,x:0,y:0},this.onReEnterView=n,this.onLeaveView=a,this.isIntersecting=!1}setContainerBoundingRect(e){this.containerBoundingRect=e}get DOMFrustumBoundingRect(){return{top:this.projectedBoundingRect.top-this.DOMFrustumMargins.top,right:this.projectedBoundingRect.right+this.DOMFrustumMargins.right,bottom:this.projectedBoundingRect.bottom+this.DOMFrustumMargins.bottom,left:this.projectedBoundingRect.left-this.DOMFrustumMargins.left}}computeClipSpaceOBB(){this.clipSpaceOBB.set(),this.boundingBox.applyMat4(this.modelViewProjectionMatrix,this.clipSpaceOBB)}setDocumentCoordsFromClipSpaceOBB(){this.computeClipSpaceOBB(),this.clipSpaceBoundingRect={top:this.clipSpaceOBB.max.y,left:this.clipSpaceOBB.min.x,width:this.clipSpaceOBB.max.x-this.clipSpaceOBB.min.x,height:this.clipSpaceOBB.max.y-this.clipSpaceOBB.min.y};const e=(this.clipSpaceOBB.min.x+1)*.5,t=(this.clipSpaceOBB.max.x+1)*.5,s=1-(this.clipSpaceOBB.min.y+1)*.5,i=1-(this.clipSpaceOBB.max.y+1)*.5,{width:n,height:a,top:o,left:h}=this.containerBoundingRect;this.projectedBoundingRect={left:e*n+h,x:e*n+h,top:i*a+o,y:i*a+o,right:t*n+h,bottom:s*a+o,width:t*n+h-(e*n+h),height:s*a+o-(i*a+o)}}setDocumentCoordsFromClipSpaceSphere(e={center:new y,radius:0}){this.clipSpaceBoundingRect={top:e.center.y+e.radius,left:e.center.x-e.radius,width:e.radius*2,height:e.radius*2};const t=(e.center.x+1)*.5,s=1-(e.center.y+1)*.5,{width:i,height:n,top:a,left:o}=this.containerBoundingRect;this.projectedBoundingRect.width=e.radius*n,this.projectedBoundingRect.height=e.radius*n,this.projectedBoundingRect.left=t*i+o-this.projectedBoundingRect.width*.5,this.projectedBoundingRect.x=this.projectedBoundingRect.left,this.projectedBoundingRect.top=s*n+a-this.projectedBoundingRect.height*.5,this.projectedBoundingRect.y=this.projectedBoundingRect.top,this.projectedBoundingRect.right=this.projectedBoundingRect.left+this.projectedBoundingRect.width,this.projectedBoundingRect.bottom=this.projectedBoundingRect.top+this.projectedBoundingRect.height}intersectsContainer(){Math.round(this.DOMFrustumBoundingRect.right)<=this.containerBoundingRect.left||Math.round(this.DOMFrustumBoundingRect.left)>=this.containerBoundingRect.left+this.containerBoundingRect.width||Math.round(this.DOMFrustumBoundingRect.bottom)<=this.containerBoundingRect.top||Math.round(this.DOMFrustumBoundingRect.top)>=this.containerBoundingRect.top+this.containerBoundingRect.height?(this.isIntersecting&&this.onLeaveView(),this.isIntersecting=!1):(this.isIntersecting||this.onReEnterView(),this.isIntersecting=!0)}}class Oi{static{u(this,"Geometry")}constructor({verticesOrder:e="ccw",topology:t="triangle-list",instancesCount:s=1,vertexBuffers:i=[],mapBuffersAtCreation:n=!0}={}){this.verticesCount=0,this.verticesOrder=e,this.topology=t,this.instancesCount=s,this.ready=!1,this.boundingBox=new Ee,this.type="Geometry",this.uuid=O(),this.indirectDraw=null,this.vertexBuffers=[],this.consumers=new Set,this.options={verticesOrder:e,topology:t,instancesCount:s,vertexBuffers:i,mapBuffersAtCreation:n};const a=i.find(o=>o.name==="attributes");!i.length||!a?this.addVertexBuffer({name:"attributes"}):a&&i.sort((o,h)=>{const l=o.name!=="attributes"?1/0:-1,d=h.name!=="attributes"?1/0:-1;return l-d});for(const o of i)this.addVertexBuffer({stepMode:o.stepMode??"vertex",name:o.name,attributes:o.attributes,...o.array&&{array:o.array},...o.buffer&&{buffer:o.buffer},...o.bufferOffset&&{bufferOffset:o.bufferOffset},...o.bufferSize&&{bufferSize:o.bufferSize}});a&&this.setWGSLFragment()}loseContext(){this.ready=!1;for(const e of this.vertexBuffers)e.buffer.destroy()}restoreContext(e){if(!this.ready){for(const t of this.vertexBuffers)!t.buffer.GPUBuffer&&t.buffer.consumers.size===0&&(t.buffer.createBuffer(e),this.uploadBuffer(e,t)),t.buffer.consumers.add(this.uuid);this.ready=!0}}addVertexBuffer({stepMode:e="vertex",name:t,attributes:s=[],buffer:i=null,array:n=null,bufferOffset:a=0,bufferSize:o=null}={}){i=i||new Je;const h={name:t??"attributes"+this.vertexBuffers.length,stepMode:e,arrayStride:0,bufferLength:0,attributes:[],buffer:i,array:n,bufferOffset:a,bufferSize:o};return s?.forEach(l=>{this.setAttribute({vertexBuffer:h,...l})}),this.vertexBuffers.push(h),h}getVertexBufferByName(e=""){return this.vertexBuffers.find(t=>t.name===e)}setAttribute({vertexBuffer:e=this.vertexBuffers[0],name:t,type:s="vec3f",bufferFormat:i="float32x3",size:n=3,array:a=new Float32Array(this.verticesCount*n),verticesStride:o=1}){const h=e.attributes,l=h.length;t||(t="geometryAttribute"+l),t==="position"&&(s!=="vec3f"||i!=="float32x3"||n!==3)&&(A(`Geometry 'position' attribute must have this exact properties set:
	type: 'vec3f',
	bufferFormat: 'float32x3',
	size: 3`),s="vec3f",i="float32x3",n=3);let d=a.length;const c=d/n;t==="position"&&(this.verticesCount=c),e.stepMode==="vertex"&&this.verticesCount&&this.verticesCount!==c*o?ae(`Geometry vertex attribute error. Attribute array of size ${n} must be of length: ${this.verticesCount*n}, current given: ${a.length}. (${this.verticesCount} vertices).`):e.stepMode==="instance"&&c!==this.instancesCount&&(e.buffer?d=this.instancesCount*n:ae(`Geometry instance attribute error. Attribute array of size ${n} must be of length: ${this.instancesCount*n}, current given: ${a.length}. (${this.instancesCount} instances).`));const f={name:t,type:s,bufferFormat:i,size:n,bufferLength:d,offset:l?h.reduce((p,m)=>p+m.bufferLength,0):0,bufferOffset:l?h[l-1].bufferOffset+h[l-1].size*4:0,array:a,verticesStride:o};e.bufferLength+=f.bufferLength*o,e.arrayStride+=f.size,e.attributes.push(f)}get shouldCompute(){return this.vertexBuffers.length&&!this.vertexBuffers[0].array}getAttributeByName(e){let t;for(const s of this.vertexBuffers)if(t=s.attributes.find(i=>i.name===e),t)break;return t}computeNormalFromTriangle(e,t,s,i,n,a){i.copy(t).sub(e),n.copy(s).sub(e),a.crossVectors(i,n).normalize()}computeFlatNormals(){const e=this.getAttributeByName("position"),t=new y,s=new y,i=new y,n=new y,a=new y,o=new y,h=e.array.length,l=new Float32Array(h);for(let d=0;d<h;d+=e.size*3){t.set(e.array[d],e.array[d+1],e.array[d+2]),s.set(e.array[d+3],e.array[d+4],e.array[d+5]),i.set(e.array[d+6],e.array[d+7],e.array[d+8]),this.computeNormalFromTriangle(t,s,i,n,a,o);for(let c=0;c<3;c++)l[d+c*3]=o.x,l[d+1+c*3]=o.y,l[d+2+c*3]=o.z}this.setAttribute({name:"normal",type:"vec3f",bufferFormat:"float32x3",size:3,array:l})}computeGeometry(){this.ready||(this.vertexBuffers.forEach((e,t)=>{if(t===0){const n=e.attributes.find(o=>o.name==="position");n||ae("Geometry must have a 'position' attribute"),(n.type!=="vec3f"||n.bufferFormat!=="float32x3"||n.size!==3)&&(A(`Geometry 'position' attribute must have this exact properties set:
	type: 'vec3f',
	bufferFormat: 'float32x3',
	size: 3`),n.type="vec3f",n.bufferFormat="float32x3",n.size=3),e.attributes.find(o=>o.name==="normal")||(this.computeFlatNormals(),this.setWGSLFragment())}e.array=new Float32Array(e.bufferLength);let s=0,i=0;for(let n=0;n<e.bufferLength;n+=e.arrayStride){for(let a=0;a<e.attributes.length;a++){const{name:o,size:h,array:l,verticesStride:d}=e.attributes[a];for(let c=0;c<h;c++){const f=l[Math.floor(i/d)*h+c];e.array[s]=f??0,o==="position"&&(c%3===0?(this.boundingBox.min.x>f&&(this.boundingBox.min.x=f),this.boundingBox.max.x<f&&(this.boundingBox.max.x=f)):c%3===1?(this.boundingBox.min.y>f&&(this.boundingBox.min.y=f),this.boundingBox.max.y<f&&(this.boundingBox.max.y=f)):c%3===2&&(this.boundingBox.min.z>f&&(this.boundingBox.min.z=f),this.boundingBox.max.z<f&&(this.boundingBox.max.z=f))),s++}}i++}}),this.wgslStructFragment||this.setWGSLFragment())}setWGSLFragment(){let e=-1;this.wgslStructFragment=`struct Attributes {
	@builtin(vertex_index) vertexIndex : u32,
	@builtin(instance_index) instanceIndex : u32,${this.vertexBuffers.map(t=>t.attributes.map(s=>(e++,`
	@location(${e}) ${s.name}: ${s.type}`))).join(",")}
};`,this.layoutCacheKey=this.vertexBuffers.map(t=>t.name+","+t.attributes.map(s=>`${s.name},${s.size}`)).join(",")+","}createBuffers({renderer:e,label:t=this.type}){if(!this.ready){for(const s of this.vertexBuffers)s.bufferSize||(s.bufferSize=s.array.length*s.array.constructor.BYTES_PER_ELEMENT),!s.buffer.GPUBuffer&&!s.buffer.consumers.size&&(s.buffer.createBuffer(e,{label:t+": "+s.name+" buffer",size:s.bufferSize,usage:this.options.mapBuffersAtCreation?["vertex"]:["copyDst","vertex"],mappedAtCreation:this.options.mapBuffersAtCreation}),this.uploadBuffer(e,s)),s.buffer.consumers.add(this.uuid);this.ready=!0}}uploadBuffer(e,t){this.options.mapBuffersAtCreation?(new t.array.constructor(t.buffer.GPUBuffer.getMappedRange()).set(t.array),t.buffer.GPUBuffer.unmap()):e.queueWriteBuffer(t.buffer.GPUBuffer,0,t.array)}useIndirectBuffer({buffer:e,offset:t=0}){this.indirectDraw={buffer:e,offset:t}}setGeometryBuffers(e){this.vertexBuffers.forEach((t,s)=>{e.setVertexBuffer(s,t.buffer.GPUBuffer,t.bufferOffset,t.bufferSize)})}drawGeometry(e){this.indirectDraw&&this.indirectDraw.buffer&&this.indirectDraw.buffer.GPUBuffer?e.drawIndirect(this.indirectDraw.buffer.GPUBuffer,this.indirectDraw.offset):e.draw(this.verticesCount,this.instancesCount)}render(e){this.ready&&(this.setGeometryBuffers(e),this.drawGeometry(e))}destroy(e=null){this.ready=!1;for(const t of this.vertexBuffers)t.buffer.consumers.delete(this.uuid),t.buffer.consumers.size||t.buffer.destroy(),t.array=null,e&&e.removeBuffer(t.buffer)}}class Nt extends Oi{static{u(this,"IndexedGeometry")}constructor({verticesOrder:e="ccw",topology:t="triangle-list",instancesCount:s=1,vertexBuffers:i=[],mapBuffersAtCreation:n=!0}={}){super({verticesOrder:e,topology:t,instancesCount:s,vertexBuffers:i,mapBuffersAtCreation:n}),this.type="IndexedGeometry"}loseContext(){super.loseContext(),this.indexBuffer&&this.indexBuffer.buffer.destroy()}restoreContext(e){this.ready||(this.indexBuffer.buffer.GPUBuffer||(this.indexBuffer.buffer.createBuffer(e),this.uploadBuffer(e,this.indexBuffer),this.indexBuffer.buffer.consumers.add(this.uuid)),super.restoreContext(e))}computeFlatNormals(){const e=this.getAttributeByName("position"),t=new y,s=new y,i=new y,n=new y,a=new y,o=new y,h=e.array.length,l=new Float32Array(h),d=this.indexBuffer.array.length;for(let c=0;c<d;c+=3){const f=this.indexBuffer.array[c]*3,p=this.indexBuffer.array[c+1]*3,m=this.indexBuffer.array[c+2]*3;if(!(h<f+2)&&(t.set(e.array[f],e.array[f+1],e.array[f+2]),!(h<p+2)&&(s.set(e.array[p],e.array[p+1],e.array[p+2]),!(h<m+2)))){i.set(e.array[m],e.array[m+1],e.array[m+2]),this.computeNormalFromTriangle(t,s,i,n,a,o);for(let g=0;g<3;g++)l[this.indexBuffer.array[c+g]*3]=o.x,l[this.indexBuffer.array[c+g]*3+1]=o.y,l[this.indexBuffer.array[c+g]*3+2]=o.z}}this.setAttribute({name:"normal",type:"vec3f",bufferFormat:"float32x3",size:3,array:l})}get useUint16IndexArray(){return this.verticesCount<256*256}setIndexBuffer({bufferFormat:e="uint32",array:t=new Uint32Array(0),buffer:s=new Je,bufferOffset:i=0,bufferSize:n=null}){this.indexBuffer={array:t,bufferFormat:e,bufferLength:t.length,buffer:s,bufferOffset:i,bufferSize:n!==null?n:t.length*t.constructor.BYTES_PER_ELEMENT}}createBuffers({renderer:e,label:t=this.type}){this.indexBuffer.buffer.GPUBuffer||(this.indexBuffer.buffer.createBuffer(e,{label:t+": index buffer",size:this.indexBuffer.array.byteLength,usage:this.options.mapBuffersAtCreation?["index"]:["copyDst","index"],mappedAtCreation:this.options.mapBuffersAtCreation}),this.uploadBuffer(e,this.indexBuffer)),this.indexBuffer.buffer.consumers.add(this.uuid),super.createBuffers({renderer:e,label:t})}setGeometryBuffers(e){super.setGeometryBuffers(e),e.setIndexBuffer(this.indexBuffer.buffer.GPUBuffer,this.indexBuffer.bufferFormat,this.indexBuffer.bufferOffset,this.indexBuffer.bufferSize)}drawGeometry(e){this.indirectDraw&&this.indirectDraw.buffer&&this.indirectDraw.buffer.GPUBuffer?e.drawIndexedIndirect(this.indirectDraw.buffer.GPUBuffer,this.indirectDraw.offset):e.drawIndexed(this.indexBuffer.bufferLength,this.instancesCount)}destroy(e=null){super.destroy(e),this.indexBuffer&&(this.indexBuffer.buffer.consumers.delete(this.uuid),this.indexBuffer.buffer.destroy(),e&&e.removeBuffer(this.indexBuffer.buffer))}}class Ui extends Nt{static{u(this,"PlaneGeometry")}constructor({widthSegments:e=1,heightSegments:t=1,instancesCount:s=1,vertexBuffers:i=[],topology:n}={}){super({verticesOrder:"ccw",topology:n,instancesCount:s,vertexBuffers:i,mapBuffersAtCreation:!0}),this.type="PlaneGeometry",e=Math.floor(e),t=Math.floor(t),this.definition={id:e*t+e,width:e,height:t,count:e*t};const a=(this.definition.width+1)*(this.definition.height+1),o=this.getIndexedVerticesAndUVs(a);for(const h of Object.values(o))this.setAttribute(h);this.setIndexArray()}setIndexArray(){const e=this.useUint16IndexArray?new Uint16Array(this.definition.count*6):new Uint32Array(this.definition.count*6);let t=0;for(let s=0;s<this.definition.height;s++)for(let i=0;i<this.definition.width;i++)e[t++]=i+s*(this.definition.width+1),e[t++]=this.definition.width+i+1+s*(this.definition.width+1),e[t++]=i+1+s*(this.definition.width+1),e[t++]=i+1+s*(this.definition.width+1),e[t++]=this.definition.width+i+1+s*(this.definition.width+1),e[t++]=this.definition.width+i+2+s*(this.definition.width+1);this.setIndexBuffer({array:e,bufferFormat:this.useUint16IndexArray?"uint16":"uint32"})}getIndexedVerticesAndUVs(e){const t={name:"uv",type:"vec2f",bufferFormat:"float32x2",size:2,array:new Float32Array(e*2)},s={name:"position",type:"vec3f",bufferFormat:"float32x3",size:3,array:new Float32Array(e*3)},i={name:"normal",type:"vec3f",bufferFormat:"float32x3",size:3,array:new Float32Array(e*3)};let n=0,a=0,o=0;for(let h=0;h<=this.definition.height;h++)for(let l=0;l<=this.definition.width;l++)t.array[o++]=1-l/this.definition.width,t.array[o++]=1-h/this.definition.height,s.array[n++]=1-l*2/this.definition.width,s.array[n++]=h*2/this.definition.height-1,s.array[n++]=0,i.array[a++]=0,i.array[a++]=0,i.array[a++]=1;return{position:s,uv:t,normal:i}}}function Ns(r){return r<.04045?r*.0773993808:Math.pow(r*.9478672986+.0521327014,2.4)}u(Ns,"sRGBToLinearFloat");function Ws(r){return r<.0031308?r*12.92:1.055*Math.pow(r,.41666)-.055}u(Ws,"linearTosRGBFloat");function mt(r=new y){return r.x=Ns(r.x),r.y=Ns(r.y),r.z=Ns(r.z),r}u(mt,"sRGBToLinear");function Qo(r=new y){return r.x=Ws(r.x),r.y=Ws(r.y),r.z=Ws(r.z),r}u(Qo,"linearTosRGB");var mn=u(r=>{throw TypeError(r)},"__typeError$k"),gn=u((r,e,t)=>e.has(r)||mn("Cannot "+t),"__accessCheck$k"),yn=u((r,e,t)=>(gn(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet$i"),xn=u((r,e,t)=>e.has(r)?mn("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$k"),vn=u((r,e,t,s)=>(gn(r,e,"write to private field"),e.set(r,t),t),"__privateSet$i"),js,qs;class Hs extends Me{static{u(this,"Light")}constructor(e,{label:t="",color:s=new y(1),intensity:i=1,type:n="lights"}={}){super(),xn(this,js),xn(this,qs),this.type=n,this.setRenderer(e),this.uuid=O(),this.options={label:t,color:s,intensity:i},this.color=s,vn(this,qs,this.color.clone()),this.color.onChange(()=>this.onPropertyChanged("color",this.actualColor)),this.intensity=i}setRenderer(e){const t=!!this.renderer;this.renderer&&this.renderer.removeLight(this),e=Ae(e,this.constructor.name),this.renderer=e,this.index===void 0&&(this.index=this.renderer.lights.filter(s=>s.type===this.type).length),this.index+1>this.renderer.lightsBindingParams[this.type].max&&this.onMaxLightOverflow(this.type),this.renderer.addLight(this),this.setRendererBinding(),t&&this.reset(!1)}setRendererBinding(){this.renderer.bindings[this.type]&&(this.rendererBinding=this.renderer.bindings[this.type])}reset(e=!0){this.setRendererBinding(),this.onPropertyChanged("color",this.actualColor)}get intensity(){return yn(this,js)}set intensity(e){vn(this,js,e),this.onPropertyChanged("color",this.actualColor)}get actualColor(){return mt(yn(this,qs).copy(this.color)).multiplyScalar(this.intensity)}onPropertyChanged(e,t){this.rendererBinding&&this.rendererBinding.inputs[e]&&(t instanceof y?(this.rendererBinding.inputs[e].value[this.index*3]=t.x,this.rendererBinding.inputs[e].value[this.index*3+1]=t.y,this.rendererBinding.inputs[e].value[this.index*3+2]=t.z):this.rendererBinding.inputs[e].value[this.index]=t,this.rendererBinding.inputs[e].shouldUpdate=!0,this.renderer.shouldUpdateCameraLightsBindGroup())}onMaxLightOverflow(e){this.renderer.onMaxLightOverflow(e,this.index),this.rendererBinding&&(this.rendererBinding=this.renderer.bindings[e])}remove(){this.renderer.removeLight(this),this.destroy()}destroy(){super.destroy()}}js=new WeakMap,qs=new WeakMap;class eh extends Hs{static{u(this,"AmbientLight")}constructor(e,{label:t="AmbientLight",color:s=new y(1),intensity:i=.1}={}){super(e,{label:t,color:s,intensity:i,type:"ambientLights"})}applyRotation(){}applyPosition(){}applyScale(){}applyTransformOrigin(){}}class Xs{static{u(this,"RenderPass")}constructor(e,{label:t="Render Pass",sampleCount:s=4,qualityRatio:i=1,fixedSize:n=null,useColorAttachments:a=!0,renderToSwapChain:o=!0,colorAttachments:h=[],useDepth:l=!0,depthTexture:d=null,depthLoadOp:c="clear",depthStoreOp:f="store",depthClearValue:p=1,depthFormat:m="depth24plus"}={}){if(this.type="RenderPass",e=$(e,t+" "+this.type),this.renderer=e,this.uuid=O(),a){const g={loadOp:"clear",storeOp:"store",clearValue:[0,0,0,0],targetFormat:this.renderer.options.context.format};h.length?h=h.map(v=>({...g,...v})):h=[g]}this.options={label:t,sampleCount:s,qualityRatio:i,fixedSize:n,useColorAttachments:a,renderToSwapChain:o,colorAttachments:h,useDepth:l,...d!==void 0&&{depthTexture:d},depthLoadOp:c,depthStoreOp:f,depthClearValue:p,depthFormat:m},this.options.useDepth&&this.createDepthTexture(),this.viewTextures=[],this.resolveTargets=[],this.options.useColorAttachments&&(!this.options.renderToSwapChain||this.options.sampleCount>1)&&(this.createViewTextures(),this.createResolveTargets()),this.setRenderPassDescriptor()}setRenderer(e){e=$(e,this.options.label+" "+this.type),this.renderer=e,this.options.useDepth&&!this.options.depthTexture&&this.depthTexture.setRenderer(this.renderer),this.viewTextures.forEach(t=>{t.setRenderer(this.renderer)}),this.resolveTargets.forEach(t=>{t&&t.setRenderer(this.renderer)})}createDepthTexture(){this.options.depthTexture?(this.depthTexture=this.options.depthTexture,this.options.depthFormat=this.options.depthTexture.options.format):this.depthTexture=new q(this.renderer,{label:this.options.label+" depth texture",name:"depthTexture",format:this.options.depthFormat,sampleCount:this.options.sampleCount,qualityRatio:this.options.qualityRatio,...this.options.fixedSize&&{fixedSize:this.options.fixedSize},type:"depth",usage:["renderAttachment","textureBinding"]})}createViewTextures(){this.options.colorAttachments.forEach((e,t)=>{this.viewTextures.push(new q(this.renderer,{label:`${this.options.label} colorAttachment[${t}] view texture`,name:`colorAttachment${t}ViewTexture`,format:e.targetFormat,sampleCount:this.options.sampleCount,qualityRatio:this.options.qualityRatio,...this.options.fixedSize&&{fixedSize:this.options.fixedSize},type:"texture",usage:["copySrc","copyDst","renderAttachment","textureBinding"]}))})}createResolveTargets(){this.options.sampleCount>1&&this.options.colorAttachments.forEach((e,t)=>{this.resolveTargets.push(this.options.renderToSwapChain&&t===0?null:new q(this.renderer,{label:`${this.options.label} resolve target[${t}] texture`,name:`resolveTarget${t}Texture`,format:e.targetFormat,sampleCount:1,qualityRatio:this.options.qualityRatio,type:"texture"}))})}get outputTextures(){return this.options.sampleCount>1?this.resolveTargets:this.viewTextures}setRenderPassDescriptor(e=null){this.descriptor={label:this.options.label+" descriptor",colorAttachments:this.options.colorAttachments.map((t,s)=>({view:this.viewTextures[s]?.texture.createView({label:this.viewTextures[s]?.texture.label+" view"}),...this.resolveTargets.length&&{resolveTarget:this.resolveTargets[s]?.texture.createView({label:this.resolveTargets[s]?.texture.label+" view"})},clearValue:t.clearValue,loadOp:t.loadOp,storeOp:t.storeOp})),...this.options.useDepth&&{depthStencilAttachment:{view:e||this.depthTexture.texture.createView({label:this.depthTexture.texture.label+" view"}),depthClearValue:this.options.depthClearValue,depthLoadOp:this.options.depthLoadOp,depthStoreOp:this.options.depthStoreOp}}}}resize(){this.options.useDepth&&(this.descriptor.depthStencilAttachment.view=this.depthTexture.texture.createView({label:this.depthTexture.options.label+" view"})),this.viewTextures.forEach((e,t)=>{this.descriptor.colorAttachments[t].view=e.texture.createView({label:e.options.label+" view"})}),this.resolveTargets.forEach((e,t)=>{e&&(this.descriptor.colorAttachments[t].resolveTarget=e.texture.createView({label:e.options.label+" view"}))})}setLoadOp(e="clear",t=0){this.options.useColorAttachments&&(this.options.colorAttachments[t]&&(this.options.colorAttachments[t].loadOp=e),this.descriptor&&this.descriptor.colorAttachments&&this.descriptor.colorAttachments[t]&&(this.descriptor.colorAttachments[t].loadOp=e))}setDepthLoadOp(e="clear"){this.options.depthLoadOp=e,this.options.useDepth&&this.descriptor.depthStencilAttachment&&(this.descriptor.depthStencilAttachment.depthLoadOp=e)}setClearValue(e=[0,0,0,0],t=0){if(this.options.useColorAttachments){if(this.renderer.options.context.alphaMode==="premultiplied"){const s=e[3];e[0]=Math.min(e[0],s),e[1]=Math.min(e[1],s),e[2]=Math.min(e[2],s)}this.options.colorAttachments[t]&&(this.options.colorAttachments[t].clearValue=e),this.descriptor&&this.descriptor.colorAttachments&&this.descriptor.colorAttachments[t]&&(this.descriptor.colorAttachments[t].clearValue=e)}}updateView(e=null){return!this.options.colorAttachments.length||!this.options.renderToSwapChain||(e||(e=this.renderer.context.getCurrentTexture(),e.label=`${this.renderer.type} context current texture`),this.options.sampleCount>1?(this.descriptor.colorAttachments[0].view=this.viewTextures[0].texture.createView({label:this.viewTextures[0].options.label+" view"}),this.descriptor.colorAttachments[0].resolveTarget=e.createView({label:e.label+" resolve target view"})):this.descriptor.colorAttachments[0].view=e.createView({label:e.label+" view"})),e}destroy(){this.viewTextures.forEach(e=>e.destroy()),this.resolveTargets.forEach(e=>e?.destroy()),!this.options.depthTexture&&this.depthTexture&&this.depthTexture.destroy()}}var bn=u(r=>{throw TypeError(r)},"__typeError$j"),wn=u((r,e,t)=>e.has(r)||bn("Cannot "+t),"__accessCheck$j"),Cn=u((r,e,t)=>(wn(r,e,"read from private field"),e.get(r)),"__privateGet$h"),th=u((r,e,t)=>e.has(r)?bn("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$j"),sh=u((r,e,t,s)=>(wn(r,e,"write to private field"),e.set(r,t),t),"__privateSet$h"),Wt;class Ii{static{u(this,"RenderTarget")}constructor(e,t={}){th(this,Wt,!0),this.type="RenderTarget",e=$(e,this.type),this.renderer=e,this.uuid=O();const{label:s,colorAttachments:i,depthTexture:n,autoRender:a,...o}=t,h=n||(this.renderer.renderPass.options.sampleCount===(t.sampleCount??4)&&(!o.qualityRatio||o.qualityRatio===1)&&!o.fixedSize?this.renderer.renderPass.depthTexture:null);this.options={label:s,...o,...h&&{depthTexture:h},...i&&{colorAttachments:i},autoRender:a===void 0?!0:a},a!==void 0&&sh(this,Wt,a),this.renderPass=new Xs(this.renderer,{label:this.options.label?`${this.options.label} Render Pass`:"Render Target Render Pass",...i&&{colorAttachments:i},depthTexture:this.options.depthTexture,...o}),o.useColorAttachments!==!1&&(this.renderTexture=new q(this.renderer,{label:this.options.label?`${this.options.label} Render Texture`:"Render Target render texture",name:"renderTexture",format:i&&i.length&&i[0].targetFormat?i[0].targetFormat:this.renderer.options.context.format,...this.options.qualityRatio!==void 0&&{qualityRatio:this.options.qualityRatio},...this.options.fixedSize!==void 0&&{fixedSize:this.options.fixedSize},usage:["copySrc","renderAttachment","textureBinding"]})),this.addToScene()}setRenderer(e){this.renderer&&this.removeFromScene(),e=$(e,this.type),this.renderer=e,this.options.depthTexture&&this.options.depthTexture.setRenderer(this.renderer),this.renderPass.setRenderer(this.renderer),this.renderTexture&&this.renderTexture.setRenderer(this.renderer),this.addToScene()}get outputTextures(){return this.renderPass.outputTextures.length?this.renderPass.outputTextures.map((e,t)=>t===0&&this.renderPass.options.renderToSwapChain?this.renderTexture:e):this.renderTexture?[this.renderTexture]:[]}addToScene(){this.renderer.renderTargets.push(this),Cn(this,Wt)&&this.renderer.scene.addRenderTarget(this)}removeFromScene(){Cn(this,Wt)&&this.renderer.scene.removeRenderTarget(this),this.renderer.renderTargets=this.renderer.renderTargets.filter(e=>e.uuid!==this.uuid)}resize(){this.options.depthTexture&&(this.renderPass.options.depthTexture.texture=this.options.depthTexture.texture),this.renderPass?.resize()}remove(){this.destroy()}destroy(){this.renderer.meshes.forEach(e=>{e.outputTarget&&e.outputTarget.uuid===this.uuid&&e.setOutputTarget(null)}),this.renderer.shaderPasses.forEach(e=>{e.outputTarget&&e.outputTarget.uuid===this.uuid&&(e.outputTarget=null,e.setOutputTarget(null))}),this.removeFromScene(),this.renderPass?.destroy(),this.renderTexture?.destroy()}}Wt=new WeakMap;class ki extends Me{static{u(this,"ProjectedObject3D")}constructor(e){super(),e=Ae(e,"ProjectedObject3D"),this.camera=e.camera}applyPosition(){super.applyPosition(),this.shouldUpdateProjectionMatrixStack()}applyRotation(){super.applyRotation(),this.shouldUpdateProjectionMatrixStack()}applyScale(){super.applyScale(),this.shouldUpdateProjectionMatrixStack()}applyTransformOrigin(){super.applyTransformOrigin(),this.shouldUpdateProjectionMatrixStack()}setMatrices(){super.setMatrices(),this.matrices={...this.matrices,modelView:{matrix:new D,shouldUpdate:!0,onUpdate:u(()=>{this.modelViewMatrix.multiplyMatrices(this.viewMatrix,this.worldMatrix)},"onUpdate")},modelViewProjection:{matrix:new D,shouldUpdate:!0,onUpdate:u(()=>{this.modelViewProjectionMatrix.multiplyMatrices(this.projectionMatrix,this.modelViewMatrix)},"onUpdate")},normal:{matrix:new de,shouldUpdate:!0,onUpdate:u(()=>{this.normalMatrix.getNormalMatrix(this.worldMatrix)},"onUpdate")}}}get modelViewMatrix(){return this.matrices.modelView.matrix}set modelViewMatrix(e){this.matrices.modelView.matrix=e,this.matrices.modelView.shouldUpdate=!0}get viewMatrix(){return this.camera.viewMatrix}get projectionMatrix(){return this.camera.projectionMatrix}get modelViewProjectionMatrix(){return this.matrices.modelViewProjection.matrix}set modelViewProjectionMatrix(e){this.matrices.modelViewProjection.matrix=e,this.matrices.modelViewProjection.shouldUpdate=!0}get normalMatrix(){return this.matrices.normal.matrix}set normalMatrix(e){this.matrices.normal.matrix=e,this.matrices.normal.shouldUpdate=!0}shouldUpdateProjectionMatrixStack(){this.matrices.modelView.shouldUpdate=!0,this.matrices.modelViewProjection.shouldUpdate=!0}shouldUpdateWorldMatrix(){super.shouldUpdateWorldMatrix(),this.shouldUpdateProjectionMatrixStack(),this.matrices.normal.shouldUpdate=!0}shouldUpdateMatrixStack(){this.shouldUpdateModelMatrix(),this.shouldUpdateProjectionMatrixStack()}}let ih=0;class Vi{static{u(this,"PipelineEntry")}constructor(e){this.type="PipelineEntry",this.uuid=O();let{renderer:t}=e;const{label:s,shaders:i,useAsync:n,bindGroups:a,cacheKey:o}=e;t=$(t,s?s+" "+this.type:this.type),this.renderer=t,Object.defineProperty(this,"index",{value:ih++}),this.layout=null,this.pipeline=null,this.status={compiling:!1,compiled:!1,error:null},this.options={label:s,shaders:i,useAsync:n!==void 0?n:!0,bindGroups:a,cacheKey:o},this.bindGroups=a}setRenderer(e){e=$(e,this.options.label+" "+this.type),this.renderer=e}get ready(){return!this.status.compiling&&this.status.compiled&&!this.status.error}get canCompile(){return!this.status.compiling&&!this.status.compiled&&!this.status.error}createShaderModule({code:e="",type:t="vertex"}){const s=this.renderer.createShaderModule({label:this.options.label+": "+t+" shader module",code:e});return"getCompilationInfo"in s&&!this.renderer.production&&s.getCompilationInfo().then(i=>{for(const n of i.messages){let a="";switch(n.lineNum&&(a+=`Line ${n.lineNum}:${n.linePos} - ${e.substring(n.offset,n.offset+n.length)}
`),a+=n.message,n.type){case"error":console.error(`${this.options.label} compilation error:
${a}`);break;case"warning":console.warn(`${this.options.label} compilation warning:
${a}`);break;case"info":console.log(`${this.options.label} compilation information:
${a}`);break}}}),s}createShaders(){}createPipelineLayout(){this.layout=this.renderer.createPipelineLayout({label:this.options.label+" layout",bindGroupLayouts:this.bindGroups.map(e=>e.bindGroupLayout)})}createPipelineDescriptor(){}flushPipelineEntry(e=[]){this.status.compiling=!1,this.status.compiled=!1,this.status.error=null,this.bindGroups=e,this.compilePipelineEntry()}compilePipelineEntry(){this.status.compiling=!0,this.createShaders(),this.createPipelineLayout(),this.createPipelineDescriptor()}}const rh=`
fn getWorldPosition(position: vec3f) -> vec4f {
  return matrices.model * vec4f(position, 1.0);
}

fn getOutputPosition(position: vec3f) -> vec4f {
  return camera.projection * matrices.modelView * vec4f(position, 1.0);
}`,nh=`
fn getWorldNormal(normal: vec3f) -> vec3f {
  return normalize(matrices.normal * normal);
}

fn getViewNormal(normal: vec3f) -> vec3f {
  return normalize((camera.view * vec4(matrices.normal * normal, 0.0)).xyz);
}`,Mn=`
fn getUVCover(uv: vec2f, textureMatrix: mat3x3f) -> vec2f {
  return (textureMatrix * vec3f(uv, 1.0)).xy;
}`,tt={vertex:{getUVCover:Mn},fragment:{getUVCover:Mn,getVertexToUVCoords:`
fn getVertex2DToUVCoords(vertex: vec2f) -> vec2f {
  return vec2(
    vertex.x * 0.5 + 0.5,
    0.5 - vertex.y * 0.5
  );
}

fn getVertex3DToUVCoords(vertex: vec3f) -> vec2f {
  return getVertex2DToUVCoords( vec2(vertex.x, vertex.y) );
}
`}},st={vertex:{getPositionHelpers:rh,getNormalHelpers:nh},fragment:{}};class gt extends Vi{static{u(this,"RenderPipelineEntry")}constructor(e){let{renderer:t,...s}=e;const{label:i,attributes:n,bindGroups:a,cacheKey:o,...h}=s,l="RenderPipelineEntry";$(t,i?i+" "+l:l),super(e),this.type=l,this.shaders={vertex:{head:"",code:"",module:null},fragment:{head:"",code:"",module:null},full:{head:"",code:"",module:null}},this.descriptor=null,this.options={...this.options,attributes:n,...h},this.attributes=n}patchShaders(){this.shaders.vertex.head="",this.shaders.vertex.code="",this.shaders.fragment.head="",this.shaders.fragment.code="",this.shaders.full.head="",this.shaders.full.code="";for(const t in tt.vertex)this.shaders.vertex.head=`${tt.vertex[t]}
${this.shaders.vertex.head}`,this.shaders.full.head=`${tt.vertex[t]}
${this.shaders.full.head}`;if(this.options.shaders.fragment)for(const t in tt.fragment)this.shaders.fragment.head=`${tt.fragment[t]}
${this.shaders.fragment.head}`,this.shaders.full.head.indexOf(tt.fragment[t])===-1&&(this.shaders.full.head=`${tt.fragment[t]}
${this.shaders.full.head}`);if(this.options.rendering.useProjection){for(const t in st.vertex)this.shaders.vertex.head=`${st.vertex[t]}
${this.shaders.vertex.head}`,this.shaders.full.head=`${st.vertex[t]}
${this.shaders.full.head}`;if(this.options.shaders.fragment)for(const t in st.fragment)this.shaders.fragment.head=`${st.fragment[t]}
${this.shaders.fragment.head}`,this.shaders.full.head.indexOf(st.fragment[t])===-1&&(this.shaders.full.head=`${st.fragment[t]}
${this.shaders.full.head}`)}const e=[];for(const t of this.bindGroups){let s=0;t.bindings.forEach((i,n)=>{i.wgslGroupFragment.forEach((a,o)=>{e.push({groupIndex:t.index,visibility:i.options.visibility,bindIndex:s,wgslStructFragment:i.wgslStructFragment,wgslGroupFragment:a,newLine:n===t.bindings.length-1&&o===i.wgslGroupFragment.length-1}),s++})})}for(const t of e)t.visibility.includes("vertex")&&(t.wgslStructFragment&&this.shaders.vertex.head.indexOf(t.wgslStructFragment)===-1&&(this.shaders.vertex.head=`
${t.wgslStructFragment}
${this.shaders.vertex.head}`),this.shaders.vertex.head.indexOf(t.wgslGroupFragment)===-1&&(this.shaders.vertex.head=`${this.shaders.vertex.head}
@group(${t.groupIndex}) @binding(${t.bindIndex}) ${t.wgslGroupFragment}`,t.newLine&&(this.shaders.vertex.head+=`
`))),this.options.shaders.fragment&&t.visibility.includes("fragment")&&(t.wgslStructFragment&&this.shaders.fragment.head.indexOf(t.wgslStructFragment)===-1&&(this.shaders.fragment.head=`
${t.wgslStructFragment}
${this.shaders.fragment.head}`),this.shaders.fragment.head.indexOf(t.wgslGroupFragment)===-1&&(this.shaders.fragment.head=`${this.shaders.fragment.head}
@group(${t.groupIndex}) @binding(${t.bindIndex}) ${t.wgslGroupFragment}`,t.newLine&&(this.shaders.fragment.head+=`
`))),t.wgslStructFragment&&this.shaders.full.head.indexOf(t.wgslStructFragment)===-1&&(this.shaders.full.head=`
${t.wgslStructFragment}
${this.shaders.full.head}`),this.shaders.full.head.indexOf(t.wgslGroupFragment)===-1&&(this.shaders.full.head=`${this.shaders.full.head}
@group(${t.groupIndex}) @binding(${t.bindIndex}) ${t.wgslGroupFragment}`,t.newLine&&(this.shaders.full.head+=`
`));this.shaders.vertex.head=`${this.attributes.wgslStructFragment}
${this.shaders.vertex.head}`,this.shaders.full.head=`${this.attributes.wgslStructFragment}
${this.shaders.full.head}`,this.shaders.vertex.code=this.shaders.vertex.head+this.options.shaders.vertex.code,typeof this.options.shaders.fragment=="object"&&(this.shaders.fragment.code=this.shaders.fragment.head+this.options.shaders.fragment.code),typeof this.options.shaders.fragment=="object"&&(this.options.shaders.vertex.entryPoint!==this.options.shaders.fragment.entryPoint&&this.options.shaders.vertex.code.localeCompare(this.options.shaders.fragment.code)===0?this.shaders.full.code=this.shaders.full.head+this.options.shaders.vertex.code:this.shaders.full.code=this.shaders.full.head+this.options.shaders.vertex.code+this.options.shaders.fragment.code)}get shadersModulesReady(){return!(!this.shaders.vertex.module||this.options.shaders.fragment&&!this.shaders.fragment.module)}createShaders(){this.patchShaders();const e=typeof this.options.shaders.fragment=="object"&&this.options.shaders.vertex.entryPoint!==this.options.shaders.fragment.entryPoint&&this.options.shaders.vertex.code.localeCompare(this.options.shaders.fragment.code)===0;this.shaders.vertex.module=this.createShaderModule({code:this.shaders[e?"full":"vertex"].code,type:"vertex"}),this.options.shaders.fragment&&(this.shaders.fragment.module=this.createShaderModule({code:this.shaders[e?"full":"fragment"].code,type:"fragment"}))}static getDefaultTransparentBlending(){return{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}createPipelineDescriptor(){if(!this.shadersModulesReady)return;let e=-1;this.options.rendering.targets.length?this.options.rendering.transparent&&(this.options.rendering.targets[0].blend=this.options.rendering.targets[0].blend?this.options.rendering.targets[0].blend:gt.getDefaultTransparentBlending()):this.options.rendering.targets=[],this.descriptor={label:this.options.label,layout:this.layout,vertex:{module:this.shaders.vertex.module,entryPoint:this.options.shaders.vertex.entryPoint,buffers:this.attributes.vertexBuffers.map(t=>({stepMode:t.stepMode,arrayStride:t.arrayStride*4,attributes:t.attributes.map(s=>(e++,{shaderLocation:e,offset:s.bufferOffset,format:s.bufferFormat}))}))},...this.options.shaders.fragment&&{fragment:{module:this.shaders.fragment.module,entryPoint:this.options.shaders.fragment.entryPoint,targets:this.options.rendering.targets}},primitive:{topology:this.options.rendering.topology,frontFace:this.options.rendering.verticesOrder,cullMode:this.options.rendering.cullMode},...this.options.rendering.depth&&{depthStencil:{depthWriteEnabled:this.options.rendering.depthWriteEnabled,depthCompare:this.options.rendering.depthCompare,format:this.options.rendering.depthFormat}},...this.options.rendering.sampleCount>1&&{multisample:{count:this.options.rendering.sampleCount}}}}createRenderPipeline(){if(this.shadersModulesReady)try{this.pipeline=this.renderer.createRenderPipeline(this.descriptor)}catch(e){this.status.error=e,ae(e)}}async createRenderPipelineAsync(){if(this.shadersModulesReady)try{this.pipeline=await this.renderer.createRenderPipelineAsync(this.descriptor),this.status.compiled=!0,this.status.compiling=!1,this.status.error=null}catch(e){this.status.error=e,ae(e)}}async compilePipelineEntry(){super.compilePipelineEntry(),this.options.useAsync?await this.createRenderPipelineAsync():(this.createRenderPipeline(),this.status.compiled=!0,this.status.compiling=!1,this.status.error=null)}}const Bn=u((r={},e={})=>Object.keys(r).filter(t=>Array.isArray(r[t])?JSON.stringify(r[t])!==JSON.stringify(e[t]):r[t]!==e[t]),"compareRenderingOptions"),Ni=`
struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) uv: vec2f,
  @location(1) normal: vec3f,
  @location(2) worldPosition: vec3f,
  @location(3) viewDirection: vec3f,
};

@vertex fn main(
  attributes: Attributes,
) -> VSOutput {
  var vsOutput: VSOutput;

  vsOutput.position = getOutputPosition(attributes.position);
  vsOutput.uv = attributes.uv;
  vsOutput.normal = getWorldNormal(attributes.normal);
  let worldPosition: vec4f = getWorldPosition(attributes.position);
  vsOutput.worldPosition = worldPosition.xyz / worldPosition.w;
  vsOutput.viewDirection = camera.position - vsOutput.worldPosition;
  
  return vsOutput;
}`,Wi=`
struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) uv: vec2f,
};

@vertex fn main(
  attributes: Attributes,
) -> VSOutput {
  var vsOutput: VSOutput;

  vsOutput.position = vec4f(attributes.position, 1.0);
  vsOutput.uv = attributes.uv;
  
  return vsOutput;
}`,ji=`
@fragment fn main() -> @location(0) vec4f {
  return vec4(0.0, 0.0, 0.0, 1.0);
}`;class qi extends Fi{static{u(this,"RenderMaterial")}constructor(e,t){const s="RenderMaterial";e=$(e,s),t.shaders||(t.shaders={}),t.shaders?.vertex||(t.shaders.vertex={code:t.useProjection?Ni:Wi,entryPoint:"main"}),t.shaders.vertex.entryPoint||(t.shaders.vertex.entryPoint="main"),t.shaders.fragment===void 0&&(t.shaders.fragment={entryPoint:"main",code:ji}),super(e,t),this.type=s,this.renderer=e;const{shaders:i}=t,{useProjection:n,transparent:a,depth:o,depthWriteEnabled:h,depthCompare:l,depthFormat:d,cullMode:c,sampleCount:f,verticesOrder:p,topology:m}=t;let{targets:g}=t;g===void 0&&(g=[{format:this.renderer.options.context.format}]),g&&g.length&&!g[0].format&&(g[0].format=this.renderer.options.context.format),this.options={...this.options,shaders:i,rendering:{useProjection:n,transparent:a,depth:o,depthWriteEnabled:h,depthCompare:l,depthFormat:d,cullMode:c,sampleCount:f,targets:g,verticesOrder:p,topology:m}},this.attributes=null,this.pipelineEntry=null}setRenderer(e){this.useCameraBindGroup&&this.renderer&&this.renderer.cameraLightsBindGroup.consumers.delete(this.uuid),super.setRenderer(e),this.useCameraBindGroup&&(this.bindGroups[0]=this.renderer.cameraLightsBindGroup,this.renderer.cameraLightsBindGroup.consumers.add(this.uuid))}setPipelineEntry(){this.pipelineEntry=this.renderer.pipelineManager.createRenderPipeline(this)}async compilePipelineEntry(){await this.pipelineEntry.compilePipelineEntry()}async compileMaterial(){this.ready||(super.compileMaterial(),this.attributes&&!this.pipelineEntry&&this.setPipelineEntry(),this.pipelineEntry&&this.pipelineEntry.canCompile&&await this.compilePipelineEntry())}setRenderingOptions(e={}){e.transparent&&e.targets.length&&!e.targets[0].blend&&(e.targets[0].blend=gt.getDefaultTransparentBlending());const t=Bn(e,this.options.rendering),s={...this.options.rendering};if(this.options.rendering={...this.options.rendering,...e},this.pipelineEntry)if(this.pipelineEntry.ready&&t.length){if(!this.renderer.production){const i=t.map(a=>({[a]:Array.isArray(s[a])?s[a].map(o=>o):s[a]})),n=t.map(a=>({[a]:Array.isArray(e[a])?e[a].map(o=>o):e[a]}));A(`${this.options.label}: the change of rendering options is causing this RenderMaterial pipeline to be recompiled. This should be avoided.

Old rendering options: ${JSON.stringify(i.reduce((a,o)=>({...a,...o}),{}),null,4)}

--------

New rendering options: ${JSON.stringify(n.reduce((a,o)=>({...a,...o}),{}),null,4)}`)}this.setPipelineEntry()}else this.pipelineEntry.options.rendering={...this.pipelineEntry.options.rendering,...this.options.rendering}}setAttributesFromGeometry(e){this.attributes={wgslStructFragment:e.wgslStructFragment,vertexBuffers:e.vertexBuffers,layoutCacheKey:e.layoutCacheKey}}get cacheKey(){return(this.attributes?.layoutCacheKey||"")+super.cacheKey}get useCameraBindGroup(){return"cameraLightsBindGroup"in this.renderer&&this.options.rendering.useProjection}createBindGroups(){this.useCameraBindGroup&&(this.bindGroups.push(this.renderer.cameraLightsBindGroup),this.renderer.cameraLightsBindGroup.consumers.add(this.uuid)),super.createBindGroups()}updateBindGroups(){const e=this.useCameraBindGroup?1:0;this.useCameraBindGroup&&this.bindGroups.length&&this.bindGroups[0].needsPipelineFlush&&this.pipelineEntry.ready&&this.pipelineEntry.flushPipelineEntry(this.bindGroups);for(let t=e;t<this.bindGroups.length;t++)this.updateBindGroup(this.bindGroups[t])}}var Sn=u(r=>{throw TypeError(r)},"__typeError$i"),Tn=u((r,e,t)=>e.has(r)||Sn("Cannot "+t),"__accessCheck$i"),Hi=u((r,e,t)=>(Tn(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet$g"),ah=u((r,e,t)=>e.has(r)?Sn("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$i"),oh=u((r,e,t,s)=>(Tn(r,e,"write to private field"),e.set(r,t),t),"__privateSet$g");let hh=0;const Pn={autoRender:!0,useProjection:!1,useAsyncPipeline:!0,cullMode:"back",depth:!0,depthWriteEnabled:!0,depthCompare:"less",depthFormat:"depth24plus",transparent:!1,visible:!0,renderOrder:0,texturesOptions:{},renderBundle:null};function Rn(r){var e,t;return t=class extends r{static{u(this,"_a")}constructor(...s){super(s[0],s[1],{...Pn,...s[2]}),ah(this,e,!0),this._onReadyCallback=()=>{},this._onBeforeRenderCallback=()=>{},this._onRenderCallback=()=>{},this._onAfterRenderCallback=()=>{},this._onAfterResizeCallback=()=>{};let i=s[0];const n={...Pn,...s[2]};this.type="MeshBase",this.uuid=O(),Object.defineProperty(this,"index",{value:hh++}),i=$(i,n.label?n.label+" "+this.type:this.type),this.renderer=i;const{label:a,shaders:o,geometry:h,visible:l,renderOrder:d,outputTarget:c,additionalOutputTargets:f,useCustomScenePassEntry:p,renderBundle:m,texturesOptions:g,autoRender:v,...x}=n;this.outputTarget=c??null,this.renderBundle=m??null,this.additionalOutputTargets=f||[],x.sampleCount=x.sampleCount?x.sampleCount:this.outputTarget?this.outputTarget.renderPass.options.sampleCount:this.renderer&&this.renderer.renderPass?this.renderer.renderPass.options.sampleCount:1,this.options={...this.options??{},label:a??"Mesh "+this.renderer.meshes.length,...o!==void 0?{shaders:o}:{},...c!==void 0&&{outputTarget:c},...m!==void 0&&{renderBundle:m},texturesOptions:g,...v!==void 0&&{autoRender:v},useCustomScenePassEntry:p,...x},v!==void 0&&oh(this,e,v),this.visible=l,this.renderOrder=d,this.ready=!1,this.userData={},h&&this.useGeometry(h),this.setMaterial({...this.cleanupRenderMaterialParameters({...this.options}),...h&&{verticesOrder:h.verticesOrder,topology:h.topology}}),this.addToScene(!0)}get autoRender(){return Hi(this,e)}get ready(){return this._ready}set ready(s){s&&!this._ready&&this._onReadyCallback&&this._onReadyCallback(),this._ready=s}addToScene(s=!1){s&&this.renderer.meshes.push(this),this.setRenderingOptionsForRenderPass(this.outputTarget?this.outputTarget.renderPass:this.renderer.renderPass),Hi(this,e)&&(this.renderer.scene.addMesh(this),this.additionalOutputTargets.length&&this.additionalOutputTargets.forEach(i=>{this.renderer.scene.addMeshToRenderTargetStack(this,i)}))}removeFromScene(s=!1){Hi(this,e)&&this.renderer.scene.removeMesh(this),s&&(this.renderer.meshes=this.renderer.meshes.filter(i=>i.uuid!==this.uuid))}setRenderer(s){if(s=s&&s.renderer||s,!s||!(s.type==="GPURenderer"||s.type==="GPUCameraRenderer"||s.type==="GPUCurtainsRenderer")){A(`${this.options.label}: Cannot set ${s} as a renderer because it is not of a valid Renderer type.`);return}this.material?.setRenderer(s);const i=this.renderer;this.removeFromScene(!0),this.renderer=s,this.addToScene(!0),i.meshes.length||i.onBeforeRenderScene.add(n=>{i.forceClear(n)},{once:!0})}setOutputTarget(s){if(s&&s.type!=="RenderTarget"){A(`${this.options.label??this.type}: outputTarget is not a RenderTarget: ${s.type}`);return}this.removeFromScene(),this.outputTarget=s,this.addToScene()}setRenderBundle(s,i=!0){i?(this.removeFromScene(),this.renderBundle=s,this.addToScene()):this.renderBundle=s}loseContext(){this.ready=!1,this.geometry.loseContext(),this.material.loseContext()}restoreContext(){this.geometry.restoreContext(this.renderer),this.material.restoreContext()}setShaders(){const{shaders:s}=this.options;s?((!s.vertex||!s.vertex.code)&&(s.vertex={code:Wi,entryPoint:"main"}),(s.fragment===void 0||s.fragment&&!s.fragment.code)&&(s.fragment={code:ji,entryPoint:"main"})):this.options.shaders={vertex:{code:Wi,entryPoint:"main"},fragment:{code:ji,entryPoint:"main"}}}useGeometry(s){if(this.geometry&&(s.shouldCompute&&s.computeGeometry(),this.geometry.layoutCacheKey!==s.layoutCacheKey&&(A(`${this.options.label} (${this.type}): the current and new geometries do not have the same vertexBuffers layout, causing a probable pipeline recompilation. This should be avoided.

Current geometry layout:

${this.geometry.wgslStructFragment}

--------

New geometry layout:

${s.wgslStructFragment}`),this.material.setAttributesFromGeometry(s),this.material.setPipelineEntry()),this.geometry.consumers.delete(this.uuid),this.options.renderBundle&&(this.options.renderBundle.ready=!1)),this.geometry=s,this.geometry.consumers.add(this.uuid),this.computeGeometry(),this.material){const i={...this.material.options.rendering,verticesOrder:s.verticesOrder,topology:s.topology};this.material.setRenderingOptions(i)}}computeGeometry(){this.geometry.shouldCompute&&this.geometry.computeGeometry()}setGeometry(){this.geometry&&(this.geometry.ready||this.geometry.createBuffers({renderer:this.renderer,label:this.options.label+" geometry"}),this.setMaterialGeometryAttributes())}setRenderingOptionsForRenderPass(s){const i={transparent:this.transparent,sampleCount:s.options.sampleCount,...s.options.colorAttachments.length&&{targets:s.options.colorAttachments.map((n,a)=>({format:n.targetFormat,...this.options.targets?.length&&this.options.targets[a]&&this.options.targets[a].blend&&{blend:this.options.targets[a].blend}}))},depth:s.options.useDepth,...s.options.useDepth&&{depthFormat:s.options.depthFormat}};this.material?.setRenderingOptions(i)}cleanupRenderMaterialParameters(s){return delete s.additionalOutputTargets,delete s.autoRender,delete s.outputTarget,delete s.renderBundle,delete s.texturesOptions,delete s.useCustomScenePassEntry,s}useMaterial(s){let i=null;this.material&&(this.geometry&&(i=this.material.cacheKey),this.options.renderBundle&&(this.options.renderBundle.ready=!1)),this.material=s,this.geometry&&this.material.setAttributesFromGeometry(this.geometry),this.transparent=this.material.options.rendering.transparent,i&&i!==this.material.cacheKey&&(this.material.ready?this.material.setPipelineEntry():this.material.compileMaterial())}setMaterial(s){this.setShaders(),s.shaders=this.options.shaders,s.label=s.label+" material",this.useMaterial(new qi(this.renderer,s))}setMaterialGeometryAttributes(){this.material&&!this.material.attributes&&this.material.setAttributesFromGeometry(this.geometry)}get transparent(){return this._transparent}set transparent(s){const i=this.transparent!==void 0&&s!==this.transparent;i&&this.removeFromScene(),this._transparent=s,i&&this.addToScene()}get visible(){return this._visible}set visible(s){this._visible=s}get textures(){return this.material?.textures||[]}createMediaTexture(s){s.name||(s.name="texture"+this.textures.length),s.label||(s.label=this.options.label+" "+s.name);const i={...s,...this.options.texturesOptions};this.renderBundle&&(i.useExternalTextures=!1);const n=new ce(this.renderer,i);return this.addTexture(n),n}createTexture(s){s.name||(s.name="texture"+this.textures.length);const i=new q(this.renderer,s);return this.addTexture(i),i}addTexture(s){this.renderBundle&&(this.renderBundle.ready=!1),this.material.addTexture(s)}get uniforms(){return this.material?.uniforms}get storages(){return this.material?.storages}resize(s){super.resize&&super.resize(s),this.resizeTextures(),this._onAfterResizeCallback&&this._onAfterResizeCallback()}resizeTextures(){this.textures?.forEach(s=>{s.options.fromTexture&&s.copy(s.options.fromTexture)})}onReady(s){return s&&(this._onReadyCallback=s),this}onBeforeRender(s){return s&&(this._onBeforeRenderCallback=s),this}onRender(s){return s&&(this._onRenderCallback=s),this}onAfterRender(s){return s&&(this._onAfterRenderCallback=s),this}onAfterResize(s){return s&&(this._onAfterResizeCallback=s),this}onBeforeRenderScene(){!this.renderer.ready||!this.ready||!this.visible||this._onBeforeRenderCallback&&this._onBeforeRenderCallback()}onBeforeRenderPass(){this.renderer.ready&&(this.setGeometry(),this.visible&&this.ready&&this._onRenderCallback&&this._onRenderCallback(),this.material.onBeforeRender(),this.ready=this.material&&this.material.ready&&this.geometry&&this.geometry.ready)}onRenderPass(s){this.ready&&(this.material.render(s),this.geometry.render(s))}onAfterRenderPass(){this._onAfterRenderCallback&&this._onAfterRenderCallback()}render(s){this.onBeforeRenderPass(),!(!this.renderer.ready||!this.visible)&&(!this.renderer.production&&s.pushDebugGroup(this.options.label),this.onRenderPass(s),!this.renderer.production&&s.popDebugGroup(),this.onAfterRenderPass())}remove(){this.removeFromScene(!0),this.destroy(),this.renderer.meshes.length||this.renderer.onBeforeRenderScene.add(s=>{this.renderer.forceClear(s)},{once:!0})}destroy(){super.destroy&&super.destroy(),this.material?.destroy(),this.geometry.consumers.delete(this.uuid),this.geometry.consumers.size||this.geometry?.destroy(this.renderer)}},e=new WeakMap,t}u(Rn,"MeshBaseMixin");const En=`
struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) uv: vec2f,
  @location(1) normal: vec3f,
};

@fragment fn main(fsInput: VSOutput) -> @location(0) vec4f {
  // normals
  return vec4(normalize(fsInput.normal) * 0.5 + 0.5, 1.0);
}`,lh=`
fn getPCFDirectionalShadowContribution(index: i32, worldPosition: vec3f, depthTexture: texture_depth_2d) -> f32 {
  let directionalShadow: DirectionalShadowsElement = directionalShadows.directionalShadowsElements[index];
  
  // get shadow coords
  let projectedShadowCoords: vec4f = directionalShadow.projectionMatrix * directionalShadow.viewMatrix * vec4(worldPosition, 1.0);
  var shadowCoords: vec3f = projectedShadowCoords.xyz / projectedShadowCoords.w;
  
  // Convert XY to (0, 1)
  // Y is flipped because texture coords are Y-down.
  shadowCoords = vec3(
    shadowCoords.xy * vec2(0.5, -0.5) + vec2(0.5),
    shadowCoords.z
  );
  
  return getPCFBaseShadowContribution(
    shadowCoords,
    directionalShadow.pcfSamples,
    directionalShadow.bias,
    directionalShadow.intensity,
    depthTexture
  );
}
`,uh=u(r=>{const e=r.shadowCastingLights.filter(s=>s.type==="directionalLights"),t=Math.max(r.lightsBindingParams.directionalLights.max,1);return`
fn getPCFDirectionalShadows(worldPosition: vec3f) -> array<f32, ${t}> {
  var directionalShadowContribution: array<f32, ${t}>;
  
  var lightDirection: vec3f;
  
  ${e.map((s,i)=>`lightDirection = worldPosition - directionalLights.elements[${i}].direction;
      
      ${s.shadow.isActive?`
      if(directionalShadows.directionalShadowsElements[${i}].isActive > 0) {
        directionalShadowContribution[${i}] = getPCFDirectionalShadowContribution(
          ${i},
          worldPosition,
          directionalShadowDepthTexture${i}
        );
      } else {
        directionalShadowContribution[${i}] = 1.0;
      }
          `:`directionalShadowContribution[${i}] = 1.0;`}`).join(`
`)}
  
  return directionalShadowContribution;
}
`},"getPCFDirectionalShadows"),dh=`
fn getPCFPointShadowContribution(index: i32, shadowPosition: vec4f, depthCubeTexture: texture_depth_cube) -> f32 {
  let pointShadow: PointShadowsElement = pointShadows.pointShadowsElements[index];

  // Percentage-closer filtering. Sample texels in the region
  // to smooth the result.
  var visibility = 0.0;
  var closestDepth = 0.0;
  let currentDepth: f32 = shadowPosition.w;
  let cameraRange: f32 = pointShadow.cameraFar - pointShadow.cameraNear;
  let normalizedDepth: f32 = (shadowPosition.w - pointShadow.cameraNear) / cameraRange;

  let maxSize: f32 = f32(max(textureDimensions(depthCubeTexture).x, textureDimensions(depthCubeTexture).y));

  let texelSize: vec3f = vec3(1.0 / maxSize);
  let sampleCount: i32 = pointShadow.pcfSamples;
  let maxSamples: f32 = f32(sampleCount) - 1.0;
  
  for (var x = 0; x < sampleCount; x++) {
    for (var y = 0; y < sampleCount; y++) {
      for (var z = 0; z < sampleCount; z++) {
        let offset = texelSize * vec3(
          f32(x) - maxSamples * 0.5,
          f32(y) - maxSamples * 0.5,
          f32(z) - maxSamples * 0.5
        );

        closestDepth = textureSampleCompareLevel(
          depthCubeTexture,
          depthComparisonSampler,
          shadowPosition.xyz + offset,
          normalizedDepth - pointShadow.bias
        );

        closestDepth *= cameraRange;

        visibility += select(0.0, 1.0, currentDepth <= closestDepth);
      }
    }
  }
  
  visibility /= f32(sampleCount * sampleCount * sampleCount);
  
  visibility = clamp(visibility, 1.0 - saturate(pointShadow.intensity), 1.0);
  
  return visibility;
}`,ch=u(r=>{const e=r.shadowCastingLights.filter(s=>s.type==="pointLights"),t=Math.max(r.lightsBindingParams.pointLights.max,1);return`
fn getPCFPointShadows(worldPosition: vec3f) -> array<f32, ${t}> {
  var pointShadowContribution: array<f32, ${t}>;
  
  var lightDirection: vec3f;
  var lightDistance: f32;
  var lightColor: vec3f;
  
  ${e.map((s,i)=>`lightDirection = pointLights.elements[${i}].position - worldPosition;
      
      lightDistance = length(lightDirection);
      lightColor = pointLights.elements[${i}].color * rangeAttenuation(pointLights.elements[${i}].range, lightDistance, 2.0);
      
      ${s.shadow.isActive?`
      if(pointShadows.pointShadowsElements[${i}].isActive > 0 && length(lightColor) > 0.0001) {
        pointShadowContribution[${i}] = getPCFPointShadowContribution(
          ${i},
          vec4(lightDirection, length(lightDirection)),
          pointShadowCubeDepthTexture${i}
        );
      } else {
        pointShadowContribution[${i}] = 1.0;
      }
            `:`pointShadowContribution[${i}] = 1.0;`}`).join(`
`)}
  
  return pointShadowContribution;
}
`},"getPCFPointShadows"),ph=u(r=>{const e=r.shadowCastingLights.filter(s=>s.type==="spotLights"),t=Math.max(r.lightsBindingParams.spotLights.max,1);return`
fn getPCFSpotShadows(worldPosition: vec3f) -> array<f32, ${t}> {
  var spotShadowContribution: array<f32, ${t}>;
  
  var lightDirection: vec3f;
  
  ${e.map((s,i)=>`lightDirection = worldPosition - spotLights.elements[${i}].direction;
      
      ${s.shadow.isActive?`
      if(spotShadows.spotShadowsElements[${i}].isActive > 0) {
        spotShadowContribution[${i}] = getPCFSpotShadowContribution(
          ${i},
          worldPosition,
          spotShadowDepthTexture${i}
        );
      } else {
        spotShadowContribution[${i}] = 1.0;
      }
          `:`spotShadowContribution[${i}] = 1.0;`}`).join(`
`)}
  
  return spotShadowContribution;
}
`},"getPCFSpotShadows"),fh=`
fn getPCFSpotShadowContribution(index: i32, worldPosition: vec3f, depthTexture: texture_depth_2d) -> f32 {
  let spotShadow: SpotShadowsElement = spotShadows.spotShadowsElements[index];
  
  // get shadow coords
  let projectedShadowCoords: vec4f = spotShadow.projectionMatrix * spotShadow.viewMatrix * vec4(worldPosition, 1.0);
  var shadowCoords: vec3f = projectedShadowCoords.xyz / projectedShadowCoords.w;
  
  // Convert XY to (0, 1)
  // Y is flipped because texture coords are Y-down.
  shadowCoords = vec3(
    shadowCoords.xy * vec2(0.5, -0.5) + vec2(0.5),
    shadowCoords.z
  );
  
  return getPCFBaseShadowContribution(
    shadowCoords,
    spotShadow.pcfSamples,
    spotShadow.bias,
    spotShadow.intensity,
    depthTexture
  );
}
`,mh=`
fn getPCFBaseShadowContribution(
  shadowCoords: vec3f,
  pcfSamples: i32,
  bias: f32,
  intensity: f32,
  depthTexture: texture_depth_2d
) -> f32 {
  var visibility = 0.0;
  
  let inFrustum: bool = shadowCoords.x >= 0.0 && shadowCoords.x <= 1.0 && shadowCoords.y >= 0.0 && shadowCoords.y <= 1.0;
  let frustumTest: bool = inFrustum && shadowCoords.z <= 1.0;
  
  if(frustumTest) {
    // Percentage-closer filtering. Sample texels in the region
    // to smooth the result.
    let size: vec2f = vec2f(textureDimensions(depthTexture).xy);
  
    let texelSize: vec2f = 1.0 / size;
    
    let sampleCount: i32 = pcfSamples;
    let maxSamples: f32 = f32(sampleCount) - 1.0;
  
    for (var x = 0; x < sampleCount; x++) {
      for (var y = 0; y < sampleCount; y++) {
        let offset = texelSize * vec2(
          f32(x) - maxSamples * 0.5,
          f32(y) - maxSamples * 0.5
        );
        
        visibility += textureSampleCompareLevel(
          depthTexture,
          depthComparisonSampler,
          shadowCoords.xy + offset,
          shadowCoords.z - bias
        );
      }
    }
    visibility /= f32(sampleCount * sampleCount);
    
    visibility = clamp(visibility, 1.0 - saturate(intensity), 1.0);
  }
  else {
    visibility = 1.0;
  }
  
  return visibility;
}
`,zn={frustumCulling:"OBB",DOMFrustumMargins:{top:0,right:0,bottom:0,left:0},receiveShadows:!1,castShadows:!1,transmissive:!1};function _n(r){return class extends Rn(r){static{u(this,"ProjectedMeshBase")}constructor(...t){super(t[0],t[1],{...zn,...t[2],useProjection:!0}),this._onReEnterViewCallback=()=>{},this._onLeaveViewCallback=()=>{};let s=t[0];const i={...zn,...t[2],useProjection:!0};this.type="MeshTransformed",s=Ae(s,i.label?i.label+" "+this.type:this.type),this.renderer=s;const{frustumCulling:n,DOMFrustumMargins:a,receiveShadows:o,castShadows:h,transmissive:l}=i;this.options={...this.options??{},frustumCulling:n,DOMFrustumMargins:a,receiveShadows:o,castShadows:h,transmissive:l},this.options.castShadows&&this.renderer.shadowCastingLights.forEach(d=>{d.shadow.isActive&&d.shadow.addShadowCastingMesh(this)}),this.setDOMFrustum()}setRenderer(t){if(this.renderer&&this.options.castShadows&&this.renderer.shadowCastingLights.forEach(s=>{s.shadow.isActive&&s.shadow.removeMesh(this)}),this.options.transmissive){t=Ae(t,this.options.label+" "+t.type),t.createTransmissionTarget();let s=this.material.textures.find(i=>i.options.name==="transmissionBackgroundTexture");s&&s.copy(t.transmissionTarget.texture)}super.setRenderer(t),this.camera=this.renderer.camera,this.options.castShadows&&this.renderer.shadowCastingLights.forEach(s=>{s.shadow.isActive&&s.shadow.addShadowCastingMesh(this)})}setRenderBundle(t,s=!0){if(this.renderBundle&&t&&this.renderBundle.uuid===t.uuid)return;const i=!!this.renderBundle,n=this.material.getBindGroupByBindingName("matrices"),a=this.material.getBufferBindingByName("matrices");this.renderBundle&&!t&&a.parent&&(a.parent=null,a.shouldResetBindGroup=!0,n.createBindingBuffer(a)),super.setRenderBundle(t,s),this.renderBundle&&this.renderBundle.binding&&(i&&n.destroyBufferBinding(a),a.options.offset=this.renderBundle.meshes.size-1,a.parent=this.renderBundle.binding,a.shouldResetBindGroup=!0)}patchRenderBundleBinding(t=0){const s=this.material.getBufferBindingByName("matrices");s.options.offset=t,s.parent=this.renderBundle.binding,s.shouldResetBindGroup=!0}setShaders(){const{shaders:t}=this.options;return t?((!t.vertex||!t.vertex.code)&&(t.vertex={code:Ni,entryPoint:"main"}),(t.fragment===void 0||t.fragment&&!t.fragment.code)&&(t.fragment={code:En,entryPoint:"main"})):this.options.shaders={vertex:{code:Ni,entryPoint:"main"},fragment:{code:En,entryPoint:"main"}},this.options.receiveShadows&&(this.renderer.shadowCastingLights.forEach(i=>{i.shadow.addShadowReceivingMesh(this)}),this.renderer.shadowCastingLights.find(i=>i.shadow.isActive)&&t.fragment&&(t.fragment.code=mh+uh(this.renderer)+lh+ch(this.renderer)+dh+ph(this.renderer)+fh+t.fragment.code)),t}useGeometry(t){super.useGeometry(t),this.renderer&&this.options.castShadows&&this.renderer.shadowCastingLights.forEach(s=>{s.shadow.isActive&&s.shadow.updateMeshGeometry(this,t)}),this.domFrustum&&(this.domFrustum.boundingBox=this.geometry.boundingBox),this.shouldUpdateMatrixStack()}setDOMFrustum(){this.domFrustum=new fn({boundingBox:this.geometry?.boundingBox,modelViewProjectionMatrix:this.modelViewProjectionMatrix,containerBoundingRect:this.renderer.boundingRect,DOMFrustumMargins:this.options.DOMFrustumMargins,onReEnterView:u(()=>{this._onReEnterViewCallback&&this._onReEnterViewCallback()},"onReEnterView"),onLeaveView:u(()=>{this._onLeaveViewCallback&&this._onLeaveViewCallback()},"onLeaveView")}),this.DOMFrustumMargins=this.domFrustum.DOMFrustumMargins,this.frustumCulling=this.options.frustumCulling}cleanupRenderMaterialParameters(t){if(delete t.castShadows,delete t.DOMFrustumMargins,delete t.frustumCulling,delete t.receiveShadows,delete t.transmissive,this.options.receiveShadows){const s=[];let i=[];this.renderer.shadowCastingLights.forEach(n=>{n.shadow.isActive&&(s.push(n.shadow.depthTexture),i.push(n.shadow.depthComparisonSampler))}),i=i.filter((n,a,o)=>o.findIndex(h=>h.uuid===n.uuid)===a),t.textures?t.textures=[...t.textures,...s]:t.textures=s,t.samplers?t.samplers=[...t.samplers,...i]:t.samplers=i}if(this.options.transmissive){this.renderer.createTransmissionTarget();const s=new q(this.renderer,{label:this.options.label+" transmission texture",name:"transmissionBackgroundTexture",fromTexture:this.renderer.transmissionTarget.texture});t.textures?t.textures=[...t.textures,s]:t.textures=[s],t.samplers?t.samplers=[...t.samplers,this.renderer.transmissionTarget.sampler]:t.samplers=[this.renderer.transmissionTarget.sampler]}return super.cleanupRenderMaterialParameters(t)}setMaterial(t){const s={label:"Matrices",name:"matrices",visibility:["vertex","fragment"],minOffset:this.renderer.device.limits.minUniformBufferOffsetAlignment,struct:{model:{type:"mat4x4f",value:this.worldMatrix},modelView:{type:"mat4x4f",value:this.modelViewMatrix},normal:{type:"mat3x3f",value:this.normalMatrix}}};this.options.renderBundle&&this.options.renderBundle.binding&&(s.parent=this.options.renderBundle.binding,s.offset=this.options.renderBundle.meshes.size);const i=new Y(s);t.bindings||(t.bindings=[]),t.bindings.unshift(i),super.setMaterial(t)}get visible(){return this._visible}set visible(t){this.shouldUpdateMatrixStack(),this._visible=t}resize(t){this.domFrustum&&this.domFrustum.setContainerBoundingRect(this.renderer.boundingRect),super.resize(t)}get projectedBoundingRect(){return this.domFrustum?.projectedBoundingRect}onReEnterView(t){return t&&(this._onReEnterViewCallback=t),this}onLeaveView(t){return t&&(this._onLeaveViewCallback=t),this}get clipSpaceBoundingSphere(){const{center:t,radius:s,min:i,max:n}=this.geometry.boundingBox,a=this.worldMatrix.getTranslation(),o=s*this.worldMatrix.getMaxScaleOnAxis(),h=t.clone().add(a);h.z+=i.z;const l=t.clone().add(a);l.z+=n.z;const d=h.clone();d.y+=o;const c=l.clone();c.y+=o,h.applyMat4(this.camera.viewProjectionMatrix),l.applyMat4(this.camera.viewProjectionMatrix),d.applyMat4(this.camera.viewProjectionMatrix),c.applyMat4(this.camera.viewProjectionMatrix);const f=h.distance(d),p=l.distance(c),m={xMin:h.x-f,xMax:h.x+f,yMin:h.y-f,yMax:h.y+f},g={xMin:l.x-p,xMax:l.x+p,yMin:l.y-p,yMax:l.y+p},v={xMin:Math.min(m.xMin,g.xMin),yMin:Math.min(m.yMin,g.yMin),xMax:Math.max(m.xMax,g.xMax),yMax:Math.max(m.yMax,g.yMax)},x=l.add(h).multiplyScalar(.5).clone();x.x=(v.xMax+v.xMin)/2,x.y=(v.yMax+v.yMin)/2;const b=Math.max(v.xMax-v.xMin,v.yMax-v.yMin)*.5;return{center:x,radius:b}}checkFrustumCulling(){this.matricesNeedUpdate&&this.domFrustum&&this.frustumCulling&&(this.frustumCulling==="sphere"?this.domFrustum.setDocumentCoordsFromClipSpaceSphere(this.clipSpaceBoundingSphere):this.domFrustum.setDocumentCoordsFromClipSpaceOBB(),this.domFrustum.intersectsContainer())}onBeforeRenderPass(){this.material&&this.matricesNeedUpdate&&this.material.shouldUpdateInputsBindings("matrices"),super.onBeforeRenderPass()}onRenderPass(t){this.ready&&(this.domFrustum&&this.domFrustum.isIntersecting||!this.frustumCulling)&&(this.material.render(t),this.geometry.render(t))}destroy(){this.options.castShadows&&this.renderer.shadowCastingLights.forEach(t=>{t.shadow.isActive&&t.shadow.removeMesh(this)}),this.options.receiveShadows&&this.renderer.shadowCastingLights.forEach(t=>{t.shadow.removeShadowReceivingMesh(this)}),super.destroy()}}}u(_n,"ProjectedMeshBaseMixin");class Xi extends _n(ki){static{u(this,"Mesh")}constructor(e,t={}){e=Ae(e,t.label?t.label+" Mesh":"Mesh"),super(e,null,t),this.type="Mesh"}}var Ln=u(r=>{throw TypeError(r)},"__typeError$h"),Yi=u((r,e,t)=>e.has(r)||Ln("Cannot "+t),"__accessCheck$h"),le=u((r,e,t)=>(Yi(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet$f"),Ve=u((r,e,t)=>e.has(r)?Ln("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$h"),Ne=u((r,e,t,s)=>(Yi(r,e,"write to private field"),e.set(r,t),t),"__privateSet$f"),An=u((r,e,t)=>(Yi(r,e,"access private method"),t),"__privateMethod$9"),Ys,Ks,Js,Zs,jt,We,it,Qs,Ki;const Ji={isActive:{type:"i32",value:0},pcfSamples:{type:"i32",value:0},bias:{type:"f32",value:0},normalBias:{type:"f32",value:0},intensity:{type:"f32",value:0}};class Zi{static{u(this,"Shadow")}constructor(e,{light:t,intensity:s=1,bias:i=0,normalBias:n=0,pcfSamples:a=1,depthTextureSize:o=new _(512),depthTextureFormat:h="depth24plus",autoRender:l=!0}={}){Ve(this,Qs),Ve(this,Ys),Ve(this,Ks),Ve(this,Js),Ve(this,Zs),Ve(this,jt),Ve(this,We),Ve(this,it),this.setRenderer(e),this.light=t,this.index=this.light.index,this.options={light:t,intensity:s,bias:i,normalBias:n,pcfSamples:a,depthTextureSize:o,depthTextureFormat:h},this.sampleCount=1,this.castingMeshes=new Map,Ne(this,it,new Map),this.depthMeshes=new Map,An(this,Qs,Ki).call(this,{intensity:s,bias:i,normalBias:n,pcfSamples:a,depthTextureSize:o,depthTextureFormat:h,autoRender:l}),this.isActive=!1}setRenderer(e){const t=this.renderer;e=Ae(e,this.constructor.name),this.renderer=e,this.setRendererBinding(),this.depthPassTarget&&this.depthPassTarget.setRenderer(this.renderer),this.castingMeshes=new Map,this.renderer.meshes.forEach(s=>{"castShadows"in s.options&&s.options.castShadows&&this.castingMeshes.set(s.uuid,s)}),this.depthMeshes?.forEach(s=>{s.setRenderer(this.renderer)}),t&&(this.reset(),le(this,We)&&this.setDepthPass())}setRendererBinding(){this.rendererBinding=null}cast({intensity:e,bias:t,normalBias:s,pcfSamples:i,depthTextureSize:n,depthTextureFormat:a,autoRender:o}={}){An(this,Qs,Ki).call(this,{intensity:e,bias:t,normalBias:s,pcfSamples:i,depthTextureSize:n,depthTextureFormat:a,autoRender:o}),this.isActive=!0}reset(){this.onPropertyChanged("isActive",this.isActive?1:0),this.isActive&&(this.onPropertyChanged("intensity",this.intensity),this.onPropertyChanged("bias",this.bias),this.onPropertyChanged("normalBias",this.normalBias),this.onPropertyChanged("pcfSamples",this.pcfSamples))}onPropertyChanged(e,t){if(this.rendererBinding&&this.rendererBinding.childrenBindings.length>this.index){if(t instanceof D){for(let s=0;s<t.elements.length;s++)this.rendererBinding.childrenBindings[this.index].inputs[e].value[s]=t.elements[s];this.rendererBinding.childrenBindings[this.index].inputs[e].shouldUpdate=!0}else this.rendererBinding.childrenBindings[this.index].inputs[e].value=t;this.renderer.shouldUpdateCameraLightsBindGroup()}}get isActive(){return le(this,jt)}set isActive(e){!e&&this.isActive?this.destroy():e&&!this.isActive&&this.init(),Ne(this,jt,e)}get intensity(){return le(this,Ys)}set intensity(e){Ne(this,Ys,e),this.onPropertyChanged("intensity",this.intensity)}get bias(){return le(this,Ks)}set bias(e){Ne(this,Ks,e),this.onPropertyChanged("bias",this.bias)}get normalBias(){return le(this,Js)}set normalBias(e){Ne(this,Js,e),this.onPropertyChanged("normalBias",this.normalBias)}get pcfSamples(){return le(this,Zs)}set pcfSamples(e){Ne(this,Zs,Math.max(1,Math.ceil(e))),this.onPropertyChanged("pcfSamples",this.pcfSamples)}init(){if(!this.depthComparisonSampler){const e=this.renderer.samplers.find(t=>t.name==="depthComparisonSampler");this.depthComparisonSampler=e||new et(this.renderer,{label:"Depth comparison sampler",name:"depthComparisonSampler",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",compare:"less",minFilter:"linear",magFilter:"linear",type:"comparison"})}this.setDepthTexture(),this.depthTextureSize.onChange(()=>this.onDepthTextureSizeChanged()),this.depthPassTarget||this.createDepthPassTarget(),le(this,We)&&(this.setDepthPass(),this.onPropertyChanged("isActive",1))}onDepthTextureSizeChanged(){this.setDepthTexture()}setDepthTexture(){this.depthTexture&&(this.depthTexture.size.width!==this.depthTextureSize.x||this.depthTexture.size.height!==this.depthTextureSize.y)?(this.depthTexture.options.fixedSize.width=this.depthTextureSize.x,this.depthTexture.options.fixedSize.height=this.depthTextureSize.y,this.depthTexture.size.width=this.depthTextureSize.x,this.depthTexture.size.height=this.depthTextureSize.y,this.depthTexture.createTexture(),this.depthPassTarget&&this.depthPassTarget.resize()):this.depthTexture||this.createDepthTexture()}createDepthTexture(){}destroyDepthTexture(){this.depthTexture?.destroy(),this.depthTexture=null,this.depthTextureSize.onChange(()=>{})}clearDepthTexture(){if(!this.depthTexture||!this.depthTexture.texture)return;const e=this.renderer.device.createCommandEncoder();!this.renderer.production&&e.pushDebugGroup(`Clear ${this.depthTexture.texture.label} command encoder`);const t={colorAttachments:[],depthStencilAttachment:{view:this.depthTexture.texture.createView({label:"Clear "+this.depthTexture.texture.label+" view"}),depthLoadOp:"clear",depthClearValue:1,depthStoreOp:"store"}};e.beginRenderPass(t).end(),!this.renderer.production&&e.popDebugGroup(),this.renderer.device.queue.submit([e.finish()])}createDepthPassTarget(){this.depthPassTarget=new Ii(this.renderer,{label:"Depth pass render target for "+this.constructor.name+" "+this.index,useColorAttachments:!1,depthTexture:this.depthTexture,sampleCount:this.sampleCount,autoRender:le(this,We)})}setDepthPass(){const e=this.renderer.scene.getRenderTargetPassEntry(this.depthPassTarget);e.useCustomRenderPass=t=>this.render(t)}render(e){if(!this.castingMeshes.size)return;let t=!1;for(const[s,i]of this.castingMeshes)if(i.visible){t=!0;break}if(!t){this.clearDepthTexture();return}this.renderDepthPass(e),this.renderer.pipelineManager.resetCurrentPipeline()}async renderOnce(){le(this,We)||(this.onPropertyChanged("isActive",1),await Promise.all([...this.depthMeshes.values()].map(async e=>{e.setGeometry(),await e.material.compileMaterial()})),this.renderer.onBeforeRenderScene.add(e=>{this.render(e)},{once:!0}))}renderDepthPass(e){this.renderer.pipelineManager.resetCurrentPipeline();const t=e.beginRenderPass(this.depthPassTarget.renderPass.descriptor);this.renderer.production||t.pushDebugGroup(`${this.constructor.name} (index: ${this.index}): depth pass`);for(const[s,i]of this.depthMeshes)this.castingMeshes.get(s)?.visible&&i.render(t);this.renderer.production||t.popDebugGroup(),t.end()}getDefaultShadowDepthVs({bindings:e=[],geometry:t}){return{code:"@vertex fn main(@location(0) position: vec4f) -> @builtin(position) vec4f { return position; }"}}getDefaultShadowDepthFs(){return!1}patchShadowCastingMeshParams(e,t={}){t={...e.material.options.rendering,...t};const s=[];e.material.inputsBindings.forEach(n=>{(n.name.includes("skin")||n.name.includes("morphTarget"))&&s.push(n)});const i=e.material.getBufferBindingByName("instances");return i&&s.push(i),t.bindings?t.bindings=[...s,...t.bindings]:t.bindings=[...s],t.shaders||(t.shaders={vertex:this.getDefaultShadowDepthVs({bindings:s,geometry:e.geometry}),fragment:this.getDefaultShadowDepthFs()}),t}addShadowCastingMesh(e,t={}){if(this.castingMeshes.get(e.uuid))return;e.options.castShadows=!0,t=this.patchShadowCastingMeshParams(e,t),this.depthMeshes.get(e.uuid)&&(this.depthMeshes.get(e.uuid).remove(),this.depthMeshes.delete(e.uuid));const s=new Xi(this.renderer,{label:`${this.constructor.name} (index: ${this.index}) ${e.options.label} depth mesh`,...t,geometry:e.geometry,targets:[],outputTarget:this.depthPassTarget,autoRender:le(this,We)});s.parent=e,this.depthMeshes.set(e.uuid,s),this.castingMeshes.set(e.uuid,e)}addShadowReceivingMesh(e){le(this,it).set(e.uuid,e)}removeShadowReceivingMesh(e){le(this,it).delete(e.uuid),le(this,it).size===0&&!this.isActive&&this.destroyDepthTexture()}removeMesh(e){const t=this.depthMeshes.get(e.uuid);t&&(t.remove(),this.depthMeshes.delete(e.uuid)),this.castingMeshes.delete(e.uuid),this.castingMeshes.size===0&&this.clearDepthTexture()}updateMeshGeometry(e,t){const s=this.depthMeshes.get(e.uuid);s&&s.useGeometry(t)}destroy(){this.onPropertyChanged("isActive",0),Ne(this,jt,!1),this.castingMeshes.forEach(e=>this.removeMesh(e)),this.castingMeshes=new Map,this.depthMeshes=new Map,this.depthPassTarget?.destroy(),le(this,it).size===0&&this.destroyDepthTexture()}}Ys=new WeakMap,Ks=new WeakMap,Js=new WeakMap,Zs=new WeakMap,jt=new WeakMap,We=new WeakMap,it=new WeakMap,Qs=new WeakSet,Ki=u(function({intensity:r=1,bias:e=0,normalBias:t=0,pcfSamples:s=1,depthTextureSize:i=new _(512),depthTextureFormat:n="depth24plus",autoRender:a=!0}={}){this.intensity=r,this.bias=e,this.normalBias=t,this.pcfSamples=s,this.depthTextureSize=i,this.depthTextureFormat=n,Ne(this,We,a)},"setParameters_fn");const ei=u(({geometry:r})=>{let e=r.vertexBuffers.map(t=>t.attributes.map(s=>`
  var ${s.name}: ${s.type} = attributes.${s.name};`).join("")).join(`
`);return e+=`
  var instanceIndex: u32 = attributes.instanceIndex;
  `,e},"declareAttributesVars$1"),gh=u(({bindings:r=[],geometry:e})=>{let t="";return r.filter(i=>i.name.includes("morphTarget")).forEach(i=>{const n=Object.values(i.inputs).filter(a=>a.name!=="weight");n.forEach(a=>{const o=xe.getType(a.type),h=e.getAttributeByName(a.name);if(h){const l=h.type,d=n.length===1?`${i.name}.${a.name}[attributes.vertexIndex]`:`${i.name}.elements[attributes.vertexIndex].${a.name}`;o===l?t+=`${a.name} += ${i.name}.weight * ${d};
	`:o==="vec3f"&&l==="vec4f"&&(t+=`${a.name} += ${i.name}.weight * vec4(${d}, 0.0);
	`)}})}),t},"getMorphTargets"),yh=u(({bindings:r=[],geometry:e})=>{let t="";const s=e.instancesCount>1&&r.find(h=>h.name==="instances"),i=[],n=[];e.vertexBuffers&&e.vertexBuffers.length&&e.vertexBuffers.forEach(h=>{h.attributes.forEach(l=>{l.name.includes("joints")&&i.push(l),l.name.includes("weights")&&n.push(l)})});const a=r.filter(h=>h.name.includes("skin")),o=i.length&&n.length&&a.length;return o&&(t+=s?`
  var instancesWorldPosition = array<vec4f, ${e.instancesCount}>();
  var instancesNormal = array<vec3f, ${e.instancesCount}>();
      `:"",t+=`
  let skinJoints: vec4f = ${i.map(h=>h.name).join(" + ")};`,t+=`
  var skinWeights: vec4f = ${n.map(h=>h.name).join(" + ")};
  
  let skinWeightsSum = dot(skinWeights, vec4(1.0));
  if(skinWeightsSum > 0.0) {
    skinWeights = skinWeights / skinWeightsSum;
  }
    `,a.forEach((h,l)=>{t+=`
  ${s?"// instancing with different skins: joints calculations for skin "+l+`
`:""}
  // position
  let skinMatrix_${l}: mat4x4f = 
    skinWeights.x * ${h.name}.joints[u32(skinJoints.x)].jointMatrix +
    skinWeights.y * ${h.name}.joints[u32(skinJoints.y)].jointMatrix +
    skinWeights.z * ${h.name}.joints[u32(skinJoints.z)].jointMatrix +
    skinWeights.w * ${h.name}.joints[u32(skinJoints.w)].jointMatrix;
      
  ${s?"instancesWorldPosition["+l+"] = skinMatrix_"+l+" * worldPosition;":"worldPosition = skinMatrix_"+l+" * worldPosition;"}
      
  // normal
  let skinNormalMatrix_${l}: mat4x4f = 
    skinWeights.x * ${h.name}.joints[u32(skinJoints.x)].normalMatrix +
    skinWeights.y * ${h.name}.joints[u32(skinJoints.y)].normalMatrix +
    skinWeights.z * ${h.name}.joints[u32(skinJoints.z)].normalMatrix +
    skinWeights.w * ${h.name}.joints[u32(skinJoints.w)].normalMatrix;
    
  let skinNormalMatrix_${l}_3: mat3x3f = mat3x3f(
    vec3(skinNormalMatrix_${l}[0].xyz),
    vec3(skinNormalMatrix_${l}[1].xyz),
    vec3(skinNormalMatrix_${l}[2].xyz)
  );
      
  ${s?"instancesNormal["+l+"] = skinNormalMatrix_"+l+"_3 * normal;":"normal = skinNormalMatrix_"+l+"_3 * normal;"}
      `})),t+=`
  var modelMatrix: mat4x4f;
  `,s?(o&&(t+=`
  worldPosition = instancesWorldPosition[instanceIndex];
  normal = instancesNormal[instanceIndex];
      `),t+=`
  modelMatrix = instances.matrices[instanceIndex].model;
  worldPosition = modelMatrix * worldPosition;
  
  normal = normalize(instances.matrices[instanceIndex].normal * normal);
    `):t+=`
  modelMatrix = matrices.model;
  worldPosition = modelMatrix * worldPosition;
  normal = getWorldNormal(normal);
    `,t},"getVertexSkinnedPositionNormal"),ti=u(({bindings:r=[],geometry:e})=>{let t="";return t+=gh({bindings:r,geometry:e}),t+=`
  var worldPosition: vec4f = vec4(position, 1.0);
  `,t+=yh({bindings:r,geometry:e}),t},"getVertexTransformedPositionNormal"),xh=u((r=0,{bindings:e=[],geometry:t})=>`
@vertex fn main(
  attributes: Attributes,
) -> @builtin(position) vec4f {  
  let directionalShadow: DirectionalShadowsElement = directionalShadows.directionalShadowsElements[${r}];
  
  ${ei({geometry:t})}
  ${ti({bindings:e,geometry:t})}
  
  let worldPos = worldPosition.xyz / worldPosition.w;
  
  let lightDirection: vec3f = normalize(worldPos - directionalLights.elements[${r}].direction);
  let NdotL: f32 = dot(normal, lightDirection);
  let sinNdotL = sqrt(1.0 - NdotL * NdotL);
  let normalBias: f32 = directionalShadow.normalBias * sinNdotL;
  
  worldPosition = vec4(worldPos - normal * normalBias, 1.0);
  
  return directionalShadow.projectionMatrix * directionalShadow.viewMatrix * worldPosition;
}`,"getDefaultDirectionalShadowDepthVs"),vh={...Ji,viewMatrix:{type:"mat4x4f",value:new Float32Array(16)},projectionMatrix:{type:"mat4x4f",value:new Float32Array(16)}};class bh extends Zi{static{u(this,"DirectionalShadow")}constructor(e,{light:t,intensity:s,bias:i,normalBias:n,pcfSamples:a,depthTextureSize:o,depthTextureFormat:h,autoRender:l,camera:d={left:-10,right:10,bottom:-10,top:10,near:.1,far:50}}={}){super(e,{light:t,intensity:s,bias:i,normalBias:n,pcfSamples:a,depthTextureSize:o,depthTextureFormat:h,autoRender:l}),this.options={...this.options,camera:d},this.camera={projectionMatrix:new D,viewMatrix:new D,up:new y(0,1,0),_left:d.left,_right:d.right,_bottom:d.bottom,_top:d.top,_near:d.near,_far:d.far};const c=this;["left","right","bottom","top","near","far"].forEach(p=>{Object.defineProperty(c.camera,p,{get(){return c.camera["_"+p]},set(m){c.camera["_"+p]=m,c.updateProjectionMatrix()}})})}setRendererBinding(){this.rendererBinding=this.renderer.bindings.directionalShadows}cast({intensity:e,bias:t,normalBias:s,pcfSamples:i,depthTextureSize:n,depthTextureFormat:a,autoRender:o,camera:h}={}){h&&(this.camera.left=h.left??-10,this.camera.right=h.right??10,this.camera.bottom=h.bottom??-10,this.camera.top=h.right??10,this.camera.near=h.near??.1,this.camera.far=h.far??50),super.cast({intensity:e,bias:t,normalBias:s,pcfSamples:i,depthTextureSize:n,depthTextureFormat:a,autoRender:o})}init(){super.init(),this.updateProjectionMatrix()}reset(){this.setRendererBinding(),super.reset(),this.isActive&&(this.onPropertyChanged("projectionMatrix",this.camera.projectionMatrix),this.onPropertyChanged("viewMatrix",this.camera.viewMatrix))}updateProjectionMatrix(){this.camera.projectionMatrix.identity().makeOrthographic({left:this.camera.left,right:this.camera.right,bottom:this.camera.bottom,top:this.camera.top,near:this.camera.near,far:this.camera.far}),this.onPropertyChanged("projectionMatrix",this.camera.projectionMatrix)}updateViewMatrix(e=new y,t=new y){e.x===0&&e.z===0?this.camera.up.set(0,0,1):this.camera.up.set(0,1,0),this.camera.viewMatrix.makeView(e,t,this.camera.up),this.onPropertyChanged("viewMatrix",this.camera.viewMatrix)}createDepthTexture(){this.depthTexture=new q(this.renderer,{label:`${this.light.options.label} (index: ${this.index}) shadow depth texture`,name:"directionalShadowDepthTexture"+this.index,type:"depth",format:this.depthTextureFormat,sampleCount:this.sampleCount,fixedSize:{width:this.depthTextureSize.x,height:this.depthTextureSize.y},autoDestroy:!1})}getDefaultShadowDepthVs({bindings:e=[],geometry:t}){return{code:xh(this.index,{bindings:e,geometry:t})}}}var Dn=u(r=>{throw TypeError(r)},"__typeError$g"),$n=u((r,e,t)=>e.has(r)||Dn("Cannot "+t),"__accessCheck$g"),rt=u((r,e,t)=>($n(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet$e"),Gn=u((r,e,t)=>e.has(r)?Dn("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$g"),Fn=u((r,e,t,s)=>($n(r,e,"write to private field"),e.set(r,t),t),"__privateSet$e"),nt,yt;class Qi extends Hs{static{u(this,"DirectionalLight")}constructor(e,{label:t="DirectionalLight",color:s=new y(1),intensity:i=1,position:n=new y(1),target:a=new y,shadow:o=null}={}){super(e,{label:t,color:s,intensity:i,type:"directionalLights"}),Gn(this,nt),Gn(this,yt),this.options={...this.options,position:n,target:a,shadow:o},Fn(this,yt,new y),Fn(this,nt,new y),this.target=a,this.target.onChange(()=>this.setDirection()),this.position.copy(n),this.parent=this.renderer.scene,this.shadow=new bh(this.renderer,{autoRender:!1,light:this}),o&&this.shadow.cast(o)}setRenderer(e){super.setRenderer(e),this.shadow&&(this.shadow.setRenderer(e),this.shadow.updateViewMatrix(rt(this,nt),this.target))}reset(e=!0){super.reset(),this.onPropertyChanged("direction",rt(this,yt)),this.shadow&&e&&(this.shadow.reset(),this.shadow.updateViewMatrix(rt(this,nt),this.target))}setDirection(){rt(this,yt).copy(this.target).sub(this.worldMatrix.getTranslation(rt(this,nt))).normalize(),this.onPropertyChanged("direction",rt(this,yt)),this.shadow?.updateViewMatrix(rt(this,nt),this.target)}applyScale(){}applyTransformOrigin(){}updateMatrixStack(){super.updateMatrixStack(),this.matricesNeedUpdate&&this.setDirection()}onMaxLightOverflow(e){super.onMaxLightOverflow(e),this.shadow?.setRendererBinding()}destroy(){super.destroy(),this.shadow.destroy()}}nt=new WeakMap,yt=new WeakMap;const wh=u((r=0,{bindings:e=[],geometry:t})=>`
struct PointShadowVSOutput {
  @builtin(position) position: vec4f,
  @location(0) worldPosition: vec3f,
}

@vertex fn main(
  attributes: Attributes,
) -> PointShadowVSOutput {  
  var pointShadowVSOutput: PointShadowVSOutput;
  let pointShadow: PointShadowsElement = pointShadows.pointShadowsElements[${r}];
  
  ${ei({geometry:t})}
  ${ti({bindings:e,geometry:t})}
  
  let worldPos = worldPosition.xyz / worldPosition.w;  
  
  let lightDirection: vec3f = normalize(pointLights.elements[${r}].position - worldPos);
  let NdotL: f32 = dot(normalize(normal), lightDirection);
  let sinNdotL = sqrt(1.0 - NdotL * NdotL);
  let normalBias: f32 = pointShadow.normalBias * sinNdotL;
  
  worldPosition = vec4(worldPos - normal * normalBias, 1.0);
    
  let shadowPosition: vec4f = pointShadow.projectionMatrix * pointShadow.viewMatrices[cubeFace.face] * worldPosition;

  pointShadowVSOutput.position = shadowPosition;
  pointShadowVSOutput.worldPosition = worldPos;

  return pointShadowVSOutput;
}`,"getDefaultPointShadowDepthVs"),Ch=u((r=0)=>`
struct PointShadowVSOutput {
  @builtin(position) position: vec4f,
  @location(0) worldPosition: vec3f,
}

@fragment fn main(fsInput: PointShadowVSOutput) -> @builtin(frag_depth) f32 {
  // get distance between fragment and light source
  var lightDistance: f32 = length(fsInput.worldPosition - pointLights.elements[${r}].position);
  
  let pointShadow: PointShadowsElement = pointShadows.pointShadowsElements[${r}];
  
  // map to [0, 1] range by dividing by far plane - near plane
  lightDistance = (lightDistance - pointShadow.cameraNear) / (pointShadow.cameraFar - pointShadow.cameraNear);
  
  // write this as modified depth
  return clamp(lightDistance, 0.0, 1.0);
}`,"getDefaultPointShadowDepthFs");var On=u(r=>{throw TypeError(r)},"__typeError$f"),Un=u((r,e,t)=>e.has(r)||On("Cannot "+t),"__accessCheck$f"),In=u((r,e,t)=>(Un(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet$d"),Mh=u((r,e,t)=>e.has(r)?On("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$f"),Bh=u((r,e,t,s)=>(Un(r,e,"write to private field"),e.set(r,t),t),"__privateSet$d"),qt;const Sh={...Ji,cameraNear:{type:"f32",value:0},cameraFar:{type:"f32",value:0},projectionMatrix:{type:"mat4x4f",value:new Float32Array(16)},viewMatrices:{type:"array<mat4x4f>",value:new Float32Array(16*6)}};class Th extends Zi{static{u(this,"PointShadow")}constructor(e,{light:t,intensity:s,bias:i,normalBias:n,pcfSamples:a,depthTextureSize:o,depthTextureFormat:h,autoRender:l,camera:d={near:.1,far:150}}={}){super(e,{light:t,intensity:s,bias:i,normalBias:n,pcfSamples:a,depthTextureSize:o,depthTextureFormat:h,autoRender:l}),Mh(this,qt),this.options={...this.options,camera:d},this.cubeDirections=[new y(-1,0,0),new y(1,0,0),new y(0,-1,0),new y(0,1,0),new y(0,0,-1),new y(0,0,1)],Bh(this,qt,new y),this.cubeUps=[new y(0,-1,0),new y(0,-1,0),new y(0,0,1),new y(0,0,-1),new y(0,-1,0),new y(0,-1,0)],d.far<=0&&(d.far=150),this.camera={projectionMatrix:new D,viewMatrices:[],_near:d.near,_far:d.far};for(let p=0;p<6;p++)this.camera.viewMatrices.push(new D);const c=this;["near","far"].forEach(p=>{Object.defineProperty(c.camera,p,{get(){return c.camera["_"+p]},set(m){c.camera["_"+p]=m,c.updateProjectionMatrix()}})})}setRendererBinding(){this.rendererBinding=this.renderer.bindings.pointShadows}cast({intensity:e,bias:t,normalBias:s,pcfSamples:i,depthTextureSize:n,depthTextureFormat:a,autoRender:o,camera:h}={}){h&&(this.camera.near=h.near??.1,this.camera.far=h.far!==void 0?h.far:this.light.range>0?this.light.range:150),super.cast({intensity:e,bias:t,normalBias:s,pcfSamples:i,depthTextureSize:n,depthTextureFormat:a,autoRender:o})}init(){super.init(),this.updateProjectionMatrix()}reset(){this.setRendererBinding(),super.reset(),this.updateProjectionMatrix()}updateProjectionMatrix(){this.camera.projectionMatrix.identity().makePerspective({near:this.camera.near,far:this.camera.far,fov:90,aspect:1}),this.onPropertyChanged("projectionMatrix",this.camera.projectionMatrix),this.onPropertyChanged("cameraNear",this.camera.near),this.onPropertyChanged("cameraFar",this.camera.far)}updateViewMatrices(e=new y){for(let t=0;t<6;t++){In(this,qt).copy(this.cubeDirections[t]).add(e),this.camera.viewMatrices[t].makeView(e,In(this,qt),this.cubeUps[t]);for(let s=0;s<16;s++)this.rendererBinding.childrenBindings[this.index].inputs.viewMatrices.value[t*16+s]=this.camera.viewMatrices[t].elements[s]}this.rendererBinding.childrenBindings[this.index].inputs.viewMatrices.shouldUpdate=!0}setDepthTexture(){if(this.depthTexture&&(this.depthTexture.size.width!==this.depthTextureSize.x||this.depthTexture.size.height!==this.depthTextureSize.y)){const e=Math.max(this.depthTextureSize.x,this.depthTextureSize.y);this.depthTexture.options.fixedSize.width=e,this.depthTexture.options.fixedSize.height=e,this.depthTexture.size.width=e,this.depthTexture.size.height=e,this.depthTexture.createTexture(),this.depthPassTarget&&this.depthPassTarget.resize()}else this.depthTexture||this.createDepthTexture()}createDepthTexture(){const e=Math.max(this.depthTextureSize.x,this.depthTextureSize.y);this.depthTexture=new q(this.renderer,{label:`${this.light.options.label} (index: ${this.index}) shadow depth texture`,name:"pointShadowCubeDepthTexture"+this.index,type:"depth",format:this.depthTextureFormat,viewDimension:"cube",sampleCount:this.sampleCount,fixedSize:{width:e,height:e},autoDestroy:!1})}clearDepthTexture(){if(!this.depthTexture||!this.depthTexture.texture)return;const e=this.renderer.device.createCommandEncoder();!this.renderer.production&&e.pushDebugGroup(`Clear ${this.depthTexture.texture.label} command encoder`);for(let t=0;t<6;t++){const s=this.depthTexture.texture.createView({label:"Clear "+this.depthTexture.texture.label+" cube face view",dimension:"2d",arrayLayerCount:1,baseArrayLayer:t}),i={colorAttachments:[],depthStencilAttachment:{view:s,depthLoadOp:"clear",depthClearValue:1,depthStoreOp:"store"}};e.beginRenderPass(i).end()}!this.renderer.production&&e.popDebugGroup(),this.renderer.device.queue.submit([e.finish()])}render(e){if(!this.castingMeshes.size)return;let t=!1;for(const[s,i]of this.castingMeshes)if(i.visible){t=!0;break}if(!t){this.clearDepthTexture();return}for(let s=0;s<6;s++)this.depthPassTarget.renderPass.setRenderPassDescriptor(this.depthTexture.texture.createView({label:this.depthTexture.texture.label+" cube face view "+s,dimension:"2d",arrayLayerCount:1,baseArrayLayer:s})),this.renderDepthPass(e,s);this.renderer.pipelineManager.resetCurrentPipeline()}renderDepthPass(e,t=0){this.renderer.pipelineManager.resetCurrentPipeline();const s=e.beginRenderPass(this.depthPassTarget.renderPass.descriptor);this.renderer.production||s.pushDebugGroup(`${this.constructor.name} (index: ${this.index}): depth pass for face ${t}`);for(const[i,n]of this.depthMeshes){if(!this.castingMeshes.get(i)?.visible)continue;const a=n.material.bindGroups.length-1;this.renderer.pointShadowsCubeFaceBindGroups[t].setIndex(a),n.material.bindGroups[a]=this.renderer.pointShadowsCubeFaceBindGroups[t],n.render(s)}this.renderer.production||s.popDebugGroup(),s.end()}getDefaultShadowDepthVs({bindings:e=[],geometry:t}){return{code:wh(this.index,{bindings:e,geometry:t})}}getDefaultShadowDepthFs(){return{code:Ch(this.index)}}patchShadowCastingMeshParams(e,t={}){return t.bindGroups||(t.bindGroups=[]),t.bindGroups=[...t.bindGroups,this.renderer.pointShadowsCubeFaceBindGroups[0]],super.patchShadowCastingMeshParams(e,t)}}qt=new WeakMap;var kn=u(r=>{throw TypeError(r)},"__typeError$e"),Vn=u((r,e,t)=>e.has(r)||kn("Cannot "+t),"__accessCheck$e"),xt=u((r,e,t)=>(Vn(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet$c"),Nn=u((r,e,t)=>e.has(r)?kn("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$e"),Wn=u((r,e,t,s)=>(Vn(r,e,"write to private field"),e.set(r,t),t),"__privateSet$c"),si,je;class jn extends Hs{static{u(this,"PointLight")}constructor(e,{label:t="PointLight",color:s=new y(1),intensity:i=1,position:n=new y,range:a=0,shadow:o=null}={}){super(e,{label:t,color:s,intensity:i,type:"pointLights"}),Nn(this,si),Nn(this,je),this.options={...this.options,position:n,range:a,shadow:o},Wn(this,je,new y),this.position.copy(n),this.range=a,this.parent=this.renderer.scene,this.shadow=new Th(this.renderer,{autoRender:!1,light:this}),o&&this.shadow.cast(o)}setRenderer(e){super.setRenderer(e),this.shadow&&(this.shadow.setRenderer(e),this.shadow.updateViewMatrices(xt(this,je)))}reset(e=!0){super.reset(),this.onPropertyChanged("range",this.range),this.onPropertyChanged("position",this.worldMatrix.getTranslation(xt(this,je))),this.shadow&&e&&(this.shadow.reset(),this.shadow.updateViewMatrices(xt(this,je)))}get range(){return xt(this,si)}set range(e){Wn(this,si,e),this.onPropertyChanged("range",this.range)}setPosition(){this.onPropertyChanged("position",this.worldMatrix.getTranslation(xt(this,je))),this.shadow?.updateViewMatrices(xt(this,je))}applyScale(){}applyTransformOrigin(){}updateMatrixStack(){super.updateMatrixStack(),this.matricesNeedUpdate&&this.setPosition()}onMaxLightOverflow(e){super.onMaxLightOverflow(e),this.shadow?.setRendererBinding()}destroy(){super.destroy(),this.shadow.destroy()}}si=new WeakMap,je=new WeakMap;const Ph=u((r=0,{bindings:e=[],geometry:t})=>`
@vertex fn main(
  attributes: Attributes,
) -> @builtin(position) vec4f {  
  let spotShadow: SpotShadowsElement = spotShadows.spotShadowsElements[${r}];
  
  ${ei({geometry:t})}
  ${ti({bindings:e,geometry:t})}
  
  let worldPos = worldPosition.xyz / worldPosition.w;
  
  let lightDirection: vec3f = normalize(worldPos - spotLights.elements[${r}].direction);
  let NdotL: f32 = dot(normal, lightDirection);
  let sinNdotL = sqrt(1.0 - NdotL * NdotL);
  let normalBias: f32 = spotShadow.normalBias * sinNdotL;
  
  worldPosition = vec4(worldPos - normal * normalBias, 1.0);
  
  return spotShadow.projectionMatrix * spotShadow.viewMatrix * worldPosition;
}`,"getDefaultSpotShadowDepthVs"),Rh={...Ji,viewMatrix:{type:"mat4x4f",value:new Float32Array(16)},projectionMatrix:{type:"mat4x4f",value:new Float32Array(16)}};class Eh extends Zi{static{u(this,"SpotShadow")}constructor(e,{light:t,intensity:s=1,bias:i=0,normalBias:n=0,pcfSamples:a=1,depthTextureSize:o=new _(512),depthTextureFormat:h="depth24plus",autoRender:l=!0}={}){super(e,{light:t,intensity:s,bias:i,normalBias:n,pcfSamples:a,depthTextureSize:o,depthTextureFormat:h,autoRender:l}),this.focus=1,this.camera=new ks({near:.1,far:this.light.range!==0?this.light.range:500,fov:180/Math.PI*2*this.light.angle*this.focus,width:this.options.depthTextureSize.x,height:this.options.depthTextureSize.y,onMatricesChanged:u(()=>{this.onPropertyChanged("projectionMatrix",this.camera.projectionMatrix),this.onPropertyChanged("viewMatrix",this.camera.viewMatrix)},"onMatricesChanged")}),this.camera.position.set(0),this.camera.parent=this.light}setRendererBinding(){this.rendererBinding=this.renderer.bindings.spotShadows}reset(){this.setRendererBinding(),super.reset(),this.onPropertyChanged("projectionMatrix",this.camera.projectionMatrix),this.onPropertyChanged("viewMatrix",this.camera.viewMatrix)}setCameraFov(){this.camera.fov=180/Math.PI*2*this.light.angle*this.focus}updateLookAt(e=new y){e.x===0&&e.z===0?this.camera.up.set(0,0,1):this.camera.up.set(0,1,0),this.camera.lookAt(this.light.target,e)}onDepthTextureSizeChanged(){super.setDepthTexture(),this.camera.setSize({width:this.depthTextureSize.x,height:this.depthTextureSize.y})}createDepthTexture(){this.depthTexture=new q(this.renderer,{label:`${this.light.options.label} (index: ${this.light.index}) shadow depth texture`,name:"spotShadowDepthTexture"+this.index,type:"depth",format:this.depthTextureFormat,sampleCount:this.sampleCount,fixedSize:{width:this.depthTextureSize.x,height:this.depthTextureSize.y},autoDestroy:!1})}getDefaultShadowDepthVs({bindings:e=[],geometry:t}){return{code:Ph(this.index,{bindings:e,geometry:t})}}}var qn=u(r=>{throw TypeError(r)},"__typeError$d"),Hn=u((r,e,t)=>e.has(r)||qn("Cannot "+t),"__accessCheck$d"),ze=u((r,e,t)=>(Hn(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet$b"),Ht=u((r,e,t)=>e.has(r)?qn("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$d"),Xt=u((r,e,t,s)=>(Hn(r,e,"write to private field"),e.set(r,t),t),"__privateSet$b"),at,vt,ii,ri,ni;class er extends Hs{static{u(this,"SpotLight")}constructor(e,{label:t="SpotLight",color:s=new y(1),intensity:i=1,position:n=new y(1),target:a=new y,angle:o=Math.PI/3,penumbra:h=0,range:l=0,shadow:d=null}={}){super(e,{label:t,color:s,intensity:i,type:"spotLights"}),Ht(this,at),Ht(this,vt),Ht(this,ii),Ht(this,ri),Ht(this,ni),Xt(this,vt,new y),Xt(this,at,new y),this.target=a,this.target.onChange(()=>this.setPositionDirection()),this.position.copy(n),this.angle=o,this.penumbra=h,this.range=l,this.parent=this.renderer.scene,this.shadow=new Eh(this.renderer,{autoRender:!1,light:this}),d&&this.shadow.cast(d)}setRenderer(e){super.setRenderer(e),this.shadow&&this.shadow.setRenderer(e)}reset(e=!0){super.reset(),this.onPropertyChanged("range",this.range),this.onPropertyChanged("coneCos",Math.cos(this.angle)),this.onPropertyChanged("penumbraCos",Math.cos(this.angle*(1-this.penumbra))),this.onPropertyChanged("position",this.worldMatrix.getTranslation(ze(this,at))),this.onPropertyChanged("direction",ze(this,vt)),this.shadow&&e&&this.shadow.reset()}setPositionDirection(){this.onPropertyChanged("position",this.worldMatrix.getTranslation(ze(this,at))),ze(this,vt).copy(this.target).sub(ze(this,at)).normalize(),this.onPropertyChanged("direction",ze(this,vt)),this.shadow?.updateLookAt(ze(this,at))}get angle(){return ze(this,ii)}set angle(e){Xt(this,ii,Math.min(Math.PI/2,Math.max(0,e))),this.onPropertyChanged("coneCos",Math.cos(this.angle)),this.onPropertyChanged("penumbraCos",Math.cos(this.angle*(1-this.penumbra))),this.shadow?.setCameraFov()}get penumbra(){return ze(this,ri)}set penumbra(e){Xt(this,ri,Math.min(1,Math.max(0,e))),this.onPropertyChanged("penumbraCos",Math.cos(this.angle*(1-this.penumbra)))}get range(){return ze(this,ni)}set range(e){Xt(this,ni,e),this.onPropertyChanged("range",this.range),this.shadow&&(this.shadow.camera.far=this.range!==0?this.range:500)}applyScale(){}applyTransformOrigin(){}updateMatrixStack(){super.updateMatrixStack(),this.matricesNeedUpdate&&this.setPositionDirection()}onMaxLightOverflow(e){super.onMaxLightOverflow(e),this.shadow?.setRendererBinding()}destroy(){super.destroy(),this.shadow.destroy()}}at=new WeakMap,vt=new WeakMap,ii=new WeakMap,ri=new WeakMap,ni=new WeakMap;class zh{static{u(this,"CacheManager")}constructor(){this.planeGeometries=[]}getPlaneGeometry(e){return this.planeGeometries.find(t=>t.definition.id===e.definition.id)}getPlaneGeometryByID(e){return this.planeGeometries.find(t=>t.definition.id===e)}addPlaneGeometry(e){this.planeGeometries.push(e)}destroy(){this.planeGeometries=[]}}const ai=new zh;class tr extends Rn(class{}){static{u(this,"FullscreenPlane")}constructor(e,t={}){e=$(e,t.label?t.label+" FullscreenQuadMesh":"FullscreenQuadMesh");let s=ai.getPlaneGeometryByID(2);s||(s=new Ui({widthSegments:1,heightSegments:1}),ai.addPlaneGeometry(s)),(!t.shaders||!t.shaders.vertex)&&["uniforms","storages"].forEach(i=>{Object.values(t[i]??{}).forEach(n=>n.visibility=["fragment"])}),t.depthWriteEnabled=!1,t.label||(t.label="FullscreenQuadMesh"),super(e,null,{geometry:s,...t}),this.size={document:{width:this.renderer.boundingRect.width,height:this.renderer.boundingRect.height,top:this.renderer.boundingRect.top,left:this.renderer.boundingRect.left}},this.type="FullscreenQuadMesh"}resize(e=null){this.size.document=e??this.renderer.boundingRect,super.resize(e)}mouseToPlaneCoords(e=new _){return new _((e.x-this.size.document.left)/this.size.document.width*2-1,1-(e.y-this.size.document.top)/this.size.document.height*2)}}class sr extends Vi{static{u(this,"ComputePipelineEntry")}constructor(e){const{label:t,renderer:s,bindGroups:i}=e,n="ComputePipelineEntry";$(s,t?t+" "+n:n),super(e),this.type=n,this.shaders={compute:{head:"",code:"",module:null}},this.descriptor=null}patchShaders(){this.shaders.compute.head="",this.shaders.compute.code="";const e=[];for(const t of this.bindGroups){let s=0;t.bindings.forEach((i,n)=>{i.wgslGroupFragment.forEach((a,o)=>{e.push({groupIndex:t.index,bindIndex:s,wgslStructFragment:i.wgslStructFragment,wgslGroupFragment:a,newLine:n===t.bindings.length-1&&o===i.wgslGroupFragment.length-1}),s++})})}for(const t of e)t.wgslStructFragment&&this.shaders.compute.head.indexOf(t.wgslStructFragment)===-1&&(this.shaders.compute.head=`
${t.wgslStructFragment}
${this.shaders.compute.head}`),this.shaders.compute.head.indexOf(t.wgslGroupFragment)===-1&&(this.shaders.compute.head=`${this.shaders.compute.head}
@group(${t.groupIndex}) @binding(${t.bindIndex}) ${t.wgslGroupFragment}`),t.newLine&&(this.shaders.compute.head+=`
`);this.shaders.compute.code=this.shaders.compute.head+this.options.shaders.compute.code}createShaders(){this.patchShaders(),this.shaders.compute.module=this.createShaderModule({code:this.shaders.compute.code,type:"compute"})}createPipelineDescriptor(){this.shaders.compute.module&&(this.descriptor={label:this.options.label,layout:this.layout,compute:{module:this.shaders.compute.module,entryPoint:this.options.shaders.compute.entryPoint}})}createComputePipeline(){if(this.shaders.compute.module)try{this.pipeline=this.renderer.createComputePipeline(this.descriptor)}catch(e){this.status.error=e,ae(e)}}async createComputePipelineAsync(){if(this.shaders.compute.module)try{this.pipeline=await this.renderer.createComputePipelineAsync(this.descriptor),this.status.compiled=!0,this.status.compiling=!1,this.status.error=null}catch(e){this.status.error=e,ae(e)}}async compilePipelineEntry(){super.compilePipelineEntry(),this.options.useAsync?await this.createComputePipelineAsync():(this.createComputePipeline(),this.status.compiled=!0,this.status.compiling=!1,this.status.error=null)}}class Xn{static{u(this,"PipelineManager")}constructor(){this.type="PipelineManager",this.currentPipelineIndex=null,this.pipelineEntries=[],this.activeBindGroups=[]}compareShaders(e,t){return e.code===t.code&&e.entryPoint===t.entryPoint}isSameRenderPipeline(e){return this.pipelineEntries.filter(t=>t instanceof gt).find(t=>{const{options:s}=t,{shaders:i,rendering:n,cacheKey:a}=e,o=a===s.cacheKey,h=this.compareShaders(i.vertex,s.shaders.vertex),l=!i.fragment&&!s.shaders.fragment||this.compareShaders(i.fragment,s.shaders.fragment),d=Bn(n,s.rendering);return o&&!d.length&&h&&l})}createRenderPipeline(e){const{renderer:t,attributes:s,bindGroups:i,cacheKey:n,options:a}=e,{shaders:o,label:h,useAsyncPipeline:l,rendering:d}=a,c={renderer:t,label:h+" render pipeline",shaders:o,useAsync:l,bindGroups:i,cacheKey:n,rendering:d,attributes:s},f=this.isSameRenderPipeline(c);if(f)return f;{const p=new gt(c);return this.pipelineEntries.push(p),p}}isSameComputePipeline(e){return this.pipelineEntries.filter(t=>t instanceof sr).find(t=>{const{options:s}=t,{shaders:i,cacheKey:n}=e,a=n===s.cacheKey,o=this.compareShaders(i.compute,s.shaders.compute);return a&&o})}createComputePipeline(e){const{renderer:t,bindGroups:s,cacheKey:i,options:n}=e,{shaders:a,label:o,useAsyncPipeline:h}=n,l={renderer:t,label:o+" compute pipeline",shaders:a,useAsync:h,bindGroups:s,cacheKey:i},d=this.isSameComputePipeline(l);if(d)return d;{const c=new sr(l);return this.pipelineEntries.push(c),c}}setCurrentPipeline(e,t){t.index!==this.currentPipelineIndex&&(e.setPipeline(t.pipeline),this.currentPipelineIndex=t.index)}setActiveBindGroups(e,t){t.forEach((s,i)=>{(!this.activeBindGroups[i]||this.activeBindGroups[i].uuid!==s.uuid||this.activeBindGroups[i].index!==s.index)&&(this.activeBindGroups[i]=s,e.setBindGroup(s.index,s.bindGroup))})}resetCurrentPipeline(){this.currentPipelineIndex=null,this.activeBindGroups=[]}}class _h{static{u(this,"ResizeManager")}constructor(){this.shouldWatch=!0,this.entries=[],typeof window=="object"&&"ResizeObserver"in window&&(this.resizeObserver=new ResizeObserver(e=>{e.map(s=>this.entries.filter(i=>i.element.isSameNode(s.target))).flat().sort((s,i)=>i.priority-s.priority)?.forEach(s=>{s&&s.callback&&s.callback()})}))}useObserver(e=!0){this.shouldWatch=e}observe({element:e,priority:t,callback:s}){if(!e||!this.shouldWatch)return;this.resizeObserver?.observe(e);const i={element:e,priority:t,callback:s};this.entries.push(i)}unobserve(e){this.resizeObserver?.unobserve(e),this.entries=this.entries.filter(t=>!t.element.isSameNode(e))}destroy(){this.resizeObserver?.disconnect()}}const Lh=new _h;class ir{static{u(this,"DOMElement")}constructor({element:e=document.body,priority:t=1,onSizeChanged:s=u((n=null)=>{},"onSizeChanged"),onPositionChanged:i=u((n=null)=>{},"onPositionChanged")}={}){if(typeof e=="string"){if(this.element=document.querySelector(e),!this.element){const n=typeof e=="string"?`'${e}' selector`:`${e} HTMLElement`;ae(`DOMElement: corresponding ${n} not found.`)}}else this.element=e;this.priority=t,this.isResizing=!1,this.onSizeChanged=s,this.onPositionChanged=i,this.resizeManager=Lh,this.resizeManager.observe({element:this.element,priority:this.priority,callback:u(()=>{this.setSize()},"callback")}),this.setSize()}compareBoundingRect(e,t){return!["x","y","left","top","right","bottom","width","height"].some(s=>e[s]!==t[s])}get boundingRect(){return this._boundingRect}set boundingRect(e){const t=!!this.boundingRect&&this.compareBoundingRect(e,this.boundingRect);this._boundingRect={top:e.top,right:e.right,bottom:e.bottom,left:e.left,width:e.width,height:e.height,x:e.x,y:e.y},t||this.onSizeChanged(this.boundingRect)}updateScrollPosition(e={x:0,y:0}){this.isResizing||(this._boundingRect.top+=e.y,this._boundingRect.left+=e.x,(e.x||e.y)&&this.onPositionChanged(this.boundingRect))}setSize(e=null){!this.element||this.isResizing||(this.isResizing=!0,this.boundingRect=e??this.element.getBoundingClientRect(),setTimeout(()=>{this.isResizing=!1},10))}destroy(){this.resizeManager.unobserve(this.element)}}const Ah=new y,Dh=new y,rr=new y,nr=new y;class Yn extends Me{static{u(this,"Scene")}constructor({renderer:e}){super(),e=$(e,"Scene"),this.renderer=e,this.computePassEntries=[],this.renderPassEntries={pingPong:[],renderTarget:[],prePass:[],screen:[],postProPass:[]}}createScreenPassEntry(e="",t=1){const s={label:e,renderPass:this.renderer.renderPass,renderTexture:null,onBeforeRenderPass:null,onAfterRenderPass:null,useCustomRenderPass:null,element:null,stack:{unProjected:{opaque:[],transparent:[]},projected:{opaque:[],transparent:[]}}};return t>=0?this.renderPassEntries.screen.push(s):this.renderPassEntries.screen.unshift(s),s}setMainRenderPassEntry(){this.createScreenPassEntry("Main scene screen render pass")}getRenderPassEntryLength(e){return e?e.element?e.element.visible?1:0:e.stack.unProjected.opaque.length+e.stack.unProjected.transparent.length+e.stack.projected.opaque.length+e.stack.projected.transparent.length:0}addComputePass(e){this.computePassEntries.push(e),this.computePassEntries.sort((t,s)=>t.renderOrder!==s.renderOrder?t.renderOrder-s.renderOrder:t.index-s.index)}removeComputePass(e){this.computePassEntries=this.computePassEntries.filter(t=>t.uuid!==e.uuid)}addRenderTarget(e){this.renderPassEntries.renderTarget.find(t=>t.renderPass.uuid===e.renderPass.uuid)||this.renderPassEntries.renderTarget.push({label:e.options.label,renderPass:e.renderPass,renderTexture:e.renderTexture,onBeforeRenderPass:null,onAfterRenderPass:null,useCustomRenderPass:null,element:null,stack:{unProjected:{opaque:[],transparent:[]},projected:{opaque:[],transparent:[]}}})}removeRenderTarget(e){this.renderPassEntries.renderTarget=this.renderPassEntries.renderTarget.filter(t=>t.renderPass.uuid!==e.renderPass.uuid)}getRenderTargetPassEntry(e=null){return e?this.renderPassEntries.renderTarget.find(t=>t.renderPass.uuid===e.renderPass.uuid):this.renderPassEntries.screen.find(t=>t.renderPass.uuid===this.renderer.renderPass.uuid)}getMeshProjectionStack(e){const t=e.options.useCustomScenePassEntry?e.options.useCustomScenePassEntry:"transmissive"in e.options&&e.options.transmissive?this.renderer.transmissionTarget.passEntry:this.getRenderTargetPassEntry(e.outputTarget),{stack:s}=t;return e.material.options.rendering.useProjection?s.projected:s.unProjected}orderStack(e){e.sort((t,s)=>t.renderOrder-s.renderOrder||t.index-s.index)}isStackObjectRenderBundle(e){return e.type==="RenderBundle"}addMeshToRenderTargetStack(e,t=null){const s=this.getRenderTargetPassEntry(t),{stack:i}=s,n=e.material.options.rendering.useProjection?i.projected:i.unProjected,o=!!e.transparent?n.transparent:n.opaque;o.push(e),this.orderStack(o)}addMesh(e){e.renderBundle&&e.renderBundle.addMesh(e,e.outputTarget?e.outputTarget.renderPass:this.renderer.renderPass);const{useProjection:t}=e.material.options.rendering;if(!e.renderBundle){const s=this.getMeshProjectionStack(e),n=!!e.transparent?s.transparent:s.opaque;n.push(e),this.orderStack(n)}"parent"in e&&!e.parent&&t&&(e.parent=this)}removeMesh(e){if(e.renderBundle)e.renderBundle.removeMesh(e,!1);else{const t=e.material.options.rendering.useProjection?"projected":"unProjected",i=!!e.transparent?"transparent":"opaque";for(const n of Object.values(this.renderPassEntries))n.forEach(a=>{a.stack&&(a.stack[t][i]=a.stack[t][i].filter(o=>o.uuid!==e.uuid))})}if("transmissive"in e.options&&e.options.transmissive){const t=this.renderer.transmissionTarget.passEntry;(t?this.getRenderPassEntryLength(t):0)===0&&this.renderer.destroyTransmissionTarget()}"parent"in e&&e.parent&&e.parent.object3DIndex===this.object3DIndex&&(e.parent=null)}addRenderBundle(e,t){const s=e.transparent?t.transparent:t.opaque;s.push(e),this.orderStack(s)}removeRenderBundle(e){const s=!!e.useProjection?"projected":"unProjected",n=!!e.transparent?"transparent":"opaque",a=this.renderPassEntries.renderTarget.find(o=>o.renderPass.uuid===e.options.renderPass?.uuid);if(a){const{stack:o}=a,h=o[s];h[n]=h[n].filter(l=>l.uuid!==e.uuid)}else this.renderPassEntries.screen.forEach(o=>{o.stack&&(o.stack[s][n]=o.stack[s][n].filter(h=>h.uuid!==e.uuid))})}addShaderPass(e){const t=e.inputTarget||e.outputTarget?null:(o,h)=>{e.renderTexture&&h&&this.renderer.copyGPUTextureToTexture(h,e.renderTexture,o),this.renderer.postProcessingPass.setLoadOp("clear")},s=!e.outputTarget&&e.options.copyOutputToRenderTexture?(o,h)=>{e.renderTexture&&h&&this.renderer.copyGPUTextureToTexture(h,e.renderTexture,o)}:null,i=e.outputTarget?e.outputTarget.renderPass:e.options.isPrePass?this.renderer.renderPass:this.renderer.postProcessingPass,a={label:e.options.isPrePass?e.options.label+" scene pre pass":e.options.label+" scene post processing pass",renderPass:i,renderTexture:e.outputTarget?e.outputTarget.renderTexture:null,onBeforeRenderPass:t,onAfterRenderPass:s,useCustomRenderPass:null,element:e,stack:null};if(e.renderBundle){const{renderBundle:o}=e;o.meshes.size>=1?(A(`${o.options.label} (${o.type}): Cannot add more than 1 ShaderPass to a render bundle. This ShaderPass will not be added: ${e.options.label}`),e.renderBundle=null):o.addMesh(e,i)}e.options.isPrePass?(this.renderPassEntries.prePass.push(a),this.renderPassEntries.prePass.sort((o,h)=>o.element.renderOrder-h.element.renderOrder||o.element.index-h.element.index)):(this.renderPassEntries.postProPass.push(a),this.renderPassEntries.postProPass.sort((o,h)=>{const l=o.element&&!o.element.outputTarget,d=o.element?o.element.renderOrder:0,c=o.element?o.element.index:0,f=h.element&&!h.element.outputTarget,p=h.element?h.element.renderOrder:0,m=h.element?h.element.index:0;return l&&!f?1:!l&&f?-1:d!==p?d-p:c-m}))}removeShaderPass(e){e.renderBundle&&e.renderBundle.empty(),e.options.isPrePass?this.renderPassEntries.prePass=this.renderPassEntries.prePass.filter(t=>!t.element||t.element.uuid!==e.uuid):this.renderPassEntries.postProPass=this.renderPassEntries.postProPass.filter(t=>!t.element||t.element.uuid!==e.uuid)}addPingPongPlane(e){if(this.renderPassEntries.pingPong.push({label:e.options.label+" scene pass",renderPass:e.outputTarget.renderPass,renderTexture:e.outputTarget.renderTexture,onBeforeRenderPass:null,onAfterRenderPass:u((t,s)=>{this.renderer.copyGPUTextureToTexture(s,e.renderTexture,t)},"onAfterRenderPass"),useCustomRenderPass:null,element:e,stack:null}),e.renderBundle){const{renderBundle:t}=e;t.meshes.size>=1?(A(`${t.options.label} (${t.type}): Cannot add more than 1 PingPongPlane to a render bundle. This PingPongPlane will not be added: ${e.options.label}`),e.renderBundle=null):t.addMesh(e,e.outputTarget.renderPass)}this.renderPassEntries.pingPong.sort((t,s)=>t.element.renderOrder-s.element.renderOrder)}removePingPongPlane(e){e.renderBundle&&e.renderBundle.empty(),this.renderPassEntries.pingPong=this.renderPassEntries.pingPong.filter(t=>t.element.uuid!==e.uuid)}getObjectRenderPassEntry(e){if(e.type==="RenderTarget")return this.renderPassEntries.renderTarget.find(t=>t.renderPass.uuid===e.renderPass.uuid);if(e.type==="PingPongPlane")return this.renderPassEntries.pingPong.find(t=>t.element.uuid===e.uuid);if(e.type==="ShaderPass")return this.renderPassEntries.screen.find(t=>t.element?.uuid===e.uuid);{const t=e.outputTarget?"renderTarget":"screen";return e.renderBundle?this.renderPassEntries[t].find(s=>[...s.stack.unProjected.opaque,...s.stack.unProjected.transparent,...s.stack.projected.opaque,...s.stack.projected.transparent].filter(i=>i.type==="RenderBundle").some(i=>i.meshes.get(e.uuid))):this.renderPassEntries[t].find(s=>[...s.stack.unProjected.opaque,...s.stack.unProjected.transparent,...s.stack.projected.opaque,...s.stack.projected.transparent].some(i=>i.uuid===e.uuid))}}sortTransparentMeshes(e){e.sort((t,s)=>{if(t.renderOrder!==s.renderOrder||this.isStackObjectRenderBundle(t)||this.isStackObjectRenderBundle(s))return t.renderOrder-s.renderOrder;t.geometry?rr.copy(t.geometry.boundingBox.center).applyMat4(t.worldMatrix):t.worldMatrix.getTranslation(rr),s.geometry?nr.copy(s.geometry.boundingBox.center).applyMat4(s.worldMatrix):s.worldMatrix.getTranslation(nr);const i=t.geometry?t.geometry.boundingBox.radius*t.worldMatrix.getMaxScaleOnAxis():0,n=s.geometry?s.geometry.boundingBox.radius*s.worldMatrix.getMaxScaleOnAxis():0;return s.camera.worldMatrix.getTranslation(Dh).distance(nr)-n-(t.camera.worldMatrix.getTranslation(Ah).distance(rr)-i)})}renderSinglePassEntry(e,t){const s=t.renderPass.updateView(t.renderTexture?.texture);if(t.onBeforeRenderPass&&t.onBeforeRenderPass(e,s),t.useCustomRenderPass)t.useCustomRenderPass(e);else{const i=e.beginRenderPass(t.renderPass.descriptor);if(this.renderer.production||i.pushDebugGroup(t.element?`${t.element.options.label} render pass using ${t.renderPass.options.label} descriptor`:`Render stack pass using ${t.renderPass.options.label}${t.renderTexture?" onto "+t.renderTexture.options.label:""}`),t.element)t.element.renderBundle?t.element.renderBundle.render(i):t.element.render(i);else if(t.stack){for(const n of t.stack.unProjected.opaque)n.render(i);for(const n of t.stack.unProjected.transparent)n.render(i);if(t.stack.projected.opaque.length||t.stack.projected.transparent.length){for(const n of t.stack.projected.opaque)n.render(i);this.sortTransparentMeshes(t.stack.projected.transparent);for(const n of t.stack.projected.transparent)n.render(i)}}this.renderer.production||i.popDebugGroup(),i.end()}t.onAfterRenderPass&&t.onAfterRenderPass(e,s),this.renderer.pipelineManager.resetCurrentPipeline()}onBeforeRender(){this.renderer.meshes.forEach(e=>{e.onBeforeRenderScene()}),this.renderer.animations.forEach(e=>e.update()),this.updateMatrixStack(),this.renderer.animations.forEach(e=>e.onAfterUpdate());for(const e of this.renderer.meshes)"checkFrustumCulling"in e&&e.visible&&e.checkFrustumCulling()}render(e){for(const t of this.computePassEntries){const s=e.beginComputePass();this.renderer.production||s.pushDebugGroup(`${t.options.label}: begin compute pass`),t.render(s),this.renderer.production||s.popDebugGroup(),s.end(),t.copyBufferToResult(e),this.renderer.pipelineManager.resetCurrentPipeline()}for(const t in this.renderPassEntries){t==="postProPass"&&this.renderer.renderPass.setDepthLoadOp("clear");let s=0;this.renderPassEntries[t].forEach(i=>{if(!this.getRenderPassEntryLength(i))return;const n=t==="screen"&&(s!==0||this.renderPassEntries.prePass.length),a=t==="postProPass"||t==="prePass"&&s!==0||n;i.renderPass.setLoadOp(a?"load":"clear"),n&&i.renderPass.setDepthLoadOp("load"),s++,this.renderSinglePassEntry(e,i)})}}}var Kn=u(r=>{throw TypeError(r)},"__typeError$c"),Jn=u((r,e,t)=>e.has(r)||Kn("Cannot "+t),"__accessCheck$c"),Zn=u((r,e,t)=>(Jn(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet$a"),$h=u((r,e,t)=>e.has(r)?Kn("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$c"),Gh=u((r,e,t,s)=>(Jn(r,e,"write to private field"),e.set(r,t),t),"__privateSet$a"),Fh=u((r,e,t,s)=>({set _(i){Gh(r,e,i)},get _(){return Zn(r,e,s)}}),"__privateWrapper"),oi;class hi{static{u(this,"TasksQueueManager")}constructor(){$h(this,oi,0),this.queue=[]}add(e=i=>{},{order:t=this.queue.length,once:s=!1}={}){const i={callback:e,order:t,once:s,id:Zn(this,oi)};return Fh(this,oi)._++,this.queue.push(i),this.queue.sort((n,a)=>n.order-a.order),i.id}remove(e=0){this.queue=this.queue.filter(t=>t.id!==e)}execute(e){this.queue.forEach(t=>{t.callback(e),t.once&&this.remove(t.id)})}}oi=new WeakMap;class ar{static{u(this,"GPURenderer")}constructor({deviceManager:e,label:t,container:s,pixelRatio:i=1,autoResize:n=!0,context:a={},renderPass:o}){this._onBeforeRenderCallback=p=>{},this._onAfterRenderCallback=p=>{},this._onResizeCallback=()=>{},this._onAfterResizeCallback=()=>{},this.type="GPURenderer",this.uuid=O(),(!e||e.constructor.name!=="GPUDeviceManager")&&ae(t?`${t} (${this.type}): no device manager or wrong device manager provided: ${e}`:`${this.type}: no device manager or wrong device manager provided: ${e}`),t||(t=`${this.constructor.name}${e.renderers.length}`),this.deviceManager=e,this.deviceManager.addRenderer(this),this.shouldRender=!0,this.shouldRenderScene=!0;const h={alphaMode:"premultiplied",format:this.deviceManager.gpu?.getPreferredCanvasFormat(),...a};o={useDepth:!0,sampleCount:4,...o},this.options={deviceManager:e,label:t,container:s,pixelRatio:i,autoResize:n,context:h,renderPass:o},this.pixelRatio=i??window.devicePixelRatio??1;const l=s instanceof OffscreenCanvas,d=l||s instanceof HTMLCanvasElement;this.canvas=d?s:document.createElement("canvas");const{width:c,height:f}=this.canvas;this.rectBBox={width:c,height:f,top:0,left:0},this.setScene(),this.setTasksQueues(),this.setRendererObjects(),l||(this.domElement=new ir({element:s,priority:5,onSizeChanged:u(()=>{this.options.autoResize&&this.resize()},"onSizeChanged")}),this.resize(),d||this.domElement.element.appendChild(this.canvas)),this.deviceManager.device&&this.setContext()}setSize(e=null){e={width:Math.max(1,this.boundingRect.width),height:Math.max(1,this.boundingRect.height),top:this.boundingRect.top,left:this.boundingRect.left,...e},this.rectBBox=e;const t={width:this.rectBBox.width,height:this.rectBBox.height};t.width*=this.pixelRatio,t.height*=this.pixelRatio,this.clampToMaxDimension(t),this.canvas.width=Math.floor(t.width),this.canvas.height=Math.floor(t.height),this.canvas.style&&(this.canvas.style.width=this.rectBBox.width+"px",this.canvas.style.height=this.rectBBox.height+"px")}setPixelRatio(e=1){this.pixelRatio=e,this.resize(this.rectBBox)}resize(e=null){this.setSize(e),this._onResizeCallback&&this._onResizeCallback(),this.resizeObjects(),this._onAfterResizeCallback&&this._onAfterResizeCallback()}resizeObjects(){this.renderBundles.forEach(e=>e.resize()),this.textures.forEach(e=>{e.resize()}),this.renderPass?.resize(),this.postProcessingPass?.resize(),this.renderTargets.forEach(e=>e.resize()),this.computePasses.forEach(e=>e.resize()),this.pingPongPlanes.forEach(e=>e.resize(this.boundingRect)),this.shaderPasses.forEach(e=>e.resize(this.boundingRect)),this.resizeMeshes()}resizeMeshes(){this.meshes.forEach(e=>{e.resize(this.boundingRect)})}get boundingRect(){if(this.domElement&&this.domElement.boundingRect)return this.domElement.boundingRect;if(this.domElement){const e=this.domElement.element?.getBoundingClientRect();return{top:e.top,right:e.right,bottom:e.bottom,left:e.left,width:e.width,height:e.height,x:e.x,y:e.y}}else return{top:this.rectBBox.top,right:this.rectBBox.left+this.rectBBox.width,bottom:this.rectBBox.top+this.rectBBox.height,left:this.rectBBox.left,width:this.rectBBox.width,height:this.rectBBox.height,x:this.rectBBox.left,y:this.rectBBox.top}}clampToMaxDimension(e){this.device&&(e.width=Math.min(this.device.limits.maxTextureDimension2D,e.width),e.height=Math.min(this.device.limits.maxTextureDimension2D,e.height))}get device(){return this.deviceManager.device}get ready(){return this.deviceManager.ready&&!!this.context&&!!this.canvas.width&&!!this.canvas.height}get production(){return this.deviceManager.production}get samplers(){return this.deviceManager.samplers}get buffers(){return this.deviceManager.buffers}get indirectBuffers(){return this.deviceManager.indirectBuffers}get pipelineManager(){return this.deviceManager.pipelineManager}get deviceRenderedObjects(){return this.deviceManager.deviceRenderedObjects}configureContext(){this.context.configure({device:this.device,...this.options.context,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST})}setContext(){this.context=this.canvas.getContext("webgpu"),this.device&&(this.configureContext(),this.setMainRenderPasses())}loseContext(){this.renderBundles.forEach(e=>e.loseContext()),this.renderedObjects.forEach(e=>e.loseContext())}restoreContext(){this.configureContext(),this.textures.forEach(e=>{e.createTexture()}),this.renderPass?.resize(),this.postProcessingPass?.resize(),this.renderTargets.forEach(e=>e.resize()),this.renderedObjects.forEach(e=>e.restoreContext()),this.environmentMaps.forEach(e=>{e.computeBRDFLUTTexture(),e.computeFromHDR()})}setMainRenderPasses(){this.renderPass=new Xs(this,{label:this.options.label+" render pass",...this.options.renderPass}),this.scene.setMainRenderPassEntry(),this.postProcessingPass=new Xs(this,{label:this.options.label+" post processing render pass",useDepth:!1,sampleCount:1})}setScene(){this.scene=new Yn({renderer:this})}createBuffer(e){const t=this.deviceManager.device?.createBuffer(e.options);return this.deviceManager.addBuffer(e),t}removeBuffer(e){this.deviceManager.removeBuffer(e)}queueWriteBuffer(e,t,s){this.deviceManager.device?.queue.writeBuffer(e,t,s)}copyBufferToBuffer({srcBuffer:e,dstBuffer:t,commandEncoder:s}){if(!e||!e.GPUBuffer)return A(`${this.options.label} (${this.type}): cannot copy to buffer because the source buffer has not been provided`),null;if(t||(t=new Je),t.GPUBuffer||t.createBuffer(this,{label:`GPURenderer (${this.options.label}): destination copy buffer from: ${e.options.label}`,size:e.GPUBuffer.size,usage:["copyDst","mapRead"]}),e.GPUBuffer.mapState!=="unmapped"){A(`${this.options.label} (${this.type}): Cannot copy from ${e.GPUBuffer} because it is currently mapped`);return}if(t.GPUBuffer.mapState!=="unmapped"){A(`${this.options.label} (${this.type}): Cannot copy from ${t.GPUBuffer} because it is currently mapped`);return}const i=!!s;if(i||(s=this.deviceManager.device?.createCommandEncoder({label:`${this.type} (${this.options.label}): Copy buffer command encoder`}),!this.production&&s.pushDebugGroup(`${this.type} (${this.options.label}): Copy buffer command encoder`)),s.copyBufferToBuffer(e.GPUBuffer,0,t.GPUBuffer,0,t.GPUBuffer.size),!i){!this.production&&s.popDebugGroup();const n=s.finish();this.deviceManager.device?.queue.submit([n])}return t}get bindGroups(){return this.deviceManager.bindGroups}addBindGroup(e){this.deviceManager.addBindGroup(e)}removeBindGroup(e){this.deviceManager.removeBindGroup(e)}createBindGroupLayout(e){return this.deviceManager.device?.createBindGroupLayout(e)}createBindGroup(e){return this.deviceManager.device?.createBindGroup(e)}createShaderModule(e){return this.device?.createShaderModule(e)}createPipelineLayout(e){return this.device?.createPipelineLayout(e)}createRenderPipeline(e){return this.device?.createRenderPipeline(e)}async createRenderPipelineAsync(e){return await this.device?.createRenderPipelineAsync(e)}createComputePipeline(e){return this.device?.createComputePipeline(e)}async createComputePipelineAsync(e){return await this.device?.createComputePipelineAsync(e)}addTexture(e){this.textures.push(e)}removeTexture(e){this.textures=this.textures.filter(t=>t.uuid!==e.uuid)}createTexture(e){return this.deviceManager.device?.createTexture(e)}uploadTexture(e,t=0){this.deviceManager.uploadTexture(e,t)}generateMips(e,t=null){this.deviceManager.generateMips(e,t)}importExternalTexture(e,t=""){return this.deviceManager.device?.importExternalTexture({label:t,source:e})}copyGPUTextureToTexture(e,t,s){s.copyTextureToTexture({texture:e},{texture:t.texture},[e.width,e.height,e.depthOrArrayLayers]),t.options.generateMips&&this.generateMips(t,s)}copyTextureToGPUTexture(e,t,s){s.copyTextureToTexture({texture:e.texture},{texture:t},[t.width,t.height,t.depthOrArrayLayers])}createSampler(e){const t=this.samplers.find(s=>JSON.stringify(s.options)===JSON.stringify(e.options)&&s.sampler);if(t)return t.sampler;{const{type:s,...i}=e.options,n=this.deviceManager.device?.createSampler({label:e.label,...i});return this.deviceManager.addSampler(e),n}}removeSampler(e){this.deviceManager.removeSampler(e)}setTasksQueues(){this.onBeforeCommandEncoderCreation=new hi,this.onBeforeRenderScene=new hi,this.onAfterRenderScene=new hi,this.onAfterCommandEncoderSubmission=new hi}setRendererObjects(){this.computePasses=[],this.pingPongPlanes=[],this.shaderPasses=[],this.renderTargets=[],this.meshes=[],this.textures=[],this.environmentMaps=new Map,this.renderBundles=new Map,this.animations=new Map}get renderedObjects(){return[...this.computePasses,...this.meshes,...this.shaderPasses,...this.pingPongPlanes]}getObjectsByBindGroup(e){return this.deviceRenderedObjects.filter(t=>[...t.material.bindGroups,...t.material.inputsBindGroups,...t.material.clonedBindGroups].some(s=>s.uuid===e.uuid))}getObjectsByTexture(e){return this.deviceRenderedObjects.filter(t=>t.material.textures.some(s=>s.uuid===e.uuid))}onBeforeRender(e){return e&&(this._onBeforeRenderCallback=e),this}onAfterRender(e){return e&&(this._onAfterRenderCallback=e),this}onResize(e){return e&&(this._onResizeCallback=e),this}onAfterResize(e){return e&&(this._onAfterResizeCallback=e),this}renderSingleComputePass(e,t,s=!0){const i=e.beginComputePass();t.render(i),i.end(),s&&t.copyBufferToResult(e)}renderSingleMesh(e,t){const s=e.beginRenderPass(this.renderPass.descriptor);t.render(s),s.end()}renderOnce(e){const t=this.device?.createCommandEncoder({label:"Render once command encoder"});!this.production&&t.pushDebugGroup("Render once command encoder"),this.pipelineManager.resetCurrentPipeline(),e.forEach(i=>{i.type==="ComputePass"?this.renderSingleComputePass(t,i):this.renderSingleMesh(t,i)}),!this.production&&t.popDebugGroup();const s=t.finish();this.device?.queue.submit([s]),this.pipelineManager.resetCurrentPipeline()}forceClear(e){const t=!!e;if(t||(e=this.device?.createCommandEncoder({label:`${this.type} (${this.options.label}): Force clear command encoder`}),!this.production&&e.pushDebugGroup(`${this.type} (${this.options.label}): Force clear command encoder`)),this.renderPass.updateView(),this.renderPass.setLoadOp("clear"),this.renderPass.setDepthLoadOp("clear"),e.beginRenderPass(this.renderPass.descriptor).end(),!t){!this.production&&e.popDebugGroup();const i=e.finish();this.device?.queue.submit([i])}}onBeforeCommandEncoder(){this.ready&&(this.shouldRenderScene&&this.scene?.onBeforeRender(),this.onBeforeCommandEncoderCreation.execute())}onAfterCommandEncoder(){this.ready&&this.onAfterCommandEncoderSubmission.execute()}render(e){!this.ready||!this.shouldRender||(this._onBeforeRenderCallback&&this._onBeforeRenderCallback(e),this.onBeforeRenderScene.execute(e),this.shouldRenderScene&&(this.textures.forEach(t=>{t instanceof ce&&t.update()}),this.scene?.render(e)),this._onAfterRenderCallback&&this._onAfterRenderCallback(e),this.onAfterRenderScene.execute(e))}destroy(){this.deviceManager.renderers=this.deviceManager.renderers.filter(e=>e.uuid!==this.uuid),this.domElement?.destroy(),this.renderBundles.forEach(e=>e.destroy()),this.animations=new Map,this.renderPass?.destroy(),this.postProcessingPass?.destroy(),this.renderTargets.forEach(e=>e.destroy()),this.renderedObjects.forEach(e=>e.remove()),this.textures.forEach(e=>e.destroy()),this.context?.unconfigure()}}var Qn=u(r=>{throw TypeError(r)},"__typeError$b"),or=u((r,e,t)=>e.has(r)||Qn("Cannot "+t),"__accessCheck$b"),Oh=u((r,e,t)=>(or(r,e,"read from private field"),e.get(r)),"__privateGet$9"),ea=u((r,e,t)=>e.has(r)?Qn("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$b"),hr=u((r,e,t,s)=>(or(r,e,"write to private field"),e.set(r,t),t),"__privateSet$9"),ta=u((r,e,t)=>(or(r,e,"access private method"),t),"__privateMethod$8"),bt,li,lr;class ur extends ar{static{u(this,"GPUCameraRenderer")}constructor({deviceManager:e,label:t,container:s,pixelRatio:i=1,autoResize:n=!0,context:a={},renderPass:o,camera:h={},lights:l={}}){super({deviceManager:e,label:t,container:s,pixelRatio:i,autoResize:n,context:a,renderPass:o}),ea(this,li),ea(this,bt),this.type="GPUCameraRenderer",h={fov:50,near:.1,far:1e3,...h},l!==!1&&(l={maxAmbientLights:2,maxDirectionalLights:5,maxPointLights:5,maxSpotLights:5,...l}),this.options={...this.options,camera:h,lights:l},this.bindings={},hr(this,bt,!0),this.lights=[],this.setCamera(h),this.setCameraBinding(),this.options.lights&&(this.setLightsBinding(),this.setShadowsBinding()),this.setCameraLightsBindGroup()}loseContext(){super.loseContext(),this.cameraLightsBindGroup.loseContext(),this.pointShadowsCubeFaceBindGroups.forEach(e=>e.loseContext())}restoreContext(){super.restoreContext(),this.cameraLightsBindGroup?.restoreContext(),this.pointShadowsCubeFaceBindGroups.forEach(e=>e.restoreContext()),this.updateCameraBindings()}setMainRenderPasses(){super.setMainRenderPasses(),this.transmissionTarget={sampler:new et(this,{label:"Transmission sampler",name:"transmissionSampler",magFilter:"linear",minFilter:"linear",mipmapFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"})}}setCamera(e){const{width:t,height:s}=this.rectBBox;this.useCamera(new ks({fov:e.fov,near:e.near,far:e.far,width:t,height:s,pixelRatio:this.pixelRatio,onMatricesChanged:u(()=>{this.onCameraMatricesChanged()},"onMatricesChanged")}))}useCamera(e){if(!(this.camera&&e&&this.camera.uuid===e.uuid)&&(this.camera&&(this.camera.parent=null,this.camera.onMatricesChanged=()=>{}),this.camera=e,this.camera.parent=this.scene,this.bindings.camera)){this.camera.onMatricesChanged=()=>this.onCameraMatricesChanged(),this.bindings.camera.inputs.view.value=this.camera.viewMatrix,this.bindings.camera.inputs.projection.value=this.camera.projectionMatrix;for(const t of this.meshes)"modelViewMatrix"in t&&(t.camera=this.camera)}}onCameraMatricesChanged(){this.updateCameraBindings();for(const e of this.meshes)"modelViewMatrix"in e&&e.shouldUpdateProjectionMatrixStack()}setCameraBinding(){this.bindings.camera=new Y({label:"Camera",name:"camera",visibility:["vertex","fragment"],struct:{view:{type:"mat4x4f",value:this.camera.viewMatrix},projection:{type:"mat4x4f",value:this.camera.projectionMatrix},position:{type:"vec3f",value:this.camera.position.clone().setFromMatrixPosition(this.camera.worldMatrix),onBeforeUpdate:u(()=>{this.bindings.camera.inputs.position.value.copy(this.camera.position).setFromMatrixPosition(this.camera.worldMatrix)},"onBeforeUpdate")}}})}addLight(e){this.lights.push(e),ta(this,li,lr).call(this,e.type)}removeLight(e){this.lights=this.lights.filter(t=>t.uuid!==e.uuid),ta(this,li,lr).call(this,e.type)}setLightsBinding(){if(!this.options.lights)return;this.lightsBindingParams={ambientLights:{max:this.options.lights.maxAmbientLights,label:"Ambient lights",params:{color:{type:"array<vec3f>",size:3}}},directionalLights:{max:this.options.lights.maxDirectionalLights,label:"Directional lights",params:{color:{type:"array<vec3f>",size:3},direction:{type:"array<vec3f>",size:3}}},pointLights:{max:this.options.lights.maxPointLights,label:"Point lights",params:{color:{type:"array<vec3f>",size:3},position:{type:"array<vec3f>",size:3},range:{type:"array<f32>",size:1}}},spotLights:{max:this.options.lights.maxSpotLights,label:"Spot lights",params:{color:{type:"array<vec3f>",size:3},direction:{type:"array<vec3f>",size:3},position:{type:"array<vec3f>",size:3},coneCos:{type:"array<f32>",size:1},penumbraCos:{type:"array<f32>",size:1},range:{type:"array<f32>",size:1}}}},Object.keys({ambientLights:null,directionalLights:null,pointLights:null,spotLights:null}).forEach(t=>{this.setLightsTypeBinding(t)})}setLightsTypeBinding(e){const t=Object.keys(this.lightsBindingParams[e].params).map(s=>({key:s,type:this.lightsBindingParams[e].params[s].type,size:this.lightsBindingParams[e].params[s].size})).reduce((s,i)=>(s[i.key]={type:i.type,value:new Float32Array(Math.max(this.lightsBindingParams[e].max,1)*i.size)},s),{});this.bindings[e]=new Y({label:this.lightsBindingParams[e].label,name:e,bindingType:"storage",visibility:["vertex","fragment","compute"],struct:{count:{type:"i32",value:0},...t}})}onMaxLightOverflow(e,t=0){this.production||A(`${this.options.label} (${this.type}): You are overflowing the current max lights count of '${this.lightsBindingParams[e].max}' for this type of lights: ${e}. This should be avoided by setting a larger ${"max"+e.charAt(0).toUpperCase()+e.slice(1)} when instancing your ${this.type}.`),this.lightsBindingParams[e].max=t+1;const s=this.cameraLightsBindGroup.getBindingByName(e);s&&this.cameraLightsBindGroup.destroyBufferBinding(s),this.setLightsTypeBinding(e);const i=this.cameraLightsBindGroup.bindings.findIndex(n=>n.name===e);if(i!==-1?this.cameraLightsBindGroup.bindings[i]=this.bindings[e]:(this.bindings[e].shouldResetBindGroup=!0,this.bindings[e].shouldResetBindGroupLayout=!0,this.cameraLightsBindGroup.addBinding(this.bindings[e]),this.shouldUpdateCameraLightsBindGroup()),e==="directionalLights"||e==="pointLights"||e==="spotLights"){const n=e.replace("Lights","")+"Shadows",a=this.cameraLightsBindGroup.getBindingByName(n);a&&this.cameraLightsBindGroup.destroyBufferBinding(a),this.setShadowsTypeBinding(e);const o=this.cameraLightsBindGroup.bindings.findIndex(h=>h.name===n);o!==-1?this.cameraLightsBindGroup.bindings[o]=this.bindings[n]:(this.bindings[n].shouldResetBindGroup=!0,this.bindings[n].shouldResetBindGroupLayout=!0,this.cameraLightsBindGroup.addBinding(this.bindings[n]),this.shouldUpdateCameraLightsBindGroup())}this.cameraLightsBindGroup.resetEntries(),this.cameraLightsBindGroup.createBindGroup(),this.lights.forEach(n=>{n.type===e&&n.reset()})}get shadowCastingLights(){return this.lights.filter(e=>e.type==="directionalLights"||e.type==="pointLights"||e.type==="spotLights")}setShadowsBinding(){this.shadowsBindingsStruct={directional:vh,point:Sh,spot:Rh},this.setShadowsTypeBinding("directionalLights"),this.setShadowsTypeBinding("pointLights"),this.setShadowsTypeBinding("spotLights")}setShadowsTypeBinding(e){const t=e.replace("Lights",""),s=t+"Shadows",i=this.shadowsBindingsStruct[t],n=t.charAt(0).toUpperCase()+t.slice(1)+" shadows";this.bindings[s]=new Y({label:n,name:s,bindingType:"storage",visibility:["vertex","fragment","compute"],childrenBindings:[{binding:new Y({label:n+" element",name:s+"Elements",bindingType:"uniform",visibility:["vertex","fragment"],struct:i}),count:Math.max(1,this.lightsBindingParams[e].max),forceArray:!0}]})}setCameraLightsBindGroup(){this.cameraLightsBindGroup=new Gt(this,{label:this.options.label+": Camera and lights uniform bind group",bindings:Object.keys(this.bindings).map(e=>this.bindings[e]).flat()}),this.cameraLightsBindGroup.consumers.add(this.uuid),this.pointShadowsCubeFaceBindGroups=[];for(let e=0;e<6;e++){const t=new Y({label:"Cube face",name:"cubeFace",bindingType:"uniform",visibility:["vertex"],struct:{face:{type:"u32",value:e}}}),s=new Gt(this,{label:`Cube face bind group ${e}`,bindings:[t]});s.createBindGroup(),s.consumers.add(this.uuid),this.pointShadowsCubeFaceBindGroups.push(s)}this.device&&this.createCameraLightsBindGroup()}createCameraLightsBindGroup(){this.cameraLightsBindGroup&&this.cameraLightsBindGroup.shouldCreateBindGroup&&(this.cameraLightsBindGroup.setIndex(0),this.cameraLightsBindGroup.createBindGroup())}shouldUpdateCameraLightsBindGroup(){hr(this,bt,!0)}updateCameraBindings(){this.bindings.camera?.shouldUpdateBinding("view"),this.bindings.camera?.shouldUpdateBinding("projection"),this.bindings.camera?.shouldUpdateBinding("position"),this.shouldUpdateCameraLightsBindGroup()}updateCameraLightsBindGroup(){this.cameraLightsBindGroup&&Oh(this,bt)&&(this.cameraLightsBindGroup.update(),hr(this,bt,!1))}getObjectsByBindGroup(e){return this.deviceRenderedObjects.filter(t=>[...t.material.bindGroups,...t.material.inputsBindGroups,...t.material.clonedBindGroups,this.cameraLightsBindGroup].some(s=>s.uuid===e.uuid))}setPerspective({fov:e,near:t,far:s}={}){this.camera?.setPerspective({fov:e,near:t,far:s,width:this.rectBBox.width,height:this.rectBBox.height,pixelRatio:this.pixelRatio})}setCameraPosition(e=new y(0,0,1)){this.camera.position.copy(e)}createTransmissionTarget(){this.transmissionTarget.texture||(this.transmissionTarget.passEntry=this.scene.createScreenPassEntry("Transmission scene screen render pass"),this.transmissionTarget.texture=new q(this,{label:"Transmission background scene render target output",name:"transmissionBackgroundTexture",generateMips:!0,format:this.options.context.format,autoDestroy:!1}),this.transmissionTarget.passEntry.onBeforeRenderPass=(e,t)=>{this.copyGPUTextureToTexture(t,this.transmissionTarget.texture,e)})}destroyTransmissionTarget(){this.transmissionTarget.texture&&(this.transmissionTarget.texture.destroy(),this.scene.renderPassEntries.screen=this.scene.renderPassEntries.screen.filter(e=>e.label!=="Transmission scene screen render pass"),this.transmissionTarget.texture=null,this.transmissionTarget.passEntry=null)}resize(e=null){this.setSize(e),this.setPerspective(),this._onResizeCallback&&this._onResizeCallback(),this.resizeObjects(),this._onAfterResizeCallback&&this._onAfterResizeCallback()}render(e){this.ready&&(this.createCameraLightsBindGroup(),this.updateCameraLightsBindGroup(),super.render(e),this.cameraLightsBindGroup&&(this.cameraLightsBindGroup.needsPipelineFlush=!1))}destroy(){this.cameraLightsBindGroup?.destroy(),this.pointShadowsCubeFaceBindGroups.forEach(e=>e.destroy()),this.destroyTransmissionTarget(),this.lights.forEach(e=>e.destroy()),super.destroy(),this.lights.forEach(e=>this.removeLight(e))}}bt=new WeakMap,li=new WeakSet,lr=u(function(r){let e=0;this.lights.filter(t=>t.type===r).forEach(t=>{e=Math.max(e,t.index+1)}),this.bindings[r].inputs.count.value=e,this.bindings[r].inputs.count.shouldUpdate=!0},"updateLightsCount_fn");var sa=u(r=>{throw TypeError(r)},"__typeError$a"),ia=u((r,e,t)=>e.has(r)||sa("Cannot "+t),"__accessCheck$a"),De=u((r,e,t)=>(ia(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet$8"),Uh=u((r,e,t)=>e.has(r)?sa("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$a"),ra=u((r,e,t,s)=>(ia(r,e,"write to private field"),e.set(r,t),t),"__privateSet$8"),pe;class na{static{u(this,"GPUDeviceManager")}constructor({label:e,production:t=!1,adapterOptions:s={},autoRender:i=!0,onError:n=u(()=>{},"onError"),onDeviceLost:a=u(h=>{},"onDeviceLost"),onDeviceDestroyed:o=u(h=>{},"onDeviceDestroyed")}={}){this._onBeforeRenderCallback=()=>{},this._onAfterRenderCallback=()=>{},Uh(this,pe),this.index=0,this.label=e??"GPUDeviceManager instance",this.production=t,this.ready=!1,this.adapterOptions=s,this.onError=n,this.onDeviceLost=a,this.onDeviceDestroyed=o,this.gpu=navigator.gpu,this.setPipelineManager(),this.setDeviceObjects(),ra(this,pe,{sampler:null,module:null,pipelineByFormat:{}}),i&&this.animate()}async setAdapterAndDevice({adapter:e=null,device:t=null}={}){await this.setAdapter(e),await this.setDevice(t)}async init({adapter:e=null,device:t=null}={}){if(await this.setAdapterAndDevice({adapter:e,device:t}),this.device)for(const s of this.renderers)s.context||s.setContext()}async setAdapter(e=null){if(this.gpu||(this.onError(),ae("GPUDeviceManager: WebGPU is not supported on your browser/OS. No 'gpu' object in 'navigator'.")),e)this.adapter=e;else try{this.adapter=await this.gpu?.requestAdapter(this.adapterOptions),this.adapter||(this.onError(),ae("GPUDeviceManager: WebGPU is not supported on your browser/OS. 'requestAdapter' failed."))}catch(t){this.onError(),ae("GPUDeviceManager: "+t.message)}}async setDevice(e=null){if(e)this.device=e,this.ready=!0,this.index++;else try{const t=[];this.adapter.features.has("float32-filterable")&&t.push("float32-filterable"),this.device=await this.adapter?.requestDevice({label:this.label+" "+this.index,requiredFeatures:t}),this.device&&(this.ready=!0,this.index++)}catch(t){this.onError(),ae(`${this.label}: WebGPU is not supported on your browser/OS. 'requestDevice' failed: ${t}`)}this.device?.lost.then(t=>{A(`${this.label}: WebGPU device was lost: ${t.message}`),this.loseDevice(),t.reason!=="destroyed"?this.onDeviceLost(t):this.onDeviceDestroyed(t)})}setPipelineManager(){this.pipelineManager=new Xn}loseDevice(){this.ready=!1,this.pipelineManager.resetCurrentPipeline();const e=new Set;this.deviceRenderedObjects.forEach(t=>{t.material&&t.material.pipelineEntry&&e.add(t.material.pipelineEntry.uuid)}),this.pipelineManager.pipelineEntries=this.pipelineManager.pipelineEntries.filter(t=>e.has(t.uuid)),this.samplers.forEach(t=>t.sampler=null),this.renderers.forEach(t=>t.loseContext()),this.bindGroupLayouts.clear(),this.buffers.clear(),ra(this,pe,{sampler:null,module:null,pipelineByFormat:{}})}async restoreDevice({adapter:e=null,device:t=null}={}){await this.setAdapterAndDevice({adapter:e,device:t}),this.device&&(this.samplers.forEach(s=>{const{type:i,...n}=s.options;s.sampler=this.device.createSampler({label:s.label,...n})}),this.indirectBuffers.forEach(s=>s.create()),this.renderers.forEach(s=>s.restoreContext()))}setDeviceObjects(){this.renderers=[],this.bindGroups=new Map,this.buffers=new Map,this.indirectBuffers=new Map,this.bindGroupLayouts=new Map,this.bufferBindings=new Map,this.samplers=[],this.texturesQueue=[]}addRenderer(e){this.renderers.push(e)}removeRenderer(e){this.renderers=this.renderers.filter(t=>t.uuid!==e.uuid)}get deviceRenderedObjects(){return this.renderers.map(e=>e.renderedObjects).flat()}addBindGroup(e){this.bindGroups.set(e.uuid,e)}removeBindGroup(e){this.bindGroups.delete(e.uuid)}addBuffer(e){this.buffers.set(e.uuid,e)}removeBuffer(e){this.buffers.delete(e?.uuid)}addSampler(e){this.samplers.push(e)}removeSampler(e){this.samplers=this.samplers.filter(t=>t.uuid!==e.uuid)}copyExternalImageToTexture(e,t,s){this.device?.queue.copyExternalImageToTexture(e,t,s)}uploadTexture(e,t=0){if("sources"in e&&e.sources.length)try{this.device?.queue.copyExternalImageToTexture({source:e.sources[t].source,flipY:e.options.flipY},{texture:e.texture,premultipliedAlpha:e.options.premultipliedAlpha,aspect:e.options.aspect,colorSpace:e.options.colorSpace,origin:[0,0,t]},{width:e.size.width,height:e.size.height,depthOrArrayLayers:1}),e.texture.mipLevelCount>1&&this.generateMips(e),this.texturesQueue.push({sourceIndex:t,texture:e})}catch({message:s}){ae(`GPUDeviceManager: could not upload texture: ${e.options.name} because: ${s}`)}else for(let s=0;s<e.size.depth;s++)this.device?.queue.writeTexture({texture:e.texture,origin:[0,0,s]},new Uint8Array(e.options.placeholderColor),{bytesPerRow:e.size.width*4},{width:1,height:1,depthOrArrayLayers:1})}generateMips(e,t=null){if(!this.device)return;De(this,pe).module||(De(this,pe).module=this.device.createShaderModule({label:"textured quad shaders for mip level generation",code:`
            struct VSOutput {
              @builtin(position) position: vec4f,
              @location(0) texcoord: vec2f,
            };

            @vertex fn vs(
              @builtin(vertex_index) vertexIndex : u32
            ) -> VSOutput {
              let pos = array(

                vec2f( 0.0,  0.0),  // center
                vec2f( 1.0,  0.0),  // right, center
                vec2f( 0.0,  1.0),  // center, top

                // 2st triangle
                vec2f( 0.0,  1.0),  // center, top
                vec2f( 1.0,  0.0),  // right, center
                vec2f( 1.0,  1.0),  // right, top
              );

              var vsOutput: VSOutput;
              let xy = pos[vertexIndex];
              vsOutput.position = vec4f(xy * 2.0 - 1.0, 0.0, 1.0);
              vsOutput.texcoord = vec2f(xy.x, 1.0 - xy.y);
              return vsOutput;
            }

            @group(0) @binding(0) var ourSampler: sampler;
            @group(0) @binding(1) var ourTexture: texture_2d<f32>;

            @fragment fn fs(fsInput: VSOutput) -> @location(0) vec4f {
              return textureSample(ourTexture, ourSampler, fsInput.texcoord);
            }
          `}),De(this,pe).sampler=this.device.createSampler({minFilter:"linear",magFilter:"linear"})),De(this,pe).pipelineByFormat[e.texture.format]||(De(this,pe).pipelineByFormat[e.texture.format]=this.device.createRenderPipeline({label:"Mip level generator pipeline",layout:"auto",vertex:{module:De(this,pe).module},fragment:{module:De(this,pe).module,targets:[{format:e.texture.format}]}}));const s=De(this,pe).pipelineByFormat[e.texture.format],i=t||this.device.createCommandEncoder({label:"Mip gen encoder"});let n=e.texture.width,a=e.texture.height,o=0;for(;n>1||a>1;){n=Math.max(1,n/2|0),a=Math.max(1,a/2|0);for(let h=0;h<e.texture.depthOrArrayLayers;++h){const l=this.device.createBindGroup({layout:s.getBindGroupLayout(0),entries:[{binding:0,resource:De(this,pe).sampler},{binding:1,resource:e.texture.createView({dimension:"2d",baseMipLevel:o,mipLevelCount:1,baseArrayLayer:h,arrayLayerCount:1})}]}),d={label:"Mip generation render pass",colorAttachments:[{view:e.texture.createView({dimension:"2d",baseMipLevel:o+1,mipLevelCount:1,baseArrayLayer:h,arrayLayerCount:1}),loadOp:"clear",storeOp:"store"}]},c=i.beginRenderPass(d);c.setPipeline(s),c.setBindGroup(0,l),c.draw(6),c.end()}++o}if(!t){const h=i.finish();this.device.queue.submit([h])}}animate(){this.render(),this.animationFrameID=requestAnimationFrame(this.animate.bind(this))}onBeforeRender(e){return e&&(this._onBeforeRenderCallback=e),this}onAfterRender(e){return e&&(this._onAfterRenderCallback=e),this}render(){if(!this.ready)return;this._onBeforeRenderCallback&&this._onBeforeRenderCallback();for(const s of this.renderers)s.shouldRender&&s.onBeforeCommandEncoder();const e=this.device?.createCommandEncoder({label:this.label+" command encoder"});!this.production&&e.pushDebugGroup(this.label+" command encoder: main render loop"),this.renderers.forEach(s=>s.render(e)),!this.production&&e.popDebugGroup();const t=e.finish();this.device?.queue.submit([t]);for(const s of this.texturesQueue)s.texture.setSourceUploaded(s.sourceIndex);this.texturesQueue=[];for(const s of this.renderers)s.shouldRender&&s.onAfterCommandEncoder();this._onAfterRenderCallback&&this._onAfterRenderCallback()}destroy(){this.animationFrameID&&cancelAnimationFrame(this.animationFrameID),this.animationFrameID=null,this.device?.destroy(),this.device=null,this.renderers.forEach(e=>e.destroy()),this.bindGroups.forEach(e=>e.destroy()),this.buffers.forEach(e=>e?.destroy()),this.indirectBuffers.forEach(e=>e.destroy()),this.setDeviceObjects()}}pe=new WeakMap;var aa=u(r=>{throw TypeError(r)},"__typeError$9"),Ih=u((r,e,t)=>e.has(r)||aa("Cannot "+t),"__accessCheck$9"),kh=u((r,e,t)=>e.has(r)?aa("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$9"),Vh=u((r,e,t)=>(Ih(r,e,"access private method"),t),"__privateMethod$7"),dr,oa;const Nh=5;class ha{static{u(this,"IndirectBuffer")}constructor(e,{label:t="Indirect buffer",geometries:s=[],minEntrySize:i=Nh}={}){kh(this,dr),this.type="IndirectBuffer",this.setRenderer(e),this.uuid=O(),this.options={label:t,geometries:s,minEntrySize:i},this.geometries=new Map,this.buffer=null,this.addGeometries(s),this.renderer.indirectBuffers.set(this.uuid,this)}setRenderer(e){e=$(e,this.type),this.renderer=e}get size(){return this.geometries.size}addGeometries(e=[]){e.forEach(t=>this.addGeometry(t))}addGeometry(e){this.geometries.set(e.uuid,e)}getByteOffsetAtIndex(e=0){return e*this.options.minEntrySize*Uint32Array.BYTES_PER_ELEMENT}create(){const e=this.getByteOffsetAtIndex(this.geometries.size);this.buffer?(this.buffer.destroy(),this.buffer.options.size=e):this.buffer=new Je({label:this.options.label,size:e,usage:["copyDst","indirect","storage"],mappedAtCreation:!0}),this.buffer.consumers.add(this.uuid),this.buffer.createBuffer(this.renderer);const t=new Uint32Array(this.buffer.GPUBuffer.getMappedRange());let s=0;this.geometries.forEach(i=>{Vh(this,dr,oa).call(this,i,t,s*this.options.minEntrySize),i.useIndirectBuffer({buffer:this.buffer,offset:this.getByteOffsetAtIndex(s)}),s++}),this.buffer.GPUBuffer.unmap()}destroy(){this.renderer.removeBuffer(this.buffer),this.renderer.indirectBuffers.delete(this.uuid),this.geometries.forEach(e=>e.indirectDraw=null),this.buffer?.destroy(),this.buffer=null,this.geometries=null}}dr=new WeakSet,oa=u(function(r,e,t=0){"indexBuffer"in r&&r.indexBuffer?(e[t]=r.indexBuffer.bufferLength,e[t+1]=r.instancesCount,e[t+2]=0,e[t+3]=0,e[t+4]=0):(e[t]=r.verticesCount,e[t+1]=r.instancesCount,e[t+2]=0,e[t+3]=0,e[t+4]=0)},"addGeometryToIndirectMappedBuffer_fn");var la=u(r=>{throw TypeError(r)},"__typeError$8"),cr=u((r,e,t)=>e.has(r)||la("Cannot "+t),"__accessCheck$8"),ua=u((r,e,t)=>(cr(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet$7"),pr=u((r,e,t)=>e.has(r)?la("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$8"),ui=u((r,e,t,s)=>(cr(r,e,"write to private field"),e.set(r,t),t),"__privateSet$7"),qe=u((r,e,t)=>(cr(r,e,"access private method"),t),"__privateMethod$6"),Yt,Kt,_e,da,fr,ca,pa,fa,mr;let Wh=0;class jh{static{u(this,"RenderBundle")}constructor(e,{label:t,renderPass:s=null,renderOrder:i=0,transparent:n=null,visible:a=!0,size:o=0,useBuffer:h=!1,useIndirectDraw:l=!1}={}){pr(this,_e),pr(this,Yt),pr(this,Kt),this.type="RenderBundle",e=$(e,this.type),this.uuid=O(),Object.defineProperty(this,"index",{value:Wh++}),this.renderOrder=i,this.transparent=n,this.visible=a,t=t??this.type+this.index,this.options={label:t,renderPass:s,useBuffer:h,size:o,useIndirectDraw:l},this.meshes=new Map,this.encoder=null,this.bundle=null,ui(this,Kt,!1),this.binding=null,this.indirectBuffer=null,this.setRenderer(e),this.options.useIndirectDraw&&(this.indirectBuffer=new ha(this.renderer)),this.options.useBuffer&&(ui(this,Yt,!0),this.options.size!==0?qe(this,_e,da).call(this):(this.options.useBuffer=!1,this.renderer.production||A(`${this.options.label} (${this.type}): Cannot use a single transformation buffer if the size parameter has not been set upon creation.`)))}setRenderer(e){this.renderer&&(this.removeFromScene(),this.renderer.renderBundles.delete(this.uuid)),this.renderer=e,this.renderer.renderBundles.set(this.uuid,this),this.meshes.size>=1&&this.addToScene()}addToScene(){const e=this.meshes.entries().next();if(e&&e.value&&e.value.length&&e.value[1]){const t=e.value[1],s=!!t.transparent;if(this.transparent===null&&(this.transparent=s),t.constructor.name!=="ShaderPass"&&t.constructor.name!=="PingPongPlane"){const{useProjection:i}=t.material.options.rendering;this.useProjection===null&&(this.useProjection=i);const n=this.renderer.scene.getMeshProjectionStack(t);this.renderer.scene.addRenderBundle(this,n)}else this.size=1,t.renderOrder=this.renderOrder,this.useProjection=!1}}removeFromScene(){this.renderer.scene.removeRenderBundle(this)}get useProjection(){return ua(this,Yt)}set useProjection(e){ui(this,Yt,e)}set size(e){e!==this.options.size&&(this.ready&&!this.renderer.production&&A(`${this.options.label} (${this.type}): The content of a render bundle is meant to be static. You should not change its size after it has been created.`),this.ready=!1,qe(this,_e,ca).call(this,e),this.options.size=e)}get ready(){return ua(this,Kt)}set ready(e){e&&!this.ready?(this.size=this.meshes.size,this.options.useIndirectDraw&&(this.meshes.forEach(t=>{this.indirectBuffer.addGeometry(t.geometry)}),this.indirectBuffer.create()),qe(this,_e,fa).call(this)):!e&&this.ready&&(this.bundle=null),ui(this,Kt,e)}addMesh(e,t){if(!this.options.renderPass)this.options.renderPass=t;else if(t.uuid!==this.options.renderPass.uuid){A(`${this.options.label} (${this.type}): Cannot add Mesh ${e.options.label} to this render bundle because the output render passes do not match.`),e.renderBundle=null;return}this.ready&&!this.renderer.production&&A(`${this.options.label} (${this.type}): The content of a render bundle is meant to be static. You should not add meshes to it after it has been created (mesh added: ${e.options.label}).`),this.ready=!1,this.meshes.set(e.uuid,e),this.meshes.size===1&&this.addToScene()}removeSceneObject(e){this.ready&&!this.renderer.production&&A(`${this.options.label} (${this.type}): The content of a render bundle is meant to be static. You should not remove meshes from it after it has been created (mesh removed: ${e.options.label}).`),this.ready=!1,this.meshes.delete(e.uuid),e.setRenderBundle(null,!1),this.options.useIndirectDraw&&(e.geometry.indirectDraw=null)}removeMesh(e,t=!0){this.removeSceneObject(e),t&&e.type!=="ShaderPass"&&e.type!=="PingPongPlane"&&this.renderer.scene.addMesh(e),this.meshes.size===0&&this.renderer.scene.removeRenderBundle(this)}updateBinding(){this.binding&&this.binding.shouldUpdate&&this.binding.buffer.GPUBuffer&&(this.renderer.queueWriteBuffer(this.binding.buffer.GPUBuffer,0,this.binding.arrayBuffer),this.binding.shouldUpdate=!1)}resize(){for(const[e,t]of this.meshes)if(t.textures.find(i=>!i.options.fixedSize)){this.ready=!1;break}}render(e){if(this.ready&&this.bundle&&this.visible&&(this.meshes.forEach(t=>{t.onBeforeRenderPass()}),this.updateBinding(),this.renderer.pipelineManager.resetCurrentPipeline(),this.renderer.production||e.pushDebugGroup(`${this.options.label}: execute bundle`),e.executeBundles([this.bundle]),this.renderer.production||e.popDebugGroup(),this.renderer.pipelineManager.resetCurrentPipeline(),this.meshes.forEach(t=>{t.onAfterRenderPass()})),!this.ready){let t=!0;for(const[s,i]of this.meshes){if(i.render(e),!i.ready){t=!1;break}for(const n of i.textures)if(n instanceof ce&&!n.sourcesUploaded){t=!1;break}}this.ready=t}}loseContext(){this.ready=!1}empty(e=!0){this.ready=!1,this.meshes.forEach(t=>{this.removeMesh(t,e)}),this.size=0}remove(){this.empty(!0),qe(this,_e,mr).call(this)}destroy(){this.ready=!1,this.meshes.forEach(e=>{e.remove()}),this.size=0,qe(this,_e,mr).call(this)}}Yt=new WeakMap,Kt=new WeakMap,_e=new WeakSet,da=u(function(){this.binding=new Y({label:this.options.label+" matrices",name:"matrices",visibility:["vertex","fragment"],struct:{model:{type:"array<mat4x4f>",value:new Float32Array(16*this.options.size)},modelView:{type:"array<mat4x4f>",value:new Float32Array(16*this.options.size)},normal:{type:"array<mat3x3f>",value:new Float32Array(12*this.options.size)}}}),qe(this,_e,fr).call(this,this.options.size)},"setBinding_fn"),fr=u(function(r){const e=this.renderer.device.limits.minUniformBufferOffsetAlignment;this.binding.arrayBufferSize<r*e&&(this.binding.arrayBufferSize=r*e,this.binding.arrayBuffer=new ArrayBuffer(this.binding.arrayBufferSize),this.binding.buffer.size=this.binding.arrayBuffer.byteLength)},"patchBindingOffset_fn"),ca=u(function(r){if(r>this.options.size&&this.binding&&(qe(this,_e,fr).call(this,r),this.binding.buffer.GPUBuffer)){this.binding.buffer.GPUBuffer.destroy(),this.binding.buffer.createBuffer(this.renderer,{label:this.binding.options.label,usage:["copySrc","copyDst",this.binding.bindingType,...this.binding.options.usage]});let e=0;this.meshes.forEach(t=>{t.patchRenderBundleBinding(e),e++}),this.binding.shouldUpdate=!0}},"onSizeChanged_fn"),pa=u(function(){this.descriptor={...this.options.renderPass.options.colorAttachments&&{colorFormats:this.options.renderPass.options.colorAttachments.map(r=>r.targetFormat)},...this.options.renderPass.options.useDepth&&{depthStencilFormat:this.options.renderPass.options.depthFormat},sampleCount:this.options.renderPass.options.sampleCount}},"setDescriptor_fn"),fa=u(function(){qe(this,_e,pa).call(this),this.renderer.pipelineManager.resetCurrentPipeline(),this.encoder=this.renderer.device.createRenderBundleEncoder({...this.descriptor,label:this.options.label+" (encoder)"}),this.renderer.production||this.encoder.pushDebugGroup(`${this.options.label}: create encoder`),this.meshes.forEach(r=>{r.material.render(this.encoder),r.geometry.render(this.encoder)}),this.renderer.production||this.encoder.popDebugGroup(),this.bundle=this.encoder.finish({label:this.options.label+" (bundle)"}),this.renderer.pipelineManager.resetCurrentPipeline()},"encodeRenderCommands_fn"),mr=u(function(){this.binding&&(this.renderer.removeBuffer(this.binding.buffer),this.binding.buffer.destroy()),this.indirectBuffer&&this.indirectBuffer.destroy(),this.renderer.renderBundles.delete(this.uuid)},"cleanUp_fn");const qh=`
struct VSOutput {
  @builtin(position) position: vec4f,
  @location(0) uv: vec2f,
};

@fragment fn main(fsInput: VSOutput) -> @location(0) vec4f {
  return textureSample(renderTexture, defaultSampler, fsInput.uv);
}`;class Hh extends tr{static{u(this,"ShaderPass")}constructor(e,t={}){e=$(e,t.label?t.label+" ShaderPass":"ShaderPass"),t.isPrePass=!!t.isPrePass;const s={color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}};t.isPrePass||(t.targets?t.targets&&t.targets.length&&!t.targets[0].blend&&(t.targets[0].blend=s):t.targets=[{blend:s}]),t.label=t.label??"ShaderPass "+e.shaderPasses?.length,t.sampleCount=t.sampleCount?t.sampleCount:e&&e.renderPass&&t.isPrePass?e.renderPass.options.sampleCount:e&&e.postProcessingPass?e&&e.postProcessingPass.options.sampleCount:1,t.shaders||(t.shaders={}),t.shaders.fragment||(t.shaders.fragment={code:qh,entryPoint:"main"}),t.depth=t.isPrePass,super(e,t),this.options={...this.options,copyOutputToRenderTexture:t.copyOutputToRenderTexture,isPrePass:t.isPrePass},t.inputTarget&&this.setInputTarget(t.inputTarget),this.outputTarget&&this.setRenderingOptionsForRenderPass(this.outputTarget.renderPass),this.type="ShaderPass",this.createTexture({label:t.label?`${t.label} render texture`:"Shader pass render texture",name:"renderTexture",fromTexture:this.inputTarget?this.inputTarget.renderTexture:null,usage:["copySrc","copyDst","textureBinding"],...this.outputTarget&&this.outputTarget.options.qualityRatio&&{qualityRatio:this.outputTarget.options.qualityRatio}})}cleanupRenderMaterialParameters(e){return delete e.copyOutputToRenderTexture,delete e.inputTarget,delete e.isPrePass,super.cleanupRenderMaterialParameters(e),e}get renderTexture(){return this.textures.find(e=>e.options.name==="renderTexture")}setInputTarget(e){if(e&&e.type!=="RenderTarget"){A(`${this.options.label??this.type}: inputTarget is not a RenderTarget: ${e}`);return}this.removeFromScene(),this.inputTarget=e,this.addToScene(),this.renderTexture&&(e?this.renderTexture.copy(this.inputTarget.renderTexture):(this.renderTexture.options.fromTexture=null,this.renderTexture.createTexture()))}addToScene(e=!1){e&&this.renderer.shaderPasses.push(this),this.setRenderingOptionsForRenderPass(this.outputTarget?this.outputTarget.renderPass:this.options.isPrePass?this.renderer.renderPass:this.renderer.postProcessingPass),this.autoRender&&this.renderer.scene.addShaderPass(this)}removeFromScene(e=!1){this.outputTarget&&this.outputTarget.destroy(),this.autoRender&&this.renderer.scene.removeShaderPass(this),e&&(this.renderer.shaderPasses=this.renderer.shaderPasses.filter(t=>t.uuid!==this.uuid))}}const $e=`
const PI = ${Math.PI};
const RECIPROCAL_PI = ${1/Math.PI};
const RECIPROCAL_PI2 = ${.5/Math.PI};
const EPSILON = 1e-6;`,ot=`
fn lessThan3(a: vec3f, b: vec3f) -> vec3f {
  return vec3f(vec3<bool>(a.x < b.x, a.y < b.y, a.z < b.z));
}

fn pow2( x: f32 ) -> f32 {
  return x * x;
}

fn pow3( x: f32 ) -> f32 {
  return x * x * x;
}

fn pow4( x: f32 ) -> f32 {
  return pow2(x) * pow2(x);
}

fn isinf(value: f32) -> bool {
  return value > 1.0e38 || value < -1.0e38;
}

fn BRDF_Lambert(diffuseColor: vec3f) -> vec3f {
  return RECIPROCAL_PI * diffuseColor;
}

fn F_Schlick(f0: vec3f, f90: f32, VdotH: f32) -> vec3f {
  let fresnel: f32 = exp2( ( - 5.55473 * VdotH - 6.98316 ) * VdotH );
  return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
`,wt=`
// linear <-> sRGB conversions
fn linearTosRGB(linear: vec3f) -> vec3f {
  return vec3( mix( pow( linear.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), linear.rgb * 12.92, vec3( lessThan3( linear.rgb, vec3( 0.0031308 ) ) ) ) );
}

fn linearTosRGB_4(linear: vec4f) -> vec4f {
  return vec4( linearTosRGB(linear.rgb), linear.a );
}

fn sRGBToLinear(srgb: vec3f) -> vec3f {
  if (all(srgb <= vec3(0.04045))) {
    return srgb / vec3(12.92);
  }
  return pow((srgb + vec3(0.055)) / vec3(1.055), vec3(2.4));
}

fn sRGBToLinear_4(srgb: vec4f) -> vec4f {
  return vec4( sRGBToLinear(srgb.rgb), srgb.a );
}

// source: https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf
fn ReinhardToneMapping( color: vec3f ) -> vec3f {
	return saturate( color / ( vec3( 1.0 ) + color ) );
}

// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/
fn CineonToneMapping( color: vec3f ) -> vec3f {
	// filmic operator by Jim Hejl and Richard Burgess-Dawson
	let maxColor = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( maxColor * ( 6.2 * maxColor + 0.5 ) ) / ( maxColor * ( 6.2 * maxColor + 1.7 ) + 0.06 ), vec3( 2.2 ) );

}

// https://modelviewer.dev/examples/tone-mapping
fn KhronosToneMapping( color: vec3f ) -> vec3f {
  var toneMapColor = color; 
  const startCompression: f32 = 0.8 - 0.04;
  const desaturation: f32 = 0.15;
  var x: f32 = min(toneMapColor.r, min(toneMapColor.g, toneMapColor.b));
  var offset: f32 = select(0.04, x - 6.25 * x * x, x < 0.08);
  toneMapColor = toneMapColor - offset;
  var peak: f32 = max(toneMapColor.r, max(toneMapColor.g, toneMapColor.b));
  if (peak < startCompression) {
    return toneMapColor;
  }
  const d: f32 = 1. - startCompression;
  let newPeak: f32 = 1. - d * d / (peak + d - startCompression);
  toneMapColor *= newPeak / peak;
  let g: f32 = 1. - 1. / (desaturation * (peak - newPeak) + 1.);
  return mix(toneMapColor, newPeak * vec3(1, 1, 1), g);
}
`,di=`
struct ReflectedLight {
  directDiffuse: vec3f,
  directSpecular: vec3f,
  indirectDiffuse: vec3f,
  indirectSpecular: vec3f,
}

struct DirectLight {
  color: vec3f,
  direction: vec3f,
  visible: bool,
}

fn rangeAttenuation(range: f32, distance: f32, decay: f32) -> f32 {
  var distanceFalloff: f32 = 1.0 / max( pow( distance, decay ), 0.01 );
  if ( range > 0.0 ) {
    distanceFalloff *= pow2( saturate( 1.0 - pow4( distance / range )) );
  }
  
  return distanceFalloff;
}

fn spotAttenuation(coneCosine: f32, penumbraCosine: f32, angleCosine: f32) -> f32 {
  return smoothstep( coneCosine, penumbraCosine, angleCosine );
}

fn getDirectionalLightInfo(directionalLight: DirectionalLightsElement, ptr_light: ptr<function, DirectLight>) {
  (*ptr_light).color = directionalLight.color;
  (*ptr_light).direction = -directionalLight.direction;
  (*ptr_light).visible = length((*ptr_light).color) > EPSILON;
}

fn getPointLightInfo(pointLight: PointLightsElement, worldPosition: vec3f, ptr_light: ptr<function, DirectLight>) {
  let lightDirection: vec3f = pointLight.position - worldPosition;
  (*ptr_light).direction = normalize(lightDirection);
  let lightDistance: f32 = length(lightDirection);
  (*ptr_light).color = pointLight.color;
  (*ptr_light).color *= rangeAttenuation(pointLight.range, lightDistance, 2.0);
  (*ptr_light).visible = length((*ptr_light).color) > EPSILON;
}

fn getSpotLightInfo(spotLight: SpotLightsElement, worldPosition: vec3f, ptr_light: ptr<function, DirectLight>) {
  let lVector: vec3f = spotLight.position - worldPosition;
  let lightDirection: vec3f = normalize(lVector);
  (*ptr_light).direction = lightDirection;

  let angleCos: f32 = dot(lightDirection, -spotLight.direction);

  let spotAttenuation: f32 = spotAttenuation(spotLight.coneCos, spotLight.penumbraCos, angleCos);

  if (spotAttenuation > 0.0) {
    let lightDistance: f32 = length(lVector);

    (*ptr_light).color = spotLight.color * spotAttenuation;
    (*ptr_light).color *= rangeAttenuation(spotLight.range, lightDistance, 2.0);
    (*ptr_light).visible = length((*ptr_light).color) > EPSILON;

  } else {
    (*ptr_light).color = vec3(0.0);
    (*ptr_light).visible = false;
  }
}
`,ci=`
fn getIndirectDiffuse(irradiance: vec3f, diffuseColor: vec3f, ptr_reflectedLight: ptr<function, ReflectedLight>) {
  (*ptr_reflectedLight).indirectDiffuse += irradiance * BRDF_Lambert( diffuseColor );
}

// Indirect Diffuse RenderEquations
fn RE_IndirectDiffuse(irradiance: vec3f, diffuseColor: vec3f, ptr_reflectedLight: ptr<function, ReflectedLight>) {
  var totalAmbientIrradiance: vec3f = irradiance;
  
  for(var i: i32 = 0; i < ambientLights.count; i++) {
    totalAmbientIrradiance += ambientLights.color[i];
  }
  
  getIndirectDiffuse(totalAmbientIrradiance, diffuseColor, ptr_reflectedLight);
}
`,ma=`
fn getLambertDirect(
  normal: vec3f,
  diffuseColor: vec3f,
  directLight: DirectLight,
  ptr_reflectedLight: ptr<function, ReflectedLight>
) {
  let NdotL = saturate(dot(normal, directLight.direction));
  
  let irradiance: vec3f = NdotL * directLight.color;
  (*ptr_reflectedLight).directDiffuse += irradiance * BRDF_Lambert( diffuseColor );
}
`,gr=`
  let pointShadows = getPCFPointShadows(worldPosition);
  let directionalShadows = getPCFDirectionalShadows(worldPosition);
  let spotShadows = getPCFSpotShadows(worldPosition);
`,yr=`
    directLight.color *= directionalShadows[i];
`,xr=`
    directLight.color *= pointShadows[i];
`,vr=`
    directLight.color *= spotShadows[i];
`,ga=u(({receiveShadows:r=!1}={})=>`
  var directLight: DirectLight;
  var reflectedLight: ReflectedLight;
  
  ${r?gr:""}
  
  // point lights
  for(var i = 0; i < pointLights.count; i++) {
    getPointLightInfo(pointLights.elements[i], worldPosition, &directLight);
    
    if(!directLight.visible) {
      continue;
    }
    
    ${r?xr:""}
    getLambertDirect(normal, outputColor.rgb, directLight, &reflectedLight);
  }

  // spot lights
  for(var i = 0; i < spotLights.count; i++) {
    getSpotLightInfo(spotLights.elements[i], worldPosition, &directLight);
    
    if(!directLight.visible) {
      continue;
    }
    
    ${r?vr:""}
    getLambertDirect(normal, outputColor.rgb, directLight, &reflectedLight);
  }
  
  // directional lights
  for(var i = 0; i < directionalLights.count; i++) {
    getDirectionalLightInfo(directionalLights.elements[i], &directLight);
    
    if(!directLight.visible) {
      continue;
    }
    
    ${r?yr:""}
    getLambertDirect(normal, outputColor.rgb, directLight, &reflectedLight);
  }
  
  // ambient lights
  var irradiance: vec3f = vec3(0.0);
  RE_IndirectDiffuse(irradiance, outputColor.rgb, &reflectedLight);
  
  let totalDirect: vec3f = reflectedLight.directDiffuse + reflectedLight.directSpecular;
  var totalIndirect: vec3f = reflectedLight.indirectDiffuse + reflectedLight.indirectSpecular;
  
  totalIndirect *= occlusion;
  
  var outgoingLight: vec3f = totalDirect + totalIndirect;`,"getLambertShading"),ht=u(({toneMapping:r="Khronos"}={})=>{let e=`
  let exposure: f32 = 1.0; // TODO
  outputColor *= exposure;
  `;return e+=(()=>{switch(r){case"Khronos":return`
  outputColor = vec4(KhronosToneMapping(outputColor.rgb), outputColor.a);
  `;case"Reinhard":return`
  outputColor = vec4(ReinhardToneMapping(outputColor.rgb), outputColor.a);
        `;case"Cineon":return`
  outputColor = vec4(CineonToneMapping(outputColor.rgb), outputColor.a);
        `;case!1:default:return`
  outputColor = saturate(outputColor);
        `}})(),e+=`
  outputColor = linearTosRGB_4(outputColor);
  `,e},"applyToneMapping"),pi=`
${$e}
${ot}
${di}
${ci}
${wt}
`,Xh=u(({addUtils:r=!0,receiveShadows:e=!1,toneMapping:t,useOcclusion:s=!1}={})=>`
${r?pi:""}
${ma}

fn getLambert(
  normal: vec3f,
  worldPosition: vec3f,
  color: vec4f,
  ${s?"occlusion: f32,":""}
) -> vec4f {
  ${s?"":"let occlusion: f32 = 1.0;"}
  
  var outputColor: vec4f = color;

  ${ga({receiveShadows:e})}
  
  outputColor = vec4(outgoingLight, outputColor.a);
  
  ${ht({toneMapping:t})}
    
  return outputColor;
}
`,"getLambert"),ya=`
fn D_BlinnPhong( shininess: f32, NdotH: f32 ) -> f32 {
  return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( NdotH, shininess );
}

fn BRDF_BlinnPhong(
  normal: vec3f,
  viewDirection: vec3f,
  specularColor: vec3f,
  shininess: f32,
  directLight: DirectLight
) -> vec3f {
  let H: vec3f = normalize(viewDirection + directLight.direction);
  
  let NdotH: f32 = saturate(dot(normal, H));
  let VdotH: f32 = saturate(dot(viewDirection, H));
  
  let F: vec3f = F_Schlick(specularColor, 1.0, VdotH);
  let G: f32 = 0.25; // blinn phong implicit
  let D = D_BlinnPhong(shininess, NdotH);
  
  let specular: vec3f = F * G * D;
        
  return specular;
}

fn getPhongDirect(
  normal: vec3f,
  diffuseColor: vec3f,
  viewDirection: vec3f,
  specularColor: vec3f,
  specularStrength: f32,
  shininess: f32,
  directLight: DirectLight,
  ptr_reflectedLight: ptr<function, ReflectedLight>
) {
  let NdotL = saturate(dot(normal, directLight.direction));
  
  let irradiance: vec3f = NdotL * directLight.color;
  (*ptr_reflectedLight).directDiffuse += irradiance * BRDF_Lambert( diffuseColor );
  (*ptr_reflectedLight).directSpecular += irradiance * BRDF_BlinnPhong( normal, viewDirection, specularColor, shininess, directLight ) * specularStrength;
}
`,xa=u(({receiveShadows:r=!1}={})=>`
  var directLight: DirectLight;
  var reflectedLight: ReflectedLight;
  
  ${r?gr:""}

  // point lights
  for(var i = 0; i < pointLights.count; i++) {  
    getPointLightInfo(pointLights.elements[i], worldPosition, &directLight);
    
    if(!directLight.visible) {
      continue;
    }
    
    ${r?xr:""}
    getPhongDirect(normal, outputColor.rgb, viewDirection, specularColor, specularIntensity, shininess, directLight, &reflectedLight);
  }
  
  // spot lights
  for(var i = 0; i < spotLights.count; i++) {
    getSpotLightInfo(spotLights.elements[i], worldPosition, &directLight);
    
    if(!directLight.visible) {
      continue;
    }
    
    ${r?vr:""}
    getPhongDirect(normal, outputColor.rgb, viewDirection, specularColor, specularIntensity, shininess, directLight, &reflectedLight);
  }
  
  // directional lights
  for(var i = 0; i < directionalLights.count; i++) {
    getDirectionalLightInfo(directionalLights.elements[i], &directLight);
    
    if(!directLight.visible) {
      continue;
    }
    
    ${r?yr:""}
    getPhongDirect(normal, outputColor.rgb, viewDirection, specularColor, specularIntensity, shininess, directLight, &reflectedLight);
  }
  
  // ambient lights
  var irradiance: vec3f = vec3(0.0);
  RE_IndirectDiffuse(irradiance, outputColor.rgb, &reflectedLight);
  
  let totalDirect: vec3f = reflectedLight.directDiffuse + reflectedLight.directSpecular;
  var totalIndirect: vec3f = reflectedLight.indirectDiffuse + reflectedLight.indirectSpecular;
  
  totalIndirect *= occlusion;
  
  var outgoingLight: vec3f = totalDirect + totalIndirect;`,"getPhongShading"),Yh=u(({addUtils:r=!0,receiveShadows:e=!1,toneMapping:t,useOcclusion:s=!1}={})=>`
${r?pi:""}
${ya}

fn getPhong(
  normal: vec3f,
  worldPosition: vec3f,
  color: vec4f,
  viewDirection: vec3f,
  specularIntensity: f32,
  specularColor: vec3f,
  shininess: f32,
  ${s?"occlusion: f32,":""}
) -> vec4f {
  ${s?"":"let occlusion: f32 = 1.0;"}

  var outputColor: vec4f = color;

  ${xa({receiveShadows:e})}
  
  outputColor = vec4(outgoingLight, outputColor.a);
  
  ${ht({toneMapping:t})}
    
  return outputColor;
}
`,"getPhong"),va=`
// Indirect Specular RenderEquations
fn RE_IndirectSpecular(
  radiance: vec3f,
  irradiance: vec3f,
  normal: vec3f,
  diffuseColor: vec3f,
  specularFactor: f32,
  specularColorFactor: vec3f,
  viewDirection: vec3f,
  metallic: f32,
  roughness: f32,
  iBLGGXFresnel: IBLGGXFresnel,
  ptr_reflectedLight: ptr<function, ReflectedLight>
) {
  let k_D: vec3f = diffuseColor * (1.0 - iBLGGXFresnel.FssEss + iBLGGXFresnel.FmsEms);

  // we just add radiance and irradiance to the indirect contributions using iBLGGXFresnel
  // we might need to adjust when implementing clearcoat, sheen or iridescence

  // we remove RECIPROCAL_PI multiplication since the LUT already ensures energy conservation
  let cosineWeightedIrradiance: vec3f = irradiance;
  // let cosineWeightedIrradiance: vec3f = irradiance * RECIPROCAL_PI;  

  (*ptr_reflectedLight).indirectSpecular += iBLGGXFresnel.FssEss * radiance;
  (*ptr_reflectedLight).indirectSpecular += iBLGGXFresnel.FmsEms * cosineWeightedIrradiance;
  
  (*ptr_reflectedLight).indirectDiffuse += k_D * cosineWeightedIrradiance;
}
`,ba=`
fn getVolumeTransmissionRay(normal: vec3f, viewDirection: vec3f, thickness: f32, ior: f32, modelScale: vec3f) -> vec3f {
  let refractionVector = refract(-viewDirection, normal, 1.0 / ior);    
  return normalize(refractionVector) * thickness * modelScale;
}

fn applyIorToRoughness(roughness: f32, ior: f32) -> f32 {
  return roughness * saturate(ior * 2.0 - 2.0);
}

fn getTransmissionSample( fragCoord: vec2f, roughness: f32, ior: f32, transmissionSceneTexture: texture_2d<f32>, sampler: sampler ) -> vec4f {
  let transmissionSamplerSize: vec2f = vec2f(textureDimensions(transmissionSceneTexture));
  let lod: f32 = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
  return textureSampleLevel( transmissionSceneTexture, sampler, fragCoord.xy, lod );
}

fn volumeAttenuation(transmissionDistance: f32, attenuationColor: vec3f, attenuationDistance: f32) -> vec3f {
  if (isinf(attenuationDistance)) {
    return vec3(1.0);
  } else {
    let attenuationCoefficient = -log(attenuationColor) / attenuationDistance;
    let transmittance = exp(-attenuationCoefficient * transmissionDistance);
    return transmittance;
  }
}

fn getIBLVolumeRefraction(
  normal: vec3f,
  viewDirection: vec3f,
  roughness: f32,
  diffuseColor: vec4f,
  specularColor: vec3f,
  specularF90: f32,
  position: vec3f,
  modelScale: vec3f,
  viewMatrix: mat4x4f,
  projMatrix: mat4x4f,
  dispersion: f32,
  ior: f32,
  thickness: f32,
  attenuationColor: vec3f,
  attenuationDistance: f32,
  transmissionBackgroundTexture: texture_2d<f32>,
  defaultSampler: sampler,
) -> vec4f {
    // TODO dispersion
    var transmittedLight: vec4f;
    var transmissionRayLength: f32;
    var transmittance: vec3f;
    
    // Calculate the transmission ray
    let transmissionRay: vec3f = getVolumeTransmissionRay(normal, viewDirection, thickness, ior, modelScale);
    let refractedRayExit = position + transmissionRay;

    // Transform to NDC space
    let ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);
    var refractionCoords = ndcPos.xy / ndcPos.w;
    refractionCoords = (refractionCoords + 1.0) / 2.0;
    refractionCoords = vec2(refractionCoords.x, 1.0 - refractionCoords.y); // webgpu Y flip

    // Sample the transmission texture
    transmittedLight = getTransmissionSample(refractionCoords, roughness, ior, transmissionBackgroundTexture, defaultSampler);

    // Compute transmittance
    transmittance = diffuseColor.rgb * volumeAttenuation(length(transmissionRay), attenuationColor, attenuationDistance);

    // Apply attenuation to transmitted light
    let attenuatedColor = transmittance * transmittedLight.rgb;

    // Compute Fresnel term using an environment BRDF
    let F = EnvironmentBRDF(normal, viewDirection, specularColor, specularF90, roughness);

    // Average the transmittance for a single factor
    let transmittanceFactor = (transmittance.r + transmittance.g + transmittance.b) / 3.0;

    // Combine results into the final color
    return vec4(
      (1.0 - F) * attenuatedColor,
      1.0 - (1.0 - transmittedLight.a) * transmittanceFactor
    );
}

fn getIBLVolumeRefractionWithDispersion(
  normal: vec3f,
  viewDirection: vec3f,
  roughness: f32,
  diffuseColor: vec4f,
  specularColor: vec3f,
  specularF90: f32,
  position: vec3f,
  modelScale: vec3f,
  viewMatrix: mat4x4f,
  projMatrix: mat4x4f,
  dispersion: f32,
  ior: f32,
  thickness: f32,
  attenuationColor: vec3f,
  attenuationDistance: f32,
  transmissionBackgroundTexture: texture_2d<f32>,
  defaultSampler: sampler,
) -> vec4f {
    var transmittedLight: vec4f;
    var transmissionRayLength: f32;
    var transmittance: vec3f;
    
    let halfSpread: f32 = (ior - 1.0) * 0.025 * dispersion;
    let iors: vec3f = vec3(ior - halfSpread, ior, ior + halfSpread);
    
    for(var i: i32 = 0; i < 3; i++) {
      let transmissionRay: vec3f = getVolumeTransmissionRay(normal, viewDirection, thickness, iors[i], modelScale);
      transmissionRayLength = length(transmissionRay);
      let refractedRayExit = position + transmissionRay;

      // Transform to NDC space
      let ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);
      var refractionCoords = ndcPos.xy / ndcPos.w;
      refractionCoords = (refractionCoords + 1.0) / 2.0;
      refractionCoords = vec2(refractionCoords.x, 1.0 - refractionCoords.y); // webgpu Y flip
      
      let transmissionSample: vec4f = getTransmissionSample(refractionCoords, roughness, iors[i], transmissionBackgroundTexture, defaultSampler);
      
      transmittedLight[i] = transmissionSample[i];
      transmittedLight.a += transmissionSample.a;
      
      // Compute transmittance
      let diffuse: vec3f = diffuseColor.rgb;
      transmittance[i] = diffuse[i] * volumeAttenuation(length(transmissionRay), attenuationColor, attenuationDistance)[i];
    }
    
    transmittedLight.a /= 3.0;

    // Apply attenuation to transmitted light
    let attenuatedColor = transmittance * transmittedLight.rgb;

    // Compute Fresnel term using an environment BRDF
    let F = EnvironmentBRDF(normal, viewDirection, specularColor, specularF90, roughness);

    // Average the transmittance for a single factor
    let transmittanceFactor = (transmittance.r + transmittance.g + transmittance.b) / 3.0;

    // Combine results into the final color
    return vec4(
      (1.0 - F) * attenuatedColor,
      1.0 - (1.0 - transmittedLight.a) * transmittanceFactor
    );
}
`,wa=`
fn DistributionGGX(NdotH: f32, roughness: f32) -> f32 {
  let a: f32 = pow2( roughness );
  let a2: f32 = pow2( a );

  let denom: f32 = (pow2( NdotH ) * (a2 - 1.0) + 1.0);

  return RECIPROCAL_PI * a2 / ( pow2( denom ) );
}

fn GeometrySmith(NdotL: f32, NdotV: f32, roughness: f32) -> f32 {
  let a: f32 = pow2( roughness );
  let a2: f32 = pow2( a );
  
  let gv: f32 = NdotL * sqrt( a2 + ( 1.0 - a2 ) * pow2( NdotV ) );
  let gl: f32 = NdotV * sqrt( a2 + ( 1.0 - a2 ) * pow2( NdotL ) );

  return 0.5 / max( gv + gl, EPSILON );
}

fn BRDF_GGX(
  NdotV: f32,
  NdotL: f32,
  NdotH: f32,
  VdotH: f32,
  roughness: f32,
  specularFactor: f32,
  specularColor: vec3f
) -> vec3f {
  // cook-torrance brdf
  let G: f32 = GeometrySmith(NdotL, NdotV, roughness);
  let D: f32 = DistributionGGX(NdotH, roughness);
  let F: vec3f = F_Schlick(specularColor, specularFactor, VdotH);
  
  return G * D * F;
}
`,Ca=`
${wa}

fn EnvironmentBRDF(
  normal: vec3<f32>, 
  viewDir: vec3<f32>, 
  specularColor: vec3<f32>, 
  specularF90: f32, 
  roughness: f32
) -> vec3<f32> {
  let fab = DFGApprox(normal, viewDir, roughness);
  return specularColor * fab.x + specularF90 * fab.y;
}

fn computeSpecularOcclusion( NdotV: f32, occlusion: f32, roughness: f32 ) -> f32 {
	return saturate(pow(NdotV + occlusion, exp2(- 16.0 * roughness - 1.0)) - 1.0 + occlusion);
}

fn getPBRDirect(
  normal: vec3f,
  diffuseColor: vec3f,
  viewDirection: vec3f,
  specularFactor: f32,
  specularColor: vec3f,
  metallic: f32,
  roughness: f32,
  directLight: DirectLight,
  ptr_reflectedLight: ptr<function, ReflectedLight>
) {
  let H: vec3f = normalize(viewDirection + directLight.direction);
  let NdotV: f32 = saturate(dot(normal, viewDirection));
  let NdotL: f32 = saturate(dot(normal, directLight.direction));
  let NdotH: f32 = saturate(dot(normal, H));
  let VdotH: f32 = saturate(dot(viewDirection, H));

  let irradiance: vec3f = NdotL * directLight.color;
  let ggx: vec3f = BRDF_GGX(NdotV, NdotL, NdotH, VdotH, roughness, specularFactor, specularColor);
  
  let diffuseContribution: vec3f = BRDF_Lambert(diffuseColor);
  
  (*ptr_reflectedLight).directDiffuse += irradiance * diffuseContribution;
  (*ptr_reflectedLight).directSpecular += irradiance * ggx;
}
`,Kh=u(({environmentMap:r=null})=>{let e="";return r&&(e+=`    
  iblIrradiance += getIBLIndirectIrradiance(
    normal,
    baseDiffuseColor.rgb,
    ${r.sampler.name},
    ${r.diffuseTexture.options.name},
    envRotation,
    envDiffuseIntensity,
  );`),e},"getIBLIndirectIrradiance$1"),Jh=u(({environmentMap:r=null})=>{let e="";return r&&(e+=`
  radiance += getIBLIndirectRadiance(
    normal,
    viewDirection,
    roughness,
    specularColor,
    specularIntensity,
    iBLGGXFresnel,
    ${r.sampler.name},
    ${r.specularTexture.options.name},
    envRotation,
    envSpecularIntensity,
  );`),e},"getIBLIndirectRadiance$1"),Zh=u(({transmissionBackgroundTexture:r=null,extensionsUsed:e=[]})=>{const s=e.includes("KHR_materials_dispersion")?"getIBLVolumeRefractionWithDispersion":"getIBLVolumeRefraction";return r?`
  var transmissionAlpha: f32 = 1.0;
  
  var transmitted: vec4f = ${s}(
    normal,
    normalize(viewDirection),
    roughness, 
    baseDiffuseColor,
    specularColor,
    specularF90,
    worldPosition,
    modelScale,
    camera.view,
    camera.projection,
    dispersion,
    ior,
    thickness,
    attenuationColor,
    attenuationDistance,
    ${r.texture.options.name},
    ${r.sampler.name},
  );
  
  transmissionAlpha = mix( transmissionAlpha, transmitted.a, transmission );
  
  totalDiffuse = mix(totalDiffuse, transmitted.rgb, transmission);
  outputColor.a *= transmissionAlpha;`:""},"getIBLVolumeRefraction"),Qh=u(({environmentMap:r=null})=>{let e=`
  var iBLGGXFresnel: IBLGGXFresnel;`;return r&&r.lutTexture?e+=`
  iBLGGXFresnel = getIBLGGXFresnel(
    normal,
    viewDirection,
    roughness,
    specularColor,
    specularIntensity,
    ${r.sampler.name},
    ${r.lutTexture.options.name},
  );`:e+=`
  computeMultiscattering(
    normal,
    viewDirection,
    specularColor,
    specularIntensity,
    roughness,
    &iBLGGXFresnel
  );`,e},"getIBLGGXFresnel$1"),Ma=u(({receiveShadows:r=!1,environmentMap:e=null,transmissionBackgroundTexture:t=null,extensionsUsed:s=[]}={})=>`
  var directLight: DirectLight;
  var reflectedLight: ReflectedLight;
  
  ${r?gr:""}
  
  let baseDiffuseColor: vec4f = outputColor * ( 1.0 - metallic );
  
  let specularF90: f32 = mix(specularIntensity, 1.0, metallic);
  specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColor, vec3( 1.0 ) ) * specularIntensity, outputColor.rgb, metallic );

  // point lights
  for(var i = 0; i < pointLights.count; i++) {
    getPointLightInfo(pointLights.elements[i], worldPosition, &directLight);
    
    if(!directLight.visible) {
      continue;
    }
    
    ${r?xr:""}
    getPBRDirect(normal, baseDiffuseColor.rgb, viewDirection, specularF90, specularColor, metallic, roughness, directLight, &reflectedLight);
  }
  
  // spot lights
  for(var i = 0; i < spotLights.count; i++) {
    getSpotLightInfo(spotLights.elements[i], worldPosition, &directLight);
    
    if(!directLight.visible) {
      continue;
    }
    
    ${r?vr:""}
    getPBRDirect(normal, baseDiffuseColor.rgb, viewDirection, specularF90, specularColor, metallic, roughness, directLight, &reflectedLight);
  }
  
  // directional lights
  for(var i = 0; i < directionalLights.count; i++) {
    getDirectionalLightInfo(directionalLights.elements[i], &directLight);
    
    if(!directLight.visible) {
      continue;
    }
    
    ${r?yr:""}
    getPBRDirect(normal, baseDiffuseColor.rgb, viewDirection, specularF90, specularColor, metallic, roughness, directLight, &reflectedLight);
  }
  
  var irradiance: vec3f = vec3(0.0);
  var iblIrradiance: vec3f = vec3(0.0);
  var radiance: vec3f = vec3(0.0);
  
  // IBL indirect contributions
  ${Qh({environmentMap:e})}
  ${Kh({environmentMap:e})}
  ${Jh({environmentMap:e})}
  
  // ambient lights
  RE_IndirectDiffuse(irradiance, baseDiffuseColor.rgb, &reflectedLight);
  
  // indirect specular (and diffuse) from IBL
  RE_IndirectSpecular(
    radiance,
    iblIrradiance,
    normal,
    baseDiffuseColor.rgb,
    specularF90,
    specularColor,
    viewDirection,
    metallic,
    roughness,
    iBLGGXFresnel,
    &reflectedLight
  );
  
  reflectedLight.indirectDiffuse *= occlusion;
  
  let NdotV: f32 = saturate(dot(geometryNormal, viewDirection));
  reflectedLight.indirectSpecular *= computeSpecularOcclusion(NdotV, occlusion, roughness);
  
  var totalDiffuse: vec3f = reflectedLight.indirectDiffuse + reflectedLight.directDiffuse;
  let totalSpecular: vec3f = reflectedLight.indirectSpecular + reflectedLight.directSpecular;
  
  ${Zh({transmissionBackgroundTexture:t,extensionsUsed:s})}
  
  var outgoingLight: vec3f = totalDiffuse + totalSpecular;`,"getPBRShading"),el=u(({addUtils:r=!0,receiveShadows:e=!1,toneMapping:t,useOcclusion:s=!1,environmentMap:i=null,transmissionBackgroundTexture:n=null,extensionsUsed:a=[]}={})=>`
${r?pi:""}
${va}
${ba}
${Ca}

fn getPBR(
  normal: vec3f,
  worldPosition: vec3f,
  color: vec4f,
  viewDirection: vec3f,
  metallic: f32,
  roughness: f32,
  specularIntensity: f32,
  specularColor: vec3f,
  ior: f32,
  transmission: f32,
  dispersion: f32,
  thickness: f32,
  attenuationDistance: f32,
  attenuationColor: vec3f,
  ${s?"occlusion: f32,":""}
) -> vec4f {
  ${s?"":"let occlusion: f32 = 1.0;"}
  
  var outputColor: vec4f = color;
  
  ${Ma({receiveShadows:e,environmentMap:i,transmissionBackgroundTexture:n,extensionsUsed:a})}
  
  outputColor = vec4(outgoingLight, outputColor.a);
  
  ${ht({toneMapping:t})}
    
  return outputColor;
}
`,"getPBR"),Ba=u(({geometry:r,additionalVaryings:e=[]})=>{const t=r.getAttributeByName("tangent"),s=[];r.vertexBuffers&&r.vertexBuffers.length&&r.vertexBuffers.forEach(a=>{a.attributes.forEach(o=>{o.name!=="position"&&s.push(o)})}),t&&s.push({name:"bitangent",type:"vec3f"});const i=s.map((a,o)=>`
  @location(${o}) ${a.name}: ${a.type},`).join(""),n=e.map((a,o)=>`
  @location(${s.length+3+o}) ${a.name}: ${a.type},`).join("");return`
  @builtin(position) position: vec4f,
  ${i}
  @location(${s.length}) viewDirection: vec3f,
  @location(${s.length+1}) worldPosition: vec3f,
  @location(${s.length+2}) modelScale: vec3f,
  ${n}`},"getVertexOutputStructContent"),tl=u(({geometry:r,additionalVaryings:e=[]})=>`
struct VSOutput {
  ${Ba({geometry:r,additionalVaryings:e})}
};`,"getVertexOutputStruct"),sl=u(({geometry:r})=>{let e=`
  vsOutput.position = camera.projection * camera.view * worldPosition;
  vsOutput.normal = normal;
  vsOutput.worldPosition = worldPosition.xyz / worldPosition.w;
  vsOutput.viewDirection = camera.position - vsOutput.worldPosition;
  vsOutput.modelScale = vec3(
    length(modelMatrix[0].xyz),
    length(modelMatrix[1].xyz),
    length(modelMatrix[2].xyz)
  );
  `;return r.getAttributeByName("tangent")&&(e+=`
  vsOutput.tangent = normalize(modelMatrix * tangent);
  vsOutput.bitangent = cross(vsOutput.normal, vsOutput.tangent.xyz) * vsOutput.tangent.w;
    `),e+=r.vertexBuffers.map(s=>s.attributes.filter(i=>i.name!=="normal"&&i.name!=="position"&&i.name!=="tangent").map(i=>`
  vsOutput.${i.name} = ${i.name};`).join("")).join(`
`),e},"getVertexOutput"),Jt=u((r=null)=>(r?(r.additionalHead||(r.additionalHead=""),r.preliminaryContribution||(r.preliminaryContribution=""),r.additionalContribution||(r.additionalContribution="")):r={additionalHead:"",preliminaryContribution:"",additionalContribution:""},r),"patchAdditionalChunks"),Sa=u(({bindings:r=[],geometry:e,chunks:t=null,additionalVaryings:s=[]})=>(t=Jt(t),`
${t.additionalHead}
  
${tl({geometry:e,additionalVaryings:s})}
  
@vertex fn main(
  attributes: Attributes,
) -> VSOutput {
  var vsOutput: VSOutput;
    
  ${ei({geometry:e})}
  
  // user defined preliminary contribution
  ${t.preliminaryContribution}
  
  ${ti({bindings:r,geometry:e})}
  
  ${sl({geometry:e})}
  
  // user defined additional contribution
  ${t.additionalContribution}

  return vsOutput;
}`),"getVertexShaderCode"),fi=u(({geometry:r,additionalVaryings:e=[]})=>`
struct FSInput {
  @builtin(front_facing) frontFacing: bool,
  ${Ba({geometry:r,additionalVaryings:e})}
};`,"getFragmentInputStruct"),mi=u(({geometry:r,additionalVaryings:e=[]})=>{let t=`
  let frontFacing: bool = fsInput.frontFacing;
  `;const s=r&&r.getAttributeByName("normal"),i=r&&r.getAttributeByName("tangent"),n=["position","normal","tangent","color","joints","weights"],a=[];return r&&r.vertexBuffers&&r.vertexBuffers.length&&r.vertexBuffers.forEach(o=>{o.attributes.forEach(h=>{n.some(l=>h.name.includes(l))||a.push(h)})}),t+=a.map(o=>`
  var ${o.name}: ${o.type} = fsInput.${o.name};`).join(""),s?t+=`
  var normal: vec3f = normalize(fsInput.normal);
    `:t+=`
  // silly default normal
  var normal: vec3f = vec3(0.0, 0.0, 1.0);
    `,i?t+=`
  var tangent: vec3f = normalize(fsInput.tangent.xyz);
  var bitangent: vec3f = normalize(fsInput.bitangent);
    `:t+=`
  var tangent: vec3f;
  var bitangent: vec3f;
    `,t+=`
  let worldPosition: vec3f = fsInput.worldPosition;
  let viewDirection: vec3f = normalize(fsInput.viewDirection);
  let modelScale: vec3f = fsInput.modelScale;
  `,t+=e.map(o=>`
  var ${o.name}: ${o.type} = fsInput.${o.name};`).join(""),t},"declareAttributesVars"),gi=u(({materialUniform:r=null,materialUniformName:e="material",shadingModel:t="PBR",environmentMap:s=null}={})=>{var i=r&&r.struct||{},n="";return i.color?n+=`
  var baseColorFactor: vec3f = ${e}.color;`:n+=`
  var baseColorFactor: vec3f = vec3(1.0);`,i.opacity?n+=`
  var baseOpacityFactor: f32 = ${e}.opacity;`:n+=`
  var baseOpacityFactor: f32 = 1.0;`,i.alphaCutoff?n+=`
  var alphaCutoff: f32 = ${e}.alphaCutoff;`:n+=`
  var alphaCutoff: f32 = 0.0;`,t!=="Unlit"&&(i.normalScale?n+=`
  var normalScale: vec2f = ${e}.normalScale;`:n+=`
  var normalScale: vec2f = vec2(1.0);`,i.occlusionIntensity?n+=`
  var occlusionIntensity: f32 = ${e}.occlusionIntensity;`:n+=`
  var occlusionIntensity: f32 = 1.0;`,i.emissiveColor?n+=`
  var emissive: vec3f = ${e}.emissiveColor;`:n+=`
  var emissive: vec3f = vec3(0.0);`,i.emissiveIntensity?n+=`
  var emissiveStrength: f32 = ${e}.emissiveIntensity;`:n+=`
  var emissiveStrength: f32 = 1.0;`),(t==="Phong"||t==="PBR")&&(i.metallic?n+=`
  var metallic: f32 = ${e}.metallic;`:n+=`
  var metallic: f32 = 1.0;`,i.roughness?n+=`
  var roughness: f32 = ${e}.roughness;`:n+=`
  var roughness: f32 = 1.0;`,i.specularIntensity?n+=`
  var specularIntensity: f32 = ${e}.specularIntensity;`:n+=`
  var specularIntensity: f32 = 1.0;`,i.specularColor?n+=`
  var specularColor: vec3f = ${e}.specularColor;`:n+=`
  var specularColor: vec3f = vec3(1.0);`,i.ior?n+=`
  var ior: f32 = ${e}.ior;`:n+=`
  var ior: f32 = 1.5;`,t==="Phong"&&(i.shininess?n+=`
  var shininess: f32 = ${e}.shininess;`:n+=`
  // approximating phong shading from PBR properties
  // arbitrary computation of diffuse, shininess and specular color from roughness and metallic  
  baseColorFactor = mix(baseColorFactor, vec3(0.0), metallic);
  specularColor = mix(specularColor, baseColorFactor, metallic);
  // from https://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
  var shininess: f32 = clamp(2.0 / (roughness * roughness * roughness * roughness) - 2.0, 1000.0);
  `)),t==="PBR"&&(i.transmission?n+=`
  var transmission: f32 = ${e}.transmission;`:n+=`
  var transmission: f32 = 0.0;`,i.dispersion?n+=`
  var dispersion: f32 = ${e}.dispersion;`:n+=`
  var dispersion: f32 = 0.0;`,i.thickness?n+=`
  var thickness: f32 = ${e}.thickness;`:n+=`
  var thickness: f32 = 0.0;`,i.attenuationDistance?n+=`
  var attenuationDistance: f32 = ${e}.attenuationDistance;`:n+=`
  var attenuationDistance: f32 = 1.0e38;`,i.attenuationColor?n+=`
  var attenuationColor: vec3f = ${e}.attenuationColor;`:n+=`
  var attenuationColor: vec3f = vec3(1.0);`,s&&(i.envRotation?n+=`
  var envRotation: mat3x3f = ${e}.envRotation;`:n+=`
  var envRotation: mat3x3f = mat3x3f();`,i.envDiffuseIntensity?n+=`
  var envDiffuseIntensity: f32 = ${e}.envDiffuseIntensity;`:n+=`
  var envDiffuseIntensity: f32 = 1.0;`,i.envSpecularIntensity?n+=`
  var envSpecularIntensity: f32 = ${e}.envSpecularIntensity;`:n+=`
  var envSpecularIntensity: f32 = 1.0;`)),n},"declareMaterialVars"),yi=u(({geometry:r=null,baseColorTexture:e=null}={})=>{let t=`
  var baseColor: vec4f = vec4(baseColorFactor, baseOpacityFactor);
  `;const s=[];return r&&r.vertexBuffers&&r.vertexBuffers.length&&r.vertexBuffers.forEach(i=>{i.attributes.forEach(n=>{n.name.includes("color")&&s.push(n)})}),s.forEach(i=>{i.type==="vec3f"?t+=`
  baseColor *= vec4(fsInput.${i.name}, 1.0);`:t+=`
  baseColor *= fsInput.${i.name};`}),e&&(t+=`
  var baseColorUV: vec2f = ${e.texCoordAttributeName??"uv"};`,"useTransform"in e.texture.options&&e.texture.options.useTransform&&(t+=`
  baseColorUV = (texturesMatrices.${e.texture.options.name}.matrix * vec3(baseColorUV, 1.0)).xy;`),t+=`
  let baseColorSample: vec4f = textureSample(${e.texture.options.name}, ${e.sampler?.name??"defaultSampler"}, baseColorUV);
  baseColor *= baseColorSample;
  `),t+=`
  if (baseColor.a < alphaCutoff) {
    discard;
  }
  
  outputColor = baseColor;
  `,t},"getBaseColor"),Ta=u(({chunks:r=null,toneMapping:e="Khronos",geometry:t,additionalVaryings:s=[],materialUniform:i=null,materialUniformName:n="material",baseColorTexture:a=null})=>(r=Jt(r),`  
${r.additionalHead}

${$e}
${ot}
${wt}

${fi({geometry:t,additionalVaryings:s})}

@fragment fn main(fsInput: FSInput) -> @location(0) vec4f {       
  var outputColor: vec4f = vec4();
  
  ${mi({geometry:t,additionalVaryings:s})}
  ${gi({materialUniform:i,materialUniformName:n,shadingModel:"Unlit"})}
  ${yi({geometry:t,baseColorTexture:a})}
  
  // user defined preliminary contribution
  ${r.preliminaryContribution}
  
  // user defined additional contribution
  ${r.additionalContribution}
  
  ${ht({toneMapping:e})}
  return outputColor;
}`),"getUnlitFragmentShaderCode"),br=u(({geometry:r=null,normalTexture:e=null}={})=>{let t=`
  let faceDirection = select(-1.0, 1.0, frontFacing);
  let geometryNormal: vec3f = faceDirection * normal;`;const s=r&&r.getAttributeByName("tangent"),i=!!(e&&s);return e?(t+=`
  var normalUV: vec2f = ${e.texCoordAttributeName??"uv"};`,"useTransform"in e.texture.options&&e.texture.options.useTransform&&(t+=`
  normalUV = (texturesMatrices.${e.texture.options.name}.matrix * vec3(normalUV, 1.0)).xy;`),i||(t+=`
  // TODO decide whether we're computing tangent and bitangent
  // with normal or with derivatives
  /*
  let Q1: vec3f = dpdx(worldPosition);
  let Q2: vec3f = dpdy(worldPosition);
  let st1: vec2f = dpdx(normalUV);
  let st2: vec2f = dpdy(normalUV);
  
  tangent = normalize(Q1 * st2.y - Q2 * st1.y);
  bitangent = normalize(-Q1 * st2.x + Q2 * st1.x);
  */
  
  bitangent = vec3(0.0, 1.0, 0.0);

  let NdotUp: f32 = dot(normal, vec3(0.0, 1.0, 0.0));
  
  if (1.0 - abs(NdotUp) <= EPSILON) {
    // Sampling +Y or -Y, so we need a more robust bitangent.
    if (NdotUp > 0.0) {
      bitangent = vec3(0.0, 0.0, 1.0);
    }
    else {
      bitangent = vec3(0.0, 0.0, -1.0);
    }
  }

  tangent = normalize(cross(bitangent, normal));
  bitangent = cross(normal, tangent);
  `),t+=`
  let tbn = mat3x3f(tangent, bitangent, geometryNormal);
  let normalMap = textureSample(${e.texture.options.name}, ${e.sampler?.name??"defaultSampler"}, normalUV).rgb;
  normal = normalize(tbn * (2.0 * normalMap - vec3(vec2(normalScale), 1.0)));`):t+=`
  normal = geometryNormal;`,t},"getNormalTangentBitangent"),wr=u(({emissiveTexture:r=null,occlusionTexture:e=null}={})=>{let t=`
  var occlusion: f32 = 1.0;`;return r&&(t+=`
  var emissiveUV: vec2f = ${r.texCoordAttributeName??"uv"};`,"useTransform"in r.texture.options&&r.texture.options.useTransform&&(t+=`
  emissiveUV = (texturesMatrices.${r.texture.options.name}.matrix * vec3(emissiveUV, 1.0)).xy;`),t+=`
  let emissiveSample: vec3f = textureSample(${r.texture.options.name}, ${r.sampler?.name??"defaultSampler"}, emissiveUV).rgb;
  emissive *= emissiveSample;`),t+=`
  emissive *= emissiveStrength;`,e&&(t+=`
  var occlusionUV: vec2f = ${e.texCoordAttributeName??"uv"};`,"useTransform"in e.texture.options&&e.texture.options.useTransform&&(t+=`
  occlusionUV = (${e.texture.options.name}Matrix * vec3(occlusionUV, 1.0)).xy;`),t+=`
  occlusion = textureSample(${e.texture.options.name}, ${e.sampler?.name??"defaultSampler"}, occlusionUV).r;`),t+=`
  occlusion = 1.0 + occlusionIntensity * (occlusion - 1.0);`,t},"getEmissiveOcclusion"),Pa=u(({chunks:r=null,toneMapping:e="Khronos",geometry:t,additionalVaryings:s=[],materialUniform:i=null,materialUniformName:n="material",receiveShadows:a=!1,baseColorTexture:o=null,normalTexture:h=null,emissiveTexture:l=null,occlusionTexture:d=null})=>(r=Jt(r),`  
${r.additionalHead}

${$e}
${ot}
${wt}
${di}
${ci}
${ma}

${fi({geometry:t,additionalVaryings:s})}

@fragment fn main(fsInput: FSInput) -> @location(0) vec4f {
  var outputColor: vec4f = vec4();
  
  ${mi({geometry:t,additionalVaryings:s})}
  ${gi({materialUniform:i,materialUniformName:n,shadingModel:"Lambert"})}
  ${yi({geometry:t,baseColorTexture:o})}
  
  // user defined preliminary contribution
  ${r.preliminaryContribution}
  
  ${br({geometry:t,normalTexture:h})}  
  ${wr({emissiveTexture:l,occlusionTexture:d})}
  
  // lights
  ${ga({receiveShadows:a})}
  
  outputColor = vec4(outgoingLight, outputColor.a);
  outputColor = vec4(outputColor.rgb + emissive, outputColor.a);
  
  // user defined additional contribution
  ${r.additionalContribution}
  
  ${ht({toneMapping:e})}
  return outputColor;
}`),"getLambertFragmentShaderCode"),Ra=u(({metallicRoughnessTexture:r=null}={})=>{let e="";return r&&(e+=`
  var metallicRoughnessUV: vec2f = ${r.texCoordAttributeName??"uv"};`,"useTransform"in r.texture.options&&r.texture.options.useTransform&&(e+=`
  metallicRoughnessUV = (${r.texture.options.name}Matrix * vec3(metallicRoughnessUV, 1.0)).xy;`),e+=`
  let metallicRoughness = textureSample(${r.texture.options.name}, ${r.sampler?.name??"defaultSampler"}, metallicRoughnessUV);
  
  metallic = metallic * metallicRoughness.b;
  roughness = roughness * metallicRoughness.g;
  `),e+=`
  metallic = saturate(metallic);
  roughness = clamp(roughness, 0.0525, 1.0);
  `,e},"getMetallicRoughness"),Ea=u(({specularTexture:r=null,specularFactorTexture:e=null,specularColorTexture:t=null}={})=>{let s="";return r?(s+=`
  var specularUV: vec2f = ${r.texCoordAttributeName??"uv"};`,"useTransform"in r.texture.options&&r.texture.options.useTransform&&(s+=`
  specularUV = (${r.texture.options.name}Matrix * vec3(specularUV, 1.0)).xy;`),s+=`
  let specularSample: vec4f = textureSample(${r.texture.options.name}, ${r.sampler?.name??"defaultSampler"}, specularUV);
  
  specularIntensity = specularIntensity * specularSample.a;
  specularColor = specularColor * specularSample.rgb;`):(e&&(s+=`
  var specularFactorUV: vec2f = ${e.texCoordAttributeName??"uv"};`,"useTransform"in e.texture.options&&e.texture.options.useTransform&&(s+=`
  specularFactorUV = (${e.texture.options.name}Matrix * vec3(specularFactorUV, 1.0)).xy;`),s+=`
  let specularFactorSample: vec4f = textureSample(${e.texture.options.name}, ${e.sampler?.name??"defaultSampler"}, specularFactorUV);
  
  specularIntensity = specularIntensity * specularSample.a;`),t&&(s+=`
  var specularColorUV: vec2f = ${t.texCoordAttributeName??"uv"};`,"useTransform"in t.texture.options&&t.texture.options.useTransform&&(s+=`
  specularColorUV = (${t.texture.options.name}Matrix * vec3(specularColorUV, 1.0)).xy;`),s+=`
  let specularColorSample: vec4f = textureSample(${t.texture.options.name}, ${t.sampler?.name??"defaultSampler"}, specularColorUV);
  
  specularColor = specularColor * specularSample.rgb;`)),s},"getSpecular"),za=u(({chunks:r=null,toneMapping:e="Khronos",geometry:t,additionalVaryings:s=[],materialUniform:i=null,materialUniformName:n="material",receiveShadows:a=!1,baseColorTexture:o=null,normalTexture:h=null,emissiveTexture:l=null,occlusionTexture:d=null,metallicRoughnessTexture:c=null,specularTexture:f=null,specularFactorTexture:p=null,specularColorTexture:m=null})=>(r=Jt(r),`  
${r.additionalHead}

${$e}
${ot}
${wt}
${di}
${ci}
${ya}

${fi({geometry:t,additionalVaryings:s})}

@fragment fn main(fsInput: FSInput) -> @location(0) vec4f {       
  var outputColor: vec4f = vec4();
  
  ${mi({geometry:t,additionalVaryings:s})}
  ${gi({materialUniform:i,materialUniformName:n,shadingModel:"Phong"})}
  ${yi({geometry:t,baseColorTexture:o})}
  
  // user defined preliminary contribution
  ${r.preliminaryContribution}
  
  ${br({geometry:t,normalTexture:h})}
  ${Ra({metallicRoughnessTexture:c})}
  ${Ea({specularTexture:f,specularFactorTexture:p,specularColorTexture:m})}
  ${wr({emissiveTexture:l,occlusionTexture:d})}
  
  // lights
  ${xa({receiveShadows:a})}
  
  outputColor = vec4(outgoingLight, outputColor.a);
  outputColor = vec4(outputColor.rgb + emissive, outputColor.a);
  
  // user defined additional contribution
  ${r.additionalContribution}
  
  ${ht({toneMapping:e})}
  return outputColor;
}`),"getPhongFragmentShaderCode"),il=`
// multi scattering equations
// not used for now since our IBL GGX Fresnel already handles energy conseervation
// could be used if we dropped the environment map LUT texture
fn DFGApprox(
  normal: vec3f,
  viewDirection: vec3f,
  roughness: f32,
) -> vec2f {
  let dotNV: f32 = saturate(dot( normal, viewDirection ));

	let c0: vec4f = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	let c1: vec4f = vec4( 1, 0.0425, 1.04, - 0.04 );

	let r: vec4f = roughness * c0 + c1;
	let a004: f32 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	
	let fab: vec2f = vec2( - 1.04, 1.04 ) * a004 + r.zw;

	return fab;
}

struct IBLGGXFresnel {
  FssEss: vec3f,
  FmsEms: vec3f
}

struct TotalScattering {
  single: vec3f,
  multi: vec3f,
}

fn computeMultiscattering(
  normal: vec3f,
  viewDirection: vec3f,
  specularColor: vec3f,
  f90: f32,
  roughness: f32,
  ptr_totalScattering: ptr<function, IBLGGXFresnel>
) {
  let fab: vec2f = DFGApprox( normal, viewDirection, roughness );

	let Fr: vec3f = specularColor;

	let FssEss: vec3f = Fr * fab.x + f90 * fab.y;

	let Ess: f32 = fab.x + fab.y;
	let Ems: f32 = 1.0 - Ess;

	let Favg: vec3f = Fr + ( 1.0 - Fr ) * 0.047619; // 1/21
	let Fms: vec3f = FssEss * Favg / ( 1.0 - Ems * Favg );

	(*ptr_totalScattering).FssEss += FssEss;
	(*ptr_totalScattering).FmsEms += Fms * Ems;
}

fn getIBLGGXFresnel(
  normal: vec3f,
  viewDirection: vec3f,
  roughness: f32,
  f0: vec3f,
  specularWeight: f32,
  clampSampler: sampler,
  lutTexture: texture_2d<f32>
) -> IBLGGXFresnel {
  var iBLGGXFresnel: IBLGGXFresnel;
  
  let NdotV: f32 = saturate(dot(normal, viewDirection));
  
  let brdfSamplePoint: vec2f = saturate(vec2(NdotV, roughness));
  
  let brdf: vec3f = textureSample(
    lutTexture,
    clampSampler,
    brdfSamplePoint
  ).rgb;
  
  let Fr: vec3f = max(vec3(1.0 - roughness), f0) - f0;
  let k_S: vec3f = f0 + Fr * pow(1.0 - NdotV, 5.0);
  iBLGGXFresnel.FssEss = specularWeight * (k_S * brdf.x + brdf.y);
  let Ems: f32 = (1.0 - (brdf.x + brdf.y));
  let F_avg: vec3f = specularWeight * (f0 + (1.0 - f0) / 21.0);
  iBLGGXFresnel.FmsEms = Ems * iBLGGXFresnel.FssEss * F_avg / (1.0 - F_avg * Ems);
  
  return iBLGGXFresnel;
}
`,rl=`
fn getIBLIndirectIrradiance(
  normal: vec3f,
  diffuseColor: vec3f,
  clampSampler: sampler,
  envDiffuseTexture: texture_cube<f32>,
  envRotation: mat3x3f,
  envDiffuseIntensity: f32,
) -> vec3f {
  // IBL diffuse (irradiance)
  let diffuseLight: vec4f = textureSample(
    envDiffuseTexture,
    clampSampler,
    normal * envRotation
  );

  return diffuseLight.rgb * envDiffuseIntensity;
}
`,nl=`
fn getIBLIndirectRadiance(
  normal: vec3f,
  viewDirection: vec3f,
  roughness: f32,
  specularColor: vec3f,
  specularFactor: f32,
  iBLGGXFresnel: IBLGGXFresnel,
  clampSampler: sampler,
  envSpecularTexture: texture_cube<f32>,
  envRotation: mat3x3f,
  envSpecularIntensity: f32,
)-> vec3f {
  let N: vec3f = normal;
  let V: vec3f = viewDirection;
  let NdotV: f32 = saturate(dot(N, V));

  let reflection: vec3f = normalize(reflect(-V, N));

  let lod: f32 = roughness * f32(textureNumLevels(envSpecularTexture) - 1);

  let specularLight: vec4f = textureSampleLevel(
    envSpecularTexture,
    clampSampler,
    reflection * envRotation,
    lod
  );

  return specularLight.rgb * envSpecularIntensity;
}
`,al=u(({transmissionTexture:r=null,thicknessTexture:e=null}={})=>{let t="";return r&&(t+=`
  var transmissionUV: vec2f = ${r.texCoordAttributeName??"uv"};`,"useTransform"in r.texture.options&&r.texture.options.useTransform&&(t+=`
  transmissionUV = (${r.texture.options.name}Matrix * vec3(transmissionUV, 1.0)).xy;`),t+=`
  let transmissionSample: vec4f = textureSample(${r.texture.options.name}, ${r.sampler?.name??"defaultSampler"}, transmissionUV);
  
  transmission = clamp(transmission * transmissionSample.r, 0.0, 1.0);`),e&&(t+=`
  var thicknessUV: vec2f = ${e.texCoordAttributeName??"uv"};`,"useTransform"in e.texture.options&&e.texture.options.useTransform&&(t+=`
  thicknessUV = (${e.texture.options.name}Matrix * vec3(thicknessUV, 1.0)).xy;`),t+=`
  let thicknessSample: vec4f = textureSample(${e.texture.options.name}, ${e.sampler?.name??"defaultSampler"}, thicknessUV);
  
  thickness *= thicknessSample.g;`),t},"getTransmissionThickness"),_a=u(({chunks:r=null,toneMapping:e="Khronos",geometry:t,additionalVaryings:s=[],materialUniform:i=null,materialUniformName:n="material",extensionsUsed:a=[],receiveShadows:o=!1,baseColorTexture:h=null,normalTexture:l=null,emissiveTexture:d=null,occlusionTexture:c=null,metallicRoughnessTexture:f=null,specularTexture:p=null,specularFactorTexture:m=null,specularColorTexture:g=null,transmissionTexture:v=null,thicknessTexture:x=null,transmissionBackgroundTexture:b=null,environmentMap:S=null})=>(r=Jt(r),`  
${r.additionalHead}

${$e}
${ot}
${wt}
${di}
${ci}
${va}
${Ca}
${il}
${rl}
${nl}
${ba}

${fi({geometry:t,additionalVaryings:s})}

@fragment fn main(fsInput: FSInput) -> @location(0) vec4f {
  var outputColor: vec4f = vec4();
  
  ${mi({geometry:t,additionalVaryings:s})}
  ${gi({materialUniform:i,materialUniformName:n,shadingModel:"PBR",environmentMap:S})}
  ${yi({geometry:t,baseColorTexture:h})}
  
  // user defined preliminary contribution
  ${r.preliminaryContribution}
  
  ${br({geometry:t,normalTexture:l})}
  ${Ra({metallicRoughnessTexture:f})}
  ${Ea({specularTexture:p,specularFactorTexture:m,specularColorTexture:g})}
  ${al({transmissionTexture:v,thicknessTexture:x})}
  ${wr({emissiveTexture:d,occlusionTexture:c})}
  
  // lights
  ${Ma({receiveShadows:o,environmentMap:S,transmissionBackgroundTexture:b,extensionsUsed:a})}
  
  outputColor = vec4(outgoingLight, outputColor.a);
  outputColor = vec4(outputColor.rgb + emissive, outputColor.a);
  
  // user defined additional contribution
  ${r.additionalContribution}
  
  ${ht({toneMapping:e})}
  return outputColor;
}`),"getPBRFragmentShaderCode"),La=u(({shadingModel:r="PBR",chunks:e=null,toneMapping:t="Khronos",geometry:s,additionalVaryings:i=[],materialUniform:n=null,materialUniformName:a="material",extensionsUsed:o=[],receiveShadows:h=!1,baseColorTexture:l=null,normalTexture:d=null,emissiveTexture:c=null,occlusionTexture:f=null,metallicRoughnessTexture:p=null,specularTexture:m=null,specularFactorTexture:g=null,specularColorTexture:v=null,transmissionTexture:x=null,thicknessTexture:b=null,transmissionBackgroundTexture:S=null,environmentMap:B=null})=>(()=>{switch(r){case"Unlit":return Ta({chunks:e,toneMapping:t,geometry:s,additionalVaryings:i,materialUniform:n,materialUniformName:a,baseColorTexture:l});case"Lambert":return Pa({chunks:e,toneMapping:t,geometry:s,additionalVaryings:i,materialUniform:n,materialUniformName:a,receiveShadows:h,baseColorTexture:l,normalTexture:d,emissiveTexture:c,occlusionTexture:f});case"Phong":return za({chunks:e,toneMapping:t,geometry:s,additionalVaryings:i,materialUniform:n,materialUniformName:a,receiveShadows:h,baseColorTexture:l,normalTexture:d,emissiveTexture:c,occlusionTexture:f,metallicRoughnessTexture:p,specularTexture:m,specularFactorTexture:g,specularColorTexture:v});case"PBR":default:return _a({chunks:e,toneMapping:t,geometry:s,additionalVaryings:i,materialUniform:n,materialUniformName:a,extensionsUsed:o,receiveShadows:h,baseColorTexture:l,normalTexture:d,emissiveTexture:c,occlusionTexture:f,metallicRoughnessTexture:p,specularTexture:m,specularFactorTexture:g,specularColorTexture:v,transmissionTexture:x,thicknessTexture:b,transmissionBackgroundTexture:S,environmentMap:B})}})(),"getFragmentShaderCode");var Aa=u(r=>{throw TypeError(r)},"__typeError$7"),Da=u((r,e,t)=>e.has(r)||Aa("Cannot "+t),"__accessCheck$7"),Ge=u((r,e,t)=>(Da(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet$6"),Cr=u((r,e,t)=>e.has(r)?Aa("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$7"),ol=u((r,e,t,s)=>(Da(r,e,"write to private field"),e.set(r,t),t),"__privateSet$6"),Zt,lt,xi;class $a extends ki{static{u(this,"DOMObject3D")}constructor(e,t,s={}){super(e),Cr(this,Zt,new y),Cr(this,lt,new y(1)),Cr(this,xi,1),this.boundingBox=new Ee(new y(-1),new y(1)),this._onAfterDOMElementResizeCallback=()=>{},e=ft(e,"DOMObject3D"),this.renderer=e,this.size={shouldUpdate:!0,normalizedWorld:{size:new _(1),position:new _},cameraWorld:{size:new _(1)},scaledWorld:{size:new y(1),position:new y}},this.watchScroll=s.watchScroll,this.camera=this.renderer.camera,this.boundingBox.min.onChange(()=>this.shouldUpdateComputedSizes()),this.boundingBox.max.onChange(()=>this.shouldUpdateComputedSizes()),this.setDOMElement(t),this.renderer.domObjects.push(this)}setRenderer(e){this.renderer&&(this.renderer.domObjects=this.renderer.domObjects.filter(t=>t.object3DIndex!==this.object3DIndex)),e=ft(e,"DOMObject3D"),this.renderer=e,this.renderer.domObjects.push(this)}setDOMElement(e){this.domElement=new ir({element:e,onSizeChanged:u(t=>this.resize(t),"onSizeChanged"),onPositionChanged:u(()=>this.onPositionChanged(),"onPositionChanged")}),this.updateSizeAndPosition()}onPositionChanged(){this.watchScroll&&this.shouldUpdateComputedSizes()}resetDOMElement(e){this.domElement&&this.domElement.destroy(),this.setDOMElement(e)}resize(e=null){!e&&(!this.domElement||this.domElement?.isResizing)||(this.updateSizeAndPosition(),this._onAfterDOMElementResizeCallback&&this._onAfterDOMElementResizeCallback())}get boundingRect(){return this.domElement?.boundingRect??{width:1,height:1,top:0,right:0,bottom:0,left:0,x:0,y:0}}setTransforms(){super.setTransforms(),this.transforms.origin.model.set(.5,.5,0),this.transforms.origin.world=new y,this.transforms.position.document=new y,this.documentPosition.onChange(()=>this.applyPosition()),this.transformOrigin.onChange(()=>this.setWorldTransformOrigin())}get documentPosition(){return this.transforms.position.document}set documentPosition(e){this.transforms.position.document=e,this.applyPosition()}get DOMObjectWorldScale(){return Ge(this,lt).clone()}get worldScale(){return this.DOMObjectWorldScale.multiply(this.scale)}get worldPosition(){return Ge(this,Zt).clone()}get transformOrigin(){return this.transforms.origin.model}set transformOrigin(e){this.transforms.origin.model=e,this.setWorldTransformOrigin()}get worldTransformOrigin(){return this.transforms.origin.world}set worldTransformOrigin(e){this.transforms.origin.world=e}shouldUpdateMatrices(){super.shouldUpdateMatrices(),(this.matricesNeedUpdate||this.size.shouldUpdate)&&(this.updateSizeAndPosition(),this.matricesNeedUpdate=!0),this.size.shouldUpdate=!1}shouldUpdateComputedSizes(){this.size.shouldUpdate=!0}updateSizeAndPosition(){this.setWorldSizes(),this.applyDocumentPosition(),this.shouldUpdateModelMatrix()}applyDocumentPosition(){let e=new y(0,0,0);this.documentPosition.equals(e)||(e=this.documentToWorldSpace(this.documentPosition)),Ge(this,Zt).set(this.position.x+this.size.scaledWorld.position.x+e.x,this.position.y+this.size.scaledWorld.position.y+e.y,this.position.z+this.size.scaledWorld.position.z+this.documentPosition.z/this.camera.CSSPerspective)}applyTransformOrigin(){this.size&&(this.setWorldTransformOrigin(),super.applyTransformOrigin())}updateModelMatrix(){this.modelMatrix.composeFromOrigin(Ge(this,Zt),this.quaternion,this.scale,this.worldTransformOrigin),this.modelMatrix.scale(this.DOMObjectWorldScale),this.shouldUpdateWorldMatrix()}documentToWorldSpace(e=new y){return new y(e.x*this.renderer.pixelRatio/this.renderer.boundingRect.width*this.camera.visibleSize.width,-(e.y*this.renderer.pixelRatio/this.renderer.boundingRect.height)*this.camera.visibleSize.height,e.z)}computeWorldSizes(){const e=this.renderer.boundingRect,t={x:this.boundingRect.width/2+this.boundingRect.left,y:this.boundingRect.height/2+this.boundingRect.top},s={x:e.width/2+e.left,y:e.height/2+e.top},{size:i,center:n}=this.boundingBox;i.x!==0&&i.y!==0&&i.z!==0&&n.divide(i),this.size.normalizedWorld.size.set(this.boundingRect.width/e.width,this.boundingRect.height/e.height),this.size.normalizedWorld.position.set((t.x-s.x)/e.width,(s.y-t.y)/e.height),this.size.cameraWorld.size.set(this.size.normalizedWorld.size.x*this.camera.visibleSize.width,this.size.normalizedWorld.size.y*this.camera.visibleSize.height),this.size.scaledWorld.size.set(this.size.cameraWorld.size.x/i.x,this.size.cameraWorld.size.y/i.y,1),this.size.scaledWorld.size.z=this.size.scaledWorld.size.y*(i.x/i.y/(this.boundingRect.width/this.boundingRect.height)),this.size.scaledWorld.position.set(this.size.normalizedWorld.position.x*this.camera.visibleSize.width,this.size.normalizedWorld.position.y*this.camera.visibleSize.height,0)}setWorldSizes(){this.computeWorldSizes(),this.setWorldScale(),this.setWorldTransformOrigin()}setWorldScale(){Ge(this,lt).set(this.size.scaledWorld.size.x,this.size.scaledWorld.size.y,this.size.scaledWorld.size.z*Ge(this,xi)),this.shouldUpdateMatrixStack()}set DOMObjectDepthScaleRatio(e){ol(this,xi,e),this.setWorldScale()}setWorldTransformOrigin(){this.transforms.origin.world=new y((this.transformOrigin.x*2-1)*Ge(this,lt).x,-(this.transformOrigin.y*2-1)*Ge(this,lt).y,this.transformOrigin.z*Ge(this,lt).z),this.shouldUpdateMatrixStack()}updateScrollPosition(e={x:0,y:0}){(e.x||e.y)&&this.domElement.updateScrollPosition(e)}onAfterDOMElementResize(e){return e&&(this._onAfterDOMElementResizeCallback=e),this}destroy(){super.destroy(),this.renderer.domObjects=this.renderer.domObjects.filter(e=>e.object3DIndex!==this.object3DIndex),this.domElement?.destroy()}}Zt=new WeakMap,lt=new WeakMap,xi=new WeakMap;const hl={autoloadSources:!0,watchScroll:!0,domTextures:[]};class Ga extends _n($a){static{u(this,"DOMMesh")}constructor(e,t,s){s={...hl,...s};const{autoloadSources:i,watchScroll:n,domTextures:a,...o}=s;super(e,t,s),this._onLoadingCallback=h=>{},ft(e,s.label?s.label+" DOMMesh":"DOMMesh"),this.type="DOMMesh",this.domTextures=[],a.forEach(h=>{this.addTexture(h),this.onDOMTextureAdded(h)}),this.autoloadSources=i,this.sourcesReady=!1,this.setInitSources()}setRenderer(e){this.renderer&&(this.renderer.domMeshes=this.renderer.domMeshes.filter(t=>t.uuid!==this.uuid)),e=ft(e,this.options.label+" DOMMesh"),super.setRenderer(e),this.renderer=e,this.renderer.domMeshes.push(this)}get ready(){return this._ready}set ready(e){e&&!this._ready&&this.sourcesReady&&this._onReadyCallback&&this._onReadyCallback(),this._ready=e}get sourcesReady(){return this._sourcesReady}set sourcesReady(e){e&&!this._sourcesReady&&this.ready&&this._onReadyCallback&&this._onReadyCallback(),this._sourcesReady=e}addToScene(e=!1){super.addToScene(e),e&&this.renderer.domMeshes.push(this)}removeFromScene(e=!1){super.removeFromScene(e),e&&(this.renderer.domMeshes=this.renderer.domMeshes.filter(t=>t.uuid!==this.uuid))}resizeTextures(){super.resizeTextures(),this.domTextures?.forEach(e=>{e.resize()})}applyScale(){super.applyScale(),this.domTextures?.forEach(e=>{e.updateModelMatrix()})}createDOMTexture(e){const t="texture"+this.textures.length;e.label||(e.label=this.options.label+" "+(e.name??t)),e.name||(e.name=t);const{viewDimension:s,useTransform:i,...n}=this.options.texturesOptions,a={...e,...n};this.renderBundle&&(a.useExternalTextures=!1);const o=new $i(this.renderer,a);return this.addTexture(o),this.onDOMTextureAdded(o),o}onDOMTextureAdded(e){e.mesh=this,this.domTextures.push(e)}setInitSources(){let e=0,t=0;if(this.autoloadSources){const s=this.domElement.element.querySelectorAll("img"),i=this.domElement.element.querySelectorAll("video"),n=this.domElement.element.querySelectorAll("canvas");e=s.length+i.length+n.length;const a=u(o=>{t++,this._onLoadingCallback&&this._onLoadingCallback(o),t===e&&(this.sourcesReady=!0)},"onSourceUploaded");e||(this.sourcesReady=!0),s.length&&s.forEach(o=>{const h=this.createDOMTexture({name:o.getAttribute("data-texture-name")??"texture"+this.domTextures.length});h.onAllSourcesUploaded(()=>a(h)).loadImage(o.src)}),i.length&&i.forEach(o=>{const h=this.createDOMTexture({name:o.getAttribute("data-texture-name")??"texture"+this.domTextures.length});h.onAllSourcesUploaded(()=>a(h)).loadVideo(o)}),n.length&&n.forEach(o=>{const h=this.createDOMTexture({name:o.getAttribute("data-texture-name")??"texture"+this.domTextures.length});h.onAllSourcesUploaded(()=>a(h)).loadCanvas(o)})}else this.sourcesReady=!0}resetDOMElement(e){e?(super.resetDOMElement(e),this.domTextures.forEach(t=>t.resize())):!e&&!this.renderer.production&&A(`${this.options.label}: You are trying to reset a ${this.type} with a HTML element that does not exist. The old HTML element will be kept instead.`)}get pixelRatioBoundingRect(){const e=window.devicePixelRatio??1,t=this.renderer.pixelRatio/e;return Object.keys(this.domElement.boundingRect).reduce((s,i)=>({...s,[i]:this.domElement.boundingRect[i]*t}),{x:0,y:0,width:0,height:0,top:0,right:0,bottom:0,left:0})}computeGeometry(){super.computeGeometry(),this.boundingBox.copy(this.geometry.boundingBox)}onLoading(e){return e&&(this._onLoadingCallback=e),this}}const ll={label:"Plane",instancesCount:1,vertexBuffers:[]};class Fa extends Ga{static{u(this,"Plane")}constructor(e,t,s={}){e=ft(e,s.label?s.label+" Plane":"Plane");const i={...ll,...s};let{geometry:n,widthSegments:a,heightSegments:o,...h}=i;const{instancesCount:l,vertexBuffers:d,...c}=h;if(!n||n.type!=="PlaneGeometry"){a=a??1,o=o??1;const f=a*o+a;d.length||(n=ai.getPlaneGeometryByID(f)),n?n.instancesCount=l:(n=new Ui({widthSegments:a,heightSegments:o,instancesCount:l,vertexBuffers:d}),ai.addPlaneGeometry(n))}super(e,t,{geometry:n,...c}),this.type="Plane"}}class vi extends ur{static{u(this,"GPUCurtainsRenderer")}constructor({deviceManager:e,label:t,container:s,pixelRatio:i=1,autoResize:n=!0,context:a={},renderPass:o,camera:h,lights:l}){super({deviceManager:e,label:t,container:s,pixelRatio:i,autoResize:n,context:a,renderPass:o,camera:h,lights:l}),this.type="GPUCurtainsRenderer"}setRendererObjects(){super.setRendererObjects(),this.domMeshes=[],this.domObjects=[],this.domTextures=[]}addDOMTexture(e){this.domTextures.push(e)}removeDOMTexture(e){this.domTextures=this.domTextures.filter(t=>t.uuid!==e.uuid)}onCameraMatricesChanged(){super.onCameraMatricesChanged(),this.domObjects.forEach(e=>{e.updateSizeAndPosition()})}resizeMeshes(){this.meshes.forEach(e=>{"domElement"in e||e.resize(this.boundingRect)}),this.domObjects.forEach(e=>{e.domElement.isResizing||e.domElement.setSize()})}}var Oa=u(r=>{throw TypeError(r)},"__typeError$6"),Ua=u((r,e,t)=>e.has(r)||Oa("Cannot "+t),"__accessCheck$6"),Ia=u((r,e,t)=>(Ua(r,e,"read from private field"),e.get(r)),"__privateGet$5"),ul=u((r,e,t)=>e.has(r)?Oa("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$6"),dl=u((r,e,t,s)=>(Ua(r,e,"write to private field"),e.set(r,t),t),"__privateSet$5"),Qt;class cl{static{u(this,"ScrollManager")}constructor({scroll:e={x:0,y:0},delta:t={x:0,y:0},shouldWatch:s=!0,onScroll:i=u((n={x:0,y:0})=>{},"onScroll")}={}){ul(this,Qt),this.scroll=e,this.delta=t,this.shouldWatch=s,this.onScroll=i,dl(this,Qt,this.setScroll.bind(this)),this.shouldWatch&&window.addEventListener("scroll",Ia(this,Qt),{passive:!0})}setScroll(){this.updateScrollValues({x:window.pageXOffset,y:window.pageYOffset})}updateScrollValues({x:e,y:t}){const s=this.scroll;this.scroll={x:e,y:t},this.delta={x:s.x-this.scroll.x,y:s.y-this.scroll.y},this.onScroll&&this.onScroll(this.delta)}destroy(){this.shouldWatch&&window.removeEventListener("scroll",Ia(this,Qt),{passive:!0})}}Qt=new WeakMap;class pl{static{u(this,"GPUCurtains")}constructor({container:e,label:t,pixelRatio:s=window.devicePixelRatio??1,context:i={},production:n=!1,adapterOptions:a={},renderPass:o,camera:h,lights:l,autoRender:d=!0,autoResize:c=!0,watchScroll:f=!0}={}){this._onScrollCallback=()=>{},this._onErrorCallback=()=>{},this._onContextLostCallback=()=>{},this._onContextDestroyedCallback=()=>{},this.type="CurtainsGPU",this.options={container:e,label:t,pixelRatio:s,camera:h,lights:l,production:n,adapterOptions:a,context:i,renderPass:o,autoRender:d,autoResize:c,watchScroll:f},this.setDeviceManager(),e&&this.setContainer(e),this.initScroll()}setContainer(e){if(e)if(typeof e=="string")if(e=document.querySelector(e),e)this.options.container=e;else{const t=document.createElement("div");t.setAttribute("id","curtains-gpu-canvas"),document.body.appendChild(t),this.options.container=t}else e instanceof Element&&(this.options.container=e);else{const t=document.createElement("div");t.setAttribute("id","curtains-gpu-canvas"),document.body.appendChild(t),this.options.container=t}this.container=this.options.container,this.setMainRenderer()}setMainRenderer(){this.createCurtainsRenderer({deviceManager:this.deviceManager,label:this.options.label||"GPUCurtains main GPUCurtainsRenderer",container:this.options.container,pixelRatio:this.options.pixelRatio,autoResize:this.options.autoResize,context:this.options.context,renderPass:this.options.renderPass,camera:this.options.camera,lights:this.options.lights})}patchRendererOptions(e){return e.pixelRatio===void 0&&(e.pixelRatio=this.options.pixelRatio),e.autoResize===void 0&&(e.autoResize=this.options.autoResize),e}createRenderer(e){return e=this.patchRendererOptions(e),new ar({...e,deviceManager:this.deviceManager})}createCameraRenderer(e){return e=this.patchRendererOptions(e),new ur({...e,deviceManager:this.deviceManager})}createCurtainsRenderer(e){return e=this.patchRendererOptions(e),new vi({...e,deviceManager:this.deviceManager})}setDeviceManager(){this.deviceManager=new na({label:"GPUCurtains default device",production:this.options.production,adapterOptions:this.options.adapterOptions,autoRender:this.options.autoRender,onError:u(()=>setTimeout(()=>{this._onErrorCallback&&this._onErrorCallback()},0),"onError"),onDeviceLost:u(e=>this._onContextLostCallback&&this._onContextLostCallback(e),"onDeviceLost"),onDeviceDestroyed:u(e=>this._onContextDestroyedCallback&&this._onContextDestroyedCallback(e),"onDeviceDestroyed")})}get renderers(){return this.deviceManager.renderers}get renderer(){return this.renderers[0]}async setDevice({adapter:e=null,device:t=null}={}){await this.deviceManager.init({adapter:e,device:t})}async restoreContext(){await this.deviceManager.restoreDevice()}get pingPongPlanes(){return this.renderers?.map(e=>e.pingPongPlanes).flat()}get shaderPasses(){return this.renderers?.map(e=>e.shaderPasses).flat()}get meshes(){return this.renderers?.map(e=>e.meshes).flat()}get domMeshes(){return this.renderers?.filter(e=>e instanceof vi).map(e=>e.domMeshes).flat()}get domObjects(){return this.renderers?.filter(e=>e instanceof vi).map(e=>e.domObjects).flat()}get planes(){return this.domMeshes.filter(e=>e instanceof Fa)}get computePasses(){return this.renderers?.map(e=>e.computePasses).flat()}get boundingRect(){return this.renderer?.boundingRect}initScroll(){this.scrollManager=new cl({scroll:{x:window.pageXOffset,y:window.pageYOffset},delta:{x:0,y:0},shouldWatch:this.options.watchScroll,onScroll:u(e=>this.updateScroll(e),"onScroll")})}updateScroll(e={x:0,y:0}){this.domObjects.forEach(t=>{t.domElement&&t.watchScroll&&t.updateScrollPosition(e)}),this._onScrollCallback&&this._onScrollCallback()}updateScrollValues(e={x:0,y:0}){this.scrollManager.updateScrollValues(e)}get scrollDelta(){return this.scrollManager.delta}get scrollValues(){return this.scrollManager.scroll}onBeforeRender(e){return this.deviceManager.onBeforeRender(e),this}onAfterRender(e){return this.deviceManager.onAfterRender(e),this}onScroll(e){return e&&(this._onScrollCallback=e),this}onError(e){return e&&(this._onErrorCallback=e),this}onContextLost(e){return e&&(this._onContextLostCallback=e),this}onContextDestroyed(e){return e&&(this._onContextDestroyedCallback=e),this}render(){this.deviceManager.render()}destroy(){this.deviceManager.destroy(),this.scrollManager?.destroy()}}var ka=u(r=>{throw TypeError(r)},"__typeError$5"),Mr=u((r,e,t)=>e.has(r)||ka("Cannot "+t),"__accessCheck$5"),T=u((r,e,t)=>(Mr(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet$4"),Z=u((r,e,t)=>e.has(r)?ka("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$5"),re=u((r,e,t,s)=>(Mr(r,e,"write to private field"),e.set(r,t),t),"__privateSet$4"),j=u((r,e,t)=>(Mr(r,e,"access private method"),t),"__privateMethod$5"),N,fe,He,F,Ct,Mt,es,Bt,ts,ss,is,rs,ns,as,os,hs,I,Br,Va,Na,Wa,ja,qa,Ha,Xa,Ya,Ka,Ja,St,Sr,Za,Qa;const Tt=new _,Pt=new _,Xe=new y;class fl{static{u(this,"OrbitControls")}constructor({camera:e,element:t=null,target:s=new y,enableZoom:i=!0,minZoom:n=0,maxZoom:a=1/0,zoomSpeed:o=1,enableRotate:h=!0,minPolarAngle:l=0,maxPolarAngle:d=Math.PI,minAzimuthAngle:c=-1/0,maxAzimuthAngle:f=1/0,rotateSpeed:p=1,enablePan:m=!0,panSpeed:g=1}){if(Z(this,I),Z(this,N,null),Z(this,fe,new y),Z(this,He,!1),Z(this,F,{radius:1,phi:0,theta:0}),Z(this,Ct,new _),Z(this,Mt,!1),Z(this,es,new _),Z(this,Bt,new y),Z(this,ts),Z(this,ss),Z(this,is),Z(this,rs),Z(this,ns),Z(this,as),Z(this,os),Z(this,hs),!e){A("OrbitControls: cannot initialize without a camera.");return}j(this,I,Br).call(this,{target:s,enableZoom:i,minZoom:n,maxZoom:a,zoomSpeed:o,enableRotate:h,minPolarAngle:l,maxPolarAngle:d,minAzimuthAngle:c,maxAzimuthAngle:f,rotateSpeed:p,enablePan:m,panSpeed:g}),re(this,ts,j(this,I,Ja).bind(this)),re(this,ss,j(this,I,Wa).bind(this)),re(this,is,j(this,I,qa).bind(this)),re(this,rs,j(this,I,Xa).bind(this)),re(this,ns,j(this,I,ja).bind(this)),re(this,as,j(this,I,Ha).bind(this)),re(this,os,j(this,I,Ya).bind(this)),re(this,hs,j(this,I,Ka).bind(this)),this.element=t??(typeof window<"u"?window:null),this.useCamera(e)}useCamera(e){this.camera=e,this.camera.position.onChange(()=>{this.camera.lookAt(this.target)}),T(this,fe).copy(this.camera.position).sub(this.target),T(this,F).radius=T(this,fe).length(),T(this,F).theta=Math.atan2(T(this,fe).x,T(this,fe).z),T(this,F).phi=Math.acos(Math.min(Math.max(T(this,fe).y/T(this,F).radius,-1),1)),j(this,I,St).call(this)}reset({position:e,target:t,enableZoom:s=this.enableZoom,minZoom:i=this.minZoom,maxZoom:n=this.maxZoom,zoomSpeed:a=this.zoomSpeed,enableRotate:o=this.enableRotate,minPolarAngle:h=this.minPolarAngle,maxPolarAngle:l=this.maxPolarAngle,minAzimuthAngle:d=this.minAzimuthAngle,maxAzimuthAngle:c=this.maxAzimuthAngle,rotateSpeed:f=this.rotateSpeed,enablePan:p=this.enablePan,panSpeed:m=this.panSpeed}={}){j(this,I,Br).call(this,{target:t,enableZoom:s,minZoom:i,maxZoom:n,zoomSpeed:a,enableRotate:o,minPolarAngle:h,maxPolarAngle:l,minAzimuthAngle:d,maxAzimuthAngle:c,rotateSpeed:f,enablePan:p,panSpeed:m}),e&&this.updatePosition(e)}updatePosition(e=new y){e.sub(this.target),T(this,F).radius=e.length(),T(this,F).theta=Math.atan2(e.x,e.z),T(this,F).phi=Math.acos(Math.min(Math.max(e.y/T(this,F).radius,-1),1)),j(this,I,St).call(this)}set element(e){T(this,N)&&(!e||T(this,N)!==e)&&(console.log("set element, remove events",e),j(this,I,Na).call(this)),re(this,N,e),e&&j(this,I,Va).call(this)}get element(){return T(this,N)}destroy(){this.element=null}}N=new WeakMap,fe=new WeakMap,He=new WeakMap,F=new WeakMap,Ct=new WeakMap,Mt=new WeakMap,es=new WeakMap,Bt=new WeakMap,ts=new WeakMap,ss=new WeakMap,is=new WeakMap,rs=new WeakMap,ns=new WeakMap,as=new WeakMap,os=new WeakMap,hs=new WeakMap,I=new WeakSet,Br=u(function({target:r,enableZoom:e=this.enableZoom,minZoom:t=this.minZoom,maxZoom:s=this.maxZoom,zoomSpeed:i=this.zoomSpeed,enableRotate:n=this.enableRotate,minPolarAngle:a=this.minPolarAngle,maxPolarAngle:o=this.maxPolarAngle,minAzimuthAngle:h=this.minAzimuthAngle,maxAzimuthAngle:l=this.maxAzimuthAngle,rotateSpeed:d=this.rotateSpeed,enablePan:c=this.enablePan,panSpeed:f=this.panSpeed}={}){r&&(this.target=r),this.enableZoom=e,this.minZoom=t,this.maxZoom=s,this.zoomSpeed=i,this.enableRotate=n,this.minPolarAngle=a,this.maxPolarAngle=o,this.minAzimuthAngle=h,this.maxAzimuthAngle=l,this.rotateSpeed=d,this.enablePan=c,this.panSpeed=f},"setBaseParams_fn"),Va=u(function(){T(this,N).addEventListener("contextmenu",T(this,ts),!1),T(this,N).addEventListener("mousedown",T(this,ss),!1),T(this,N).addEventListener("mousemove",T(this,is),!1),T(this,N).addEventListener("mouseup",T(this,rs),!1),T(this,N).addEventListener("touchstart",T(this,ns),{passive:!1}),T(this,N).addEventListener("touchmove",T(this,as),{passive:!1}),T(this,N).addEventListener("touchend",T(this,os),!1),T(this,N).addEventListener("wheel",T(this,hs),{passive:!1})},"addEvents_fn"),Na=u(function(){T(this,N).removeEventListener("contextmenu",T(this,ts),!1),T(this,N).removeEventListener("mousedown",T(this,ss),!1),T(this,N).removeEventListener("mousemove",T(this,is),!1),T(this,N).removeEventListener("mouseup",T(this,rs),!1),T(this,N).removeEventListener("touchstart",T(this,ns),{passive:!1}),T(this,N).removeEventListener("touchmove",T(this,as),{passive:!1}),T(this,N).removeEventListener("touchend",T(this,os),!1),T(this,N).removeEventListener("wheel",T(this,hs),{passive:!1})},"removeEvents_fn"),Wa=u(function(r){r.button===0&&this.enableRotate?(re(this,He,!0),T(this,Ct).set(r.clientX,r.clientY)):r.button===2&&this.enablePan&&(re(this,Mt,!0),T(this,es).set(r.clientX,r.clientY)),r.stopPropagation(),r.preventDefault()},"onMouseDown_fn"),ja=u(function(r){r.touches.length===1&&this.enableRotate&&(re(this,He,!0),T(this,Ct).set(r.touches[0].pageX,r.touches[0].pageY))},"onTouchStart_fn"),qa=u(function(r){T(this,He)&&this.enableRotate?j(this,I,Sr).call(this,r.clientX,r.clientY):T(this,Mt)&&this.enablePan&&j(this,I,Za).call(this,r.clientX,r.clientY)},"onMouseMove_fn"),Ha=u(function(r){T(this,He)&&this.enableRotate&&j(this,I,Sr).call(this,r.touches[0].pageX,r.touches[0].pageY)},"onTouchMove_fn"),Xa=u(function(r){re(this,He,!1),re(this,Mt,!1)},"onMouseUp_fn"),Ya=u(function(r){re(this,He,!1),re(this,Mt,!1)},"onTouchEnd_fn"),Ka=u(function(r){this.enableZoom&&(j(this,I,Qa).call(this,r.deltaY),r.preventDefault())},"onMouseWheel_fn"),Ja=u(function(r){r.preventDefault()},"onContextMenu_fn"),St=u(function(){const r=T(this,F).radius*Math.sin(Math.max(1e-6,T(this,F).phi));T(this,fe).x=r*Math.sin(T(this,F).theta),T(this,fe).y=T(this,F).radius*Math.cos(T(this,F).phi),T(this,fe).z=r*Math.cos(T(this,F).theta),this.camera.position.copy(this.target).add(T(this,fe))},"update_fn"),Sr=u(function(r,e){Tt.set(r,e),Pt.copy(Tt).sub(T(this,Ct)).multiplyScalar(this.rotateSpeed),T(this,F).theta-=2*Math.PI*Pt.x/this.camera.size.height,T(this,F).phi-=2*Math.PI*Pt.y/this.camera.size.height,T(this,F).theta=Math.min(this.maxAzimuthAngle,Math.max(this.minAzimuthAngle,T(this,F).theta)),T(this,F).phi=Math.min(this.maxPolarAngle,Math.max(this.minPolarAngle,T(this,F).phi)),T(this,Ct).copy(Tt),j(this,I,St).call(this)},"rotate_fn"),Za=u(function(r,e){Tt.set(r,e),Pt.copy(Tt).sub(T(this,es)).multiplyScalar(this.panSpeed),T(this,Bt).set(0),Xe.copy(this.camera.position).sub(this.target);let t=Xe.length();t*=Math.tan(this.camera.fov/2*Math.PI/180),Xe.set(this.camera.modelMatrix.elements[0],this.camera.modelMatrix.elements[1],this.camera.modelMatrix.elements[2]),Xe.multiplyScalar(-(2*Pt.x*t)/this.camera.size.height),T(this,Bt).add(Xe),Xe.set(this.camera.modelMatrix.elements[4],this.camera.modelMatrix.elements[5],this.camera.modelMatrix.elements[6]),Xe.multiplyScalar(2*Pt.y*t/this.camera.size.height),T(this,Bt).add(Xe),T(this,es).copy(Tt),this.target.add(T(this,Bt)),T(this,fe).copy(this.camera.position).sub(this.target),T(this,F).radius=T(this,fe).length(),j(this,I,St).call(this)},"pan_fn"),Qa=u(function(r){T(this,F).radius=Math.min(this.maxZoom,Math.max(this.minZoom+1e-6,T(this,F).radius+r*this.zoomSpeed/100)),j(this,I,St).call(this)},"zoom_fn");var eo=u(r=>{throw TypeError(r)},"__typeError$4"),ml=u((r,e,t)=>e.has(r)||eo("Cannot "+t),"__accessCheck$4"),gl=u((r,e,t)=>e.has(r)?eo("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$4"),me=u((r,e,t)=>(ml(r,e,"access private method"),t),"__privateMethod$4"),oe,to,so,Tr,bi,io,ro,Pr,no,ao;class oo{static{u(this,"HDRLoader")}constructor(){gl(this,oe)}async loadFromUrl(e){const t=await(await fetch(e)).arrayBuffer();return me(this,oe,to).call(this,new DataView(t))}}oe=new WeakSet,to=u(function(r){const e={data:r,offset:0},t=me(this,oe,so).call(this,e);return{width:t.width,height:t.height,exposure:t.exposure,gamma:t.gamma,data:me(this,oe,io).call(this,e,t)}},"decodeRGBE_fn"),so=u(function(r){let e=me(this,oe,bi).call(this,r);const t={colorCorr:[1,1,1],exposure:1,gamma:1,width:0,height:0,flipX:!1,flipY:!1};if(e!=="#?RADIANCE"&&e!=="#?RGBE")throw new Error("Incorrect file format!");for(;e!=="";){e=me(this,oe,bi).call(this,r);const i=e.split("=");switch(i[0]){case"GAMMA":t.gamma=parseFloat(i[1]);break;case"FORMAT":if(i[1]!=="32-bit_rle_rgbe"&&i[1]!=="32-bit_rle_xyze")throw new Error("Incorrect encoding format!");break;case"EXPOSURE":t.exposure=parseFloat(i[1]);break;case"COLORCORR":t.colorCorr=i[1].replace(/^\s+|\s+$/g,"").split(" ").map(n=>parseFloat(n));break}}e=me(this,oe,bi).call(this,r);const s=e.split(" ");return me(this,oe,Tr).call(this,s[0],parseInt(s[1]),t),me(this,oe,Tr).call(this,s[2],parseInt(s[3]),t),t},"parseHeader_fn"),Tr=u(function(r,e,t){switch(r){case"+X":t.width=e;break;case"-X":t.width=e,t.flipX=!0,console.warn("Flipping horizontal orientation not currently supported");break;case"-Y":t.height=e,t.flipY=!0;break;case"+Y":t.height=e;break}},"parseSize_fn"),bi=u(function(r){let e,t="";for(;(e=r.data.getUint8(r.offset++))!==10;)t+=String.fromCharCode(e);return t},"readLine_fn"),io=u(function(r,e){const t=r.data.getUint16(r.offset);let s;if(t===514)s=me(this,oe,ro).call(this,r,e),e.flipX&&me(this,oe,no).call(this,s,e),e.flipY&&me(this,oe,ao).call(this,s,e);else throw new Error("Obsolete HDR file version!");return s},"parseData_fn"),ro=u(function(r,e){const{width:t,height:s,colorCorr:i}=e,n=new Float32Array(t*s*4);let a=0,{offset:o,data:h}=r;for(let l=0;l<s;++l){if(h.getUint16(o)!==514)throw new Error("Incorrect scanline start hash");if(h.getUint16(o+2)!==t)throw new Error("Scanline doesn't match picture dimension!");o+=4;const d=t*4,c=[];let f=0;for(;f<d;){let p=h.getUint8(o++);if(p>128){const m=p-128;p=h.getUint8(o++);for(let g=0;g<m;++g)c[f++]=p}else for(let m=0;m<p;++m)c[f++]=h.getUint8(o++)}for(f=0;f<t;++f){const p=c[f],m=c[f+t],g=c[f+t*2];let v=c[f+t*3];v=v?Math.pow(2,v-136):0,n[a++]=p*v*i[0],n[a++]=m*v*i[1],n[a++]=g*v*i[2],n[a++]=v}}return n},"parseNewRLE_fn"),Pr=u(function(r,e,t){e*=4,t*=4;for(let s=0;s<4;++s){const i=r[e+s];r[e+s]=r[t+s],r[t+s]=i}},"swap_fn"),no=u(function(r,e){const{width:t,height:s}=e,i=t>>1;for(let n=0;n<s;++n){const a=n*t;for(let o=0;o<i;++o){const h=a+o,l=a+t-1-o;me(this,oe,Pr).call(this,r,h,l)}}},"flipX_fn"),ao=u(function(r,e){const{width:t,height:s}=e,i=s>>1;for(let n=0;n<i;++n){const a=n*t,o=(s-1-n)*t;for(let h=0;h<t;++h)me(this,oe,Pr).call(this,r,a+h,o+h)}},"flipY_fn");const ho=`
fn radicalInverse_VdC(inputBits: u32) -> f32 {
  var bits: u32 = inputBits;
  bits = (bits << 16u) | (bits >> 16u);
  bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
  bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
  bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
  bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
  return f32(bits) * 2.3283064365386963e-10; // / 0x100000000
}

// hammersley2d describes a sequence of points in the 2d unit square [0,1)^2
// that can be used for quasi Monte Carlo integration
fn hammersley2d(i: u32, N: u32) -> vec2f {
  return vec2(f32(i) / f32(N), radicalInverse_VdC(i));
}
`,lo=`
// TBN generates a tangent bitangent normal coordinate frame from the normal
// (the normal must be normalized)
fn generateTBN(normal: vec3f) -> mat3x3f {
  var bitangent: vec3f = vec3(0.0, 1.0, 0.0);

  let NdotUp: f32 = dot(normal, vec3(0.0, 1.0, 0.0));
  
  if (1.0 - abs(NdotUp) <= EPSILON) {
    // Sampling +Y or -Y, so we need a more robust bitangent.
    if (NdotUp > 0.0) {
      bitangent = vec3(0.0, 0.0, 1.0);
    }
    else {
      bitangent = vec3(0.0, 0.0, -1.0);
    }
  }

  let tangent: vec3f = normalize(cross(bitangent, normal));
  bitangent = cross(normal, tangent);

  return mat3x3f(tangent, bitangent, normal);
}
`,yl=`
${$e}
${ot}
${ho}
${lo}
${wa}

// GGX microfacet distribution
struct MicrofacetDistributionSample {
  pdf: f32,
  cosTheta: f32,
  sinTheta: f32,
  phi: f32
};

// https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.html
// This implementation is based on https://bruop.github.io/ibl/,
//  https://www.tobias-franke.eu/log/2014/03/30/notes_on_importance_sampling.html
// and https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch20.html
fn GGX(xi: vec2f, roughness: f32) -> MicrofacetDistributionSample {
  var ggx: MicrofacetDistributionSample;

  // evaluate sampling equations
  let alpha: f32 = roughness * roughness;
  ggx.cosTheta = clamp(sqrt((1.0 - xi.y) / (1.0 + (alpha * alpha - 1.0) * xi.y)), 0.0, 1.0);
  ggx.sinTheta = sqrt(1.0 - ggx.cosTheta * ggx.cosTheta);
  ggx.phi = 2.0 * PI * xi.x;

  // evaluate GGX pdf (for half vector)
  ggx.pdf = DistributionGGX(ggx.cosTheta, alpha);

  // Apply the Jacobian to obtain a pdf that is parameterized by l
  // see https://bruop.github.io/ibl/
  // Typically you'd have the following:
  // float pdf = DistributionGGX(NoH, roughness) * NoH / (4.0 * VoH);
  // but since V = N => VoH == NoH
  ggx.pdf /= 4.0;

  return ggx;
}

fn Lambertian(xi: vec2f, roughness: f32) -> MicrofacetDistributionSample {
    var lambertian: MicrofacetDistributionSample;

  // Cosine weighted hemisphere sampling
  // http://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/2D_Sampling_with_Multidimensional_Transformations.html#Cosine-WeightedHemisphereSampling
  lambertian.cosTheta = sqrt(1.0 - xi.y);
  lambertian.sinTheta = sqrt(xi.y); // equivalent to \`sqrt(1.0 - cosTheta*cosTheta)\`;
  lambertian.phi = 2.0 * PI * xi.x;

  lambertian.pdf = lambertian.cosTheta / PI; // evaluation for solid angle, therefore drop the sinTheta

  return lambertian;
}

// getImportanceSample returns an importance sample direction with pdf in the .w component
fn getImportanceSample(Xi: vec2<f32>, N: vec3f, roughness: f32) -> vec4f {
  var importanceSample: MicrofacetDistributionSample;
  
  importanceSample = GGX(Xi, roughness);
  
   // transform the hemisphere sample to the normal coordinate frame
  // i.e. rotate the hemisphere to the normal direction
  let localSpaceDirection: vec3f = normalize(vec3(
    importanceSample.sinTheta * cos(importanceSample.phi), 
    importanceSample.sinTheta * sin(importanceSample.phi), 
    importanceSample.cosTheta
  ));
  
  let TBN: mat3x3f = generateTBN(N);
  let direction: vec3f = TBN * localSpaceDirection;

  return vec4(direction, importanceSample.pdf);
}

@compute @workgroup_size(16, 16, 1)
fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {  
  let texelSize: vec2<u32> = textureDimensions(lutStorageTexture);

  let x: u32 = global_id.x;
  let y: u32 = global_id.y;

  // Check bounds
  if (x >= texelSize.x || y >= texelSize.y) {
     return;
  }
  
  let epsilon: f32 = 1e-6;

  // Compute roughness and N\xB7V from texture coordinates
  let NdotV: f32 = max(f32(x) / f32(texelSize.x - 1), epsilon);    // Maps x-axis to N\xB7V (0.0 to 1.0)
  let roughness: f32 = max(f32(y) / f32(texelSize.y - 1), epsilon);  // Maps y-axis to roughness (0.0 to 1.0)

  // Calculate view vector and normal vector
  let V: vec3<f32> = vec3<f32>(sqrt(1.0 - NdotV * NdotV), 0.0, NdotV);  // Normalized view vector
  let N: vec3<f32> = vec3<f32>(0.0, 0.0, 1.0);                          // Normal is along z-axis

  // Initialize integration variables
  var A: f32 = 0.0;
  var B: f32 = 0.0;
  var C: f32 = 0.0;

  // Monte Carlo integration to calculate A and B factors
  let sampleCount: u32 = params.sampleCount;
  for (var i: u32 = 0; i < sampleCount; i++) {
    let Xi: vec2<f32> = hammersley2d(i, sampleCount);  // Importance sampling (Hammersley sequence)
    
    //let H: vec3<f32> = importanceSampleGGX(Xi, N, roughness);
    let importanceSample: vec4f = getImportanceSample(Xi, N, roughness);
    let H: vec3f = importanceSample.xyz;
    // let pdf: f32 = importanceSample.w;
    
    let L: vec3<f32> = normalize(reflect(-V, H));
    
    let NdotL: f32 = clamp(L.z, 0.0, 1.0);
    let NdotH: f32 = clamp(H.z, 0.0, 1.0);
    let VdotH: f32 = clamp(dot(V, H), 0.0, 1.0);

    // Ensure valid light direction
    if (NdotL > 0.0) {     
      // LUT for GGX distribution.

      // Taken from: https://bruop.github.io/ibl
      // Shadertoy: https://www.shadertoy.com/view/3lXXDB
      // Terms besides V are from the GGX PDF we're dividing by.
      let V_pdf: f32 = GeometrySmith(NdotV, NdotL, roughness) * VdotH * NdotL / max(NdotH, epsilon);
      let Fc: f32 = pow(1.0 - VdotH, 5.0);
      A += (1.0 - Fc) * V_pdf;
      B += Fc * V_pdf;
      C += 0.0;
    }
  }

  // Average the integration result
  // The PDF is simply pdf(v, h) -> NDF * <nh>.
  // To parametrize the PDF over l, use the Jacobian transform, yielding to: pdf(v, l) -> NDF * <nh> / 4<vh>
  // Since the BRDF divide through the PDF to be normalized, the 4 can be pulled out of the integral.
  A = A * 4.0 / f32(sampleCount);
  B = B * 4.0 / f32(sampleCount);
  C = C * 4.0 * 2.0 * PI / f32(sampleCount);
    
  // Store the result in the LUT texture
  textureStore(lutStorageTexture, vec2<u32>(x, y), vec4<f32>(A, B, C, 1.0));
}
`,xl=`
${$e}

// Cube face lookup vectors
// positive and negative Y need to be inverted
const faceVectors = array<array<vec3<f32>, 2>, 6>(
  array<vec3<f32>, 2>(vec3<f32>(1.0, 0.0, 0.0), vec3<f32>(0.0, 1.0, 0.0)), // +X
  array<vec3<f32>, 2>(vec3<f32>(-1.0, 0.0, 0.0), vec3<f32>(0.0, 1.0, 0.0)), // -X
  array<vec3<f32>, 2>(vec3<f32>(0.0, -1.0, 0.0), vec3<f32>(0.0, 0.0, 1.0)),  // -Y
  array<vec3<f32>, 2>(vec3<f32>(0.0, 1.0, 0.0), vec3<f32>(0.0, 0.0, -1.0)), // +Y
  array<vec3<f32>, 2>(vec3<f32>(0.0, 0.0, 1.0), vec3<f32>(0.0, 1.0, 0.0)), // +Z
  array<vec3<f32>, 2>(vec3<f32>(0.0, 0.0, -1.0), vec3<f32>(0.0, 1.0, 0.0)) // -Z
);

// Utility to calculate 3D direction for a given cube face pixel
fn texelDirection(faceIndex : u32, u : f32, v : f32) -> vec3<f32> {
  let forward = faceVectors[faceIndex][0];
  let up = faceVectors[faceIndex][1];
  let right = normalize(cross(up, forward));
  return normalize(forward + (2.0 * u - 1.0) * right + (2.0 * v - 1.0) * up);
}

// Map 3D direction to equirectangular coordinates
fn dirToEquirect(dir : vec3<f32>) -> vec2<f32> {
  let phi = atan2(dir.z, dir.x);
  let theta = asin(dir.y);
  let u = 0.5 + 0.5 * phi / PI;
  let v = 0.5 - theta / PI;
  return vec2<f32>(u, v);
}

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
  let faceSize = params.faceSize;
  let cubeFaceIndex = global_id.z;
  let x = global_id.x;
  let y = global_id.y;

  if (x >= faceSize || y >= faceSize || cubeFaceIndex >= 6u) {
    return;
  }

  let u = f32(x) / f32(faceSize);
  let v = f32(y) / f32(faceSize);

  // Get the 3D direction for this cube face texel
  let dir = texelDirection(cubeFaceIndex, u, v);

  // Map to equirectangular coordinates
  let uv = dirToEquirect(dir);        
  
  let hdrWidth = params.imageSize.x;
  let hdrHeight = params.imageSize.y;

  let texX = u32(clamp(uv.x * hdrWidth, 0.0, hdrWidth - 1.0));
  let texY = u32(clamp(uv.y * hdrHeight, 0.0, hdrHeight - 1.0));

  let hdrTexelIndex = texY * u32(hdrWidth) + texX;
  
  // Sample the equirectangular texture
  let sampledColor = params.hdrImageData[hdrTexelIndex];
  
  // Correct cube face order in texture store (fix for reversed face indices)
  textureStore(
    specularStorageCubemap,
    vec2<u32>(x, y),
    cubeFaceIndex,
    sampledColor
  );
}
`,vl=u(r=>`
${$e}
${ho}
${lo}

// Mipmap Filtered Samples (GPU Gems 3, 20.4)
// https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling
// https://cgg.mff.cuni.cz/~jaroslav/papers/2007-sketch-fis/Final_sap_0073.pdf
fn computeLod(pdf: f32) -> f32 {
  // https://cgg.mff.cuni.cz/~jaroslav/papers/2007-sketch-fis/Final_sap_0073.pdf
  return 0.5 * log2( 6.0 * f32(params.faceSize) * f32(params.faceSize) / (f32(params.sampleCount) * pdf));
}

fn transformDirection(face: u32, uv: vec2f) -> vec3f {
  // Transform the direction based on the cubemap face
  switch (face) {
    case 0u {
      // +X
      return vec3f( 1.0,  uv.y, -uv.x);
    }
    case 1u {
      // -X
      return vec3f(-1.0,  uv.y,  uv.x);
    }
    case 2u {
      // +Y
      return vec3f( uv.x,  -1.0, uv.y);
    }
    case 3u {
      // -Y
      return vec3f( uv.x, 1.0,  -uv.y);
    }
    case 4u {
      // +Z
      return vec3f( uv.x,  uv.y,  1.0);
    }
    case 5u {
      // -Z
      return vec3f(-uv.x,  uv.y, -1.0);
    }
    default {
      return vec3f(0.0, 0.0, 0.0);
    }
  }
}

@compute @workgroup_size(8, 8, 1) fn main(
  @builtin(global_invocation_id) GlobalInvocationID: vec3u,
) {
  let faceSize: u32 = params.faceSize;
  let sampleCount: u32 = params.sampleCount;
  
  let face: u32 = GlobalInvocationID.z;
  let x: u32 = GlobalInvocationID.x;
  let y: u32 = GlobalInvocationID.y;

  if (x >= faceSize || y >= faceSize) {
    return;
  }

  let texelSize: f32 = 1.0 / f32(faceSize);
  let halfTexel: f32 = texelSize * 0.5;
  
  var uv: vec2f = vec2(
    (f32(x) + halfTexel) * texelSize,
    (f32(y) + halfTexel) * texelSize
  );
  
  uv = uv * 2.0 - 1.0;

  let normal: vec3<f32> = transformDirection(face, uv);
  
  var irradiance: vec3f = vec3f(0.0, 0.0, 0.0);

  for (var i: u32 = 0; i < sampleCount; i++) {
    // generate a quasi monte carlo point in the unit square [0.1)^2
    let xi: vec2f = hammersley2d(i, sampleCount);
    
    let cosTheta: f32 = sqrt(1.0 - xi.y);
    let sinTheta: f32 = sqrt(1.0 - cosTheta * cosTheta);
    let phi: f32 = 2.0 * PI * xi.x;
    let pdf: f32 = cosTheta / PI; // evaluation for solid angle, therefore drop the sinTheta

    let sampleVec: vec3f = vec3f(
      sinTheta * cos(phi),
      sinTheta * sin(phi),
      cosTheta
    );
    
    let TBN: mat3x3f = generateTBN(normalize(normal));
    
    var direction: vec3f = TBN * sampleVec;
    
    // invert along Y axis
    direction.y *= -1.0;
    
    let lod: f32 = computeLod(pdf);
    
    let sampleLevel = min(lod, f32(params.maxMipLevel));

    // Convert sampleVec to texture coordinates of the specular env map
    irradiance += textureSampleLevel(
      ${r.options.name},
      clampSampler,
      direction,
      sampleLevel
    ).rgb;
  }

  irradiance /= f32(sampleCount);

  textureStore(diffuseEnvMap, vec2(x, y), face, vec4f(irradiance, 1.0));
}
`,"computeDiffuseFromSpecularCubemap");var uo=u(r=>{throw TypeError(r)},"__typeError$3"),Rr=u((r,e,t)=>e.has(r)||uo("Cannot "+t),"__accessCheck$3"),Fe=u((r,e,t)=>(Rr(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet$3"),Er=u((r,e,t)=>e.has(r)?uo("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$3"),co=u((r,e,t,s)=>(Rr(r,e,"write to private field"),e.set(r,t),t),"__privateSet$3"),zr=u((r,e,t)=>(Rr(r,e,"access private method"),t),"__privateMethod$3"),ut,Ye,ls,wi;class bl{static{u(this,"EnvironmentMap")}constructor(e,t={}){Er(this,ls),Er(this,ut),Er(this,Ye),this._onRotationAxisChangedCallback=()=>{},this.uuid=O(),this.setRenderer(e),t={lutTextureParams:{size:256,computeSampleCount:1024,label:"Environment LUT texture",name:"lutTexture",format:"rgba32float"},diffuseTextureParams:{size:128,computeSampleCount:2048,label:"Environment diffuse texture",name:"envDiffuseTexture",format:"rgba16float"},specularTextureParams:{label:"Environment specular texture",name:"envSpecularTexture",format:"rgba16float",generateMips:!0},diffuseIntensity:1,specularIntensity:1,rotation:Math.PI/2,...t},this.options=t,this.sampler=new et(this.renderer,{label:"Clamp sampler",name:"clampSampler",magFilter:"linear",minFilter:"linear",mipmapFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}),this.rotationMatrix=new de().rotateByAngleY(-Math.PI/2),this.hdrLoader=new oo,this.createLUTTextures(),this.createSpecularDiffuseTextures(),this.computeBRDFLUTTexture()}setRenderer(e){this.renderer&&this.renderer.environmentMaps.delete(this.uuid),e=$(e,"EnvironmentMap"),this.renderer=e,this.renderer.environmentMaps.set(this.uuid,this)}get rotation(){return this.options.rotation}set rotation(e){e!==this.options.rotation&&(this.options.rotation=e,this.rotationMatrix.rotateByAngleY(-e),this._onRotationAxisChangedCallback&&this._onRotationAxisChangedCallback())}onRotationAxisChanged(e){return e&&(this._onRotationAxisChangedCallback=e),this}createLUTTextures(){const{size:e,computeSampleCount:t,...s}=this.options.lutTextureParams;co(this,Ye,new q(this.renderer,{label:"LUT storage texture",name:"lutStorageTexture",format:s.format,visibility:["compute","fragment"],usage:["copySrc","storageBinding","textureBinding"],type:"storage",fixedSize:{width:e,height:e},autoDestroy:!1})),this.lutTexture=new q(this.renderer,{...s,visibility:["fragment"],fixedSize:{width:e,height:e},autoDestroy:!1,fromTexture:Fe(this,Ye)})}createSpecularDiffuseTextures(){const e={viewDimension:"cube",autoDestroy:!1};this.specularTexture=new q(this.renderer,{...this.options.specularTextureParams,visibility:["fragment","compute"],fixedSize:{width:256,height:256},...e});const{size:t,computeSampleCount:s,...i}=this.options.diffuseTextureParams;this.diffuseTexture=new q(this.renderer,{...i,visibility:["fragment"],fixedSize:{width:t,height:t},...e})}async computeBRDFLUTTexture(){let e=null;for(const i of this.renderer.deviceManager.renderers){for(const[n,a]of i.environmentMaps)if(n!==this.uuid&&a.lutTexture&&a.lutTexture.size.width===this.lutTexture.size.width){e=a.lutTexture;break}if(e)break}if(e){this.lutTexture.copy(e);return}const{computeSampleCount:t}=this.options.lutTextureParams;let s=new Vs(this.renderer,{label:"Compute LUT texture",autoRender:!1,dispatchSize:[Math.ceil(Fe(this,Ye).size.width/16),Math.ceil(Fe(this,Ye).size.height/16),1],shaders:{compute:{code:yl}},uniforms:{params:{struct:{sampleCount:{type:"u32",value:t}}}},textures:[Fe(this,Ye)]});await s.material.compileMaterial(),zr(this,ls,wi).call(this,{computePass:s,label:"Compute LUT texture command encoder"}),this.lutTexture.textureBinding.resource=this.lutTexture.texture,s.remove(),s=null}async computeSpecularCubemapFromHDRData(e){let t=new q(this.renderer,{label:"Specular storage cubemap",name:"specularStorageCubemap",format:this.specularTexture.options.format,visibility:["compute"],usage:["copySrc","storageBinding"],type:"storage",fixedSize:{width:this.specularTexture.size.width,height:this.specularTexture.size.height,depth:6},viewDimension:"2d-array"}),s=new Vs(this.renderer,{label:"Compute specular cubemap from equirectangular",autoRender:!1,dispatchSize:[Math.ceil(this.specularTexture.size.width/8),Math.ceil(this.specularTexture.size.height/8),6],shaders:{compute:{code:xl}},storages:{params:{struct:{hdrImageData:{type:"array<vec4f>",value:e.data},imageSize:{type:"vec2f",value:new _(e.width,e.height)},faceSize:{type:"u32",value:this.specularTexture.size.width}}}},textures:[t]});await s.material.compileMaterial(),zr(this,ls,wi).call(this,{computePass:s,label:"Compute specular cube map command encoder",onAfterCompute:u(i=>{this.renderer.copyGPUTextureToTexture(t.texture,this.specularTexture,i),this.specularTexture.textureBinding.resource=this.specularTexture.texture},"onAfterCompute")}),s.remove(),t.destroy(),t=null,s=null}async computeDiffuseFromSpecular(){if(this.specularTexture.options.viewDimension!=="cube"){A("Could not compute the diffuse texture because the specular texture is not a cube map:"+this.specularTexture.options.viewDimension);return}let e=new q(this.renderer,{label:"Diffuse storage cubemap",name:"diffuseEnvMap",format:this.diffuseTexture.options.format,visibility:["compute"],usage:["copySrc","storageBinding"],type:"storage",fixedSize:{width:this.diffuseTexture.size.width,height:this.diffuseTexture.size.height,depth:6},viewDimension:"2d-array"}),t=new Vs(this.renderer,{label:"Compute diffuse map from specular map",autoRender:!1,dispatchSize:[Math.ceil(this.diffuseTexture.size.width/8),Math.ceil(this.diffuseTexture.size.height/8),6],shaders:{compute:{code:vl(this.specularTexture)}},uniforms:{params:{struct:{faceSize:{type:"u32",value:this.diffuseTexture.size.width},maxMipLevel:{type:"u32",value:this.specularTexture.texture.mipLevelCount},sampleCount:{type:"u32",value:this.options.diffuseTextureParams.computeSampleCount}}}},samplers:[this.sampler],textures:[this.specularTexture,e]});await t.material.compileMaterial(),zr(this,ls,wi).call(this,{computePass:t,label:"Compute diffuse cube map from specular cube map command encoder",onAfterCompute:u(s=>{this.renderer.copyGPUTextureToTexture(e.texture,this.diffuseTexture,s),this.diffuseTexture.textureBinding.resource=this.diffuseTexture.texture},"onAfterCompute")}),t.remove(),e.destroy(),e=null,t=null}async loadAndComputeFromHDR(e){co(this,ut,await this.hdrLoader.loadFromUrl(e));const{width:t,height:s}=Fe(this,ut)?Fe(this,ut):{width:1024,height:512},i=Math.max(t/4,s/2);(this.specularTexture.size.width!==i||this.specularTexture.size.height!==i)&&(this.specularTexture.options.fixedSize.width=i,this.specularTexture.options.fixedSize.height=i,this.specularTexture.size.width=i,this.specularTexture.size.height=i,this.specularTexture.createTexture());const{size:n}=this.options.diffuseTextureParams,a=Math.min(n,i);(this.diffuseTexture.size.width!==a||this.diffuseTexture.size.height!==a)&&(this.diffuseTexture.options.fixedSize.width=a,this.diffuseTexture.options.fixedSize.height=a,this.diffuseTexture.size.width=a,this.diffuseTexture.size.height=a,this.diffuseTexture.createTexture()),this.computeFromHDR()}computeFromHDR(){Fe(this,ut)&&this.computeSpecularCubemapFromHDRData(Fe(this,ut)).then(()=>{this.computeDiffuseFromSpecular()})}destroy(){this.diffuseTexture?.destroy(),this.specularTexture?.destroy(),this.lutTexture?.destroy(),Fe(this,Ye).destroy()}}ut=new WeakMap,Ye=new WeakMap,ls=new WeakSet,wi=u(function({computePass:r,label:e="",onAfterCompute:t=u(s=>{},"onAfterCompute")}){const s=this.renderer.device?.createCommandEncoder({label:e});!this.renderer.production&&s.pushDebugGroup(e),this.renderer.renderSingleComputePass(s,r,!1),t(s),!this.renderer.production&&s.popDebugGroup();const i=s.finish();this.renderer.device?.queue.submit([i]),this.renderer.pipelineManager.resetCurrentPipeline()},"runComputePass_fn");class wl extends Nt{static{u(this,"BoxGeometry")}constructor({instancesCount:e=1,vertexBuffers:t=[],topology:s,mapBuffersAtCreation:i=!0,widthSegments:n=1,heightSegments:a=1,depthSegments:o=1}={}){super({verticesOrder:"ccw",topology:s,instancesCount:e,vertexBuffers:t,mapBuffersAtCreation:i}),this.type="BoxGeometry",n=Math.floor(n),a=Math.floor(a),o=Math.floor(o);const h=[],l=[],d=[],c=[];let f=0;const p=u((m,g,v,x,b,S,B,C,P,w)=>{const z=S/P,R=B/w,L=S/2,U=B/2,K=C/2,G=P+1,Q=w+1;let ee=0;const k=new y;for(let W=0;W<Q;W++){const X=W*R-U;for(let te=0;te<G;te++){const he=te*z-L;k[m]=he*x,k[g]=X*b,k[v]=K,h.push(k.x,k.y,k.z),k[m]=0,k[g]=0,k[v]=C>0?1:-1,d.push(k.x,k.y,k.z),l.push(te/P),l.push(W/w),ee+=1}}for(let W=0;W<w;W++)for(let X=0;X<P;X++){const te=f+X+G*W,he=f+X+G*(W+1),Ie=f+(X+1)+G*(W+1),bs=f+(X+1)+G*W;c.push(te,he,bs),c.push(he,Ie,bs),f+=ee}},"buildPlane");p("z","y","x",-1,-1,2,2,2,o,a),p("z","y","x",1,-1,2,2,-2,o,a),p("x","z","y",1,1,2,2,2,n,o),p("x","z","y",1,-1,2,2,-2,n,o),p("x","y","z",1,-1,2,2,2,n,a),p("x","y","z",-1,-1,2,2,-2,n,a),this.setAttribute({name:"position",type:"vec3f",bufferFormat:"float32x3",size:3,array:new Float32Array(h)}),this.setAttribute({name:"uv",type:"vec2f",bufferFormat:"float32x2",size:2,array:new Float32Array(l)}),this.setAttribute({name:"normal",type:"vec3f",bufferFormat:"float32x3",size:3,array:new Float32Array(d)}),this.setIndexBuffer({array:this.useUint16IndexArray?new Uint16Array(c):new Uint32Array(c),bufferFormat:this.useUint16IndexArray?"uint16":"uint32"})}}class Cl extends Nt{static{u(this,"SphereGeometry")}constructor({topology:e,instancesCount:t=1,vertexBuffers:s=[],mapBuffersAtCreation:i=!0,widthSegments:n=32,heightSegments:a=16,phiStart:o=0,phiLength:h=Math.PI*2,thetaStart:l=0,thetaLength:d=Math.PI}={}){super({verticesOrder:"ccw",topology:e,instancesCount:t,vertexBuffers:s,mapBuffersAtCreation:i}),this.type="SphereGeometry",n=Math.max(3,Math.floor(n)),a=Math.max(2,Math.floor(a));const c=1,f=Math.min(l+d,Math.PI);let p=0;const m=[],g=new y,v=new y,x=[],b=[],S=[],B=[];for(let C=0;C<=a;C++){const P=[],w=C/a;let z=0;C===0&&l===0?z=.5/n:C===a&&f===Math.PI&&(z=-.5/n);for(let R=0;R<=n;R++){const L=R/n;g.x=-c*Math.cos(o+L*h)*Math.sin(l+w*d),g.y=c*Math.cos(l+w*d),g.z=c*Math.sin(o+L*h)*Math.sin(l+w*d),b.push(g.x,g.y,g.z),v.copy(g).normalize(),S.push(v.x,v.y,v.z),B.push(L+z,w),P.push(p++)}m.push(P)}for(let C=0;C<a;C++)for(let P=0;P<n;P++){const w=m[C][P+1],z=m[C][P],R=m[C+1][P],L=m[C+1][P+1];(C!==0||l>0)&&x.push(w,z,L),(C!==a-1||f<Math.PI)&&x.push(z,R,L)}this.setAttribute({name:"position",type:"vec3f",bufferFormat:"float32x3",size:3,array:new Float32Array(b)}),this.setAttribute({name:"uv",type:"vec2f",bufferFormat:"float32x2",size:2,array:new Float32Array(B)}),this.setAttribute({name:"normal",type:"vec3f",bufferFormat:"float32x3",size:3,array:new Float32Array(S)}),this.setIndexBuffer({array:this.useUint16IndexArray?new Uint16Array(x):new Uint32Array(x),bufferFormat:this.useUint16IndexArray?"uint16":"uint32"})}}class Be extends Xi{static{u(this,"LitMesh")}constructor(e,t={}){e=Ae(e,"LitMesh");const{material:s,...i}=t;let{colorSpace:n}=s;n||(n="srgb");const{shading:a,additionalVaryings:o,vertexChunks:h,fragmentChunks:l,toneMapping:d,color:c,opacity:f,alphaCutoff:p,metallic:m,roughness:g,normalScale:v,occlusionIntensity:x,emissiveIntensity:b,emissiveColor:S,specularIntensity:B,specularColor:C,shininess:P,transmission:w,ior:z,dispersion:R,thickness:L,attenuationDistance:U,attenuationColor:K,baseColorTexture:G,normalTexture:Q,emissiveTexture:ee,occlusionTexture:k,metallicRoughnessTexture:W,specularTexture:X,specularFactorTexture:te,specularColorTexture:he,transmissionTexture:Ie,thicknessTexture:bs,environmentMap:ke}=s,Ir=Be.getMaterialUniform({shading:a,colorSpace:n,color:c,opacity:f,alphaCutoff:p,metallic:m,roughness:g,normalScale:v,occlusionIntensity:x,emissiveIntensity:b,emissiveColor:S,specularIntensity:B,specularColor:C,shininess:P,transmission:w,ior:z,dispersion:R,thickness:L,attenuationDistance:U,attenuationColor:K,environmentMap:ke});i.uniforms?i.uniforms={...i.uniforms,material:Ir}:i.uniforms={material:Ir},i.textures||(i.textures=[]),i.samplers||(i.samplers=[]),Be.getMaterialTexturesDescriptors({shading:a,baseColorTexture:G,normalTexture:Q,emissiveTexture:ee,occlusionTexture:k,metallicRoughnessTexture:W,specularTexture:X,specularFactorTexture:te,specularColorTexture:he,transmissionTexture:Ie,thicknessTexture:bs}).forEach(Bi=>{Bi.sampler&&(i.samplers.find(Fl=>Fl.uuid===Bi.sampler.uuid)||i.samplers.push(Bi.sampler)),i.textures.push(Bi.texture)});const Co=ke&&(a==="PBR"||!a);Co&&(i.textures||(i.textures=[]),i.textures=[...i.textures,ke.lutTexture,ke.diffuseTexture,ke.specularTexture],i.samplers||(i.samplers=[]),i.samplers=[...i.samplers,ke.sampler]);let Mo=null;t.transmissive&&(e.createTransmissionTarget(),Mo={texture:e.transmissionTarget.texture,sampler:e.transmissionTarget.sampler});const Bo=[];R&&Bo.push("KHR_materials_dispersion");const Al=i.geometry&&i.geometry.getAttributeByName("normal");i.geometry&&!Al&&i.geometry.computeGeometry();const Dl=Be.getVertexShaderCode({bindings:i.bindings,geometry:i.geometry,chunks:h,additionalVaryings:o}),$l=Be.getFragmentShaderCode({shadingModel:a,chunks:l,extensionsUsed:Bo,receiveShadows:i.receiveShadows,toneMapping:d,geometry:i.geometry,additionalVaryings:o,materialUniform:Ir,baseColorTexture:G,normalTexture:Q,metallicRoughnessTexture:W,specularTexture:X,specularFactorTexture:te,specularColorTexture:he,transmissionTexture:Ie,thicknessTexture:bs,emissiveTexture:ee,occlusionTexture:k,transmissionBackgroundTexture:Mo,environmentMap:ke}),Gl={vertex:{code:Dl,entryPoint:"main"},fragment:{code:$l,entryPoint:"main"}};super(e,{...i,shaders:Gl}),Co&&ke.onRotationAxisChanged(()=>{this.uniforms.material.envRotation.value=ke.rotationMatrix})}static getMaterialUniform(e){const{shading:t,colorSpace:s,color:i,opacity:n,alphaCutoff:a,metallic:o,roughness:h,normalScale:l,occlusionIntensity:d,emissiveIntensity:c,emissiveColor:f,specularIntensity:p,specularColor:m,shininess:g,transmission:v,ior:x,dispersion:b,thickness:S,attenuationDistance:B,attenuationColor:C,environmentMap:P}=e,w={color:{type:"vec3f",value:i!==void 0?s==="srgb"?mt(i.clone()):i.clone():new y(1)},opacity:{type:"f32",value:n!==void 0?n:1},alphaCutoff:{type:"f32",value:a!==void 0?a:.5}},z={...w,normalScale:{type:"vec2f",value:l!==void 0?l:new _(1)},occlusionIntensity:{type:"f32",value:d!==void 0?d:1},emissiveIntensity:{type:"f32",value:c!==void 0?c:1},emissiveColor:{type:"vec3f",value:f!==void 0?s==="srgb"?mt(f.clone()):f.clone():new y}},R={...z,specularIntensity:{type:"f32",value:p!==void 0?p:1},specularColor:{type:"vec3f",value:m!==void 0?s==="srgb"?mt(m.clone()):m.clone():new y(1)}},L={...R,shininess:{type:"f32",value:g!==void 0?g:30}},U={...R,metallic:{type:"f32",value:o!==void 0?o:1},roughness:{type:"f32",value:h!==void 0?h:1},transmission:{type:"f32",value:v!==void 0?v:0},ior:{type:"f32",value:x!==void 0?x:1.5},dispersion:{type:"f32",value:b!==void 0?b:0},thickness:{type:"f32",value:S!==void 0?S:0},attenuationDistance:{type:"f32",value:B!==void 0?B:1/0},attenuationColor:{type:"vec3f",value:C!==void 0?s==="srgb"?mt(C.clone()):C.clone():new y(1)},...P&&{envRotation:{type:"mat3x3f",value:P.rotationMatrix},envDiffuseIntensity:{type:"f32",value:P.options.diffuseIntensity},envSpecularIntensity:{type:"f32",value:P.options.specularIntensity}}},K=(()=>{switch(t){case"Unlit":return w;case"Lambert":return z;case"Phong":return L;case"PBR":default:return U}})();return{visibility:["fragment"],struct:K}}static getMaterialTexturesDescriptors(e){const{shading:t,baseColorTexture:s,normalTexture:i,emissiveTexture:n,occlusionTexture:a,metallicRoughnessTexture:o,specularTexture:h,specularFactorTexture:l,specularColorTexture:d,transmissionTexture:c,thicknessTexture:f}=e,p=[s],m=[...p,i,n,a],g=[...m,o,h,l,d],v=[...g,c,f];return(()=>{switch(t){case"Unlit":return p;case"Lambert":return m;case"Phong":return g;case"PBR":default:return v}})().filter(Boolean)}static getVertexShaderCode(e){return Sa(e)}static getFragmentShaderCode(e){return La(e)}}class Ml extends tr{static{u(this,"PingPongPlane")}constructor(e,t={}){e=$(e,t.label?t.label+" PingPongPlane":"PingPongPlane");const s=t.targets&&t.targets.length&&t.targets.map(i=>({targetFormat:i.format}));t.outputTarget=new Ii(e,{label:t.label?t.label+" render target":"Ping Pong render target",useDepth:!1,...s&&{colorAttachments:s}}),t.transparent=!1,t.depth=!1,t.label=t.label??"PingPongPlane "+e.pingPongPlanes?.length,super(e,t),this.type="PingPongPlane",this.createTexture({label:t.label?`${t.label} render texture`:"PingPongPlane render texture",name:"renderTexture",...t.targets&&t.targets.length&&{format:t.targets[0].format},usage:["copyDst","textureBinding"]})}get renderTexture(){return this.textures.find(e=>e.options.name==="renderTexture")}addToScene(e=!1){e&&this.renderer.pingPongPlanes.push(this),this.autoRender&&this.renderer.scene.addPingPongPlane(this)}removeFromScene(e=!1){this.outputTarget&&this.outputTarget.destroy(),this.autoRender&&this.renderer.scene.removePingPongPlane(this),e&&(this.renderer.pingPongPlanes=this.renderer.pingPongPlanes.filter(t=>t.uuid!==this.uuid))}}var po=u(r=>{throw TypeError(r)},"__typeError$2"),_r=u((r,e,t)=>e.has(r)||po("Cannot "+t),"__accessCheck$2"),E=u((r,e,t)=>(_r(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet$2"),ge=u((r,e,t)=>e.has(r)?po("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$2"),be=u((r,e,t,s)=>(_r(r,e,"write to private field"),e.set(r,t),t),"__privateSet$2"),Bl=u((r,e,t)=>(_r(r,e,"access private method"),t),"__privateMethod$2"),Se,Oe,Rt,Et,Te,Pe,us,ds,cs,ps,fs,ms,Lr,fo;class Sl{static{u(this,"Raycaster")}constructor(e){ge(this,Lr),ge(this,Se),ge(this,Oe),ge(this,Rt),ge(this,Et),ge(this,Te),ge(this,Pe),ge(this,us),ge(this,ds),ge(this,cs),ge(this,ps),ge(this,fs),ge(this,ms),this.type="Raycaster",this.setRenderer(e),this.pointer=new _(1/0),this.ray={origin:new y,direction:new y},be(this,Se,{origin:this.ray.origin.clone(),direction:this.ray.direction.clone()}),be(this,Oe,new y),be(this,Rt,new y),be(this,Et,new y),be(this,Te,new y),be(this,Pe,new y),be(this,us,new _),be(this,ds,new _),be(this,cs,new _),be(this,ps,new y),be(this,fs,new y),be(this,ms,new y)}setRenderer(e){e=Ae(e,this.type),this.renderer=e,this.camera=this.renderer.camera}setFromMouse(e){const{clientX:t,clientY:s}=e.targetTouches&&e.targetTouches.length?e.targetTouches[0]:e;this.setFromNDCCoords((t-this.renderer.boundingRect.left)/this.renderer.boundingRect.width*2-1,-((s-this.renderer.boundingRect.top)/this.renderer.boundingRect.height)*2+1)}setFromNDCCoords(e=0,t=0){this.pointer.set(e,t),this.setRay()}setRay(){this.camera.worldMatrix.getTranslation(this.ray.origin),this.ray.direction.set(this.pointer.x,this.pointer.y,-1).unproject(this.camera).sub(this.ray.origin).normalize()}rayIntersectsTriangle(e){const s=new y,i=new y;s.crossVectors(E(this,Se).direction,E(this,Pe));const n=E(this,Te).dot(s);if(Math.abs(n)<1e-6)return!1;const a=1/n,o=E(this,Se).origin.clone().sub(E(this,Oe)),h=a*o.dot(s);if(h<0||h>1)return!1;i.crossVectors(o,E(this,Te));const l=a*E(this,Se).direction.dot(i);if(l<0||h+l>1)return!1;const d=a*E(this,Pe).dot(i);return d>1e-6?(e.copy(E(this,Se).origin).add(E(this,Se).direction.clone().multiplyScalar(d)),!0):!1}getBarycentricCoordinates(e){const t=e.clone().sub(E(this,Oe)),s=E(this,Te).dot(E(this,Te)),i=E(this,Te).dot(E(this,Pe)),n=E(this,Pe).dot(E(this,Pe)),a=t.dot(E(this,Te)),o=t.dot(E(this,Pe)),h=s*n-i*i,l=new y(0,(n*a-i*o)/h,(s*o-i*a)/h);return l.x=1-l.y-l.z,l}getTriangleNormal(){return new y().crossVectors(E(this,Te),E(this,Pe)).normalize()}setAttributeVectorAtIndex(e,t,s,i,n){const a=s?s[e*3+t]:e*3+t;n.x=i.array[a*i.size],n.y=i.array[a*i.size+1],"z"in n&&(n.z=i.array[a*i.size+2])}intersectObject(e,t=!0,s=[]){if(!(e instanceof Me))return this.renderer.production||A(`${this.type}: object to test intersection again is not of type Object3D`),s;const i=Po(e);return i&&Bl(this,Lr,fo).call(this,i,s),t&&e.children.forEach(n=>{this.intersectObject(n,t,s)}),s.length&&s.sort((n,a)=>this.ray.origin.distance(n.point)-this.ray.origin.distance(a.point)),s}intersectObjects(e,t=!0,s=[]){return e.forEach(i=>{this.intersectObject(i,t,s)}),s.length&&s.sort((i,n)=>this.ray.origin.distance(i.point)-this.ray.origin.distance(n.point)),s}}Se=new WeakMap,Oe=new WeakMap,Rt=new WeakMap,Et=new WeakMap,Te=new WeakMap,Pe=new WeakMap,us=new WeakMap,ds=new WeakMap,cs=new WeakMap,ps=new WeakMap,fs=new WeakMap,ms=new WeakMap,Lr=new WeakSet,fo=u(function(r,e=[]){if(!r.geometry)return e;const t=r.geometry.getAttributeByName("position");if(!t)return this.renderer.production||A(`Raycaster: can't raycast on a mesh that has no position attribute: ${r.options.label}`),e;if(!t.array)return this.renderer.production||A(`Raycaster: can't raycast on a mesh that has no position attribute array: ${r.options.label}`),e;if(r.frustumCulling&&r.domFrustum){const{clipSpaceBoundingRect:h}=r.domFrustum;if(r.domFrustum.isIntersecting){if(this.pointer.x>h.left+h.width||this.pointer.x<h.left||this.pointer.y>h.top||this.pointer.y<h.top-h.height)return e}else return e}const s=r.worldMatrix.getInverse();E(this,Se).origin.copy(this.ray.origin).applyMat4(s),E(this,Se).direction.copy(this.ray.direction).transformDirection(s);const i=r.geometry.getAttributeByName("uv"),n=r.geometry.getAttributeByName("normal"),a=r.geometry.indexBuffer?.array,o=a?a.length/3:t.array.length/9;for(let h=0;h<o;h++){if(this.setAttributeVectorAtIndex(h,0,a,t,E(this,Oe)),this.setAttributeVectorAtIndex(h,1,a,t,E(this,Rt)),this.setAttributeVectorAtIndex(h,2,a,t,E(this,Et)),E(this,Te).copy(E(this,Rt)).sub(E(this,Oe)),E(this,Pe).copy(E(this,Et)).sub(E(this,Oe)),r.material.options.rendering.cullMode!=="none"){const f=this.getTriangleNormal().dot(E(this,Se).direction);if(f>0&&r.material.options.rendering.cullMode==="back")continue;if(f<0&&r.material.options.rendering.cullMode==="front")continue}const l=new y;if(this.rayIntersectsTriangle(l)){const c=this.getBarycentricCoordinates(l),f=l.clone().applyMat4(r.worldMatrix),p=this.ray.origin.distance(f),m={object:r,distance:p,localPoint:l,point:f,triangle:[E(this,Oe).clone(),E(this,Rt).clone(),E(this,Et).clone()],triangleIndex:h};i&&i.array&&i.array.length&&(this.setAttributeVectorAtIndex(h,0,a,i,E(this,us)),this.setAttributeVectorAtIndex(h,1,a,i,E(this,ds)),this.setAttributeVectorAtIndex(h,2,a,i,E(this,cs)),m.uv=E(this,us).clone().multiplyScalar(c.x).add(E(this,ds).clone().multiplyScalar(c.y)).add(E(this,cs).clone().multiplyScalar(c.z))),n&&n.array&&n.array.length&&(this.setAttributeVectorAtIndex(h,0,a,n,E(this,ps)),this.setAttributeVectorAtIndex(h,1,a,n,E(this,fs)),this.setAttributeVectorAtIndex(h,2,a,n,E(this,ms)),m.normal=E(this,ps).clone().multiplyScalar(c.x).add(E(this,fs).clone().multiplyScalar(c.y)).add(E(this,ms).clone().multiplyScalar(c.z))),e.push(m)}}return e},"intersectMesh_fn");const gs=new y,zt=new ue;class Ar{static{u(this,"KeyframesAnimation")}constructor({label:e="",inputIndex:t=null,keyframes:s=null,values:i=null,path:n=null,interpolation:a="LINEAR"}={}){this.label=e,this.keyframes=s,this.values=i,this.path=n,this.interpolation=a,this.inputIndex=t,this.weightsBindingInputs=[],this.onAfterUpdate=null,this.duration=this.keyframes?this.keyframes[this.keyframes.length-1]:0}addWeightBindingInput(e){this.weightsBindingInputs.push(e)}getCubicSplineComponentValue(e,t,s,i,n){const a=e*e,o=a*e;return(2*o-3*a+1)*t+(o-2*a+e)*i+(-2*o+3*a)*s+(o-a)*n}getIndexFromInterpolation(e=0,t=1){return this.interpolation==="CUBICSPLINE"?e*3*t+t:e*t}update(e,t=0){if(!this.keyframes||!this.values||!this.path)return;const s=this.keyframes.findIndex(l=>l>=t);if(s===-1)return;const i=s-1;if(i===-1)return;const n=this.keyframes[s],a=this.keyframes[i],o=(t-a)/(n-a),h=n-a;if(this.path==="rotation"){const l=this.getIndexFromInterpolation(i,4),d=this.getIndexFromInterpolation(s,4);if(e.quaternion.setFromArray([this.values[l],this.values[l+1],this.values[l+2],this.values[l+3]]),this.interpolation==="LINEAR"||this.interpolation==="CUBICSPLINE")if(zt.setFromArray([this.values[d],this.values[d+1],this.values[d+2],this.values[d+3]]),this.interpolation==="CUBICSPLINE"){const c=[this.values[l+4],this.values[l+5],this.values[l+6],this.values[l+7]],f=[this.values[d-4],this.values[d-3],this.values[d-2],this.values[d-1]],p=[this.getCubicSplineComponentValue(o,e.quaternion.elements[0],zt.elements[0],h*c[0],h*f[0]),this.getCubicSplineComponentValue(o,e.quaternion.elements[1],zt.elements[1],h*c[1],h*f[1]),this.getCubicSplineComponentValue(o,e.quaternion.elements[2],zt.elements[2],h*c[2],h*f[2]),this.getCubicSplineComponentValue(o,e.quaternion.elements[3],zt.elements[3],h*c[3],h*f[3])];e.quaternion.setFromArray(p).normalize()}else e.quaternion.slerp(zt,o);e.shouldUpdateModelMatrix()}else if(this.path==="translation"||this.path==="scale"){const l=this.path==="translation"?"position":this.path,d=this.getIndexFromInterpolation(i,3),c=this.getIndexFromInterpolation(s,3);if(e[l].set(this.values[d],this.values[d+1],this.values[d+2]),this.interpolation==="LINEAR"||this.interpolation==="CUBICSPLINE")if(gs.set(this.values[c],this.values[c+1],this.values[c+2]),this.interpolation==="CUBICSPLINE"){const f=[this.values[d+3],this.values[d+4],this.values[d+5]],p=[this.values[c-3],this.values[c-2],this.values[c-1]],m=[this.getCubicSplineComponentValue(o,e[l].x,gs.x,h*f[0],h*p[0]),this.getCubicSplineComponentValue(o,e[l].y,gs.y,h*f[1],h*p[1]),this.getCubicSplineComponentValue(o,e[l].z,gs.z,h*f[2],h*p[2])];e[l].set(m[0],m[1],m[2])}else e[l].lerp(gs,o)}else if(this.path==="weights"){const l=this.getIndexFromInterpolation(i,this.weightsBindingInputs.length),d=this.getIndexFromInterpolation(s,this.weightsBindingInputs.length);for(let c=0;c<this.weightsBindingInputs.length;c++){const f=this.values[l+c];if(this.weightsBindingInputs[c].value=f,this.interpolation==="LINEAR"){const p=this.values[d+c];this.weightsBindingInputs[c].value+=(p-f)*o}else if(this.interpolation==="CUBICSPLINE"){const p=this.values[d+c],m=this.values[l+c+1],g=this.values[d+c-1];this.weightsBindingInputs[c].value=this.getCubicSplineComponentValue(o,f,p,h*m[0],h*g[0])}}}}}var mo=u(r=>{throw TypeError(r)},"__typeError$1"),Dr=u((r,e,t)=>e.has(r)||mo("Cannot "+t),"__accessCheck$1"),Ue=u((r,e,t)=>(Dr(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet$1"),_t=u((r,e,t)=>e.has(r)?mo("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd$1"),ne=u((r,e,t,s)=>(Dr(r,e,"write to private field"),e.set(r,t),t),"__privateSet$1"),go=u((r,e,t)=>(Dr(r,e,"access private method"),t),"__privateMethod$1"),Le,ys,Lt,Ke,At,Ci,$r;class yo{static{u(this,"TargetsAnimationsManager")}constructor(e,{label:t="",targets:s=[]}={}){_t(this,Ci),_t(this,Le),_t(this,ys),_t(this,Lt),_t(this,Ke),_t(this,At),this.uuid=O(),this.inputIndices=[],this.setRenderer(e),this.label=t,this.targets=[],this.duration=0,this.timeScale=1,ne(this,Le,performance.now()),ne(this,ys,performance.now()),ne(this,Lt,0),ne(this,Ke,0),ne(this,Ke,0),ne(this,At,1/0),this.isPlaying=!1,this.siblings=new Map,s&&s.length&&(this.targets=[...this.targets,...s])}setRenderer(e){this.renderer&&(this.renderer.animations.delete(this.uuid),this.renderer.animations.forEach(t=>t.siblings.delete(this.uuid))),e&&(e=$(e,"TargetsAnimationsManager"),this.renderer=e,this.renderer.animations.set(this.uuid,this),this.inputIndices.length&&go(this,Ci,$r).call(this))}addTarget(e){const t={object:e,animations:[]};return this.targets.push(t),t}addTargets(e){e.forEach(t=>this.addTarget(t))}addTargetAnimation(e,t){this.duration=Math.max(this.duration,t.duration);let s=this.getTargetByObject3D(e);s||(s=this.addTarget(e)),s.animations.push(t),t.inputIndex!==null&&!this.inputIndices.includes(t.inputIndex)&&this.inputIndices.push(t.inputIndex),go(this,Ci,$r).call(this)}getTargetByObject3D(e){return this.targets.find(t=>t.object.object3DIndex===e.object3DIndex)}getAnimationByObject3DAndPath(e,t){const s=this.getTargetByObject3D(e);return s?s.animations.find(i=>i.path===t):null}play(){this.isPlaying=!0}playOnce(){ne(this,At,1),this.play()}pause(){this.isPlaying=!1,ne(this,Le,-1)}stop(){this.isPlaying=!1,ne(this,Ke,0),this.siblings.size||ne(this,Le,0),this.targets.forEach(e=>e.animations.forEach(t=>t.update(e.object,Math.min(t.duration,this.duration)))),this.renderer.onAfterRenderScene.add(()=>{this.targets.forEach(e=>{e.animations.forEach(t=>{t.onAfterUpdate&&t.onAfterUpdate()})})},{once:!0})}stopAtEndOfLoop(){ne(this,At,Ue(this,Ke)+1)}update(){if(!this.isPlaying)return;Ue(this,Le)===-1?ne(this,Le,performance.now()-Ue(this,Lt)):Ue(this,Le)===0&&ne(this,Le,performance.now()),ne(this,ys,performance.now()),ne(this,Lt,Ue(this,ys)-Ue(this,Le));const e=Ue(this,Lt)*this.timeScale/1e3,t=e%this.duration;if(ne(this,Ke,Math.floor(e/this.duration)),Ue(this,Ke)>=Ue(this,At)){this.stop();return}this.targets.forEach(s=>s.animations.forEach(i=>i.update(s.object,t)))}onAfterUpdate(){this.isPlaying&&this.targets.forEach(e=>e.animations.forEach(t=>{t.onAfterUpdate&&t.onAfterUpdate()}))}}Le=new WeakMap,ys=new WeakMap,Lt=new WeakMap,Ke=new WeakMap,At=new WeakMap,Ci=new WeakSet,$r=u(function(){this.siblings=new Map,this.renderer.animations.forEach(r=>{r.uuid!==this.uuid&&JSON.stringify(r.inputIndices)===JSON.stringify(this.inputIndices)?(this.siblings.set(r.uuid,r),r.siblings.set(this.uuid,this)):r.siblings.delete(this.uuid)})},"setSiblings_fn");var xo=u(r=>{throw TypeError(r)},"__typeError"),Gr=u((r,e,t)=>e.has(r)||xo("Cannot "+t),"__accessCheck"),Fr=u((r,e,t)=>(Gr(r,e,"read from private field"),t?t.call(r):e.get(r)),"__privateGet"),vo=u((r,e,t)=>e.has(r)?xo("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,t),"__privateAdd"),bo=u((r,e,t,s)=>(Gr(r,e,"write to private field"),e.set(r,t),t),"__privateSet"),xs=u((r,e,t)=>(Gr(r,e,"access private method"),t),"__privateMethod"),dt,ct,Mi,Or;const H=WebGLRenderingContext,we=class ye{static{u(this,"_GLTFScenesManager")}constructor({renderer:e,gltf:t}){vo(this,ct),vo(this,dt),e=Ae(e,"GLTFScenesManager"),this.renderer=e,this.gltf=t,bo(this,dt,new Map),this.scenesManager={node:new Me,nodes:new Map,boundingBox:new Ee,samplers:[],materialsTextures:[],materialsParams:[],scenes:[],meshes:[],meshesDescriptors:[],animations:[],cameras:[],skins:[],lights:[]},this.createSamplers(),this.createMaterialTextures(),this.createMaterialsParams(),this.createLights(),this.createAnimations(),this.createScenes()}static getVertexAttributeParamsFromType(e){switch(e){case"VEC2":return{type:"vec2f",bufferFormat:"float32x2",size:2};case"VEC3":return{type:"vec3f",bufferFormat:"float32x3",size:3};case"VEC4":return{type:"vec4f",bufferFormat:"float32x4",size:4};case"MAT2":return{type:"mat2x2f",bufferFormat:"float32x2",size:6};case"MAT3":return{type:"mat3x3f",bufferFormat:"float32x3",size:9};case"MAT4":return{type:"mat4x4f",bufferFormat:"float32x4",size:16};case"SCALAR":default:return{type:"f32",bufferFormat:"float32",size:1}}}static getTypedArrayConstructorFromComponentType(e){switch(e){case H.BYTE:return Int8Array;case H.UNSIGNED_BYTE:return Uint8Array;case H.SHORT:return Int16Array;case H.UNSIGNED_SHORT:return Uint16Array;case H.UNSIGNED_INT:return Uint32Array;case H.FLOAT:default:return Float32Array}}static gpuPrimitiveTopologyForMode(e){switch(e){case H.TRIANGLES:return"triangle-list";case H.TRIANGLE_STRIP:return"triangle-strip";case H.LINES:return"line-list";case H.LINE_STRIP:return"line-strip";case H.POINTS:return"point-list"}}static gpuAddressModeForWrap(e){switch(e){case H.CLAMP_TO_EDGE:return"clamp-to-edge";case H.MIRRORED_REPEAT:return"mirror-repeat";default:return"repeat"}}createAnimations(){this.gltf.animations?.forEach((e,t)=>{this.scenesManager.animations.push(new yo(this.renderer,{label:e.name??"Animation "+t}))})}createLights(){if(this.gltf.extensions&&this.gltf.extensions.KHR_lights_punctual)for(const e of this.gltf.extensions.KHR_lights_punctual.lights)if(e.type==="spot"){const t=e.spot.innerConeAngle!==void 0?e.spot.innerConeAngle:0,s=e.spot.outerConeAngle!==void 0?e.spot.outerConeAngle:Math.PI/4;this.scenesManager.lights.push(new er(this.renderer,{...e.name!==void 0&&{label:e.name},color:e.color!==void 0?new y(e.color[0],e.color[1],e.color[2]):new y(1),intensity:e.intensity!==void 0?e.intensity:1,range:e.range!==void 0?e.range:0,angle:s,penumbra:1-t/s}))}else e.type==="directional"?this.scenesManager.lights.push(new Qi(this.renderer,{...e.name!==void 0&&{label:e.name},color:e.color!==void 0?new y(e.color[0],e.color[1],e.color[2]):new y(1),intensity:e.intensity!==void 0?e.intensity:1})):e.type==="point"&&this.scenesManager.lights.push(new jn(this.renderer,{...e.name!==void 0&&{label:e.name},color:e.color!==void 0?new y(e.color[0],e.color[1],e.color[2]):new y(1),intensity:e.intensity!==void 0?e.intensity:1,range:e.range!==void 0?e.range:0}))}createSamplers(){if(this.gltf.samplers)for(const[e,t]of Object.entries(this.gltf.samplers)){const s={label:"glTF sampler "+e,name:"gltfSampler"+e,addressModeU:ye.gpuAddressModeForWrap(t.wrapS),addressModeV:ye.gpuAddressModeForWrap(t.wrapT)};switch((!t.magFilter||t.magFilter===H.LINEAR)&&(s.magFilter="linear"),t.minFilter){case H.NEAREST:break;case H.LINEAR:case H.LINEAR_MIPMAP_NEAREST:s.minFilter="linear";break;case H.NEAREST_MIPMAP_LINEAR:s.mipmapFilter="linear";break;case H.LINEAR_MIPMAP_LINEAR:default:s.minFilter="linear",s.mipmapFilter="linear";break}this.scenesManager.samplers.push(new et(this.renderer,s))}else this.scenesManager.samplers.push(new et(this.renderer,{label:"Default sampler",name:"defaultSampler",magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"}))}createTexture(e,t,s,i=!1){const n=(()=>{switch(s){case"baseColorTexture":case"emissiveTexture":case"specularTexture":case"specularColorTexture":return"rgba8unorm-srgb";case"occlusionTexture":case"transmissionTexture":return"r8unorm";case"thicknessTexture":return"rg8unorm";default:return"rgba8unorm"}})(),a=new ce(this.renderer,{label:e.name?e.name+": "+s:s,name:s,format:n,visibility:["fragment"],generateMips:!0,fixedSize:{width:t.width,height:t.height},useTransform:i});return a.useImageBitmap(t),a}createMaterialTextures(){this.scenesManager.materialsTextures=[];const e=[];if(this.gltf.materials)for(const[t,s]of Object.entries(this.gltf.materials)){const i={material:t,texturesDescriptors:[]},n=u(c=>c.texCoord&&c.texCoord!==0?"uv"+c.texCoord:"uv","getUVAttributeName"),a=u((c,f)=>{const p=c.index,m=this.gltf.textures[p],g=m.extensions&&m.extensions.EXT_texture_webp?m.extensions.EXT_texture_webp.source:m.source,v=this.gltf.textures.find(w=>(w.extensions&&w.extensions.EXT_texture_webp?w.extensions.EXT_texture_webp.source:w.source)===p)?.sampler,x=this.scenesManager.samplers[v??0],b=c.extensions&&c.extensions.KHR_texture_transform,S=n(b&&b.texCoord!==void 0?b:c),B=e.find(w=>w.index===p);if(B){const w=new ce(this.renderer,{label:s.name?s.name+": "+f:f,name:f,visibility:["fragment"],generateMips:!0,fromTexture:B.texture,...b&&{useTransform:!0}});if(b){const{offset:z,rotation:R,scale:L}=b;z!==void 0&&w.offset.set(z[0],z[1]),R!==void 0&&(w.rotation=R),L!==void 0&&w.scale.set(L[0],L[1])}i.texturesDescriptors.push({texture:w,sampler:x,texCoordAttributeName:S});return}const C=this.gltf.imagesBitmaps[g],P=this.createTexture(s,C,f,!!b);if(b){const{offset:w,rotation:z,scale:R}=b;w!==void 0&&P.offset.set(w[0],w[1]),z!==void 0&&(P.rotation=z),R!==void 0&&P.scale.set(R[0],R[1])}i.texturesDescriptors.push({texture:P,sampler:x,texCoordAttributeName:S}),e.push({index:p,texture:P})},"createTexture");this.scenesManager.materialsTextures[t]=i,s.pbrMetallicRoughness&&(s.pbrMetallicRoughness.baseColorTexture&&s.pbrMetallicRoughness.baseColorTexture.index!==void 0&&a(s.pbrMetallicRoughness.baseColorTexture,"baseColorTexture"),s.pbrMetallicRoughness.metallicRoughnessTexture&&s.pbrMetallicRoughness.metallicRoughnessTexture.index!==void 0&&a(s.pbrMetallicRoughness.metallicRoughnessTexture,"metallicRoughnessTexture")),s.normalTexture&&s.normalTexture.index!==void 0&&a(s.normalTexture,"normalTexture"),s.occlusionTexture&&s.occlusionTexture.index!==void 0&&a(s.occlusionTexture,"occlusionTexture"),s.emissiveTexture&&s.emissiveTexture.index!==void 0&&a(s.emissiveTexture,"emissiveTexture");const{extensions:o}=s,h=o&&o.KHR_materials_transmission||null,l=o&&o.KHR_materials_specular||null,d=o&&o.KHR_materials_volume||null;if(h&&h.transmissionTexture&&h.transmissionTexture.index!==void 0&&a(h.transmissionTexture,"transmissionTexture"),l&&(l.specularTexture||l.specularColorTexture)){const{specularTexture:c,specularColorTexture:f}=l;c&&f&&(c.index!==void 0&&f.index!==void 0&&c.index===f.index?a(l.specularTexture,"specularTexture"):(c&&c.index!==void 0&&a(l.specularTexture,"specularFactorTexture"),f&&f.index!==void 0&&a(l.specularColorTexture,"specularColorTexture")))}d&&d.thicknessTexture&&d.thicknessTexture.index!==void 0&&a(d.thicknessTexture,"thicknessTexture")}}getMaterialBaseParameters(e,t=null){const s={},i=this.gltf.materials&&this.gltf.materials[e]||{};t?s.label=t+(i.name?" "+i.name:""):i.name&&(s.label=i.name);const{extensions:n}=i,a=n&&n.KHR_materials_dispersion||null,o=n&&n.KHR_materials_emissive_strength||null,h=n&&n.KHR_materials_ior||null,l=n&&n.KHR_materials_transmission||null,d=n&&n.KHR_materials_specular||null,c=n&&n.KHR_materials_volume||null,f={colorSpace:"linear",color:i.pbrMetallicRoughness&&i.pbrMetallicRoughness.baseColorFactor!==void 0?new y(i.pbrMetallicRoughness.baseColorFactor[0],i.pbrMetallicRoughness.baseColorFactor[1],i.pbrMetallicRoughness.baseColorFactor[2]):new y(1),opacity:i.pbrMetallicRoughness&&i.pbrMetallicRoughness.baseColorFactor!==void 0?i.pbrMetallicRoughness.baseColorFactor[3]:1,alphaCutoff:i.alphaCutoff!==void 0?i.alphaCutoff:i.alphaMode==="MASK"?.5:0,metallic:i.pbrMetallicRoughness?.metallicFactor===void 0?1:i.pbrMetallicRoughness.metallicFactor,roughness:i.pbrMetallicRoughness?.roughnessFactor===void 0?1:i.pbrMetallicRoughness.roughnessFactor,normalScale:i.normalTexture?.scale===void 0?new _(1):new _(i.normalTexture.scale),occlusionIntensity:i.occlusionTexture?.strength===void 0?1:i.occlusionTexture.strength,emissiveIntensity:o&&o.emissiveStrength!==void 0?o.emissiveStrength:1,emissiveColor:i.emissiveFactor!==void 0?new y(i.emissiveFactor[0],i.emissiveFactor[1],i.emissiveFactor[2]):new y(0),specularIntensity:d&&d.specularFactor!==void 0?d.specularFactor:1,specularColor:d&&d.specularColorFactor!==void 0?new y(d.specularColorFactor[0],d.specularColorFactor[1],d.specularColorFactor[2]):new y(1),transmission:l&&l.transmissionFactor!==void 0?l.transmissionFactor:0,ior:h&&h.ior!==void 0?h.ior:1.5,dispersion:a&&a.dispersion!==void 0?a.dispersion:0,thickness:c&&c.thicknessFactor!==void 0?c.thicknessFactor:0,attenuationDistance:c&&c.attenuationDistance!==void 0?c.attenuationDistance:1/0,attenuationColor:c&&c.attenuationColor!==void 0?new y(c.attenuationColor[0],c.attenuationColor[1],c.attenuationColor[2]):new y(1)};return s.material=f,s.cullMode=i.doubleSided?"none":"back",i.alphaMode==="BLEND"&&(s.transparent=!0,s.targets=[{blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one"}}}]),s}createMaterialsParams(){this.gltf.materials?.forEach((e,t)=>{this.scenesManager.materialsParams.push(this.getMaterialBaseParameters(t))})}createNode(e,t,s){const i={index:s,name:t.name,node:new Me,children:[]};this.scenesManager.nodes.set(s,i.node),e.children.push(i),i.node.parent=e.node,t.matrix?(i.node.modelMatrix.setFromArray(new Float32Array(t.matrix)),i.node.matrices.model.shouldUpdate=!1):(t.translation&&i.node.position.set(t.translation[0],t.translation[1],t.translation[2]),t.scale&&i.node.scale.set(t.scale[0],t.scale[1],t.scale[2]),t.rotation&&i.node.quaternion.setFromArray(new Float32Array(t.rotation))),t.children&&t.children.forEach(a=>{const o=this.gltf.nodes[a];this.createNode(i,o,a)});let n=null;if(t.mesh!==void 0){let a=null;if(t.extensions&&t.extensions.EXT_mesh_gpu_instancing){const{attributes:h}=t.extensions.EXT_mesh_gpu_instancing;a={count:0,nodesTransformations:{}};for(const l of Object.entries(h)){const d=this.gltf.accessors[l[1]],c=this.gltf.bufferViews[d.bufferView],f=ye.getTypedArrayConstructorFromComponentType(d.componentType),p=ye.getVertexAttributeParamsFromType(d.type).size,m=new f(this.gltf.arrayBuffers[c.buffer],d.byteOffset+c.byteOffset,d.count*p);a.count=d.count,a.nodesTransformations[l[0].toLowerCase()]=m}}const o=this.gltf.meshes[t.mesh];o.primitives.forEach((h,l)=>{const d={parent:i.node,texturesDescriptors:[],variantName:"Default",parameters:{label:o.name?o.name+" "+l:"glTF mesh "+l},nodes:[],extensionsUsed:[],alternateDescriptors:new Map,alternateMaterials:new Map};if(n=Fr(this,dt).get(h),n||(n={instances:[],nodes:[],meshDescriptor:d},Fr(this,dt).set(h,n)),n.instances.push(t),n.nodes.push(i.node),a&&a.count)for(let c=0;c<a.count;c++){const f=new Me;if(a.nodesTransformations){const{translation:p,scale:m,rotation:g}=a.nodesTransformations;p&&f.position.set(p[c*3],p[c*3+1],p[c*3+2]),m&&f.scale.set(m[c*3],m[c*3+1],m[c*3+2]),g&&f.quaternion.setFromArray(Float32Array.from([g[c*4],g[c*4+1],g[c*4+2],g[c*4+3]]))}f.parent=i.node,n.instances.push(t),n.nodes.push(f)}})}if(t.extensions&&t.extensions.KHR_lights_punctual){const a=this.scenesManager.lights[t.extensions.KHR_lights_punctual.light];a.position.set(0,0,0),(a instanceof Qi||a instanceof er)&&a.target.set(0,0,-1),a.parent=i.node}if(t.camera!==void 0){const a=this.gltf.cameras[t.camera];if(a.type==="perspective"){const o=Math.min(this.renderer.boundingRect.width,this.renderer.boundingRect.height),h=o/a.perspective.aspectRatio,l=o*a.perspective.aspectRatio,d=a.perspective.yfov*180/Math.PI,c=new ks({fov:d,near:a.perspective.znear,far:a.perspective.zfar,width:h,height:l,pixelRatio:this.renderer.pixelRatio});c.parent=i.node,this.scenesManager.cameras.push(c)}else a.type==="orthographic"&&A("GLTFScenesManager: Orthographic cameras are not supported yet.")}this.gltf.animations&&this.scenesManager.animations.forEach((a,o)=>{const h=this.gltf.animations[o],l=h.channels.filter(d=>d.target.node===s);l&&l.length&&(a.addTarget(i.node),l.forEach(d=>{const c=h.samplers[d.sampler],f=d.target.path,p=this.gltf.accessors[c.input],m=this.gltf.bufferViews[p.bufferView],g=ye.getTypedArrayConstructorFromComponentType(p.componentType),v=this.gltf.accessors[c.output],x=this.gltf.bufferViews[v.bufferView],b=ye.getTypedArrayConstructorFromComponentType(v.componentType),S=new g(this.gltf.arrayBuffers[m.buffer],p.byteOffset+m.byteOffset,p.count*ye.getVertexAttributeParamsFromType(p.type).size),B=new b(this.gltf.arrayBuffers[x.buffer],v.byteOffset+x.byteOffset,v.count*ye.getVertexAttributeParamsFromType(v.type).size),C=t.name?`${t.name} animation`:`${d.target.path} animation ${s}`,P=new Ar({label:h.name?`${h.name} ${C}`:`Animation ${o} ${C}`,inputIndex:c.input,keyframes:S,values:B,path:f,interpolation:c.interpolation});a.addTargetAnimation(i.node,P)}))})}static getCleanAttributeName(e){return e==="TEXCOORD_0"?"uv":e.replace("_","").replace("TEXCOORD","uv").toLowerCase()}sortAttributesByNames(e,t){t.sort((s,i)=>{let n=e.findIndex(o=>o===s.name);n=n===-1?1/0:n;let a=e.findIndex(o=>o===i.name);return a=a===-1?1/0:a,n-a})}createGeometry(e,t){const{instances:s,meshDescriptor:i}=t,n=new Ee;for(const[m,g]of Object.entries(e.attributes))if(m==="POSITION"){const v=this.gltf.accessors[g];n&&(n.min.min(new y(v.min[0],v.min[1],v.min[2])),n.max.max(new y(v.max[0],v.max[1],v.max[2])))}let a=[],o=xs(this,ct,Or).call(this,e.attributes,a);const h="indices"in e;let l=null,d=null;if(h){const m=this.gltf.accessors[e.indices],g=this.gltf.bufferViews[m.bufferView];d=ye.getTypedArrayConstructorFromComponentType(m.componentType);const v=d.name==="Uint8Array"?Uint16Array.BYTES_PER_ELEMENT:d.BYTES_PER_ELEMENT,x=m.byteOffset+g.byteOffset,b=this.gltf.arrayBuffers[g.buffer],S=Math.ceil(m.count/v)*v;l=d.name==="Uint8Array"?Uint16Array.from(new d(b,x,S)):new d(b,x,S)}const c=a.find(m=>m.name==="normal");c||(a=a.filter(m=>m.name!=="tangent"),o=null),o||this.sortAttributesByNames(["position","uv","normal"],a);const f={instancesCount:s.length,topology:ye.gpuPrimitiveTopologyForMode(e.mode),vertexBuffers:[{name:"attributes",stepMode:"vertex",attributes:a,...o&&{array:o}}]},p=h?Nt:Oi;i.parameters.geometry=new p(f),h&&d&&l&&i.parameters.geometry.setIndexBuffer({bufferFormat:d.name==="Uint32Array"?"uint32":"uint16",array:l}),c||i.parameters.geometry.computeGeometry(),i.parameters.geometry.boundingBox=n}createSkins(){this.gltf.skins&&this.gltf.skins.forEach((e,t)=>{const i=this.gltf.nodes.find(c=>c.skin!==void 0&&c.mesh!==void 0&&c.skin===t).mesh;let n;if(e.inverseBindMatrices){const c=this.gltf.accessors[e.inverseBindMatrices],f=this.gltf.bufferViews[c.bufferView],p=ye.getTypedArrayConstructorFromComponentType(c.componentType);n=new p(this.gltf.arrayBuffers[f.buffer],c.byteOffset+f.byteOffset,c.count*ye.getVertexAttributeParamsFromType(c.type).size)}else{n=new Float32Array(16*e.joints.length);for(let c=0;c<e.joints.length*16;c+=16)n[c]=1,n[c+5]=1,n[c+10]=1,n[c+15]=1}const a=new Y({label:"Skin "+t,name:"skin"+t,bindingType:"storage",visibility:["vertex"],childrenBindings:[{binding:new Y({label:"Joints "+t,name:"joints",bindingType:"storage",visibility:["vertex"],struct:{jointMatrix:{type:"mat4x4f",value:new Float32Array(16)},normalMatrix:{type:"mat4x4f",value:new Float32Array(16)}}}),count:e.joints.length,forceArray:!0}]});for(let c=0;c<e.joints.length;c++){for(let f=0;f<16;f++)a.childrenBindings[c].inputs.jointMatrix.value[f]=n[c*16+f],a.childrenBindings[c].inputs.normalMatrix.value[f]=n[c*16+f];a.childrenBindings[c].inputs.jointMatrix.shouldUpdate=!0,a.childrenBindings[c].inputs.normalMatrix.shouldUpdate=!0}const o=e.joints.map(c=>this.scenesManager.nodes.get(c)),h=new D,l=new D,d=this.gltf.nodes.findIndex(c=>c.mesh!==void 0&&c.skin!==void 0&&c.mesh===i);if(d!==-1){const c=this.scenesManager.nodes.get(d),f=new D,p=c.updateWorldMatrix.bind(c);if(c.updateWorldMatrix=()=>{p(),f.copy(c.worldMatrix).invert()},this.scenesManager.animations.length)for(const m of this.scenesManager.animations)o.forEach((g,v)=>{const x=u(()=>{m.isPlaying?h.setFromArray(n,v*16).premultiply(g.worldMatrix).premultiply(f):h.identity(),l.copy(h).invert().transpose();for(let C=0;C<16;C++)a.childrenBindings[v].inputs.jointMatrix.value[C]=h.elements[C],a.childrenBindings[v].inputs.normalMatrix.value[C]=l.elements[C];a.childrenBindings[v].inputs.jointMatrix.shouldUpdate=!0,a.childrenBindings[v].inputs.normalMatrix.shouldUpdate=!0},"updateJointMatrix"),b=this.gltf.nodes[v],S=b.name?`${b.name} skin animation`:`skin animation ${v}`,B=new Ar({label:m.label?`${m.label} ${S}`:`Animation ${S}`});B.onAfterUpdate=x,m.addTargetAnimation(g,B)});else o.forEach((m,g)=>{h.setFromArray(n,g*16).premultiply(m.worldMatrix).premultiply(f),l.copy(h).invert().transpose();for(let v=0;v<16;v++)a.childrenBindings[g].inputs.jointMatrix.value[v]=h.elements[v],a.childrenBindings[g].inputs.normalMatrix.value[v]=l.elements[v];a.childrenBindings[g].inputs.jointMatrix.shouldUpdate=!0,a.childrenBindings[g].inputs.normalMatrix.shouldUpdate=!0});this.scenesManager.skins.push({parentNode:c,joints:o,inverseBindMatrices:n,jointMatrix:h,normalMatrix:l,parentInverseWorldMatrix:f,binding:a})}})}createMaterial(e,t){const{instances:s,nodes:i,meshDescriptor:n}=t,a=s.length,o=s[0].mesh;if(e.targets){const x=[],b=this.gltf.meshes[o].weights;let S;for(const B of this.scenesManager.animations)if(S=B.getAnimationByObject3DAndPath(n.parent,"weights"),S)break;e.targets.forEach((B,C)=>{const P=[];xs(this,ct,Or).call(this,B,P);const w=P.reduce((R,L)=>R={...R,[L.name]:{type:`array<${L.type}>`,value:L.array}},{weight:{type:"f32",value:b&&b.length?b[C]:0}}),z=new Y({label:"Morph target "+C,name:"morphTarget"+C,bindingType:"storage",visibility:["vertex"],struct:w});S&&S.addWeightBindingInput(z.inputs.weight),x.push(z)}),n.parameters.bindings||(n.parameters.bindings=[]),n.parameters.bindings=[...n.parameters.bindings,...x]}this.gltf.skins&&this.gltf.skins.forEach((x,b)=>{n.parameters.bindings||(n.parameters.bindings=[]),s.forEach((S,B)=>{if(S.skin!==void 0&&S.skin===b){const C=this.scenesManager.skins[b];if(n.parameters.bindings=[...n.parameters.bindings,C.binding],B>0){const P=n.parameters.geometry.boundingBox.clone(),w=new D;C.joints.forEach((z,R)=>{w.setFromArray(C.inverseBindMatrices,R*16);const L=P.applyMat4(w).applyMat4(z.worldMatrix);this.scenesManager.boundingBox.min.min(L.min),this.scenesManager.boundingBox.max.max(L.max)})}}})});const h=this.scenesManager.materialsParams[e.material],l=this.scenesManager.materialsTextures[e.material];n.texturesDescriptors=l?.texturesDescriptors||[],n.parameters={...n.parameters,...h};const d=this.gltf.materials&&this.gltf.materials[e.material]||{},{extensions:c}=d;if(c)for(const x of Object.keys(c))x==="KHR_materials_unlit"&&this.gltf.extensionsRequired&&this.gltf.extensionsRequired.includes(x),n.extensionsUsed.push(x);const f=c&&c.KHR_materials_dispersion||null,p=c&&c.KHR_materials_transmission||null,m=c&&c.KHR_materials_volume||null,g=p||m||f,v=this.gltf.extensionsUsed&&(this.gltf.extensionsUsed.includes("KHR_materials_transmission")||this.gltf.extensionsUsed.includes("KHR_materials_volume")||this.gltf.extensionsUsed.includes("KHR_materials_dispersion"));if(v&&g&&(n.parameters.transmissive=!0),v&&g&&(this.renderer.createTransmissionTarget(),n.texturesDescriptors.push({texture:this.renderer.transmissionTarget.texture,sampler:this.renderer.transmissionTarget.sampler})),n.parameters.material={...n.parameters.material,...n.texturesDescriptors.reduce((x,b)=>({...x,[b.texture.options.name]:b}),{})},a>1){const x=new Y({label:"Instance matrices",name:"matrices",visibility:["vertex","fragment"],bindingType:"storage",struct:{model:{type:"mat4x4f",value:new D},normal:{type:"mat3x3f",value:new de}}}),b=new Y({label:"Instances",name:"instances",visibility:["vertex","fragment"],bindingType:"storage",childrenBindings:[{binding:x,count:a,forceArray:!0}]});b.childrenBindings.forEach((S,B)=>{const C=i[B],P=u(()=>{S.inputs.model.value.copy(C.worldMatrix),S.inputs.normal.value.getNormalMatrix(C.worldMatrix),S.inputs.model.shouldUpdate=!0,S.inputs.normal.shouldUpdate=!0},"updateInstanceMatrices"),w=C.updateWorldMatrix.bind(C);C.updateWorldMatrix=()=>{w(),P()},P()}),n.parameters.bindings||(n.parameters.bindings=[]),n.parameters.bindings.push(b)}for(let x=0;x<i.length;x++){const S=n.parameters.geometry.boundingBox.clone().applyMat4(n.nodes[x].worldMatrix);this.scenesManager.boundingBox.min.min(S.min),this.scenesManager.boundingBox.max.max(S.max)}this.scenesManager.boundingBox.max.max(new y(.001)),e.extensions&&e.extensions.KHR_materials_variants&&this.gltf.extensionsUsed&&this.gltf.extensionsUsed.includes("KHR_materials_variants")&&(n.extensionsUsed.push("KHR_materials_variants"),this.gltf.extensions.KHR_materials_variants.variants.forEach((x,b)=>{const S=e.extensions.KHR_materials_variants.mappings.find(B=>B.variants&&B.variants.includes(b));if(S){const B=this.gltf.materials[S.material],C=this.scenesManager.materialsParams[S.material],w=this.scenesManager.materialsTextures[S.material]?.texturesDescriptors||[];v&&g&&w.push({texture:this.renderer.transmissionTarget.texture,sampler:this.renderer.transmissionTarget.sampler});const{extensions:z}=B,R=[];if(z)for(const U of Object.keys(z))U==="KHR_materials_unlit"&&this.gltf.extensionsRequired&&this.gltf.extensionsRequired.includes(U),R.push(U);const L={variantName:x.name,parent:n.parent,nodes:n.nodes,extensionsUsed:[...n.extensionsUsed,...R],texturesDescriptors:w,parameters:{geometry:n.parameters.geometry,label:x.name+" "+C.label,transmissive:!!n.parameters.transmissive,bindings:n.parameters.bindings??[],transparent:!!C.transparent,cullMode:C.cullMode,material:{...C.material,...w.reduce((U,K)=>({...U,[K.texture.options.name]:K}),{})},...C.targets&&{targets:C.targets}}};n.alternateDescriptors.set(x.name,L)}}))}createScenes(){this.scenesManager.node.parent=this.renderer.scene,this.gltf.scenes.forEach(e=>{const t={name:e.name,children:[],node:new Me};t.node.parent=this.scenesManager.node,this.scenesManager.scenes.push(t),e.nodes.forEach(s=>{const i=this.gltf.nodes[s];this.createNode(t,i,s)})}),this.scenesManager.node.updateMatrixStack(),this.createSkins();for(const[e,t]of Fr(this,dt)){const{nodes:s,meshDescriptor:i}=t;i.nodes=s,this.scenesManager.meshesDescriptors.push(i),this.createGeometry(e,t),this.createMaterial(e,t)}}addMeshes(e=t=>{}){return this.scenesManager.node.updateMatrixStack(),this.scenesManager.meshesDescriptors.map(t=>{const{geometry:s}=t.parameters;if(s){e(t),t.extensionsUsed.includes("KHR_materials_unlit")&&(t.parameters.material.shading="Unlit");const i=new Be(this.renderer,{...t.parameters});return t.alternateMaterials.set("Default",i.material),t.alternateDescriptors.forEach(n=>{const{material:a}=t.parameters,{environmentMap:o,shading:h,vertexChunks:l,additionalVaryings:d,fragmentChunks:c,toneMapping:f}=a,{label:p,targets:m,transparent:g,material:v}=n.parameters;v.shading=h,n.extensionsUsed.includes("KHR_materials_unlit")&&(v.shading="Unlit");let{uniforms:x,samplers:b,textures:S,bindings:B}=n.parameters;S||(S=[]),b||(b=[]);const C=Be.getMaterialTexturesDescriptors(v);C.forEach(G=>{G.sampler&&(b.find(ee=>ee.uuid===G.sampler.uuid)||b.push(G.sampler)),S.push(G.texture)}),o&&(v.shading==="PBR"||!v.shading)&&(v.environmentMap=o,S=[...S,o.lutTexture,o.diffuseTexture,o.specularTexture],b=[...b,o.sampler]),x||(x={});const P=Be.getMaterialUniform(v);x={...x,material:P},t.parameters.uniforms&&(x={...t.parameters.uniforms,...x}),B||(B=[]),B=[i.material.getBufferBindingByName("matrices"),...B],t.parameters.bindings&&t.parameters.bindings.forEach(G=>{B.find(ee=>ee.name===G.name)||B.push(G)});let z=null;t.parameters.transmissive&&(this.renderer.createTransmissionTarget(),z={texture:this.renderer.transmissionTarget.texture,sampler:this.renderer.transmissionTarget.sampler},S=[...S,this.renderer.transmissionTarget.texture],b=[...b,this.renderer.transmissionTarget.sampler]),t.parameters.storages&&(n.parameters.storages=t.parameters.storages),t.parameters.bindGroups&&(n.parameters.bindGroups=t.parameters.bindGroups);const R=Be.getVertexShaderCode({bindings:B,geometry:s,chunks:l,additionalVaryings:d}),L=Be.getFragmentShaderCode({shadingModel:h,chunks:c,extensionsUsed:n.extensionsUsed,receiveShadows:t.parameters.receiveShadows,toneMapping:f,geometry:s,additionalVaryings:d,materialUniform:P,...C.reduce((G,Q)=>({...G,[Q.texture.options.name]:Q}),{}),transmissionBackgroundTexture:z,...o&&{environmentMap:o}}),U={vertex:{code:R,entryPoint:"main"},fragment:{code:L,entryPoint:"main"}},K=new qi(this.renderer,{...JSON.parse(JSON.stringify(i.material.options.rendering)),label:p,shaders:U,uniforms:x,bindings:B,...b&&{samplers:b},...S&&{textures:S},...m&&{targets:m},transparent:!!g,verticesOrder:s.verticesOrder,topology:s.topology});t.alternateMaterials.set(n.variantName,K)}),i.parent=t.parent,this.scenesManager.meshes.push(i),i}})}destroy(){this.scenesManager.lights.filter(Boolean).forEach(e=>e.remove()),this.scenesManager.meshes.forEach(e=>e.remove()),this.scenesManager.meshes=[],this.scenesManager.meshesDescriptors.forEach(e=>{e.alternateMaterials.forEach(t=>t.destroy())}),this.scenesManager.nodes.forEach(e=>{e.destroy()}),this.scenesManager.nodes=new Map,this.scenesManager.scenes.forEach(e=>{e.node.destroy()}),this.scenesManager.animations.forEach(e=>e.setRenderer(null)),this.scenesManager.node.destroy(),bo(this,dt,new Map)}};dt=new WeakMap,ct=new WeakSet,Mi=u(function(r){if(!r.sparse)return{indices:null,values:null};const e=we.getTypedArrayConstructorFromComponentType(r.componentType),t=we.getVertexAttributeParamsFromType(r.type).size,s=we.getTypedArrayConstructorFromComponentType(r.sparse.indices.componentType),i=this.gltf.bufferViews[r.sparse.indices.bufferView],n=new s(this.gltf.arrayBuffers[i.buffer],r.byteOffset+i.byteOffset,r.sparse.count),a=this.gltf.bufferViews[r.sparse.values.bufferView],o=new e(this.gltf.arrayBuffers[a.buffer],r.byteOffset+a.byteOffset,r.sparse.count*t);return{indices:n,values:o}},"getSparseAccessorIndicesAndValues_fn"),Or=u(function(r,e){let t=null,s=null,i=0;const n=Object.entries(r);n.sort((o,h)=>o[1]-h[1]);const a=Object.values(r);a.sort((o,h)=>o-h);for(const[o,h]of n){const l=we.getCleanAttributeName(o),d=this.gltf.accessors[h],c=d.componentType?we.getTypedArrayConstructorFromComponentType(d.componentType):Float32Array,f=this.gltf.bufferViews[d.bufferView],p=f.byteStride,m=d.byteOffset;p!==void 0&&m!==void 0&&m<p?i=Math.max(m,i):i=0,l==="position"&&(s=f);const v=we.getVertexAttributeParamsFromType(d.type),{size:x}=v;let b;if(i>0){const B=new c(this.gltf.arrayBuffers[f.buffer],0,f.byteLength/c.BYTES_PER_ELEMENT);b=new c(d.count*x);const C=m/c.BYTES_PER_ELEMENT;for(let P=0;P<d.count;P++)for(let w=0;w<x;w++)b[P*x+w]=B[C+x*P+x*P+w]}else if(f.byteStride&&f.byteStride>c.BYTES_PER_ELEMENT*x){const B=new DataView(this.gltf.arrayBuffers[f.buffer],f.byteOffset+d.byteOffset);b=new c(d.count*x);for(let C=0;C<d.count;C++){const P=C*f.byteStride;for(let w=0;w<x;w++)b[C*x+w]=B.getUint16(P+w*c.BYTES_PER_ELEMENT,!0)}}else b=new c(this.gltf.arrayBuffers[f.buffer],d.byteOffset+f.byteOffset,d.count*x);if(d.sparse){const{indices:B,values:C}=xs(this,ct,Mi).call(this,d);for(let P=0;P<B.length;P++)for(let w=0;w<x;w++)b[B[P]*x+w]=C[P*x+w]}if(l.includes("weights"))for(let B=0;B<d.count*x;B+=x){const C=b[B],P=b[B+1],w=b[B+2],z=b[B+3];let R=Math.abs(C)+Math.abs(P)+Math.abs(w)+Math.abs(z);R>0?R=1/Math.sqrt(R):R=1,b[B]*=R,b[B+1]*=R,b[B+2]*=R,b[B+3]*=R}const S={name:l,...v,array:b};e.push(S)}if(i>0){const o=a.map(h=>this.gltf.accessors[h].bufferView);if(o.every(h=>h===o[0])){t=new Float32Array(this.gltf.arrayBuffers[s.buffer],s.byteOffset,Math.ceil(s.byteLength/4)*4/Float32Array.BYTES_PER_ELEMENT);let h=0;a.forEach(c=>{const f=this.gltf.accessors[c],p=we.getVertexAttributeParamsFromType(f.type).size,{indices:m,values:g}=xs(this,ct,Mi).call(this,f);if(m&&g)for(let v=0;v<m.length;v++)for(let x=0;x<p;x++){const b=h+p*v;t[b+m[v]*p+x]=g[v*p+x]}h+=p});const d=Object.entries(r).sort((c,f)=>{const p=this.gltf.accessors[c[1]].byteOffset,m=this.gltf.accessors[f[1]].byteOffset;return p-m}).map(c=>we.getCleanAttributeName(c[0]));this.sortAttributesByNames(d,e)}else{let h=0;const l={},d=a.reduce((f,p)=>{const m=this.gltf.accessors[p],g=we.getVertexAttributeParamsFromType(m.type).size;return l[m.bufferView]||(l[m.bufferView]=0),l[m.bufferView]=Math.max(l[m.bufferView],m.byteOffset+g*Float32Array.BYTES_PER_ELEMENT),h+=g*Float32Array.BYTES_PER_ELEMENT,f+m.count*g},0);t=new Float32Array(Math.ceil(d/4)*4),a.forEach(f=>{const p=this.gltf.accessors[f],m=this.gltf.bufferViews[p.bufferView],g=we.getVertexAttributeParamsFromType(p.type).size,{indices:v,values:x}=xs(this,ct,Mi).call(this,p);for(let b=0;b<p.count;b++){const S=p.byteOffset/Float32Array.BYTES_PER_ELEMENT+b*h/Float32Array.BYTES_PER_ELEMENT,B=new Float32Array(this.gltf.arrayBuffers[m.buffer],m.byteOffset+p.byteOffset+b*l[p.bufferView],g);if(v&&x&&v.includes(b))for(let C=0;b<g;C++)B[C]=x[b*g+C];t.subarray(S,S+g).set(B)}});const c=Object.entries(r).map(f=>we.getCleanAttributeName(f[0]));this.sortAttributesByNames(c,e)}}return t},"parsePrimitiveProperty_fn");let Tl=we;const wo=WebGLRenderingContext,Pl=1179937895,Ur={JSON:1313821514,BIN:5130562},Rl=[0,0,0],El=[0,0,0,1],zl=[1,1,1],_l=typeof window<"u"&&new RegExp(`^${window.location.protocol}`,"i")||RegExp("^(http|https):","i"),Ll=/^data:/;class vs{static{u(this,"GLTFLoader")}constructor(){this.gltf=null}static resolveUri(e,t){return e.match(_l)||e.match(Ll)?e:t+e}async loadFromUrl(e){const t=e.lastIndexOf("/"),s=t!==0?e.substring(0,t+1):"",i=await fetch(e);if(e.endsWith(".gltf"))return this.loadFromJson(await i.json(),s);if(e.endsWith(".glb"))return this.loadFromBinary(await i.arrayBuffer(),s);throw new Error("Unrecognized file extension")}async loadFromJsonBase(e,t,s=null){if(!t)throw new Error("baseUrl must be specified.");if(!e.asset)throw new Error("Missing asset description.");if(e.asset.minVersion!=="2.0"&&e.asset.version!=="2.0")throw new Error("Incompatible asset version.");for(const a of e.accessors)a.byteOffset=a.byteOffset??0,a.normalized=a.normalized??!1;for(const a of e.bufferViews)a.byteOffset=a.byteOffset??0;for(const a of e.nodes)a.matrix||(a.rotation=a.rotation??El,a.scale=a.scale??zl,a.translation=a.translation??Rl);if(e.samplers)for(const a of e.samplers)a.wrapS=a.wrapS??wo.REPEAT,a.wrapT=a.wrapT??wo.REPEAT;const i=[];if(s)i.push(Promise.resolve(s));else for(const a in e.buffers){const o=e.buffers[a],h=vs.resolveUri(o.uri,t);i[a]=fetch(h).then(l=>l.arrayBuffer())}const n=[];for(let a=0;a<e.images?.length;++a){const o=e.images[a];if(o.uri)o.uri.includes(".webp")?n[a]=new Promise((h,l)=>{const d=new Image;d.crossOrigin="anonymous",d.onload=()=>{createImageBitmap(d,{colorSpaceConversion:"none"}).then(h).catch(l)},d.onerror=l,d.src=vs.resolveUri(o.uri,t)}):n[a]=fetch(vs.resolveUri(o.uri,t)).then(async h=>createImageBitmap(await h.blob(),{colorSpaceConversion:"none"}));else{const h=e.bufferViews[o.bufferView];n[a]=i[h.buffer].then(l=>{const d=new Blob([new Uint8Array(l,h.byteOffset,h.byteLength)],{type:o.mimeType});return o.mimeType==="image/webp"?new Promise((c,f)=>{const p=new Image;p.crossOrigin="anonymous",p.src=URL.createObjectURL(d),p.onload=()=>{createImageBitmap(p,{colorSpaceConversion:"none"}).then(m=>{URL.revokeObjectURL(p.src),c(m)}).catch(f)},p.onerror=m=>{URL.revokeObjectURL(p.src),f(m)}}):createImageBitmap(d,{colorSpaceConversion:"none"})})}}return{...e,arrayBuffers:await Promise.all(i),imagesBitmaps:await Promise.all(n)}}async loadFromBinary(e,t){const s=new DataView(e,0,12),i=s.getUint32(0,!0),n=s.getUint32(4,!0),a=s.getUint32(8,!0);if(i!==Pl)throw new Error("Invalid magic string in binary header.");if(n!==2)throw new Error("Incompatible version in binary header.");const o={};let h=12;for(;h<a;){const c=new DataView(e,h,8),f=c.getUint32(0,!0),p=c.getUint32(4,!0);o[p]=e.slice(h+8,h+8+f),h+=f+8}if(!o[Ur.JSON])throw new Error("File contained no json chunk.");const d=new TextDecoder("utf-8").decode(o[Ur.JSON]);return this.loadFromJson(JSON.parse(d),t,o[Ur.BIN])}async loadFromJson(e,t,s=null){return this.gltf=await this.loadFromJsonBase(e,t,s),this.gltf}}M.AmbientLight=eh,M.BindGroup=Gt,M.Binding=Ms,M.Box3=Ee,M.BoxGeometry=wl,M.Buffer=Je,M.BufferBinding=Y,M.Camera=ks,M.ComputeMaterial=ln,M.ComputePass=Vs,M.ComputePipelineEntry=sr,M.DOMElement=ir,M.DOMFrustum=fn,M.DOMMesh=Ga,M.DOMObject3D=$a,M.DOMTexture=$i,M.DirectionalLight=Qi,M.EnvironmentMap=bl,M.FullscreenPlane=tr,M.GLTFLoader=vs,M.GLTFScenesManager=Tl,M.GPUCameraRenderer=ur,M.GPUCurtains=pl,M.GPUCurtainsRenderer=vi,M.GPUDeviceManager=na,M.GPURenderer=ar,M.Geometry=Oi,M.HDRLoader=oo,M.IndexedGeometry=Nt,M.IndirectBuffer=ha,M.KeyframesAnimation=Ar,M.LitMesh=Be,M.Mat3=de,M.Mat4=D,M.Material=Fi,M.MediaTexture=ce,M.Mesh=Xi,M.Object3D=Me,M.OrbitControls=fl,M.PingPongPlane=Ml,M.PipelineEntry=Vi,M.PipelineManager=Xn,M.Plane=Fa,M.PlaneGeometry=Ui,M.PointLight=jn,M.ProjectedObject3D=ki,M.Quat=ue,M.Raycaster=Sl,M.RenderBundle=jh,M.RenderMaterial=qi,M.RenderPass=Xs,M.RenderPipelineEntry=gt,M.RenderTarget=Ii,M.Sampler=et,M.SamplerBinding=an,M.Scene=Yn,M.ShaderPass=Hh,M.SphereGeometry=Cl,M.SpotLight=er,M.TargetsAnimationsManager=yo,M.Texture=q,M.TextureBindGroup=Gi,M.TextureBinding=_i,M.Vec2=_,M.Vec3=y,M.WritableBufferBinding=zi,M.common=ot,M.constants=$e,M.getFragmentShaderCode=La,M.getLambert=Xh,M.getLambertFragmentShaderCode=Pa,M.getPBR=el,M.getPBRFragmentShaderCode=_a,M.getPhong=Yh,M.getPhongFragmentShaderCode=za,M.getUnlitFragmentShaderCode=Ta,M.getVertexShaderCode=Sa,M.lambertUtils=pi,M.linearTosRGB=Qo,M.linearTosRGBFloat=Ws,M.sRGBToLinear=mt,M.sRGBToLinearFloat=Ns,M.toneMappingUtils=wt});
//# sourceMappingURL=gpu-curtains.umd.min.js.map
