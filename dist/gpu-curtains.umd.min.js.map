{"version":3,"file":"gpu-curtains.umd.min.js","sources":["../src/utils/utils.ts","../src/core/renderers/utils.ts","../src/utils/webgpu-constants.ts","../src/core/bindings/utils.ts","../src/core/bindings/Binding.ts","../src/math/Vec2.ts","../src/math/Quat.ts","../src/math/Vec3.ts","../src/core/bindings/bufferElements/BufferElement.ts","../src/core/bindings/bufferElements/BufferArrayElement.ts","../src/core/bindings/bufferElements/BufferInterleavedArrayElement.ts","../src/core/buffers/utils.ts","../src/core/buffers/Buffer.ts","../src/core/bindings/BufferBinding.ts","../src/core/bindings/WritableBufferBinding.ts","../src/core/bindGroups/BindGroup.ts","../src/core/bindings/TextureBinding.ts","../src/math/Mat4.ts","../src/core/objects3D/Object3D.ts","../src/core/textures/utils.ts","../src/core/textures/DOMTexture.ts","../src/core/bindGroups/TextureBindGroup.ts","../src/core/bindings/SamplerBinding.ts","../src/core/camera/Camera.ts","../src/core/samplers/Sampler.ts","../src/core/textures/Texture.ts","../src/core/materials/Material.ts","../src/core/materials/ComputeMaterial.ts","../src/core/computePasses/ComputePass.ts","../src/math/Box3.ts","../src/core/DOM/DOMFrustum.ts","../src/core/geometries/Geometry.ts","../src/core/geometries/IndexedGeometry.ts","../src/core/geometries/PlaneGeometry.ts","../src/core/lights/Light.ts","../src/core/lights/AmbientLight.ts","../src/core/renderPasses/RenderPass.ts","../src/core/renderPasses/RenderTarget.ts","../src/core/pipelines/PipelineEntry.ts","../src/core/shaders/chunks/helpers/get_output_position.wgsl.js","../src/core/shaders/chunks/helpers/get_normals.wgsl.js","../src/core/shaders/chunks/helpers/get_uv_cover.wgsl.js","../src/core/shaders/chunks/helpers/get_vertex_to_uv_coords.wgsl.js","../src/core/shaders/ShaderChunks.ts","../src/core/pipelines/RenderPipelineEntry.ts","../src/core/materials/utils.ts","../src/core/shaders/chunks/default/default_projected_vs.wgsl.js","../src/core/shaders/chunks/default/default_vs.wgsl.js","../src/core/shaders/chunks/default/default_fs.wgsl.js","../src/core/materials/RenderMaterial.ts","../src/core/shaders/chunks/shading/shadows.ts","../src/core/shadows/Shadow.ts","../src/core/shadows/DirectionalShadow.ts","../src/core/lights/DirectionalLight.ts","../src/core/shadows/PointShadow.ts","../src/core/lights/PointLight.ts","../src/core/meshes/mixins/MeshBaseMixin.ts","../src/utils/CacheManager.ts","../src/core/meshes/FullscreenPlane.ts","../src/math/Mat3.ts","../src/core/objects3D/ProjectedObject3D.ts","../src/core/shaders/chunks/default/default_normal_fs.wgsl.js","../src/core/bindings/BufferBindingOffsetChild.ts","../src/core/meshes/mixins/ProjectedMeshBaseMixin.ts","../src/core/meshes/Mesh.ts","../src/core/pipelines/ComputePipelineEntry.ts","../src/core/pipelines/PipelineManager.ts","../src/utils/ResizeManager.ts","../src/core/DOM/DOMElement.ts","../src/core/scenes/Scene.ts","../src/utils/TasksQueueManager.ts","../src/core/renderers/GPURenderer.ts","../src/core/renderers/GPUCameraRenderer.ts","../src/core/renderers/GPUDeviceManager.ts","../src/core/renderPasses/RenderBundle.ts","../src/core/shaders/chunks/default/default_pass_fs.wgsl.js","../src/core/renderPasses/ShaderPass.ts","../src/core/shaders/chunks/helpers/common.wgsl.js","../src/core/shaders/chunks/helpers/lights/light_utils.wgsl.js","../src/core/shaders/chunks/shading/tone-mapping-utils.ts","../src/core/shaders/chunks/helpers/lights/RE_indirect_diffuse.wgsl.js","../src/core/shaders/chunks/helpers/constants.wgsl.js","../src/core/shaders/chunks/shading/lambert-shading.ts","../src/core/shaders/chunks/shading/phong-shading.ts","../src/core/shaders/chunks/helpers/lights/RE_indirect_specular.wgsl.js","../src/core/shaders/chunks/shading/pbr-shading.ts","../src/core/shaders/chunks/shading/ibl-shading.ts","../src/curtains/objects3D/DOMObject3D.ts","../src/curtains/meshes/DOMMesh.ts","../src/curtains/meshes/Plane.ts","../src/curtains/renderers/GPUCurtainsRenderer.ts","../src/utils/ScrollManager.ts","../src/curtains/GPUCurtains.ts","../src/extras/controls/OrbitControls.ts","../src/extras/geometries/BoxGeometry.ts","../src/extras/geometries/SphereGeometry.ts","../src/extras/meshes/PingPongPlane.ts","../src/extras/raycaster/Raycaster.ts","../src/extras/gltf/GLTFScenesManager.ts","../src/extras/gltf/utils.ts","../src/extras/loaders/GLTFLoader.ts","../src/extras/loaders/HDRLoader.ts","../src/utils/debug.ts"],"sourcesContent":["/**\r\n * Generate a unique universal id\r\n * @returns - unique universal id generated\r\n */\r\nexport const generateUUID = (): string => {\r\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n    const r = (Math.random() * 16) | 0,\r\n      v = c === 'x' ? r : (r & 0x3) | 0x8\r\n    return v.toString(16).toUpperCase()\r\n  })\r\n}\r\n\r\n/**\r\n * Turns a string into a camel case string\r\n * @param string - string to transform\r\n * @returns - camel case string created\r\n */\r\nexport const toCamelCase = (string: string): string => {\r\n  return string\r\n    .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (ltr, idx) => (idx === 0 ? ltr.toLowerCase() : ltr.toUpperCase()))\r\n    .replace(/\\s+/g, '')\r\n}\r\n\r\n/**\r\n * Turns a string into a kebab case string\r\n * @param string - string to transform\r\n * @returns - kebab case string created\r\n */\r\nexport const toKebabCase = (string: string): string => {\r\n  const camelCase = toCamelCase(string)\r\n  return camelCase.charAt(0).toUpperCase() + camelCase.slice(1)\r\n}\r\n\r\nlet warningThrown = 0\r\n\r\n/**\r\n * Throw a console warning with the passed arguments\r\n * @param warning - warning to be thrown\r\n */\r\nexport const throwWarning = (warning: string) => {\r\n  if (warningThrown > 100) {\r\n    return\r\n  } else if (warningThrown === 100) {\r\n    console.warn('GPUCurtains: too many warnings thrown, stop logging.')\r\n  } else {\r\n    console.warn(warning)\r\n  }\r\n\r\n  warningThrown++\r\n}\r\n\r\n/**\r\n * Throw a javascript error with the passed arguments\r\n * @param error - error to be thrown\r\n */\r\nexport const throwError = (error: string) => {\r\n  throw new Error(error)\r\n}\r\n","import { throwError } from '../../utils/utils'\r\nimport { GPURenderer, ProjectedMesh } from './GPURenderer'\r\nimport { GPUCameraRenderer } from './GPUCameraRenderer'\r\nimport { GPUCurtainsRenderer } from '../../curtains/renderers/GPUCurtainsRenderer'\r\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\r\n\r\n/**\r\n * A Renderer could be either a {@link GPURenderer}, a {@link GPUCameraRenderer} or a {@link GPUCurtainsRenderer}\r\n * @type {Renderer}\r\n */\r\nexport type Renderer = GPUCurtainsRenderer | GPUCameraRenderer | GPURenderer\r\n/**\r\n * A CameraRenderer could be either a {@link GPUCameraRenderer} or a {@link GPUCurtainsRenderer}\r\n * @type {CameraRenderer}\r\n */\r\nexport type CameraRenderer = GPUCurtainsRenderer | GPUCameraRenderer\r\n\r\n/**\r\n * Format a renderer error based on given renderer, renderer type and object type\r\n * @param renderer - renderer that failed the test\r\n * @param rendererType - expected renderer type\r\n * @param type - object type\r\n */\r\nconst formatRendererError = (renderer: Renderer, rendererType = 'GPURenderer', type: string | null): void => {\r\n  const error = type\r\n    ? `Unable to create ${type} because the ${rendererType} is not defined: ${renderer}`\r\n    : `The ${rendererType} is not defined: ${renderer}`\r\n  throwError(error)\r\n}\r\n\r\n/**\r\n * Check if the given renderer is a {@link Renderer}\r\n * @param renderer - renderer to test\r\n * @param type - object type used to format the error if needed\r\n * @returns - the {@link Renderer} if correctly set\r\n */\r\nexport const isRenderer = (renderer: GPUCurtains | Renderer | undefined, type: string | null): Renderer => {\r\n  renderer = ((renderer && (renderer as GPUCurtains).renderer) || renderer) as Renderer\r\n\r\n  const isRenderer =\r\n    renderer &&\r\n    (renderer.type === 'GPURenderer' ||\r\n      renderer.type === 'GPUCameraRenderer' ||\r\n      renderer.type === 'GPUCurtainsRenderer')\r\n\r\n  if (!isRenderer) {\r\n    formatRendererError(renderer, 'GPURenderer', type)\r\n  }\r\n\r\n  return renderer\r\n}\r\n\r\n/**\r\n * Check if the given renderer is a {@link CameraRenderer}\r\n * @param renderer - renderer to test\r\n * @param type - object type used to format the error if needed\r\n * @returns - the {@link CameraRenderer} if correctly set\r\n */\r\nexport const isCameraRenderer = (\r\n  renderer: GPUCurtains | CameraRenderer | undefined,\r\n  type: string | null\r\n): CameraRenderer => {\r\n  renderer = ((renderer && (renderer as GPUCurtains).renderer) || renderer) as CameraRenderer\r\n\r\n  const isCameraRenderer =\r\n    renderer && (renderer.type === 'GPUCameraRenderer' || renderer.type === 'GPUCurtainsRenderer')\r\n\r\n  if (!isCameraRenderer) {\r\n    formatRendererError(renderer, 'GPUCameraRenderer', type)\r\n  }\r\n\r\n  return renderer\r\n}\r\n\r\n/**\r\n * Check if the given renderer is a {@link GPUCurtainsRenderer}\r\n * @param renderer - renderer to test\r\n * @param type - object type used to format the error if needed\r\n * @returns - the {@link GPUCurtainsRenderer} if correctly set\r\n */\r\nexport const isCurtainsRenderer = (\r\n  renderer: GPUCurtains | GPUCurtainsRenderer | undefined,\r\n  type: string | null\r\n): GPUCurtainsRenderer => {\r\n  renderer = ((renderer && (renderer as GPUCurtains).renderer) || renderer) as GPUCurtainsRenderer\r\n\r\n  const isCurtainsRenderer = renderer && renderer.type === 'GPUCurtainsRenderer'\r\n\r\n  if (!isCurtainsRenderer) {\r\n    formatRendererError(renderer, 'GPUCurtainsRenderer', type)\r\n  }\r\n\r\n  return renderer\r\n}\r\n\r\n/**\r\n * Check if a given object is a {@link ProjectedMesh | projected mesh}.\r\n * @param object - Object to test.\r\n * @returns - Given object as a {@link ProjectedMesh | projected mesh} if the test is successful, `false` otherwise.\r\n */\r\nexport const isProjectedMesh = (object: object): false | ProjectedMesh => {\r\n  return object.constructor.name === 'Mesh' ||\r\n    object.constructor.name === 'DOMMesh' ||\r\n    object.constructor.name === 'Plane'\r\n    ? (object as ProjectedMesh)\r\n    : false\r\n}\r\n\r\n/**\r\n * Helper to generate mips on the GPU\r\n * Taken from https://webgpufundamentals.org/webgpu/lessons/webgpu-importing-textures.html\r\n */\r\nexport const generateMips = (() => {\r\n  let sampler\r\n  let module\r\n  const pipelineByFormat = {}\r\n\r\n  return function generateMips(device: GPUDevice, texture: GPUTexture) {\r\n    if (!module) {\r\n      module = device.createShaderModule({\r\n        label: 'textured quad shaders for mip level generation',\r\n        code: `\r\n            struct VSOutput {\r\n              @builtin(position) position: vec4f,\r\n              @location(0) texcoord: vec2f,\r\n            };\r\n\r\n            @vertex fn vs(\r\n              @builtin(vertex_index) vertexIndex : u32\r\n            ) -> VSOutput {\r\n              let pos = array(\r\n\r\n                vec2f( 0.0,  0.0),  // center\r\n                vec2f( 1.0,  0.0),  // right, center\r\n                vec2f( 0.0,  1.0),  // center, top\r\n\r\n                // 2st triangle\r\n                vec2f( 0.0,  1.0),  // center, top\r\n                vec2f( 1.0,  0.0),  // right, center\r\n                vec2f( 1.0,  1.0),  // right, top\r\n              );\r\n\r\n              var vsOutput: VSOutput;\r\n              let xy = pos[vertexIndex];\r\n              vsOutput.position = vec4f(xy * 2.0 - 1.0, 0.0, 1.0);\r\n              vsOutput.texcoord = vec2f(xy.x, 1.0 - xy.y);\r\n              return vsOutput;\r\n            }\r\n\r\n            @group(0) @binding(0) var ourSampler: sampler;\r\n            @group(0) @binding(1) var ourTexture: texture_2d<f32>;\r\n\r\n            @fragment fn fs(fsInput: VSOutput) -> @location(0) vec4f {\r\n              return textureSample(ourTexture, ourSampler, fsInput.texcoord);\r\n            }\r\n          `,\r\n      })\r\n\r\n      sampler = device.createSampler({\r\n        minFilter: 'linear',\r\n        magFilter: 'linear',\r\n      })\r\n    }\r\n\r\n    if (!pipelineByFormat[texture.format]) {\r\n      pipelineByFormat[texture.format] = device.createRenderPipeline({\r\n        label: 'Mip level generator pipeline',\r\n        layout: 'auto',\r\n        vertex: {\r\n          module,\r\n        },\r\n        fragment: {\r\n          module,\r\n          targets: [{ format: texture.format }],\r\n        },\r\n      })\r\n    }\r\n    const pipeline = pipelineByFormat[texture.format]\r\n\r\n    const encoder = device.createCommandEncoder({\r\n      label: 'Mip gen encoder',\r\n    })\r\n\r\n    let width = texture.width\r\n    let height = texture.height\r\n    let baseMipLevel = 0\r\n    while (width > 1 || height > 1) {\r\n      width = Math.max(1, (width / 2) | 0)\r\n      height = Math.max(1, (height / 2) | 0)\r\n\r\n      for (let layer = 0; layer < texture.depthOrArrayLayers; ++layer) {\r\n        const bindGroup = device.createBindGroup({\r\n          layout: pipeline.getBindGroupLayout(0),\r\n          entries: [\r\n            { binding: 0, resource: sampler },\r\n            {\r\n              binding: 1,\r\n              resource: texture.createView({\r\n                dimension: '2d',\r\n                baseMipLevel,\r\n                mipLevelCount: 1,\r\n                baseArrayLayer: layer,\r\n                arrayLayerCount: 1,\r\n              }),\r\n            },\r\n          ],\r\n        })\r\n\r\n        const renderPassDescriptor = {\r\n          label: 'Mip generation render pass',\r\n          colorAttachments: [\r\n            {\r\n              view: texture.createView({\r\n                dimension: '2d',\r\n                baseMipLevel: baseMipLevel + 1,\r\n                mipLevelCount: 1,\r\n                baseArrayLayer: layer,\r\n                arrayLayerCount: 1,\r\n              }),\r\n              loadOp: 'clear',\r\n              storeOp: 'store',\r\n            },\r\n          ],\r\n        }\r\n\r\n        const pass = encoder.beginRenderPass(renderPassDescriptor as GPURenderPassDescriptor)\r\n        pass.setPipeline(pipeline)\r\n        pass.setBindGroup(0, bindGroup)\r\n        pass.draw(6) // call our vertex shader 6 times\r\n        pass.end()\r\n      }\r\n      ++baseMipLevel\r\n    }\r\n\r\n    const commandBuffer = encoder.finish()\r\n    device.queue.submit([commandBuffer])\r\n  }\r\n})()\r\n","/**\r\n * GPUShaderStage constants with fallbacks.\r\n */\r\nexport const WebGPUShaderStageConstants: Record<string, number> =\r\n  typeof GPUShaderStage !== 'undefined'\r\n    ? GPUShaderStage\r\n    : {\r\n        VERTEX: 1,\r\n        FRAGMENT: 2,\r\n        COMPUTE: 4,\r\n      }\r\n\r\n/**\r\n * GPUBufferUsage constants with fallbacks.\r\n */\r\nexport const WebGPUBufferUsageConstants: Record<string, number> =\r\n  typeof GPUBufferUsage !== 'undefined'\r\n    ? GPUBufferUsage\r\n    : {\r\n        MAP_READ: 1,\r\n        MAP_WRITE: 2,\r\n        COPY_SRC: 4,\r\n        COPY_DST: 8,\r\n        INDEX: 16,\r\n        VERTEX: 32,\r\n        UNIFORM: 64,\r\n        STORAGE: 128,\r\n        INDIRECT: 256,\r\n        QUERY_RESOLVE: 512,\r\n      }\r\n\r\n/**\r\n * GPUTextureUsage constants with fallbacks.\r\n */\r\nexport const WebGPUTextureUsageConstants: Record<string, number> =\r\n  typeof GPUTextureUsage !== 'undefined'\r\n    ? GPUTextureUsage\r\n    : {\r\n        COPY_SRC: 1,\r\n        COPY_DST: 2,\r\n        TEXTURE_BINDING: 4,\r\n        STORAGE_BINDING: 8,\r\n        RENDER_ATTACHMENT: 16,\r\n      }\r\n","import { WebGPUShaderStageConstants } from '../../utils/webgpu-constants'\r\nimport { BufferBinding } from './BufferBinding'\r\nimport { TextureBinding } from './TextureBinding'\r\nimport { MaterialShadersType } from '../../types/Materials'\r\n\r\n/**\r\n * Map {@link MaterialShadersType | shaders types names} with actual {@link GPUShaderStageFlags | shaders visibility bitwise flags}.\r\n */\r\nconst bindingVisibilities: Map<MaterialShadersType, GPUShaderStageFlags> = new Map([\r\n  ['vertex', WebGPUShaderStageConstants.VERTEX],\r\n  ['fragment', WebGPUShaderStageConstants.FRAGMENT],\r\n  ['compute', WebGPUShaderStageConstants.COMPUTE],\r\n])\r\n\r\n/**\r\n * Get the corresponding {@link GPUShaderStageFlags | shaders visibility bitwise flags} based on an array of {@link MaterialShadersType | shaders types names}.\r\n * @param visibilities - array of {@link MaterialShadersType | shaders types names}.\r\n * @returns - corresponding {@link GPUShaderStageFlags | shaders visibility bitwise flags}.\r\n */\r\nexport const getBindingVisibility = (visibilities: MaterialShadersType[] = []): GPUShaderStageFlags => {\r\n  return visibilities.reduce((acc, v) => {\r\n    return acc | bindingVisibilities.get(v)\r\n  }, 0)\r\n}\r\n\r\n/** Defines a typed array */\r\nexport type TypedArray =\r\n  | Int8Array\r\n  | Uint8Array\r\n  | Uint8ClampedArray\r\n  | Int16Array\r\n  | Uint16Array\r\n  | Int32Array\r\n  | Uint32Array\r\n  | Float32Array\r\n  | Float64Array\r\n\r\n/** Defines a typed array constructor */\r\nexport type TypedArrayConstructor =\r\n  | Int8ArrayConstructor\r\n  | Uint8ArrayConstructor\r\n  | Int16ArrayConstructor\r\n  | Uint16ArrayConstructor\r\n  | Int32ArrayConstructor\r\n  | Uint32ArrayConstructor\r\n  | Float32ArrayConstructor\r\n  | Float64ArrayConstructor\r\n\r\n/** Defines the possible WGSL variable types */\r\nexport type WGSLVariableType = string // TODO 'mat4x4f', 'mat3x3f', 'vec3f', 'vec2f', 'f32' etc\r\n\r\n/**\r\n * Defines a {@link BufferLayout} object used to pad our {@link GPUBuffer} arrays\r\n */\r\nexport type BufferLayout = {\r\n  /** Number of elements hold by this variable type */\r\n  numElements: number\r\n  /** Required alignment by this variable type */\r\n  align: number\r\n  /** Size in bytes of this variable type */\r\n  size: number\r\n  /** Variable type */\r\n  type: WGSLVariableType\r\n  /** Typed array constructor required by this variable type */\r\n  View: TypedArrayConstructor\r\n  /** Pad values required by this variable type */\r\n  pad?: number[]\r\n}\r\n\r\n/** Object containing all buffer layouts */\r\nconst bufferLayouts: Record<string, BufferLayout> = {\r\n  i32: { numElements: 1, align: 4, size: 4, type: 'i32', View: Int32Array },\r\n  u32: { numElements: 1, align: 4, size: 4, type: 'u32', View: Uint32Array },\r\n  f32: { numElements: 1, align: 4, size: 4, type: 'f32', View: Float32Array },\r\n  f16: { numElements: 1, align: 2, size: 2, type: 'u16', View: Uint16Array },\r\n\r\n  vec2f: { numElements: 2, align: 8, size: 8, type: 'f32', View: Float32Array },\r\n  vec2i: { numElements: 2, align: 8, size: 8, type: 'i32', View: Int32Array },\r\n  vec2u: { numElements: 2, align: 8, size: 8, type: 'u32', View: Uint32Array },\r\n  vec2h: { numElements: 2, align: 4, size: 4, type: 'u16', View: Uint16Array },\r\n  vec3i: { numElements: 3, align: 16, size: 12, type: 'i32', View: Int32Array },\r\n  vec3u: { numElements: 3, align: 16, size: 12, type: 'u32', View: Uint32Array },\r\n  vec3f: { numElements: 3, align: 16, size: 12, type: 'f32', View: Float32Array },\r\n  vec3h: { numElements: 3, align: 8, size: 6, type: 'u16', View: Uint16Array },\r\n  vec4i: { numElements: 4, align: 16, size: 16, type: 'i32', View: Int32Array },\r\n  vec4u: { numElements: 4, align: 16, size: 16, type: 'u32', View: Uint32Array },\r\n  vec4f: { numElements: 4, align: 16, size: 16, type: 'f32', View: Float32Array },\r\n  vec4h: { numElements: 4, align: 8, size: 8, type: 'u16', View: Uint16Array },\r\n\r\n  // AlignOf(vecR)\tSizeOf(array<vecR, C>)\r\n  mat2x2f: { numElements: 4, align: 8, size: 16, type: 'f32', View: Float32Array },\r\n  mat2x2h: { numElements: 4, align: 4, size: 8, type: 'u16', View: Uint16Array },\r\n  mat3x2f: { numElements: 6, align: 8, size: 24, type: 'f32', View: Float32Array },\r\n  mat3x2h: { numElements: 6, align: 4, size: 12, type: 'u16', View: Uint16Array },\r\n  mat4x2f: { numElements: 8, align: 8, size: 32, type: 'f32', View: Float32Array },\r\n  mat4x2h: { numElements: 8, align: 4, size: 16, type: 'u16', View: Uint16Array },\r\n  mat2x3f: { numElements: 8, align: 16, size: 32, pad: [3, 1], type: 'f32', View: Float32Array },\r\n  mat2x3h: { numElements: 8, align: 8, size: 16, pad: [3, 1], type: 'u16', View: Uint16Array },\r\n  mat3x3f: { numElements: 12, align: 16, size: 48, pad: [3, 1], type: 'f32', View: Float32Array },\r\n  mat3x3h: { numElements: 12, align: 8, size: 24, pad: [3, 1], type: 'u16', View: Uint16Array },\r\n  mat4x3f: { numElements: 16, align: 16, size: 64, pad: [3, 1], type: 'f32', View: Float32Array },\r\n  mat4x3h: { numElements: 16, align: 8, size: 32, pad: [3, 1], type: 'u16', View: Uint16Array },\r\n  mat2x4f: { numElements: 8, align: 16, size: 32, type: 'f32', View: Float32Array },\r\n  mat2x4h: { numElements: 8, align: 8, size: 16, type: 'u16', View: Uint16Array },\r\n  mat3x4f: { numElements: 12, align: 16, size: 48, pad: [3, 1], type: 'f32', View: Float32Array },\r\n  mat3x4h: { numElements: 12, align: 8, size: 24, pad: [3, 1], type: 'u16', View: Uint16Array },\r\n  mat4x4f: { numElements: 16, align: 16, size: 64, type: 'f32', View: Float32Array },\r\n  mat4x4h: { numElements: 16, align: 8, size: 32, type: 'u16', View: Uint16Array },\r\n}\r\n\r\n// from https://github.com/greggman/webgpu-utils/blob/main/src/buffer-views.ts\r\n/**\r\n * Get the correct {@link BufferLayout | buffer layout} for given {@link WGSLVariableType | variable type}\r\n * @param bufferType - [{@link WGSLVariableType | variable type} to use\r\n * @returns - the ={@link BufferLayout | buffer layout}\r\n */\r\nexport const getBufferLayout = (bufferType: WGSLVariableType): BufferLayout => {\r\n  return bufferLayouts[bufferType]\r\n}\r\n\r\n/**\r\n * Get the correct WGSL variable declaration code fragment based on the given {@link BufferBinding}\r\n * @param binding - {@link BufferBinding} to use\r\n * @returns - WGSL variable declaration code fragment\r\n */\r\nexport const getBindingWGSLVarType = (binding: BufferBinding): string => {\r\n  return (() => {\r\n    switch (binding.bindingType) {\r\n      case 'storage':\r\n        return `var<${binding.bindingType}, ${binding.options.access}>`\r\n      case 'uniform':\r\n      default:\r\n        return 'var<uniform>'\r\n    }\r\n  })()\r\n}\r\n\r\n/**\r\n * Get the correct WGSL variable declaration code fragment based on the given {@link TextureBinding}\r\n * @param binding - {@link TextureBinding} to use\r\n * @returns - WGSL variable declaration code fragment\r\n */\r\nexport const getTextureBindingWGSLVarType = (binding: TextureBinding): string => {\r\n  if (binding.bindingType === 'externalTexture') {\r\n    return `var ${binding.name}: texture_external;`\r\n  }\r\n\r\n  return binding.bindingType === 'storage'\r\n    ? `var ${binding.name}: texture_storage_${binding.options.viewDimension.replace('-', '_')}<${\r\n        binding.options.format\r\n      }, ${binding.options.access}>;`\r\n    : binding.bindingType === 'depth'\r\n    ? `var ${binding.name}: texture_depth${\r\n        binding.options.multisampled ? '_multisampled' : ''\r\n      }_${binding.options.viewDimension.replace('-', '_')};`\r\n    : `var ${binding.name}: texture${\r\n        binding.options.multisampled ? '_multisampled' : ''\r\n      }_${binding.options.viewDimension.replace('-', '_')}<f32>;`\r\n}\r\n\r\n/**\r\n * Get the correct {@link GPUBindGroupLayout | bind group layout} resource type based on the given {@link core/bindings/Binding.BindingType | binding type}\r\n * @param binding - {@link BufferBinding | buffer binding} to use\r\n * @returns - {@link GPUBindGroupLayout | bind group layout} resource type\r\n */\r\nexport const getBindGroupLayoutBindingType = (binding: BufferBinding): GPUBufferBindingType => {\r\n  if (binding.bindingType === 'storage' && binding.options.access === 'read_write') {\r\n    return 'storage'\r\n  } else if (binding.bindingType === 'storage') {\r\n    return 'read-only-storage'\r\n  } else {\r\n    return 'uniform'\r\n  }\r\n}\r\n\r\n/**\r\n * Get the correct {@link GPUBindGroupLayout} resource type based on the given {@link core/bindings/Binding.BindingType | texture binding type}\r\n * @param binding - {@link TextureBinding | texture binding} to use\r\n * @returns - {@link GPUBindGroupLayout} resource type\r\n */\r\nexport const getBindGroupLayoutTextureBindingType = (\r\n  binding: TextureBinding\r\n): GPUTextureBindingLayout | GPUExternalTextureBindingLayout | GPUStorageTextureBindingLayout | null => {\r\n  return (() => {\r\n    switch (binding.bindingType) {\r\n      case 'externalTexture':\r\n        return { externalTexture: {} }\r\n      case 'storage':\r\n        return {\r\n          storageTexture: {\r\n            format: binding.options.format,\r\n            viewDimension: binding.options.viewDimension,\r\n          } as GPUStorageTextureBindingLayout,\r\n        }\r\n      case 'texture':\r\n        return {\r\n          texture: {\r\n            multisampled: binding.options.multisampled,\r\n            viewDimension: binding.options.viewDimension,\r\n            sampleType: binding.options.multisampled ? 'unfilterable-float' : 'float',\r\n          } as GPUTextureBindingLayout,\r\n        }\r\n      case 'depth':\r\n        return {\r\n          texture: {\r\n            multisampled: binding.options.multisampled,\r\n            viewDimension: binding.options.viewDimension,\r\n            sampleType: 'depth',\r\n          } as GPUTextureBindingLayout,\r\n        }\r\n      default:\r\n        return null\r\n    }\r\n  })()\r\n}\r\n\r\n/**\r\n * Get the correct {@link TextureBinding | texture binding} cache key.\r\n * @param binding - {@link TextureBinding | texture binding} to use\r\n * @returns - binding cache key\r\n */\r\nexport const getBindGroupLayoutTextureBindingCacheKey = (binding: TextureBinding): string => {\r\n  return (() => {\r\n    switch (binding.bindingType) {\r\n      case 'externalTexture':\r\n        return `externalTexture,${binding.visibility},`\r\n      case 'storage':\r\n        return `storageTexture,${binding.options.format},${binding.options.viewDimension},${binding.visibility},`\r\n      case 'texture':\r\n        return `texture,${binding.options.multisampled},${binding.options.viewDimension},${\r\n          binding.options.multisampled ? 'unfilterable-float' : 'float'\r\n        },${binding.visibility},`\r\n      case 'depth':\r\n        return `depthTexture,${binding.options.format},${binding.options.viewDimension},${binding.visibility},`\r\n      default:\r\n        return `${binding.visibility},`\r\n    }\r\n  })()\r\n}\r\n","import { toCamelCase } from '../../utils/utils'\r\nimport { MaterialShadersType } from '../../types/Materials'\r\nimport { TextureBinding } from './TextureBinding'\r\nimport { SamplerBinding } from './SamplerBinding'\r\nimport { getBindingVisibility } from './utils'\r\n\r\n/** Defines all kind of buffer binding types */\r\nexport type BufferBindingType = 'uniform' | 'storage'\r\n/** Defines all kind of texture binding types */\r\nexport type TextureBindingType = 'texture' | 'storage' | 'depth'\r\n/** Defines all kind of DOM texture binding types */\r\nexport type DOMTextureBindingType = 'externalTexture' | TextureBindingType\r\n/** Defines all kind of sampler binding types */\r\nexport type SamplerBindingType = 'sampler'\r\n/** Defines all kind of binding types  */\r\nexport type BindingType = BufferBindingType | DOMTextureBindingType | SamplerBindingType\r\n\r\n// see https://www.w3.org/TR/WGSL/#memory-access-mode\r\n/** Defines buffer binding memory access types (read only or read/write) */\r\nexport type BufferBindingMemoryAccessType = 'read' | 'read_write'\r\n/** Defines texture binding memory access types (read only, write only or read/write) */\r\nexport type BindingMemoryAccessType = BufferBindingMemoryAccessType | 'write'\r\n\r\n/**\r\n * Defines all kind of {@link Binding} that are related to textures or samplers\r\n */\r\nexport type TextureSamplerBindings = TextureBinding | SamplerBinding\r\n\r\n/**\r\n * An object defining all possible {@link Binding} class instancing parameters\r\n */\r\nexport interface BindingParams {\r\n  /** {@link Binding} label */\r\n  label?: string\r\n  /** {@link Binding} name/key */\r\n  name?: string\r\n  /** {@link BindingType | binding type} to use with this {@link Binding} */\r\n  bindingType?: BindingType\r\n  /** {@link Binding} variables shaders visibility as an array of {@link MaterialShadersType | shaders types names} */\r\n  visibility?: MaterialShadersType[]\r\n}\r\n\r\n/**\r\n * Used as a shell to build actual bindings upon, like {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}, {@link core/bindings/WritableBufferBinding.WritableBufferBinding | WritableBufferBinding}, {@link TextureBinding} and {@link SamplerBinding}.\r\n *\r\n * Ultimately the goal of a {@link Binding} element is to provide correct resources for {@link GPUBindGroupLayoutEntry} and {@link GPUBindGroupEntry}\r\n *\r\n * ## WGSL\r\n *\r\n * Each {@link Binding} creates its own WGSL code snippet variable declaration, using structured types or not.\r\n */\r\nexport class Binding {\r\n  /** The label of the {@link Binding} */\r\n  label: string\r\n  /** The name/key of the {@link Binding} */\r\n  name: string\r\n  /** The binding type of the {@link Binding} */\r\n  bindingType: BindingType\r\n  /** The visibility of the {@link Binding} in the shaders */\r\n  visibility: GPUShaderStageFlags\r\n  /** Options used to create this {@link Binding} */\r\n  options: BindingParams\r\n\r\n  /** Flag indicating whether we should recreate the parentMesh {@link core/bindGroups/BindGroup.BindGroup#bindGroup | bind group}, usually when a resource has changed */\r\n  shouldResetBindGroup: boolean\r\n  /** Flag indicating whether we should recreate the parentMesh {@link core/bindGroups/BindGroup.BindGroup#bindGroupLayout | GPU bind group layout}, usually when a resource layout has changed */\r\n  shouldResetBindGroupLayout: boolean\r\n\r\n  /** A cache key allowing to get / set bindings from the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#bufferBindings | device manager map cache}. Used for {@link core/bindings/BufferBinding.BufferBinding | BufferBinding} only at the moment. */\r\n  cacheKey: string\r\n\r\n  /**\r\n   * Binding constructor\r\n   * @param parameters - {@link BindingParams | parameters} used to create our {@link Binding}\r\n   */\r\n  constructor({\r\n    label = 'Uniform',\r\n    name = 'uniform',\r\n    bindingType = 'uniform',\r\n    visibility = ['vertex', 'fragment', 'compute'],\r\n  }: BindingParams) {\r\n    this.label = label\r\n    this.name = toCamelCase(name)\r\n    this.bindingType = bindingType\r\n\r\n    this.visibility = getBindingVisibility(visibility)\r\n\r\n    this.options = {\r\n      label,\r\n      name,\r\n      bindingType,\r\n      visibility,\r\n    }\r\n\r\n    this.shouldResetBindGroup = false\r\n    this.shouldResetBindGroupLayout = false\r\n\r\n    this.cacheKey = `${bindingType},${this.visibility},`\r\n  }\r\n}\r\n","/**\r\n * Really basic 2D vector class used for vector calculations\r\n * @see https://github.com/mrdoob/three.js/blob/dev/src/math/Vector2.js\r\n * @see http://glmatrix.net/docs/vec2.js.html\r\n */\r\nexport class Vec2 {\r\n  /** The type of the {@link Vec2} */\r\n  type: string\r\n  /** X component of our {@link Vec2} */\r\n  private _x: number\r\n  /** Y component of our {@link Vec2} */\r\n  private _y: number\r\n\r\n  /** function assigned to the {@link onChange} callback */\r\n  _onChangeCallback?(): void\r\n\r\n  /**\r\n   * Vec2 constructor\r\n   * @param x - X component of our {@link Vec2}\r\n   * @param y - Y component of our {@link Vec2}\r\n   */\r\n  constructor(x = 0, y = x) {\r\n    this.type = 'Vec2'\r\n\r\n    this._x = x\r\n    this._y = y\r\n  }\r\n\r\n  /**\r\n   * Get the X component of the {@link Vec2}\r\n   */\r\n  get x(): number {\r\n    return this._x\r\n  }\r\n\r\n  /**\r\n   * Set the X component of the {@link Vec2}\r\n   * Can trigger {@link onChange} callback\r\n   * @param value - X component to set\r\n   */\r\n  set x(value: number) {\r\n    const changed = value !== this._x\r\n    this._x = value\r\n    changed && this._onChangeCallback && this._onChangeCallback()\r\n  }\r\n\r\n  /**\r\n   * Get the Y component of the {@link Vec2}\r\n   */\r\n  get y(): number {\r\n    return this._y\r\n  }\r\n\r\n  /**\r\n   * Set the Y component of the {@link Vec2}\r\n   * Can trigger {@link onChange} callback\r\n   * @param value - Y component to set\r\n   */\r\n  set y(value: number) {\r\n    const changed = value !== this._y\r\n    this._y = value\r\n    changed && this._onChangeCallback && this._onChangeCallback()\r\n  }\r\n\r\n  /**\r\n   * Called when at least one component of the {@link Vec2} has changed\r\n   * @param callback - callback to run when at least one component of the {@link Vec2} has changed\r\n   * @returns - our {@link Vec2}\r\n   */\r\n  onChange(callback: () => void): Vec2 {\r\n    if (callback) {\r\n      this._onChangeCallback = callback\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Set the {@link Vec2} from values\r\n   * @param x - new X component to set\r\n   * @param y - new Y component to set\r\n   * @returns - this {@link Vec2} after being set\r\n   */\r\n  set(x = 0, y = x): Vec2 {\r\n    this.x = x\r\n    this.y = y\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Add a {@link Vec2} to this {@link Vec2}\r\n   * @param vector - {@link Vec2} to add\r\n   * @returns - this {@link Vec2} after addition\r\n   */\r\n  add(vector: Vec2 = new Vec2()): Vec2 {\r\n    this.x += vector.x\r\n    this.y += vector.y\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Add a scalar to all the components of this {@link Vec2}\r\n   * @param value - number to add\r\n   * @returns - this {@link Vec2} after addition\r\n   */\r\n  addScalar(value = 0): Vec2 {\r\n    this.x += value\r\n    this.y += value\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Subtract a {@link Vec2} from this {@link Vec2}\r\n   * @param vector - {@link Vec2} to subtract\r\n   * @returns - this {@link Vec2} after subtraction\r\n   */\r\n  sub(vector: Vec2 = new Vec2()): Vec2 {\r\n    this.x -= vector.x\r\n    this.y -= vector.y\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Subtract a scalar to all the components of this {@link Vec2}\r\n   * @param value - number to subtract\r\n   * @returns - this {@link Vec2} after subtraction\r\n   */\r\n  subScalar(value = 0): Vec2 {\r\n    this.x -= value\r\n    this.y -= value\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Multiply a {@link Vec2} with this {@link Vec2}\r\n   * @param vector - {@link Vec2} to multiply with\r\n   * @returns - this {@link Vec2} after multiplication\r\n   */\r\n  multiply(vector: Vec2 = new Vec2(1)): Vec2 {\r\n    this.x *= vector.x\r\n    this.y *= vector.y\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Multiply all components of this {@link Vec2} with a scalar\r\n   * @param value - number to multiply with\r\n   * @returns - this {@link Vec2} after multiplication\r\n   */\r\n  multiplyScalar(value = 1): Vec2 {\r\n    this.x *= value\r\n    this.y *= value\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Divide a {@link Vec2} with this {@link Vec2}\r\n   * @param vector - {@link Vec2} to divide with\r\n   * @returns - this {@link Vec2} after division\r\n   */\r\n  divide(vector: Vec2 = new Vec2(1)): Vec2 {\r\n    this.x /= vector.x\r\n    this.y /= vector.y\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Divide all components of this {@link Vec2} with a scalar\r\n   * @param value - number to divide with\r\n   * @returns - this {@link Vec2} after division\r\n   */\r\n  divideScalar(value = 1): Vec2 {\r\n    this.x /= value\r\n    this.y /= value\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Copy a {@link Vec2} into this {@link Vec2}\r\n   * @param vector - {@link Vec2} to copy\r\n   * @returns - this {@link Vec2} after copy\r\n   */\r\n  copy(vector: Vec2 = new Vec2()): Vec2 {\r\n    this.x = vector.x\r\n    this.y = vector.y\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Clone this {@link Vec2}\r\n   * @returns - cloned {@link Vec2}\r\n   */\r\n  clone(): Vec2 {\r\n    return new Vec2(this.x, this.y)\r\n  }\r\n\r\n  /**\r\n   * Apply max values to this {@link Vec2} components\r\n   * @param vector - {@link Vec2} representing max values\r\n   * @returns - {@link Vec2} with max values applied\r\n   */\r\n  max(vector: Vec2 = new Vec2()): Vec2 {\r\n    this.x = Math.max(this.x, vector.x)\r\n    this.y = Math.max(this.y, vector.y)\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Apply min values to this {@link Vec2} components\r\n   * @param vector - {@link Vec2} representing min values\r\n   * @returns - {@link Vec2} with min values applied\r\n   */\r\n  min(vector: Vec2 = new Vec2()): Vec2 {\r\n    this.x = Math.min(this.x, vector.x)\r\n    this.y = Math.min(this.y, vector.y)\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Clamp this {@link Vec2} components by min and max {@link Vec2} vectors\r\n   * @param min - minimum {@link Vec2} components to compare with\r\n   * @param max - maximum {@link Vec2} components to compare with\r\n   * @returns - clamped {@link Vec2}\r\n   */\r\n  clamp(min: Vec2 = new Vec2(), max: Vec2 = new Vec2()): Vec2 {\r\n    this.x = Math.max(min.x, Math.min(max.x, this.x))\r\n    this.y = Math.max(min.y, Math.min(max.y, this.y))\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Check if 2 {@link Vec2} are equal\r\n   * @param vector - {@link Vec2} to compare\r\n   * @returns - whether the {@link Vec2} are equals or not\r\n   */\r\n  equals(vector: Vec2 = new Vec2()): boolean {\r\n    return this.x === vector.x && this.y === vector.y\r\n  }\r\n\r\n  /**\r\n   * Get the square length of this {@link Vec2}\r\n   * @returns - square length of this {@link Vec2}\r\n   */\r\n  lengthSq(): number {\r\n    return this.x * this.x + this.y * this.y\r\n  }\r\n\r\n  /**\r\n   * Get the length of this {@link Vec2}\r\n   * @returns - length of this {@link Vec2}\r\n   */\r\n  length(): number {\r\n    return Math.sqrt(this.lengthSq())\r\n  }\r\n\r\n  /**\r\n   * Normalize this {@link Vec2}\r\n   * @returns - normalized {@link Vec2}\r\n   */\r\n  normalize(): Vec2 {\r\n    // normalize\r\n    let len = this.x * this.x + this.y * this.y\r\n    if (len > 0) {\r\n      len = 1 / Math.sqrt(len)\r\n    }\r\n    this.x *= len\r\n    this.y *= len\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Calculate the dot product of 2 {@link Vec2}\r\n   * @param vector - {@link Vec2} to use for dot product\r\n   * @returns - dot product of the 2 {@link Vec2}\r\n   */\r\n  dot(vector: Vec2 = new Vec2()): number {\r\n    return this.x * vector.x + this.y * vector.y\r\n  }\r\n\r\n  /**\r\n   * Calculate the linear interpolation of this {@link Vec2} by given {@link Vec2} and alpha, where alpha is the percent distance along the line\r\n   * @param vector - {@link Vec2} to interpolate towards\r\n   * @param [alpha=1] - interpolation factor in the [0, 1] interval\r\n   * @returns - this {@link Vec2} after linear interpolation\r\n   */\r\n  lerp(vector: Vec2 = new Vec2(), alpha = 1): Vec2 {\r\n    this.x += (vector.x - this.x) * alpha\r\n    this.y += (vector.y - this.y) * alpha\r\n\r\n    return this\r\n  }\r\n}\r\n","import { Vec3 } from './Vec3'\r\nimport { Mat4 } from './Mat4'\r\n\r\n/** Defines all possible rotations axis orders */\r\nexport type AxisOrder = 'XYZ' | 'XZY' | 'YXZ' | 'YZX' | 'ZXY' | 'ZYX'\r\n\r\n/**\r\n * Really basic quaternion class used for 3D rotation calculations\r\n * @see https://github.com/mrdoosb/three.js/blob/dev/src/math/Quaternion.js\r\n */\r\nexport class Quat {\r\n  /** The type of the {@link Quat} */\r\n  type: string\r\n  /** Our quaternion array */\r\n  elements: Float32Array\r\n  /** Rotation axis order */\r\n  axisOrder: AxisOrder\r\n\r\n  /**\r\n   * Quat constructor\r\n   * @param [elements] - initial array to use\r\n   * @param [axisOrder='XYZ'] - axis order to use\r\n   */\r\n  constructor(elements: Float32Array = new Float32Array([0, 0, 0, 1]), axisOrder: AxisOrder = 'XYZ') {\r\n    this.type = 'Quat'\r\n    this.elements = elements\r\n    // rotation axis order\r\n    this.axisOrder = axisOrder\r\n  }\r\n\r\n  /**\r\n   * Sets the {@link Quat} values from an array\r\n   * @param array - an array of at least 4 elements\r\n   * @returns - this {@link Quat} after being set\r\n   */\r\n  setFromArray(array: Float32Array | number[] = new Float32Array([0, 0, 0, 1])): Quat {\r\n    this.elements[0] = array[0]\r\n    this.elements[1] = array[1]\r\n    this.elements[2] = array[2]\r\n    this.elements[3] = array[3]\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Sets the {@link Quat} axis order\r\n   * @param axisOrder - axis order to use\r\n   * @returns - this {@link Quat} after axis order has been set\r\n   */\r\n  setAxisOrder(axisOrder: AxisOrder | string = 'XYZ'): Quat {\r\n    // force uppercase for strict equality tests\r\n    axisOrder = axisOrder.toUpperCase()\r\n\r\n    switch (axisOrder) {\r\n      case 'XYZ':\r\n      case 'YXZ':\r\n      case 'ZXY':\r\n      case 'ZYX':\r\n      case 'YZX':\r\n      case 'XZY':\r\n        this.axisOrder = axisOrder\r\n        break\r\n      default:\r\n        // apply a default axis order\r\n        this.axisOrder = 'XYZ'\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Copy a {@link Quat} into this {@link Quat}\r\n   * @param quaternion - {@link Quat} to copy\r\n   * @returns - this {@link Quat} after copy\r\n   */\r\n  copy(quaternion: Quat = new Quat()): Quat {\r\n    this.elements = quaternion.elements\r\n    this.axisOrder = quaternion.axisOrder\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Clone a {@link Quat}\r\n   * @returns - cloned {@link Quat}\r\n   */\r\n  clone(): Quat {\r\n    return new Quat().copy(this)\r\n  }\r\n\r\n  /**\r\n   * Check if 2 {@link Quat} are equal\r\n   * @param quaternion - {@link Quat} to check against\r\n   * @returns - whether the {@link Quat} are equal or not\r\n   */\r\n  equals(quaternion: Quat = new Quat()): boolean {\r\n    return (\r\n      this.elements[0] === quaternion.elements[0] &&\r\n      this.elements[1] === quaternion.elements[1] &&\r\n      this.elements[2] === quaternion.elements[2] &&\r\n      this.elements[3] === quaternion.elements[3] &&\r\n      this.axisOrder === quaternion.axisOrder\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Sets a rotation {@link Quat} using Euler angles {@link Vec3 | vector} and its axis order\r\n   * @param vector - rotation {@link Vec3 | vector} to set our {@link Quat} from\r\n   * @returns - {@link Quat} after having applied the rotation\r\n   */\r\n  setFromVec3(vector: Vec3): Quat {\r\n    const ax = vector.x * 0.5\r\n    const ay = vector.y * 0.5\r\n    const az = vector.z * 0.5\r\n\r\n    const cosx = Math.cos(ax)\r\n    const cosy = Math.cos(ay)\r\n    const cosz = Math.cos(az)\r\n    const sinx = Math.sin(ax)\r\n    const siny = Math.sin(ay)\r\n    const sinz = Math.sin(az)\r\n\r\n    // XYZ order\r\n    if (this.axisOrder === 'XYZ') {\r\n      this.elements[0] = sinx * cosy * cosz + cosx * siny * sinz\r\n      this.elements[1] = cosx * siny * cosz - sinx * cosy * sinz\r\n      this.elements[2] = cosx * cosy * sinz + sinx * siny * cosz\r\n      this.elements[3] = cosx * cosy * cosz - sinx * siny * sinz\r\n    } else if (this.axisOrder === 'YXZ') {\r\n      this.elements[0] = sinx * cosy * cosz + cosx * siny * sinz\r\n      this.elements[1] = cosx * siny * cosz - sinx * cosy * sinz\r\n      this.elements[2] = cosx * cosy * sinz - sinx * siny * cosz\r\n      this.elements[3] = cosx * cosy * cosz + sinx * siny * sinz\r\n    } else if (this.axisOrder === 'ZXY') {\r\n      this.elements[0] = sinx * cosy * cosz - cosx * siny * sinz\r\n      this.elements[1] = cosx * siny * cosz + sinx * cosy * sinz\r\n      this.elements[2] = cosx * cosy * sinz + sinx * siny * cosz\r\n      this.elements[3] = cosx * cosy * cosz - sinx * siny * sinz\r\n    } else if (this.axisOrder === 'ZYX') {\r\n      this.elements[0] = sinx * cosy * cosz - cosx * siny * sinz\r\n      this.elements[1] = cosx * siny * cosz + sinx * cosy * sinz\r\n      this.elements[2] = cosx * cosy * sinz - sinx * siny * cosz\r\n      this.elements[3] = cosx * cosy * cosz + sinx * siny * sinz\r\n    } else if (this.axisOrder === 'YZX') {\r\n      this.elements[0] = sinx * cosy * cosz + cosx * siny * sinz\r\n      this.elements[1] = cosx * siny * cosz + sinx * cosy * sinz\r\n      this.elements[2] = cosx * cosy * sinz - sinx * siny * cosz\r\n      this.elements[3] = cosx * cosy * cosz - sinx * siny * sinz\r\n    } else if (this.axisOrder === 'XZY') {\r\n      this.elements[0] = sinx * cosy * cosz - cosx * siny * sinz\r\n      this.elements[1] = cosx * siny * cosz - sinx * cosy * sinz\r\n      this.elements[2] = cosx * cosy * sinz + sinx * siny * cosz\r\n      this.elements[3] = cosx * cosy * cosz + sinx * siny * sinz\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Set a {@link Quat} from a rotation axis {@link Vec3 | vector} and an angle\r\n   * @param axis - normalized {@link Vec3 | vector} around which to rotate\r\n   * @param angle - angle (in radians) to rotate\r\n   * @returns - {@link Quat} after having applied the rotation\r\n   */\r\n  setFromAxisAngle(axis: Vec3, angle = 0): Quat {\r\n    // https://github.com/mrdoob/three.js/blob/dev/src/math/Quaternion.js#L275\r\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\r\n    // assumes axis is normalized\r\n\r\n    const halfAngle = angle / 2,\r\n      s = Math.sin(halfAngle)\r\n\r\n    this.elements[0] = axis.x * s\r\n    this.elements[1] = axis.y * s\r\n    this.elements[2] = axis.z * s\r\n    this.elements[3] = Math.cos(halfAngle)\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Set a {@link Quat} from a rotation {@link Mat4 | matrix}\r\n   * @param matrix - rotation {@link Mat4 | matrix} to use\r\n   * @returns - {@link Quat} after having applied the rotation\r\n   */\r\n  setFromRotationMatrix(matrix: Mat4): Quat {\r\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n    const te = matrix.elements,\r\n      m11 = te[0],\r\n      m12 = te[4],\r\n      m13 = te[8],\r\n      m21 = te[1],\r\n      m22 = te[5],\r\n      m23 = te[9],\r\n      m31 = te[2],\r\n      m32 = te[6],\r\n      m33 = te[10],\r\n      trace = m11 + m22 + m33\r\n\r\n    if (trace > 0) {\r\n      const s = 0.5 / Math.sqrt(trace + 1.0)\r\n\r\n      this.elements[3] = 0.25 / s\r\n      this.elements[0] = (m32 - m23) * s\r\n      this.elements[1] = (m13 - m31) * s\r\n      this.elements[2] = (m21 - m12) * s\r\n    } else if (m11 > m22 && m11 > m33) {\r\n      const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33)\r\n\r\n      this.elements[3] = (m32 - m23) / s\r\n      this.elements[0] = 0.25 * s\r\n      this.elements[1] = (m12 + m21) / s\r\n      this.elements[2] = (m13 + m31) / s\r\n    } else if (m22 > m33) {\r\n      const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33)\r\n\r\n      this.elements[3] = (m13 - m31) / s\r\n      this.elements[0] = (m12 + m21) / s\r\n      this.elements[1] = 0.25 * s\r\n      this.elements[2] = (m23 + m32) / s\r\n    } else {\r\n      const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22)\r\n\r\n      this.elements[3] = (m21 - m12) / s\r\n      this.elements[0] = (m13 + m31) / s\r\n      this.elements[1] = (m23 + m32) / s\r\n      this.elements[2] = 0.25 * s\r\n    }\r\n\r\n    return this\r\n  }\r\n}\r\n","import { Mat4 } from './Mat4'\r\nimport { Quat } from './Quat'\r\nimport { Camera } from '../core/camera/Camera'\r\n\r\n/**\r\n * Really basic 3D vector class used for vector calculations\r\n * @see https://github.com/mrdoob/three.js/blob/dev/src/math/Vector3.js\r\n * @see http://glmatrix.net/docs/vec3.js.html\r\n */\r\nexport class Vec3 {\r\n  /** The type of the {@link Vec3} */\r\n  type: string\r\n  /** X component of our {@link Vec3} */\r\n  private _x: number\r\n  /** Y component of our {@link Vec3} */\r\n  private _y: number\r\n  /** Z component of our {@link Vec3} */\r\n  private _z: number\r\n\r\n  /** function assigned to the {@link onChange} callback */\r\n  _onChangeCallback?(): void\r\n\r\n  /**\r\n   * Vec3 constructor\r\n   * @param x - X component of our {@link Vec3}\r\n   * @param y - Y component of our {@link Vec3}\r\n   * @param z - Z component of our {@link Vec3}\r\n   */\r\n  constructor(x = 0, y = x, z = x) {\r\n    this.type = 'Vec3'\r\n\r\n    this._x = x\r\n    this._y = y\r\n    this._z = z\r\n  }\r\n\r\n  /**\r\n   * Get the X component of the {@link Vec3}\r\n   */\r\n  get x(): number {\r\n    return this._x\r\n  }\r\n\r\n  /**\r\n   * Set the X component of the {@link Vec3}\r\n   * Can trigger {@link onChange} callback\r\n   * @param value - X component to set\r\n   */\r\n  set x(value: number) {\r\n    const changed = value !== this._x\r\n    this._x = value\r\n    changed && this._onChangeCallback && this._onChangeCallback()\r\n  }\r\n\r\n  /**\r\n   * Get the Y component of the {@link Vec3}\r\n   */\r\n  get y(): number {\r\n    return this._y\r\n  }\r\n\r\n  /**\r\n   * Set the Y component of the {@link Vec3}\r\n   * Can trigger {@link onChange} callback\r\n   * @param value - Y component to set\r\n   */\r\n  set y(value: number) {\r\n    const changed = value !== this._y\r\n    this._y = value\r\n    changed && this._onChangeCallback && this._onChangeCallback()\r\n  }\r\n\r\n  /**\r\n   * Get the Z component of the {@link Vec3}\r\n   */\r\n  get z(): number {\r\n    return this._z\r\n  }\r\n\r\n  /**\r\n   * Set the Z component of the {@link Vec3}\r\n   * Can trigger {@link onChange} callback\r\n   * @param value - Z component to set\r\n   */\r\n  set z(value: number) {\r\n    const changed = value !== this._z\r\n    this._z = value\r\n    changed && this._onChangeCallback && this._onChangeCallback()\r\n  }\r\n\r\n  /**\r\n   * Called when at least one component of the {@link Vec3} has changed\r\n   * @param callback - callback to run when at least one component of the {@link Vec3} has changed\r\n   * @returns - our {@link Vec3}\r\n   */\r\n  onChange(callback: () => void): Vec3 {\r\n    if (callback) {\r\n      this._onChangeCallback = callback\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Set the {@link Vec3} from values\r\n   * @param x - new X component to set\r\n   * @param y - new Y component to set\r\n   * @param z - new Z component to set\r\n   * @returns - this {@link Vec3} after being set\r\n   */\r\n  set(x = 0, y = x, z = x): Vec3 {\r\n    this.x = x\r\n    this.y = y\r\n    this.z = z\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Add a {@link Vec3} to this {@link Vec3}\r\n   * @param vector - {@link Vec3} to add\r\n   * @returns - this {@link Vec3} after addition\r\n   */\r\n  add(vector: Vec3 = new Vec3()): Vec3 {\r\n    this.x += vector.x\r\n    this.y += vector.y\r\n    this.z += vector.z\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Add a scalar to all the components of this {@link Vec3}\r\n   * @param value - number to add\r\n   * @returns - this {@link Vec3} after addition\r\n   */\r\n  addScalar(value = 0): Vec3 {\r\n    this.x += value\r\n    this.y += value\r\n    this.z += value\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Subtract a {@link Vec3} from this {@link Vec3}\r\n   * @param vector - {@link Vec3} to subtract\r\n   * @returns - this {@link Vec3} after subtraction\r\n   */\r\n  sub(vector: Vec3 = new Vec3()): Vec3 {\r\n    this.x -= vector.x\r\n    this.y -= vector.y\r\n    this.z -= vector.z\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Subtract a scalar to all the components of this {@link Vec3}\r\n   * @param value - number to subtract\r\n   * @returns - this {@link Vec3} after subtraction\r\n   */\r\n  subScalar(value = 0): Vec3 {\r\n    this.x -= value\r\n    this.y -= value\r\n    this.z -= value\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Multiply a {@link Vec3} with this {@link Vec3}\r\n   * @param vector - {@link Vec3} to multiply with\r\n   * @returns - this {@link Vec3} after multiplication\r\n   */\r\n  multiply(vector: Vec3 = new Vec3(1)): Vec3 {\r\n    this.x *= vector.x\r\n    this.y *= vector.y\r\n    this.z *= vector.z\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Multiply all components of this {@link Vec3} with a scalar\r\n   * @param value - number to multiply with\r\n   * @returns - this {@link Vec3} after multiplication\r\n   */\r\n  multiplyScalar(value = 1): Vec3 {\r\n    this.x *= value\r\n    this.y *= value\r\n    this.z *= value\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Divide a {@link Vec3} with this {@link Vec3}\r\n   * @param vector - {@link Vec3} to divide with\r\n   * @returns - this {@link Vec3} after division\r\n   */\r\n  divide(vector: Vec3 = new Vec3(1)): Vec3 {\r\n    this.x /= vector.x\r\n    this.y /= vector.y\r\n    this.z /= vector.z\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Divide all components of this {@link Vec3} with a scalar\r\n   * @param value - number to divide with\r\n   * @returns - this {@link Vec3} after division\r\n   */\r\n  divideScalar(value = 1): Vec3 {\r\n    this.x /= value\r\n    this.y /= value\r\n    this.z /= value\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Copy a {@link Vec3} into this {@link Vec3}\r\n   * @param vector - {@link Vec3} to copy\r\n   * @returns - this {@link Vec3} after copy\r\n   */\r\n  copy(vector: Vec3 = new Vec3()): Vec3 {\r\n    this.x = vector.x\r\n    this.y = vector.y\r\n    this.z = vector.z\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Clone this {@link Vec3}\r\n   * @returns - cloned {@link Vec3}\r\n   */\r\n  clone(): Vec3 {\r\n    return new Vec3(this.x, this.y, this.z)\r\n  }\r\n\r\n  /**\r\n   * Apply max values to this {@link Vec3} components\r\n   * @param vector - {@link Vec3} representing max values\r\n   * @returns - {@link Vec3} with max values applied\r\n   */\r\n  max(vector: Vec3 = new Vec3()): Vec3 {\r\n    this.x = Math.max(this.x, vector.x)\r\n    this.y = Math.max(this.y, vector.y)\r\n    this.z = Math.max(this.z, vector.z)\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Apply min values to this {@link Vec3} components\r\n   * @param vector - {@link Vec3} representing min values\r\n   * @returns - {@link Vec3} with min values applied\r\n   */\r\n  min(vector: Vec3 = new Vec3()): Vec3 {\r\n    this.x = Math.min(this.x, vector.x)\r\n    this.y = Math.min(this.y, vector.y)\r\n    this.z = Math.min(this.z, vector.z)\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Clamp this {@link Vec3} components by min and max {@link Vec3} vectors\r\n   * @param min - minimum {@link Vec3} components to compare with\r\n   * @param max - maximum {@link Vec3} components to compare with\r\n   * @returns - clamped {@link Vec3}\r\n   */\r\n  clamp(min: Vec3 = new Vec3(), max: Vec3 = new Vec3()): Vec3 {\r\n    this.x = Math.max(min.x, Math.min(max.x, this.x))\r\n    this.y = Math.max(min.y, Math.min(max.y, this.y))\r\n    this.z = Math.max(min.z, Math.min(max.z, this.z))\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Check if 2 {@link Vec3} are equal\r\n   * @param vector - {@link Vec3} to compare\r\n   * @returns - whether the {@link Vec3} are equals or not\r\n   */\r\n  equals(vector: Vec3 = new Vec3()): boolean {\r\n    return this.x === vector.x && this.y === vector.y && this.z === vector.z\r\n  }\r\n\r\n  /**\r\n   * Get the square length of this {@link Vec3}\r\n   * @returns - square length of this {@link Vec3}\r\n   */\r\n  lengthSq(): number {\r\n    return this.x * this.x + this.y * this.y + this.z * this.z\r\n  }\r\n\r\n  /**\r\n   * Get the length of this {@link Vec3}\r\n   * @returns - length of this {@link Vec3}\r\n   */\r\n  length(): number {\r\n    return Math.sqrt(this.lengthSq())\r\n  }\r\n\r\n  /**\r\n   * Get the euclidian distance between this {@link Vec3} and another {@link Vec3}\r\n   * @param vector - {@link Vec3} to use for distance calculation\r\n   * @returns - euclidian distance\r\n   */\r\n  distance(vector: Vec3 = new Vec3()): number {\r\n    return Math.hypot(vector.x - this.x, vector.y - this.y, vector.z - this.z)\r\n  }\r\n\r\n  /**\r\n   * Normalize this {@link Vec3}\r\n   * @returns - normalized {@link Vec3}\r\n   */\r\n  normalize(): Vec3 {\r\n    // normalize\r\n    let len = this.lengthSq()\r\n    if (len > 0) {\r\n      len = 1 / Math.sqrt(len)\r\n    }\r\n    this.x *= len\r\n    this.y *= len\r\n    this.z *= len\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Calculate the dot product of 2 {@link Vec3}\r\n   * @param vector - {@link Vec3} to use for dot product\r\n   * @returns - dot product of the 2 {@link Vec3}\r\n   */\r\n  dot(vector: Vec3 = new Vec3()): number {\r\n    return this.x * vector.x + this.y * vector.y + this.z * vector.z\r\n  }\r\n\r\n  /**\r\n   * Get the cross product of this {@link Vec3} with another {@link Vec3}\r\n   * @param vector - {@link Vec3} to use for cross product\r\n   * @returns - this {@link Vec3} after cross product\r\n   */\r\n  cross(vector: Vec3 = new Vec3()): Vec3 {\r\n    return this.crossVectors(this, vector)\r\n  }\r\n\r\n  /**\r\n   * Set this {@link Vec3} as the result of the cross product of two {@link Vec3}\r\n   * @param a - first {@link Vec3} to use for cross product\r\n   * @param b - second {@link Vec3} to use for cross product\r\n   * @returns - this {@link Vec3} after cross product\r\n   */\r\n  crossVectors(a: Vec3 = new Vec3(), b: Vec3 = new Vec3()): Vec3 {\r\n    const ax = a.x,\r\n      ay = a.y,\r\n      az = a.z\r\n    const bx = b.x,\r\n      by = b.y,\r\n      bz = b.z\r\n\r\n    this.x = ay * bz - az * by\r\n    this.y = az * bx - ax * bz\r\n    this.z = ax * by - ay * bx\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Calculate the linear interpolation of this {@link Vec3} by given {@link Vec3} and alpha, where alpha is the percent distance along the line\r\n   * @param vector - {@link Vec3} to interpolate towards\r\n   * @param alpha - interpolation factor in the [0, 1] interval\r\n   * @returns - this {@link Vec3} after linear interpolation\r\n   */\r\n  lerp(vector: Vec3 = new Vec3(), alpha = 1): Vec3 {\r\n    this.x += (vector.x - this.x) * alpha\r\n    this.y += (vector.y - this.y) * alpha\r\n    this.z += (vector.z - this.z) * alpha\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Apply a {@link Mat4 | matrix} to a {@link Vec3}\r\n   * Useful to convert a position {@link Vec3} from plane local world to webgl space using projection view matrix for example\r\n   * Source code from: http://glmatrix.net/docs/vec3.js.html\r\n   * @param matrix - {@link Mat4 | matrix} to use\r\n   * @returns - this {@link Vec3} after {@link Mat4 | matrix} application\r\n   */\r\n  applyMat4(matrix: Mat4): Vec3 {\r\n    const x = this._x,\r\n      y = this._y,\r\n      z = this._z\r\n    const mArray = matrix.elements\r\n\r\n    let w = mArray[3] * x + mArray[7] * y + mArray[11] * z + mArray[15]\r\n    w = w || 1\r\n\r\n    this.x = (mArray[0] * x + mArray[4] * y + mArray[8] * z + mArray[12]) / w\r\n    this.y = (mArray[1] * x + mArray[5] * y + mArray[9] * z + mArray[13]) / w\r\n    this.z = (mArray[2] * x + mArray[6] * y + mArray[10] * z + mArray[14]) / w\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Set this {@link Vec3} to the translation component of a {@link Mat4 | matrix}.\r\n   * @param matrix - {@link Mat4 | matrix} to use\r\n   * @returns - this {@link Vec3} after {@link Mat4 | matrix} application.\r\n   */\r\n  setFromMatrixPosition(matrix: Mat4) {\r\n    const e = matrix.elements\r\n\r\n    this.x = e[12]\r\n    this.y = e[13]\r\n    this.z = e[14]\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Apply a {@link Quat | quaternion} (rotation in 3D space) to this {@link Vec3}\r\n   * @param quaternion - {@link Quat | quaternion} to use\r\n   * @returns - this {@link Vec3} with the transformation applied\r\n   */\r\n  applyQuat(quaternion: Quat = new Quat()): Vec3 {\r\n    const x = this.x,\r\n      y = this.y,\r\n      z = this.z\r\n    const qx = quaternion.elements[0],\r\n      qy = quaternion.elements[1],\r\n      qz = quaternion.elements[2],\r\n      qw = quaternion.elements[3]\r\n\r\n    // calculate quat * vector\r\n\r\n    const ix = qw * x + qy * z - qz * y\r\n    const iy = qw * y + qz * x - qx * z\r\n    const iz = qw * z + qx * y - qy * x\r\n    const iw = -qx * x - qy * y - qz * z\r\n\r\n    // calculate result * inverse quat\r\n\r\n    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy\r\n    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz\r\n    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Rotate a {@link Vec3} around and axis by a given angle\r\n   * @param axis - normalized {@link Vec3} around which to rotate\r\n   * @param angle - angle (in radians) to rotate\r\n   * @param quaternion - optional {@link Quat | quaternion} to use for rotation computations\r\n   * @returns - this {@link Vec3} with the rotation applied\r\n   */\r\n  applyAxisAngle(axis = new Vec3(), angle = 0, quaternion = new Quat()): Vec3 {\r\n    // https://github.com/mrdoob/three.js/blob/master/src/math/Vector3.js#L212\r\n    return this.applyQuat(quaternion.setFromAxisAngle(axis, angle))\r\n  }\r\n\r\n  /**\r\n   * Transforms the direction of this vector by a {@link Mat4} (the upper left 3 x 3 subset) and then normalizes the result.\r\n   * @param matrix - {@link Mat4} to use for transformation.\r\n   * @returns - this {@link Vec3} with the transformation applied.\r\n   */\r\n  transformDirection(matrix: Mat4): Vec3 {\r\n    // input: Mat4 affine matrix\r\n    // vector interpreted as a direction\r\n\r\n    const x = this.x,\r\n      y = this.y,\r\n      z = this.z\r\n    const e = matrix.elements\r\n\r\n    this.x = e[0] * x + e[4] * y + e[8] * z\r\n    this.y = e[1] * x + e[5] * y + e[9] * z\r\n    this.z = e[2] * x + e[6] * y + e[10] * z\r\n\r\n    return this.normalize()\r\n  }\r\n\r\n  /**\r\n   * Project a 3D coordinate {@link Vec3} to a 2D coordinate {@link Vec3}\r\n   * @param camera - {@link Camera} to use for projection\r\n   * @returns - projected {@link Vec3}\r\n   */\r\n  project(camera: Camera): Vec3 {\r\n    this.applyMat4(camera.viewMatrix).applyMat4(camera.projectionMatrix)\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Unproject a 2D coordinate {@link Vec3} to 3D coordinate {@link Vec3}\r\n   * @param camera - {@link Camera} to use for projection\r\n   * @returns - unprojected {@link Vec3}\r\n   */\r\n  unproject(camera: Camera): Vec3 {\r\n    this.applyMat4(camera.projectionMatrix.getInverse()).applyMat4(camera.modelMatrix)\r\n    return this\r\n  }\r\n}\r\n","import { BufferLayout, getBufferLayout, TypedArray, WGSLVariableType } from '../utils'\nimport { Vec2 } from '../../../math/Vec2'\nimport { Vec3 } from '../../../math/Vec3'\nimport { Quat } from '../../../math/Quat'\nimport { Mat4 } from '../../../math/Mat4'\nimport { throwWarning } from '../../../utils/utils'\nimport { Mat3 } from '../../../math/Mat3'\nimport { InputValue } from '../../../types/BindGroups'\n\n/** Number of slots per row */\nexport const slotsPerRow = 4\n/** Number of bytes per slot */\nexport const bytesPerSlot = 4\n/** Number of bytes per row */\nexport const bytesPerRow = slotsPerRow * bytesPerSlot\n\n/**\n * Defines a position in our array buffer with a row index and a byte index\n */\nexport interface BufferElementAlignmentPosition {\n  /** row index of that position */\n  row: number\n  /** byte index of that position */\n  byte: number\n}\n\n/**\n * Defines our {@link BufferElement} alignment:\n * Keep track of an entry start and end row and bytes indexes (16 bytes per row)\n */\nexport interface BufferElementAlignment {\n  /** The row and byte indexes at which this {@link BufferElement} starts */\n  start: BufferElementAlignmentPosition\n  /** The row and byte indexes at which this {@link BufferElement} ends */\n  end: BufferElementAlignmentPosition\n}\n\n/**\n * Parameters used to create a {@link BufferElement}\n */\nexport interface BufferElementParams {\n  /** The name of the {@link BufferElement} */\n  name: string\n  /** The key of the {@link BufferElement} */\n  key: string\n  /** The WGSL variable type of the {@link BufferElement} */\n  type: WGSLVariableType\n}\n\n/**\n * Used to handle each {@link core/bindings/BufferBinding.BufferBinding#arrayBuffer | buffer binding array} view and data layout alignment.\n * Compute the exact alignment offsets needed to fill an {@link ArrayBuffer} that will be sent to a {@link GPUBuffer}, based on an input type and value.\n * Also update the view array at the correct offset.\n *\n * So all our struct need to be packed into our arrayBuffer using a precise layout.\n * They will be stored in rows, each row made of 4 slots and each slots made of 4 bytes. Depending on the binding element type, its row and slot may vary and we may have to insert empty padded values.\n * All in all it looks like that:<br>\n * <pre>\n *          slot 0    slot 1    slot 2    slot 3\n * row 0 | _ _ _ _ | _ _ _ _ | _ _ _ _ | _ _ _ _ |\n * row 1 | _ _ _ _ | _ _ _ _ | _ _ _ _ | _ _ _ _ |\n * row 2 | _ _ _ _ | _ _ _ _ | _ _ _ _ | _ _ _ _ |\n * </pre>\n * see https://webgpufundamentals.org/webgpu/lessons/resources/wgsl-offset-computer.html\n */\nexport class BufferElement {\n  /** The name of the {@link BufferElement} */\n  name: string\n  /** The WGSL variable type of the {@link BufferElement} */\n  type: WGSLVariableType\n  /** The key of the {@link BufferElement} */\n  key: string\n\n  /** {@link BufferLayout} used to fill the {@link core/bindings/BufferBinding.BufferBinding#arrayBuffer | buffer binding array} at the right offsets */\n  bufferLayout: BufferLayout\n\n  /**\n   * Object defining exactly at which place a binding should be inserted into the {@link core/bindings/BufferBinding.BufferBinding#arrayBuffer | buffer binding array}\n   */\n  alignment: BufferElementAlignment\n\n  /** Array containing the {@link BufferElement} values */\n  view?: TypedArray\n\n  /** Function assigned to set the {@link view} values */\n  setValue: (value: InputValue) => void | null\n\n  /**\n   * BufferElement constructor\n   * @param parameters - {@link BufferElementParams | parameters} used to create our {@link BufferElement}\n   */\n  constructor({ name, key, type = 'f32' }: BufferElementParams) {\n    this.name = name\n    this.key = key\n    this.type = type\n\n    this.bufferLayout = getBufferLayout(this.type.replace('array', '').replace('<', '').replace('>', ''))\n\n    // set init alignment\n    this.alignment = {\n      start: {\n        row: 0,\n        byte: 0,\n      },\n      end: {\n        row: 0,\n        byte: 0,\n      },\n    }\n\n    this.setValue = null\n  }\n\n  /**\n   * Get the total number of rows used by this {@link BufferElement}\n   * @readonly\n   */\n  get rowCount(): number {\n    return this.alignment.end.row - this.alignment.start.row + 1\n  }\n\n  /**\n   * Get the total number of bytes used by this {@link BufferElement} based on {@link BufferElementAlignment | alignment} start and end offsets\n   * @readonly\n   */\n  get byteCount(): number {\n    return Math.abs(this.endOffset - this.startOffset) + 1\n  }\n\n  /**\n   * Get the total number of bytes used by this {@link BufferElement}, including final padding\n   * @readonly\n   */\n  get paddedByteCount(): number {\n    return (this.alignment.end.row + 1) * bytesPerRow\n  }\n\n  /**\n   * Get the offset (i.e. byte index) at which our {@link BufferElement} starts\n   * @readonly\n   */\n  get startOffset(): number {\n    return this.getByteCountAtPosition(this.alignment.start)\n  }\n\n  /**\n   * Get the array offset (i.e. array index) at which our {@link BufferElement} starts\n   * @readonly\n   */\n  get startOffsetToIndex(): number {\n    return this.startOffset / bytesPerSlot\n  }\n\n  /**\n   * Get the offset (i.e. byte index) at which our {@link BufferElement} ends\n   * @readonly\n   */\n  get endOffset(): number {\n    return this.getByteCountAtPosition(this.alignment.end)\n  }\n\n  /**\n   * Get the array offset (i.e. array index) at which our {@link BufferElement} ends\n   * @readonly\n   */\n  get endOffsetToIndex(): number {\n    return Math.floor(this.endOffset / bytesPerSlot)\n  }\n\n  /**\n   * Get the position at given offset (i.e. byte index)\n   * @param offset - byte index to use\n   */\n  getPositionAtOffset(offset = 0): BufferElementAlignmentPosition {\n    return {\n      row: Math.floor(offset / bytesPerRow),\n      byte: offset % bytesPerRow,\n    }\n  }\n\n  /**\n   * Get the number of bytes at a given {@link BufferElementAlignmentPosition | position}\n   * @param position - {@link BufferElementAlignmentPosition | position} from which to count\n   * @returns - byte count at the given {@link BufferElementAlignmentPosition | position}\n   */\n  getByteCountAtPosition(position: BufferElementAlignmentPosition = { row: 0, byte: 0 }): number {\n    return position.row * bytesPerRow + position.byte\n  }\n\n  /**\n   * Check that a {@link BufferElementAlignmentPosition#byte | byte position} does not overflow its max value (16)\n   * @param position - {@link BufferElementAlignmentPosition | position}\n   * @returns - updated {@link BufferElementAlignmentPosition | position}\n   */\n  applyOverflowToPosition(\n    position: BufferElementAlignmentPosition = { row: 0, byte: 0 }\n  ): BufferElementAlignmentPosition {\n    if (position.byte > bytesPerRow - 1) {\n      const overflow = position.byte % bytesPerRow\n      position.row += Math.floor(position.byte / bytesPerRow)\n      position.byte = overflow\n    }\n\n    return position\n  }\n\n  /**\n   * Get the number of bytes between two {@link BufferElementAlignmentPosition | positions}\n   * @param p1 - first {@link BufferElementAlignmentPosition | position}\n   * @param p2 - second {@link BufferElementAlignmentPosition | position}\n   * @returns - number of bytes\n   */\n  getByteCountBetweenPositions(\n    p1: BufferElementAlignmentPosition = { row: 0, byte: 0 },\n    p2: BufferElementAlignmentPosition = { row: 0, byte: 0 }\n  ): number {\n    return Math.abs(this.getByteCountAtPosition(p2) - this.getByteCountAtPosition(p1))\n  }\n\n  /**\n   * Compute the right alignment (i.e. start and end rows and bytes) given the size and align properties and the next available {@link BufferElementAlignmentPosition | position}\n   * @param nextPositionAvailable - next {@link BufferElementAlignmentPosition | position} at which we should insert this element\n   * @returns - computed {@link BufferElementAlignment | alignment}\n   */\n  getElementAlignment(\n    nextPositionAvailable: BufferElementAlignmentPosition = { row: 0, byte: 0 }\n  ): BufferElementAlignment {\n    const alignment = {\n      start: nextPositionAvailable,\n      end: nextPositionAvailable,\n    }\n\n    const { size, align } = this.bufferLayout\n\n    // check the alignment, i.e. even if there's enough space for our binding\n    // we might have to pad the slot because some types need a specific alignment\n    if (nextPositionAvailable.byte % align !== 0) {\n      nextPositionAvailable.byte += nextPositionAvailable.byte % align\n    }\n\n    if (size <= bytesPerRow && nextPositionAvailable.byte + size > bytesPerRow) {\n      // in the case of a binding that could fit on one row\n      // but we don't have space on the current row for this binding element\n      // go to next row\n      nextPositionAvailable.row += 1\n      nextPositionAvailable.byte = 0\n    } else if (size > bytesPerRow && (nextPositionAvailable.byte > bytesPerRow || nextPositionAvailable.byte > 0)) {\n      // there's also the case where the binding size is too big\n      // and we have already padded it above\n      // or we've just started a new row\n      // but the binding size is too big to fit in one row\n      // just go to next row as well\n      nextPositionAvailable.row += 1\n      nextPositionAvailable.byte = 0\n    }\n\n    alignment.end = {\n      row: nextPositionAvailable.row + Math.ceil(size / bytesPerRow) - 1,\n      byte: nextPositionAvailable.byte + (size % bytesPerRow === 0 ? bytesPerRow - 1 : (size % bytesPerRow) - 1), // end of row ? then it ends on slot (bytesPerRow - 1)\n    }\n\n    // now final check, if end slot has overflown\n    alignment.end = this.applyOverflowToPosition(alignment.end)\n\n    return alignment\n  }\n\n  /**\n   * Set the {@link BufferElementAlignment | alignment} from a {@link BufferElementAlignmentPosition | position}\n   * @param position - {@link BufferElementAlignmentPosition | position} at which to start inserting the values in the {@link !core/bindings/BufferBinding.BufferBinding#arrayBuffer | buffer binding array}\n   */\n  setAlignmentFromPosition(position: BufferElementAlignmentPosition = { row: 0, byte: 0 }) {\n    this.alignment = this.getElementAlignment(position)\n  }\n\n  /**\n   * Set the {@link BufferElementAlignment | alignment} from an offset (byte count)\n   * @param startOffset - offset at which to start inserting the values in the {@link core/bindings/BufferBinding.BufferBinding#arrayBuffer | buffer binding array}\n   */\n  setAlignment(startOffset = 0) {\n    this.setAlignmentFromPosition(this.getPositionAtOffset(startOffset))\n  }\n\n  /**\n   * Set the {@link view}\n   * @param arrayBuffer - the {@link core/bindings/BufferBinding.BufferBinding#arrayBuffer | buffer binding array}\n   * @param arrayView - the {@link core/bindings/BufferBinding.BufferBinding#arrayView | buffer binding array view}\n   */\n  setView(arrayBuffer: ArrayBuffer, arrayView: DataView) {\n    this.view = new this.bufferLayout.View(\n      arrayBuffer,\n      this.startOffset,\n      this.byteCount / this.bufferLayout.View.BYTES_PER_ELEMENT\n    )\n  }\n\n  /**\n   * Set the {@link view} value from a float or an int\n   * @param value - float or int to use\n   */\n  setValueFromFloat(value: number) {\n    this.view[0] = value as number\n  }\n\n  /**\n   * Set the {@link view} value from a {@link Vec2} or an array\n   * @param value - {@link Vec2} or array to use\n   */\n  setValueFromVec2(value: Vec2 | number[]) {\n    this.view[0] = (value as Vec2).x ?? value[0] ?? 0\n    this.view[1] = (value as Vec2).y ?? value[1] ?? 0\n  }\n\n  /**\n   * Set the {@link view} value from a {@link Vec3} or an array\n   * @param value - {@link Vec3} or array to use\n   */\n  setValueFromVec3(value: Vec3 | number[]) {\n    this.view[0] = (value as Vec3).x ?? value[0] ?? 0\n    this.view[1] = (value as Vec3).y ?? value[1] ?? 0\n    this.view[2] = (value as Vec3).z ?? value[2] ?? 0\n  }\n\n  /**\n   * Set the {@link view} value from a {@link Mat4} or {@link Quat}\n   * @param value - {@link Mat4} or {@link Quat} to use\n   */\n  setValueFromMat4OrQuat(value: Mat4 | Quat) {\n    this.view.set(value.elements)\n  }\n\n  /**\n   * Set the {@link view} value from a {@link Mat3}\n   * @param value - {@link Mat3} to use\n   */\n  setValueFromMat3(value: Mat3) {\n    // mat3x3f are padded!\n    this.setValueFromArrayWithPad(value.elements)\n  }\n\n  /**\n   * Set the {@link view} value from an array\n   * @param value - array to use\n   */\n  setValueFromArray(value: number[] | TypedArray) {\n    this.view.set(value as number[] | TypedArray)\n  }\n\n  /**\n   * Set the {@link view} value from an array with pad applied\n   * @param value - array to use\n   */\n  setValueFromArrayWithPad(value: number[] | TypedArray) {\n    for (\n      let i = 0, offset = 0;\n      i < this.view.length;\n      i += this.bufferLayout.pad[0] + this.bufferLayout.pad[1], offset++\n    ) {\n      for (let j = 0; j < this.bufferLayout.pad[0]; j++) {\n        this.view[i + j] = value[i + j - offset]\n      }\n    }\n  }\n\n  /**\n   * Update the {@link view} based on the new value\n   * @param value - new value to use\n   */\n  update(value: InputValue) {\n    if (!this.setValue) {\n      this.setValue = ((value) => {\n        if (this.type === 'f32' || this.type === 'u32' || this.type === 'i32') {\n          return this.setValueFromFloat\n        } else if (this.type === 'vec2f') {\n          return this.setValueFromVec2\n        } else if (this.type === 'vec3f') {\n          return this.setValueFromVec3\n        } else if (this.type === 'mat3x3f') {\n          return (value as Mat3).elements ? this.setValueFromMat3 : this.setValueFromArrayWithPad\n        } else if ((value as Quat | Mat4).elements) {\n          return this.setValueFromMat4OrQuat\n        } else if (ArrayBuffer.isView(value) || Array.isArray(value)) {\n          if (!this.bufferLayout.pad) {\n            return this.setValueFromArray\n          } else {\n            return this.setValueFromArrayWithPad\n          }\n        } else {\n          throwWarning(`${this.constructor.name}: value passed to ${this.name} cannot be used: ${value}`)\n        }\n      })(value)\n    }\n\n    this.setValue(value)\n  }\n\n  /**\n   * Extract the data corresponding to this specific {@link BufferElement} from a {@link Float32Array} holding the {@link GPUBuffer} data of the parentMesh {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}\n   * @param result - {@link Float32Array} holding {@link GPUBuffer} data\n   * @returns - extracted data from the {@link Float32Array}\n   */\n  extractDataFromBufferResult(result: Float32Array) {\n    return result.slice(this.startOffsetToIndex, this.endOffsetToIndex)\n  }\n}\n","import { BufferElement, BufferElementParams, bytesPerSlot } from './BufferElement'\r\nimport { TypedArray } from '../utils'\r\n\r\n/**\r\n * Parameters used to create a {@link BufferArrayElement}\r\n */\r\nexport interface BufferArrayElementParams extends BufferElementParams {\r\n  /** Initial length of the input {@link core/bindings/BufferBinding.BufferBinding#arrayBuffer | buffer binding array} */\r\n  arrayLength: number\r\n}\r\n\r\n/**\r\n * Used to handle specific array {@link core/bindings/BufferBinding.BufferBinding | BufferBinding} types\r\n */\r\nexport class BufferArrayElement extends BufferElement {\r\n  /** Initial length of the input {@link core/bindings/BufferBinding.BufferBinding#arrayBuffer | buffer binding array} */\r\n  arrayLength: number\r\n  /** Total number of elements (i.e. {@link arrayLength} divided by {@link core/bindings/utils.BufferLayout | buffer layout} number of elements */\r\n  numElements: number\r\n  /** Number of bytes in the {@link ArrayBuffer} between two elements {@link startOffset} */\r\n  arrayStride: number\r\n\r\n  /**\r\n   * BufferArrayElement constructor\r\n   * @param parameters - {@link BufferArrayElementParams | parameters} used to create our {@link BufferArrayElement}\r\n   */\r\n  constructor({ name, key, type = 'f32', arrayLength = 1 }: BufferArrayElementParams) {\r\n    super({ name, key, type })\r\n\r\n    this.arrayLength = arrayLength\r\n    this.numElements = Math.ceil(this.arrayLength / this.bufferLayout.numElements)\r\n  }\r\n\r\n  /**\r\n   * Get the array stride between two elements of the array, in indices\r\n   * @readonly\r\n   */\r\n  get arrayStrideToIndex(): number {\r\n    return this.arrayStride / bytesPerSlot\r\n  }\r\n\r\n  /**\r\n   * Set the {@link core/bindings/bufferElements/BufferElement.BufferElementAlignment | alignment}\r\n   * To compute how arrays are packed, we get the second item alignment as well and use it to calculate the arrayStride between two array elements. Using the arrayStride and the total number of elements, we can easily get the end alignment position.\r\n   * @param startOffset - offset at which to start inserting the values in the {@link core/bindings/BufferBinding.BufferBinding#arrayBuffer | buffer binding array buffer}\r\n   */\r\n  setAlignment(startOffset = 0) {\r\n    super.setAlignment(startOffset)\r\n\r\n    // repeat for a second element to know how things are laid out\r\n    const nextAlignment = this.getElementAlignment(this.getPositionAtOffset(this.endOffset + 1))\r\n    this.arrayStride = this.getByteCountBetweenPositions(this.alignment.end, nextAlignment.end)\r\n\r\n    this.alignment.end = this.getPositionAtOffset(this.endOffset + this.arrayStride * (this.numElements - 1))\r\n  }\r\n\r\n  /**\r\n   * Set the strided {@link view} value from an array\r\n   * @param value - array to use\r\n   */\r\n  setValueFromArray(value: number[] | TypedArray) {\r\n    let valueIndex = 0\r\n\r\n    const viewLength = this.byteCount / this.bufferLayout.View.BYTES_PER_ELEMENT\r\n    // arrayStride is our view length divided by the number of elements in our array\r\n    const stride = Math.ceil(viewLength / this.numElements)\r\n\r\n    for (let i = 0; i < this.numElements; i++) {\r\n      for (let j = 0; j < this.bufferLayout.numElements; j++) {\r\n        this.view[j + i * stride] = value[valueIndex]\r\n\r\n        valueIndex++\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { BufferArrayElement, BufferArrayElementParams } from './BufferArrayElement'\r\nimport { InputValue } from '../../../types/BindGroups'\r\n\r\n/**\r\n * Used to compute alignment when dealing with arrays of Struct\r\n */\r\nexport class BufferInterleavedArrayElement extends BufferArrayElement {\r\n  /** Corresponding {@link DataView} set function based on {@link view} type */\r\n  viewSetFunction: DataView['setInt32'] | DataView['setUint16'] | DataView['setUint32'] | DataView['setFloat32']\r\n\r\n  /**\r\n   * BufferInterleavedArrayElement constructor\r\n   * @param parameters - {@link BufferArrayElementParams | parameters} used to create our {@link BufferInterleavedArrayElement}\r\n   */\r\n  constructor({ name, key, type = 'f32', arrayLength = 1 }: BufferArrayElementParams) {\r\n    super({ name, key, type, arrayLength })\r\n\r\n    this.arrayStride = 1\r\n\r\n    this.arrayLength = arrayLength\r\n    this.numElements = Math.ceil(this.arrayLength / this.bufferLayout.numElements)\r\n  }\r\n\r\n  /**\r\n   * Get the total number of slots used by this {@link BufferInterleavedArrayElement} based on buffer layout size and total number of elements\r\n   * @readonly\r\n   */\r\n  get byteCount(): number {\r\n    return this.bufferLayout.size * this.numElements\r\n  }\r\n\r\n  /**\r\n   * Set the {@link core/bindings/bufferElements/BufferElement.BufferElementAlignment | alignment}\r\n   * To compute how arrays are packed, we need to compute the arrayStride between two elements beforehand and pass it here. Using the arrayStride and the total number of elements, we can easily get the end alignment position.\r\n   * @param startOffset - offset at which to start inserting the values in the {@link core/bindings/BufferBinding.BufferBinding#arrayBuffer | buffer binding array}\r\n   * @param stride - Stride in the {@link ArrayBuffer} between two elements of the array\r\n   */\r\n  setAlignment(startOffset = 0, stride = 0) {\r\n    this.alignment = this.getElementAlignment(this.getPositionAtOffset(startOffset))\r\n\r\n    this.arrayStride = stride\r\n\r\n    this.alignment.end = this.getPositionAtOffset(this.endOffset + stride * (this.numElements - 1))\r\n  }\r\n\r\n  /**\r\n   * Set the {@link view} and {@link viewSetFunction}\r\n   * @param arrayBuffer - the {@link core/bindings/BufferBinding.BufferBinding#arrayBuffer | buffer binding array}\r\n   * @param arrayView - the {@link core/bindings/BufferBinding.BufferBinding#arrayView | buffer binding array view}\r\n   */\r\n  setView(arrayBuffer: ArrayBuffer, arrayView: DataView) {\r\n    // our view will be a simple typed array, not linked to the array buffer\r\n    this.view = new this.bufferLayout.View(this.bufferLayout.numElements * this.numElements)\r\n\r\n    // but our viewSetFunction is linked to the array view\r\n    this.viewSetFunction = ((arrayView) => {\r\n      switch (this.bufferLayout.View) {\r\n        case Int32Array:\r\n          return arrayView.setInt32.bind(arrayView) as DataView['setInt32']\r\n        case Uint16Array:\r\n          return arrayView.setUint16.bind(arrayView) as DataView['setUint16']\r\n        case Uint32Array:\r\n          return arrayView.setUint32.bind(arrayView) as DataView['setUint32']\r\n        case Float32Array:\r\n        default:\r\n          return arrayView.setFloat32.bind(arrayView) as DataView['setFloat32']\r\n      }\r\n    })(arrayView)\r\n  }\r\n\r\n  /**\r\n   * Update the {@link view} based on the new value, and then update the {@link core/bindings/BufferBinding.BufferBinding#arrayView | buffer binding array view} using sub arrays\r\n   * @param value - new value to use\r\n   */\r\n  update(value: InputValue) {\r\n    super.update(value)\r\n\r\n    // now use our viewSetFunction to fill the array view with interleaved alignment\r\n    for (let i = 0; i < this.numElements; i++) {\r\n      const subarray = this.view.subarray(\r\n        i * this.bufferLayout.numElements,\r\n        i * this.bufferLayout.numElements + this.bufferLayout.numElements\r\n      )\r\n\r\n      const startByteOffset = this.startOffset + i * this.arrayStride\r\n\r\n      // view set function need to be called for each subarray entry, so loop over subarray entries\r\n      subarray.forEach((value, index) => {\r\n        this.viewSetFunction(startByteOffset + index * this.bufferLayout.View.BYTES_PER_ELEMENT, value, true)\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract the data corresponding to this specific {@link BufferInterleavedArrayElement} from a {@link Float32Array} holding the {@link GPUBuffer} data of the parentMesh {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}\r\n   * @param result - {@link Float32Array} holding {@link GPUBuffer} data\r\n   */\r\n  extractDataFromBufferResult(result: Float32Array) {\r\n    const interleavedResult = new Float32Array(this.arrayLength)\r\n    for (let i = 0; i < this.numElements; i++) {\r\n      const resultOffset = this.startOffsetToIndex + i * this.arrayStrideToIndex\r\n\r\n      for (let j = 0; j < this.bufferLayout.numElements; j++) {\r\n        interleavedResult[i * this.bufferLayout.numElements + j] = result[resultOffset + j]\r\n      }\r\n    }\r\n    return interleavedResult\r\n  }\r\n}\r\n","// buffers bitwise flags\r\nimport { WebGPUBufferUsageConstants } from '../../utils/webgpu-constants'\r\nimport { BufferBindingType } from '../bindings/Binding'\r\n\r\n/**  Defines all kinds of allowed buffer usages as camel case strings. */\r\nexport type BufferUsageKeys =\r\n  | 'copySrc'\r\n  | 'copyDst'\r\n  | 'index'\r\n  | 'indirect'\r\n  | 'mapRead'\r\n  | 'mapWrite'\r\n  | 'queryResolve'\r\n  | 'vertex'\r\n  | BufferBindingType\r\n\r\n/**\r\n * Map {@link BufferUsageKeys | buffer usage names} with actual {@link GPUBufferUsageFlags | buffer usage bitwise flags}.\r\n */\r\nconst bufferUsages: Map<BufferUsageKeys, GPUBufferUsageFlags> = new Map([\r\n  ['copySrc', WebGPUBufferUsageConstants.COPY_SRC],\r\n  ['copyDst', WebGPUBufferUsageConstants.COPY_DST],\r\n  ['index', WebGPUBufferUsageConstants.INDEX],\r\n  ['indirect', WebGPUBufferUsageConstants.INDIRECT],\r\n  ['mapRead', WebGPUBufferUsageConstants.MAP_READ],\r\n  ['mapWrite', WebGPUBufferUsageConstants.MAP_WRITE],\r\n  ['queryResolve', WebGPUBufferUsageConstants.QUERY_RESOLVE],\r\n  ['storage', WebGPUBufferUsageConstants.STORAGE],\r\n  ['uniform', WebGPUBufferUsageConstants.UNIFORM],\r\n  ['vertex', WebGPUBufferUsageConstants.VERTEX],\r\n])\r\n\r\n/**\r\n * Get the corresponding {@link GPUBufferUsageFlags | buffer usage bitwise flags} based on an array of {@link BufferUsageKeys | buffer usage names}.\r\n * @param usages - array of {@link BufferUsageKeys | buffer usage names}.\r\n * @returns - corresponding {@link GPUBufferUsageFlags | buffer usage bitwise flags}.\r\n */\r\nexport const getBufferUsages = (usages: BufferUsageKeys[] = []): GPUBufferUsageFlags => {\r\n  return usages.reduce((acc, v) => {\r\n    return acc | bufferUsages.get(v)\r\n  }, 0)\r\n}\r\n","import { generateUUID } from '../../utils/utils'\r\nimport { BufferUsageKeys, getBufferUsages } from './utils'\r\n\r\n/**\r\n * Parameters used to create a {@link Buffer}.\r\n */\r\nexport interface BufferParams extends Partial<Omit<GPUBufferDescriptor, 'usage'>> {\r\n  /** Allowed usages for the {@link Buffer#GPUBuffer | GPU buffer} as an array of {@link BufferUsageKeys | buffer usages names} */\r\n  usage?: BufferUsageKeys[]\r\n}\r\n\r\n/**\r\n * Used as a wrapper around {@link GPUBuffer}.\r\n *\r\n * Useful to keep tracks of all the {@link GPUBuffer} created thanks to the {@link uuid} property.\r\n */\r\nexport class Buffer {\r\n  /** The type of the {@link Buffer} */\r\n  type: string\r\n  /** The universal unique id of the {@link Buffer} */\r\n  uuid: string\r\n  /** Options used to create this {@link Buffer}, also used as {@link GPUBufferDescriptor} */\r\n  options: GPUBufferDescriptor\r\n\r\n  /** The actual {@link GPUBuffer} after having been created. */\r\n  GPUBuffer: null | GPUBuffer\r\n\r\n  /** A Set to store this {@link Buffer} consumers (usually {@link core/geometries/Geometry.Geometry#uuid | Geometry uuid} or {@link core/bindGroups/BindGroup.BindGroup#uuid | BindGroup uuid}) */\r\n  consumers: Set<string>\r\n\r\n  /**\r\n   * Buffer constructor\r\n   * @param parameters - {@link GPUBufferDescriptor | parameters} used to create our Buffer\r\n   */\r\n  constructor(\r\n    {\r\n      label = 'Buffer',\r\n      size = 0,\r\n      usage = ['copySrc', 'copyDst'],\r\n      mappedAtCreation = false,\r\n    }: BufferParams = {} as BufferParams\r\n  ) {\r\n    this.type = 'Buffer'\r\n\r\n    this.reset()\r\n\r\n    this.uuid = generateUUID()\r\n\r\n    this.consumers = new Set()\r\n\r\n    this.options = {\r\n      label,\r\n      size,\r\n      usage: getBufferUsages(usage),\r\n      mappedAtCreation,\r\n    }\r\n  }\r\n\r\n  /** Reset the {@link GPUBuffer} value to `null`. */\r\n  reset() {\r\n    this.GPUBuffer = null\r\n  }\r\n\r\n  /** Allow to dynamically set the size of the {@link GPUBuffer}. */\r\n  set size(value: number) {\r\n    this.options.size = value\r\n  }\r\n\r\n  /**\r\n   * Create a {@link GPUBuffer} based on the descriptor stored in the {@link options | Buffer options}.\r\n   * @param renderer - {@link core/renderers/GPURenderer.GPURenderer | renderer} used to create the {@link GPUBuffer}.\r\n   * @param options - optional way to update the {@link options} previously set before creating the {@link GPUBuffer}.\r\n   */\r\n  createBuffer(renderer, options: BufferParams = {}) {\r\n    const { usage, ...staticOptions } = options\r\n\r\n    this.options = {\r\n      ...this.options,\r\n      ...staticOptions,\r\n      ...(usage !== undefined && { usage: getBufferUsages(usage) }),\r\n    }\r\n\r\n    this.setBuffer(renderer.createBuffer(this))\r\n  }\r\n\r\n  /**\r\n   * Set the {@link GPUBuffer}. This allows to use a {@link Buffer} with a {@link GPUBuffer} created separately.\r\n   * @param GPUBuffer - GPU buffer to use.\r\n   */\r\n  setBuffer(GPUBuffer: GPUBuffer) {\r\n    this.GPUBuffer = GPUBuffer\r\n  }\r\n\r\n  /**\r\n   * Copy an {@link Buffer#GPUBuffer | Buffer GPUBuffer} and its {@link options} into this {@link Buffer}.\r\n   * @param buffer - {@link Buffer} to use for the copy.\r\n   * @param destroyPreviousBuffer - whether to destroy the previous {@link Buffer} before the copy.\r\n   */\r\n  copy(buffer: Buffer, destroyPreviousBuffer: boolean = false) {\r\n    if (destroyPreviousBuffer) {\r\n      this.destroy()\r\n    }\r\n\r\n    this.options = buffer.options\r\n    this.GPUBuffer = buffer.GPUBuffer\r\n    this.consumers = new Set([...this.consumers, ...buffer.consumers])\r\n  }\r\n\r\n  /**\r\n   * Map the {@link GPUBuffer} and put a copy of the data into a {@link Float32Array}.\r\n   * @async\r\n   * @returns - {@link Float32Array} holding the {@link GPUBuffer} data.\r\n   */\r\n  async mapBufferAsync() {\r\n    if (!this.GPUBuffer || this.GPUBuffer.mapState !== 'unmapped') return new Float32Array(0)\r\n\r\n    await this.GPUBuffer.mapAsync(GPUMapMode.READ)\r\n    const result = new Float32Array(this.GPUBuffer.getMappedRange().slice(0))\r\n    this.GPUBuffer.unmap()\r\n\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * Destroy the {@link GPUBuffer} and {@link reset} its value.\r\n   */\r\n  destroy() {\r\n    this.GPUBuffer?.destroy()\r\n    this.reset()\r\n    this.consumers.clear()\r\n  }\r\n}\r\n","import { Binding, BindingParams, BufferBindingMemoryAccessType, BufferBindingType } from './Binding'\nimport { getBindGroupLayoutBindingType, getBindingWGSLVarType, getBufferLayout, TypedArray } from './utils'\nimport { throwWarning, toCamelCase, toKebabCase } from '../../utils/utils'\nimport { Vec2 } from '../../math/Vec2'\nimport { Vec3 } from '../../math/Vec3'\nimport { Input, InputBase, InputValue } from '../../types/BindGroups'\nimport { BufferElement, bytesPerRow } from './bufferElements/BufferElement'\nimport { BufferArrayElement } from './bufferElements/BufferArrayElement'\nimport { BufferInterleavedArrayElement } from './bufferElements/BufferInterleavedArrayElement'\nimport { Buffer, BufferParams } from '../buffers/Buffer'\n\n/**\n * Defines a {@link BufferBinding} input object that can set a value and run a callback function when this happens\n */\nexport interface BufferBindingInput extends InputBase {\n  /** Original {@link InputValue | input value} */\n  _value: InputValue\n\n  /** Get the {@link InputValue | input value} */\n  get value(): InputValue\n\n  /** Set the {@link InputValue | input value} */\n  set value(value: InputValue)\n\n  /** Whether the {@link InputValue | input value} has changed and we should update the {@link BufferBinding#arrayBuffer | buffer binding array} */\n  shouldUpdate: boolean\n\n  /** {@link BufferBindingInput} name */\n  name: string\n}\n\n/**\n * Base parameters used to create a {@link BufferBinding}\n */\nexport interface BufferBindingBaseParams {\n  /** Whether this {@link BufferBinding} should use structured WGSL variables */\n  useStruct?: boolean\n  /** {@link BufferBinding} memory access types (read only or read/write) */\n  access?: BufferBindingMemoryAccessType\n  /** Object containing one or multiple {@link Input | inputs} describing the structure of the {@link BufferBinding} */\n  struct?: Record<string, Input>\n  /** Allowed usages for the {@link BufferBinding#buffer} as an array of {@link core/buffers/utils.BufferUsageKeys | buffer usages names} */\n  usage?: BufferParams['usage']\n}\n\n/**\n * Parameters used to create a {@link BufferBinding}\n */\nexport interface BufferBindingParams extends BindingParams, BufferBindingBaseParams {\n  /** The binding type of the {@link BufferBinding} */\n  bindingType?: BufferBindingType\n\n  /** Optional array of already created {@link BufferBinding} to add to this {@link BufferBinding}. */\n  bindings?: BufferBinding[]\n}\n\n/** All allowed {@link BufferElement | buffer elements} */\nexport type AllowedBufferElement = BufferElement | BufferArrayElement | BufferInterleavedArrayElement\n\n/**\n * Used to format {@link BufferBindingParams#struct | uniforms or storages struct inputs} and create a single typed array that will hold all those inputs values. The array needs to be correctly padded depending on every value type, so it can be safely used as a GPUBuffer input.<br>\n * It will also create WGSL Structs and variables according to the BufferBindings inputs parameters.<br>\n * The WGSL structs and variables declaration may vary based on the input types, especially if there's one or more arrays involved (i.e. `array<f32>`, `array<vec3f>` etc.).\n *\n * @example\n * ```javascript\n * // create a GPU buffer binding\n * const bufferBinding = new BufferBinding({\n *   name: 'params', // name of the WGSL object\n *   bindingType: 'uniform', // should be 'storage' for large arrays\n *   struct: {\n *     opacity: {\n *       type: 'f32',\n *       value: 1,\n *     },\n *     mousePosition: {\n *       type: 'vec2f',\n *       value: new Vec2(),\n *     },\n *   },\n * })\n * ```\n */\nexport class BufferBinding extends Binding {\n  /** The binding type of the {@link BufferBinding} */\n  bindingType: BufferBindingType\n  /** Flag to indicate whether this {@link BufferBinding} {@link bufferElements | buffer elements} should be packed in a single structured object or if each one of them should be a separate binding. */\n  useStruct: boolean\n  /** All the {@link BufferBinding} data inputs */\n  inputs: Record<string, BufferBindingInput>\n\n  /** Flag to indicate whether one of the {@link inputs} value has changed and we need to update the GPUBuffer linked to the {@link arrayBuffer} array */\n  shouldUpdate: boolean\n\n  /** An array describing how each corresponding {@link inputs} should be inserted into our {@link arrayView} array */\n  bufferElements: AllowedBufferElement[]\n\n  /** Total size of our {@link arrayBuffer} array in bytes */\n  arrayBufferSize: number\n  /** Array buffer that will be sent to the {@link GPUBuffer} */\n  arrayBuffer: ArrayBuffer\n  /** Data view of our {@link arrayBuffer | array buffer} */\n  arrayView: DataView\n\n  /** The {@link Buffer} holding the {@link GPUBuffer}  */\n  buffer: Buffer\n\n  /** A string to append to our shaders code describing the WGSL structure representing this {@link BufferBinding} */\n  wgslStructFragment: string\n  /** An array of strings to append to our shaders code declaring all the WGSL variables representing this {@link BufferBinding} */\n  wgslGroupFragment: string[]\n  /** Options used to create this {@link BufferBinding} */\n  options: BufferBindingParams\n\n  /**\n   * BufferBinding constructor\n   * @param parameters - {@link BufferBindingParams | parameters} used to create our BufferBindings\n   */\n  constructor({\n    label = 'Uniform',\n    name = 'uniform',\n    bindingType,\n    visibility,\n    useStruct = true,\n    access = 'read',\n    usage = [],\n    struct = {},\n    bindings = [],\n  }: BufferBindingParams) {\n    bindingType = bindingType ?? 'uniform'\n\n    super({ label, name, bindingType, visibility })\n\n    this.options = {\n      ...this.options,\n      useStruct,\n      access,\n      usage,\n      struct,\n      bindings,\n    }\n\n    this.cacheKey += `${useStruct},${access},`\n\n    this.arrayBufferSize = 0\n\n    this.shouldUpdate = false\n    this.useStruct = useStruct\n\n    this.bufferElements = []\n    this.inputs = {}\n    this.buffer = new Buffer()\n\n    if (Object.keys(struct).length) {\n      this.setBindings(struct)\n      this.setInputsAlignment()\n    }\n\n    if (Object.keys(struct).length || this.options.bindings.length) {\n      this.setBufferAttributes()\n      this.setWGSLFragment()\n    }\n  }\n\n  /**\n   * Get {@link GPUBindGroupLayoutEntry#buffer | bind group layout entry resource}\n   * @readonly\n   */\n  get resourceLayout(): {\n    /** {@link GPUBindGroupLayout | bind group layout} resource */\n    buffer: GPUBufferBindingLayout\n  } {\n    return {\n      buffer: {\n        type: getBindGroupLayoutBindingType(this),\n      },\n    }\n  }\n\n  /**\n   * Get the resource cache key\n   * @readonly\n   */\n  get resourceLayoutCacheKey(): string {\n    return `buffer,${getBindGroupLayoutBindingType(this)},${this.visibility},`\n  }\n\n  /**\n   * Get {@link GPUBindGroupEntry#resource | bind group resource}\n   * @readonly\n   */\n  get resource(): {\n    /** {@link GPUBindGroup | bind group} resource */\n    buffer: GPUBuffer | null\n  } {\n    return { buffer: this.buffer.GPUBuffer }\n  }\n\n  /**\n   * Clone this {@link BufferBinding} into a new one. Allows to skip buffer layout alignment computations.\n   * @param params - params to use for cloning\n   */\n  clone(params: BufferBindingParams) {\n    const { struct, ...defaultParams } = params\n\n    const bufferBindingCopy = new (this.constructor as typeof BufferBinding)(defaultParams)\n    struct && bufferBindingCopy.setBindings(struct)\n    bufferBindingCopy.options.struct = struct\n\n    bufferBindingCopy.arrayBufferSize = this.arrayBufferSize\n\n    bufferBindingCopy.arrayBuffer = new ArrayBuffer(bufferBindingCopy.arrayBufferSize)\n    bufferBindingCopy.arrayView = new DataView(\n      bufferBindingCopy.arrayBuffer,\n      0,\n      bufferBindingCopy.arrayBuffer.byteLength\n    )\n\n    bufferBindingCopy.buffer.size = bufferBindingCopy.arrayBuffer.byteLength\n\n    this.bufferElements.forEach((bufferElement: BufferArrayElement) => {\n      const newBufferElement = new (bufferElement.constructor as typeof BufferArrayElement)({\n        name: bufferElement.name,\n        key: bufferElement.key,\n        type: bufferElement.type,\n        ...(bufferElement.arrayLength && {\n          arrayLength: bufferElement.arrayLength,\n        }),\n      })\n\n      newBufferElement.alignment = JSON.parse(JSON.stringify(bufferElement.alignment))\n      if (bufferElement.arrayStride) {\n        newBufferElement.arrayStride = bufferElement.arrayStride\n      }\n\n      newBufferElement.setView(bufferBindingCopy.arrayBuffer, bufferBindingCopy.arrayView)\n      bufferBindingCopy.bufferElements.push(newBufferElement)\n    })\n\n    // TODO bindings\n\n    if (this.name === bufferBindingCopy.name && this.label === bufferBindingCopy.label) {\n      bufferBindingCopy.wgslStructFragment = this.wgslStructFragment\n      bufferBindingCopy.wgslGroupFragment = this.wgslGroupFragment\n    } else {\n      bufferBindingCopy.setWGSLFragment()\n    }\n\n    bufferBindingCopy.shouldUpdate = bufferBindingCopy.arrayBufferSize > 0\n\n    return bufferBindingCopy\n  }\n\n  /**\n   * Format bindings struct and set our {@link inputs}\n   * @param bindings - bindings inputs\n   */\n  setBindings(bindings: Record<string, Input>) {\n    for (const bindingKey of Object.keys(bindings)) {\n      const binding = {} as BufferBindingInput\n\n      for (const key in bindings[bindingKey]) {\n        if (key !== 'value') {\n          binding[key] = bindings[bindingKey][key]\n        }\n      }\n\n      // binding name is the key\n      binding.name = bindingKey\n\n      // define a \"value\" getter/setter so we can now when to update the buffer binding\n      Object.defineProperty(binding, 'value', {\n        get() {\n          return binding._value\n        },\n        set(v) {\n          binding._value = v\n          binding.shouldUpdate = true\n        },\n      })\n\n      binding.value = bindings[bindingKey].value\n\n      if (binding.value instanceof Vec2 || binding.value instanceof Vec3) {\n        // add binding update to _onChangeCallback\n        const _onChangeCallback = binding.value._onChangeCallback\n\n        binding.value._onChangeCallback = () => {\n          if (_onChangeCallback) {\n            _onChangeCallback()\n          }\n\n          binding.shouldUpdate = true\n        }\n      }\n\n      this.inputs[bindingKey] = binding\n\n      this.cacheKey += `${bindingKey},${bindings[bindingKey].type},`\n    }\n  }\n\n  /**\n   * Set the buffer alignments from {@link inputs}.\n   */\n  setInputsAlignment() {\n    // early on, check if there's at least one array binding\n    // If there's one and only one, put it at the end of the binding elements array, treat it as a single entry of the type, but loop on it by array.length / size to fill the alignment\n    // If there's more than one, create buffer interleaved elements.\n\n    // if length === 0, OK\n    // if length === 1, put it at the end of our struct\n    // if length > 1, create a buffer interleaved elements\n    let orderedBindings = Object.keys(this.inputs)\n\n    const arrayBindings = orderedBindings.filter((bindingKey) => {\n      return this.inputs[bindingKey].type.includes('array')\n    })\n\n    // put the array struct at the end\n    if (arrayBindings.length) {\n      orderedBindings.sort((bindingKeyA, bindingKeyB) => {\n        // 0 if it's an array, -1 else\n        const isBindingAArray = Math.min(0, this.inputs[bindingKeyA].type.indexOf('array'))\n        const isBindingBArray = Math.min(0, this.inputs[bindingKeyB].type.indexOf('array'))\n\n        return isBindingAArray - isBindingBArray\n      })\n\n      if (arrayBindings.length > 1) {\n        // remove interleaved arrays from the ordered struct key array\n        orderedBindings = orderedBindings.filter((bindingKey) => !arrayBindings.includes(bindingKey))\n      }\n    }\n\n    // handle buffer (non interleaved) elements\n    for (const bindingKey of orderedBindings) {\n      const binding = this.inputs[bindingKey]\n\n      const bufferElementOptions = {\n        name: toCamelCase(binding.name ?? bindingKey),\n        key: bindingKey,\n        type: binding.type,\n      }\n\n      const isArray =\n        binding.type.includes('array') && (Array.isArray(binding.value) || ArrayBuffer.isView(binding.value))\n\n      this.bufferElements.push(\n        isArray\n          ? new BufferArrayElement({\n              ...bufferElementOptions,\n              arrayLength: (binding.value as number[]).length,\n            })\n          : new BufferElement(bufferElementOptions)\n      )\n    }\n\n    // set their alignments\n    this.bufferElements.forEach((bufferElement, index) => {\n      const startOffset = index === 0 ? 0 : this.bufferElements[index - 1].endOffset + 1\n\n      bufferElement.setAlignment(startOffset)\n    })\n\n    // now create our interleaved buffer elements\n    if (arrayBindings.length > 1) {\n      // first get the sizes of the arrays\n      const arraySizes = arrayBindings.map((bindingKey) => {\n        const binding = this.inputs[bindingKey]\n        const bufferLayout = getBufferLayout(binding.type.replace('array', '').replace('<', '').replace('>', ''))\n\n        return Math.ceil((binding.value as number[] | TypedArray).length / bufferLayout.numElements)\n      })\n\n      // are they all of the same size?\n      const equalSize = arraySizes.every((size, i, array) => size === array[0])\n\n      if (equalSize) {\n        // this will hold our interleaved buffer elements\n        const interleavedBufferElements = arrayBindings.map((bindingKey) => {\n          const binding = this.inputs[bindingKey]\n          return new BufferInterleavedArrayElement({\n            name: toCamelCase(binding.name ?? bindingKey),\n            key: bindingKey,\n            type: binding.type,\n            arrayLength: (binding.value as number[]).length,\n          })\n        })\n\n        // now create temp buffer elements that we'll use to fill the interleaved buffer elements alignments\n        const tempBufferElements = arrayBindings.map((bindingKey) => {\n          const binding = this.inputs[bindingKey]\n          return new BufferElement({\n            name: toCamelCase(binding.name ?? bindingKey),\n            key: bindingKey,\n            type: binding.type.replace('array', '').replace('<', '').replace('>', ''),\n          })\n        })\n\n        // set temp buffer alignments as if it was regular buffer elements\n        tempBufferElements.forEach((bufferElement, index) => {\n          if (index === 0) {\n            if (this.bufferElements.length) {\n              // if we already have buffer elements\n              // get last one end row, and start at the next row\n              bufferElement.setAlignmentFromPosition({\n                row: this.bufferElements[this.bufferElements.length - 1].alignment.end.row + 1,\n                byte: 0,\n              })\n            } else {\n              bufferElement.setAlignment(0)\n            }\n          } else {\n            bufferElement.setAlignment(tempBufferElements[index - 1].endOffset + 1)\n          }\n        })\n\n        // now use last temp buffer end offset as our interleaved arrayStride\n        const totalStride =\n          tempBufferElements[tempBufferElements.length - 1].endOffset + 1 - tempBufferElements[0].startOffset\n\n        // finally, set interleaved buffer elements alignment\n        interleavedBufferElements.forEach((bufferElement, index) => {\n          bufferElement.setAlignment(\n            tempBufferElements[index].startOffset,\n            Math.ceil(totalStride / bytesPerRow) * bytesPerRow\n          )\n        })\n\n        // add to our buffer elements array\n        this.bufferElements = [...this.bufferElements, ...interleavedBufferElements]\n      } else {\n        throwWarning(\n          `BufferBinding: \"${\n            this.label\n          }\" contains multiple array inputs that should use an interleaved array, but their sizes do not match. These inputs cannot be added to the BufferBinding: \"${arrayBindings.join(\n            ', '\n          )}\"`\n        )\n      }\n    }\n  }\n\n  /**\n   * Set our buffer attributes:\n   * Takes all the {@link inputs} and adds them to the {@link bufferElements} array with the correct start and end offsets (padded), then fill our {@link arrayBuffer} typed array accordingly.\n   */\n  setBufferAttributes() {\n    const bufferElementsArrayBufferSize = this.bufferElements.length\n      ? this.bufferElements[this.bufferElements.length - 1].paddedByteCount\n      : 0\n\n    this.arrayBufferSize = bufferElementsArrayBufferSize\n\n    this.options.bindings.forEach((binding) => {\n      this.arrayBufferSize += binding.arrayBufferSize\n    })\n\n    this.arrayBuffer = new ArrayBuffer(this.arrayBufferSize)\n    this.arrayView = new DataView(this.arrayBuffer, 0, bufferElementsArrayBufferSize)\n\n    this.options.bindings.forEach((binding, index) => {\n      let offset = bufferElementsArrayBufferSize\n\n      for (let i = 0; i < index; i++) {\n        offset += this.options.bindings[i].arrayBuffer.byteLength\n      }\n\n      const bufferElLastRow = this.bufferElements.length\n        ? this.bufferElements[this.bufferElements.length - 1].alignment.end.row + 1\n        : 0\n\n      const bindingLastRow =\n        index > 0\n          ? this.options.bindings[index - 1].bufferElements.length\n            ? this.options.bindings[index - 1].bufferElements[\n                this.options.bindings[index - 1].bufferElements.length - 1\n              ].alignment.end.row + 1\n            : 0\n          : 0\n\n      binding.bufferElements.forEach((bufferElement) => {\n        bufferElement.alignment.start.row += bufferElLastRow + bindingLastRow\n        bufferElement.alignment.end.row += bufferElLastRow + bindingLastRow\n      })\n\n      binding.arrayView = new DataView(this.arrayBuffer, offset, binding.arrayBuffer.byteLength)\n\n      for (const bufferElement of binding.bufferElements) {\n        bufferElement.setView(this.arrayBuffer, binding.arrayView)\n      }\n    })\n\n    this.buffer.size = this.arrayBuffer.byteLength\n\n    for (const bufferElement of this.bufferElements) {\n      bufferElement.setView(this.arrayBuffer, this.arrayView)\n    }\n\n    this.shouldUpdate = this.arrayBufferSize > 0\n  }\n\n  /**\n   * Set the WGSL code snippet to append to the shaders code. It consists of variable (and Struct structures if needed) declarations.\n   */\n  setWGSLFragment() {\n    if (!this.bufferElements.length && !this.options.bindings.length) return\n\n    const uniqueBindings = []\n    this.options.bindings.forEach((binding) => {\n      const bindingExists = uniqueBindings.find((b) => b.name === binding.name)\n      if (!bindingExists) {\n        uniqueBindings.push({\n          name: binding.name,\n          label: binding.label,\n          count: 1,\n          wgslStructFragment: binding.wgslStructFragment,\n        })\n      } else {\n        bindingExists.count++\n      }\n    })\n\n    const kebabCaseLabel = toKebabCase(this.label)\n\n    if (this.useStruct) {\n      const structs = {}\n\n      structs[kebabCaseLabel] = {}\n\n      const bufferElements = this.bufferElements.filter(\n        (bufferElement) => !(bufferElement instanceof BufferInterleavedArrayElement)\n      )\n      const interleavedBufferElements = this.bufferElements.filter(\n        (bufferElement) => bufferElement instanceof BufferInterleavedArrayElement\n      ) as BufferInterleavedArrayElement[]\n\n      if (interleavedBufferElements.length) {\n        const arrayLength = this.bindingType === 'uniform' ? `, ${interleavedBufferElements[0].numElements}` : ''\n\n        if (bufferElements.length) {\n          structs[`${kebabCaseLabel}Element`] = {}\n\n          interleavedBufferElements.forEach((binding) => {\n            structs[`${kebabCaseLabel}Element`][binding.name] = binding.type\n              .replace('array', '')\n              .replace('<', '')\n              .replace('>', '')\n          })\n\n          bufferElements.forEach((binding) => {\n            structs[kebabCaseLabel][binding.name] = binding.type\n          })\n\n          const interleavedBufferName = this.bufferElements.find((bufferElement) => bufferElement.name === 'elements')\n            ? `${this.name}Elements`\n            : 'elements'\n\n          structs[kebabCaseLabel][interleavedBufferName] = `array<${kebabCaseLabel}Element${arrayLength}>`\n\n          const varType = getBindingWGSLVarType(this)\n          this.wgslGroupFragment = [`${varType} ${this.name}: ${kebabCaseLabel};`]\n        } else {\n          this.bufferElements.forEach((binding) => {\n            structs[kebabCaseLabel][binding.name] = binding.type.replace('array', '').replace('<', '').replace('>', '')\n          })\n\n          const varType = getBindingWGSLVarType(this)\n          this.wgslGroupFragment = [`${varType} ${this.name}: array<${kebabCaseLabel}${arrayLength}>;`]\n        }\n      } else {\n        bufferElements.forEach((binding) => {\n          const bindingType =\n            this.bindingType === 'uniform' && 'numElements' in binding\n              ? `array<${binding.type.replace('array', '').replace('<', '').replace('>', '')}, ${binding.numElements}>`\n              : binding.type\n\n          structs[kebabCaseLabel][binding.name] = bindingType\n        })\n\n        const varType = getBindingWGSLVarType(this)\n        this.wgslGroupFragment = [`${varType} ${this.name}: ${kebabCaseLabel};`]\n      }\n\n      if (uniqueBindings.length) {\n        uniqueBindings.forEach((binding) => {\n          // unique bindings come from bindings children\n          // we assume those have to be iterable\n          structs[kebabCaseLabel][binding.name] = `array<${toKebabCase(binding.label)}>`\n        })\n      }\n\n      const additionalBindings = uniqueBindings.length\n        ? uniqueBindings.map((binding) => binding.wgslStructFragment).join('\\n\\n') + '\\n\\n'\n        : ''\n\n      this.wgslStructFragment =\n        additionalBindings +\n        Object.keys(structs)\n          .reverse()\n          .map((struct) => {\n            return `struct ${struct} {\\n\\t${Object.keys(structs[struct])\n              .map((binding) => `${binding}: ${structs[struct][binding]}`)\n              .join(',\\n\\t')}\\n};`\n          })\n          .join('\\n\\n')\n    } else {\n      this.wgslStructFragment = ''\n      this.wgslGroupFragment = this.bufferElements.map((binding) => {\n        const varType = getBindingWGSLVarType(this)\n        return `${varType} ${binding.name}: ${binding.type};`\n      })\n    }\n  }\n\n  /**\n   * Set a {@link BufferBinding#shouldUpdate | binding shouldUpdate} flag to `true` to update our {@link arrayBuffer} array during next render.\n   * @param bindingName - the binding name/key to update\n   */\n  shouldUpdateBinding(bindingName = '') {\n    if (this.inputs[bindingName]) {\n      this.inputs[bindingName].shouldUpdate = true\n    }\n  }\n\n  /**\n   * Executed at the beginning of a Material render call.\n   * If any of the {@link inputs} has changed, run its `onBeforeUpdate` callback then updates our {@link arrayBuffer} array.\n   * Also sets the {@link shouldUpdate} property to true so the {@link core/bindGroups/BindGroup.BindGroup | BindGroup} knows it will need to update the {@link GPUBuffer}.\n   */\n  update() {\n    const inputs = Object.values(this.inputs)\n\n    for (const binding of inputs) {\n      const bufferElement = this.bufferElements.find((bufferEl) => bufferEl.key === binding.name)\n\n      if (binding.shouldUpdate && bufferElement) {\n        binding.onBeforeUpdate && binding.onBeforeUpdate()\n        // we're going to directly update the arrayBuffer from the buffer element update method\n        bufferElement.update(binding.value)\n\n        this.shouldUpdate = true\n        binding.shouldUpdate = false\n      }\n    }\n\n    this.options.bindings.forEach((binding) => {\n      binding.update()\n      if (binding.shouldUpdate) {\n        this.shouldUpdate = true\n      }\n    })\n  }\n\n  /**\n   * Extract the data corresponding to a specific {@link BufferElement} from a {@link Float32Array} holding the {@link BufferBinding#buffer | GPU buffer} data of this {@link BufferBinding}\n   * @param parameters - parameters used to extract the data\n   * @param parameters.result - {@link Float32Array} holding {@link GPUBuffer} data\n   * @param parameters.bufferElementName - name of the {@link BufferElement} to use to extract the data\n   * @returns - extracted data from the {@link Float32Array}\n   */\n  extractBufferElementDataFromBufferResult({\n    result,\n    bufferElementName,\n  }: {\n    result: Float32Array\n    bufferElementName: BufferElement['name']\n  }): Float32Array {\n    const bufferElement = this.bufferElements.find((bufferElement) => bufferElement.name === bufferElementName)\n    if (bufferElement) {\n      return bufferElement.extractDataFromBufferResult(result)\n    } else {\n      return result\n    }\n  }\n}\n","import { BufferBinding, BufferBindingParams } from './BufferBinding'\r\nimport { Buffer } from '../buffers/Buffer'\r\n\r\n/**\r\n * Parameters used to create a {@link WritableBufferBinding}\r\n */\r\nexport interface WritableBufferBindingParams extends BufferBindingParams {\r\n  /** Whether whe should automatically copy the {@link WritableBufferBinding#buffer | GPU buffer} content into our {@link WritableBufferBinding#resultBuffer | result GPU buffer} */\r\n  shouldCopyResult?: boolean\r\n}\r\n\r\n/**\r\n * Used to create a {@link BufferBinding} that can hold read/write storage bindings along with a {@link WritableBufferBinding#resultBuffer | result GPU buffer} that can be used to get data back from the GPU.\r\n *\r\n * Note that it is automatically created by the {@link core/bindGroups/BindGroup.BindGroup | BindGroup} when a {@link types/BindGroups.BindGroupInputs#storages | storages input} has its {@link BufferBindingParams#access | access} property set to `\"read_write\"`.\r\n */\r\nexport class WritableBufferBinding extends BufferBinding {\r\n  /** Flag indicating whether whe should automatically copy the {@link buffer | GPU buffer} content into our {@link resultBuffer | result GPU buffer} */\r\n  shouldCopyResult: boolean\r\n  /** The result GPUBuffer */\r\n  resultBuffer: Buffer\r\n  /** Options used to create this {@link WritableBufferBinding} */\r\n  options: WritableBufferBindingParams\r\n\r\n  /**\r\n   * WritableBufferBinding constructor\r\n   * @param parameters - {@link WritableBufferBindingParams | parameters} used to create our {@link WritableBufferBinding}\r\n   */\r\n  constructor({\r\n    label = 'Work',\r\n    name = 'work',\r\n    bindingType,\r\n    visibility,\r\n    useStruct = true,\r\n    access = 'read_write',\r\n    usage = [],\r\n    struct = {},\r\n    shouldCopyResult = false,\r\n  }: WritableBufferBindingParams) {\r\n    bindingType = 'storage'\r\n    visibility = ['compute']\r\n\r\n    super({ label, name, bindingType, visibility, useStruct, access, usage, struct })\r\n\r\n    this.options = {\r\n      ...this.options,\r\n      shouldCopyResult,\r\n    }\r\n\r\n    this.shouldCopyResult = shouldCopyResult\r\n    this.cacheKey += `${shouldCopyResult},`\r\n\r\n    // can be used as our buffer copy destination\r\n    this.resultBuffer = new Buffer()\r\n  }\r\n}\r\n","import { isRenderer, Renderer } from '../renderers/utils'\nimport { generateUUID, toKebabCase } from '../../utils/utils'\nimport { WritableBufferBinding, WritableBufferBindingParams } from '../bindings/WritableBufferBinding'\nimport { BufferBinding } from '../bindings/BufferBinding'\nimport { BufferBindingOffsetChild, BufferBindingOffsetChildParams } from '../bindings/BufferBindingOffsetChild'\nimport {\n  AllowedBindGroups,\n  BindGroupBindingElement,\n  BindGroupBufferBindingElement,\n  BindGroupEntries,\n  BindGroupParams,\n  ReadOnlyInputBindings,\n} from '../../types/BindGroups'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\nimport { TextureBindGroupParams } from './TextureBindGroup'\nimport { BufferBindingType } from '../bindings/Binding'\nimport { BufferUsageKeys } from '../buffers/utils'\n\n/**\n * Used to handle all inputs data sent to the GPU.<br>\n * In WebGPU, data (buffers, textures or samplers, called bindings) are organised by bind groups, containing those bindings.\n *\n * ## Bindings\n *\n * A {@link BindGroup} is responsible for creating each {@link BufferBinding} {@link GPUBuffer} and then the {@link GPUBindGroup} and {@link GPUBindGroupLayout} that are used to create {@link GPUComputePipeline} or {@link GPURenderPipeline}.<br>\n * Those are generally automatically created by the {@link core/materials/Material.Material | Material} using this {@link BindGroup}. If you need to manually create them, you will have to call its {@link BindGroup#createBindGroup | `createBindGroup()` method}\n *\n * ### Samplers and textures\n *\n * A {@link BindGroup} is best suited to handle {@link GPUBuffer} only bindings. If you need to handle {@link GPUSampler}, a {@link GPUTexture} or a {@link GPUExternalTexture}, you should use a {@link core/bindGroups/TextureBindGroup.TextureBindGroup | TextureBindGroup} instead.\n *\n * ### Updating a GPUBindGroup or GPUBindGroupLayout\n *\n * Each time one of the {@link https://developer.mozilla.org/en-US/docs/Web/API/GPUDevice/createBindGroup#resource | binding resource} changes, its {@link BindGroup#bindGroup | bindGroup} will be recreated (usually, when a {@link GPUTexture} is uploaded).<br>\n * Each time one of the {@link https://developer.mozilla.org/en-US/docs/Web/API/GPUDevice/createBindGroupLayout#resource_layout_objects | binding resource layout} changes, its {@link BindGroup#bindGroupLayout | bindGroupLayout} and {@link BindGroup#bindGroup | bindGroup} will be recreated, and the {@link GPUComputePipeline} or {@link GPURenderPipeline} will be recreated as well.\n *\n * @example\n * ```javascript\n * // set our main GPUCurtains instance\n * const gpuCurtains = new GPUCurtains({\n *   container: '#canvas' // selector of our WebGPU canvas container\n * })\n *\n * // set the GPU device\n * // note this is asynchronous\n * await gpuCurtains.setDevice()\n *\n * const bindGroup = new BindGroup(gpuCurtains, {\n *   label: 'My bind group',\n *   uniforms: {\n *     params: {\n *       visibility: ['fragment'],\n *       struct: {\n *         opacity: {\n *           value: 'f32',\n *           value: 1,\n *         },\n *         mousePosition: {\n *           value: 'vec2f',\n *           value: new Vec2(),\n *         },\n *       },\n *     },\n *   },\n * })\n *\n * // create the GPU buffer, bindGroupLayout and bindGroup\n * bindGroup.createBindGroup()\n * ```\n */\nexport class BindGroup {\n  /** The type of the {@link BindGroup} */\n  type: string\n  /** The universal unique id of the {@link BindGroup} */\n  uuid: string\n  /** The {@link Renderer} used */\n  renderer: Renderer\n  /** Options used to create this {@link BindGroup} */\n  options: TextureBindGroupParams\n  /** Index of this {@link BindGroup}, used to link struct in the shaders */\n  index: number\n\n  /** List of {@link BindGroupBindingElement | bindings} (buffers, texture, etc.) handled by this {@link BindGroup} */\n  bindings: BindGroupBindingElement[]\n\n  /** Our {@link BindGroup} {@link BindGroupEntries | entries} objects */\n  entries: BindGroupEntries\n\n  /** Our {@link BindGroup}{@link GPUBindGroupLayout} */\n  bindGroupLayout: null | GPUBindGroupLayout\n  /** Our {@link BindGroup} {@link GPUBindGroup} */\n  bindGroup: null | GPUBindGroup\n\n  /** A cache key allowing to get / set {@link GPUBindGroupLayout} from the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#bindGroupLayouts | device manager map cache}. */\n  layoutCacheKey: string\n  /** A cache key allowing the {@link core/pipelines/PipelineManager.PipelineManager | PipelineManager} to compare {@link core/pipelines/RenderPipelineEntry.RenderPipelineEntry | RenderPipelineEntry} bind groups content. */\n  pipelineCacheKey: string\n\n  /** Flag indicating whether we need to flush and recreate the pipeline using this {@link BindGroup} s*/\n  needsPipelineFlush: boolean\n\n  /** A Set to store this {@link BindGroup} consumers ({@link core/materials/Material.Material#uuid | Material uuid})  */\n  consumers: Set<string>\n\n  /**\n   * BindGroup constructor\n   * @param renderer - a {@link Renderer} class object or a {@link GPUCurtains} class object\n   * @param parameters - {@link BindGroupParams | parameters} used to create our {@link BindGroup}\n   */\n  constructor(\n    renderer: Renderer | GPUCurtains,\n    { label = 'BindGroup', index = 0, bindings = [], uniforms, storages }: BindGroupParams = {}\n  ) {\n    this.type = 'BindGroup'\n\n    renderer = isRenderer(renderer, this.type)\n\n    this.renderer = renderer\n    this.options = {\n      label,\n      index,\n      bindings,\n      ...(uniforms && { uniforms }),\n      ...(storages && { storages }),\n    }\n\n    this.index = index\n    this.uuid = generateUUID()\n\n    this.bindings = []\n    bindings.length && this.addBindings(bindings)\n    if (this.options.uniforms || this.options.storages) this.setInputBindings()\n\n    this.layoutCacheKey = ''\n    this.pipelineCacheKey = ''\n    this.resetEntries()\n\n    this.bindGroupLayout = null\n    this.bindGroup = null\n\n    // if we ever update our bind group layout\n    // we will have to recreate the whole pipeline again\n    this.needsPipelineFlush = false\n\n    this.consumers = new Set()\n\n    // add the bind group to the buffers consumers\n    for (const binding of this.bufferBindings) {\n      if ('buffer' in binding) {\n        if ('parent' in binding && binding.parent) {\n          binding.parent.buffer.consumers.add(this.uuid)\n        } else {\n          binding.buffer.consumers.add(this.uuid)\n        }\n      }\n\n      if ('resultBuffer' in binding) {\n        binding.resultBuffer.consumers.add(this.uuid)\n      }\n    }\n\n    this.renderer.addBindGroup(this)\n  }\n\n  /**\n   * Sets our {@link BindGroup#index | bind group index}\n   * @param index - {@link BindGroup#index | bind group index} to set\n   */\n  setIndex(index: number) {\n    this.index = index\n  }\n\n  /**\n   * Adds an array of already created {@link bindings} (buffers, texture, etc.) to the {@link bindings} array\n   * @param bindings - {@link bindings} to add\n   */\n  addBindings(bindings: BindGroupBindingElement[] = []) {\n    bindings.forEach((binding) => {\n      if ('buffer' in binding) {\n        if ('parent' in binding && binding.parent) {\n          this.renderer.deviceManager.bufferBindings.set(binding.parent.cacheKey, binding.parent)\n          binding.parent.buffer.consumers.add(this.uuid)\n        } else {\n          this.renderer.deviceManager.bufferBindings.set(binding.cacheKey, binding)\n          binding.buffer.consumers.add(this.uuid)\n        }\n      }\n    })\n\n    this.bindings = [...this.bindings, ...bindings]\n  }\n\n  /**\n   * Adds an already created {@link bindings} (buffers, texture, etc.) to the {@link bindings} array\n   * @param binding - binding to add\n   */\n  addBinding(binding: BindGroupBindingElement) {\n    this.bindings.push(binding)\n  }\n\n  /**\n   * Destroy a {@link BufferBinding} buffers.\n   * @param binding - {@link BufferBinding} from which to destroy the buffers.\n   */\n  destroyBufferBinding(binding: BindGroupBufferBindingElement) {\n    if ('buffer' in binding) {\n      this.renderer.removeBuffer(binding.buffer)\n\n      binding.buffer.consumers.delete(this.uuid)\n      if (!binding.buffer.consumers.size) {\n        binding.buffer.destroy()\n      }\n\n      if ('parent' in binding && binding.parent) {\n        binding.parent.buffer.consumers.delete(this.uuid)\n\n        if (!binding.parent.buffer.consumers.size) {\n          this.renderer.removeBuffer(binding.parent.buffer)\n          binding.parent.buffer.destroy()\n        }\n      }\n    }\n\n    if ('resultBuffer' in binding) {\n      this.renderer.removeBuffer(binding.resultBuffer)\n\n      binding.resultBuffer.consumers.delete(this.uuid)\n      if (!binding.resultBuffer.consumers.size) {\n        binding.resultBuffer.destroy()\n      }\n    }\n  }\n\n  /**\n   * Creates Bindings based on a list of inputs\n   * @param bindingType - {@link core/bindings/Binding.Binding#bindingType | binding type}\n   * @param inputs - {@link ReadOnlyInputBindings | inputs (uniform or storage)} that will be used to create the binding\n   * @returns - a {@link bindings} array\n   */\n  createInputBindings(\n    bindingType: BufferBindingType = 'uniform',\n    inputs: ReadOnlyInputBindings = {}\n  ): BindGroupBindingElement[] {\n    let bindings = [\n      ...Object.keys(inputs).map((inputKey) => {\n        const binding = inputs[inputKey] as WritableBufferBindingParams\n\n        // bail if no struct\n        if (!binding.struct) return\n\n        const bindingParams: WritableBufferBindingParams = {\n          label: toKebabCase(binding.label || inputKey),\n          name: inputKey,\n          bindingType,\n          visibility: binding.access === 'read_write' ? ['compute'] : binding.visibility,\n          useStruct: true, // by default\n          access: binding.access ?? 'read', // read by default\n          ...(binding.usage && { usage: binding.usage }),\n          struct: binding.struct,\n          ...(binding.shouldCopyResult !== undefined && { shouldCopyResult: binding.shouldCopyResult }),\n        }\n\n        if (binding.useStruct !== false) {\n          let key = `${bindingType},${\n            binding.visibility === undefined ? 'all' : binding.access === 'read_write' ? 'compute' : binding.visibility\n          },true,${binding.access ?? 'read'},`\n\n          Object.keys(binding.struct).forEach((bindingKey) => {\n            key += `${bindingKey},${binding.struct[bindingKey].type},`\n          })\n\n          if (binding.shouldCopyResult !== undefined) {\n            key += `${binding.shouldCopyResult},`\n          }\n\n          const cachedBinding = this.renderer.deviceManager.bufferBindings.get(key)\n\n          if (cachedBinding) {\n            return cachedBinding.clone(bindingParams)\n          }\n        }\n\n        const BufferBindingConstructor = bindingParams.access === 'read_write' ? WritableBufferBinding : BufferBinding\n\n        return binding.useStruct !== false\n          ? new BufferBindingConstructor(bindingParams)\n          : Object.keys(binding.struct).map((bindingKey) => {\n              bindingParams.label = toKebabCase(binding.label ? binding.label + bindingKey : inputKey + bindingKey)\n              bindingParams.name = inputKey + bindingKey\n              bindingParams.useStruct = false\n              bindingParams.struct = { [bindingKey]: binding.struct[bindingKey] }\n\n              return new BufferBindingConstructor(bindingParams)\n            })\n      }),\n    ].flat()\n\n    // filter to leave only valid bindings\n    bindings = bindings.filter(Boolean)\n\n    bindings.forEach((binding) => {\n      this.renderer.deviceManager.bufferBindings.set(binding.cacheKey, binding)\n    })\n\n    return bindings\n  }\n\n  /**\n   * Create and adds {@link bindings} based on inputs provided upon creation\n   */\n  setInputBindings() {\n    this.addBindings([\n      ...this.createInputBindings('uniform', this.options.uniforms),\n      ...this.createInputBindings('storage', this.options.storages),\n    ])\n  }\n\n  /**\n   * Get whether the GPU bind group is ready to be created\n   * It can be created if it has {@link bindings} and has not been created yet\n   * @readonly\n   */\n  get shouldCreateBindGroup(): boolean {\n    return !this.bindGroup && !!this.bindings.length\n  }\n\n  /**\n   * Reset our {@link BindGroup} {@link entries}\n   */\n  resetEntries() {\n    this.entries = {\n      bindGroupLayout: [],\n      bindGroup: [],\n    }\n  }\n\n  /**\n   * Create the GPU buffers, {@link bindings}, {@link entries}, {@link bindGroupLayout} and {@link bindGroup}\n   */\n  createBindGroup() {\n    this.fillEntries()\n    this.setBindGroupLayout()\n    this.setBindGroup()\n  }\n\n  /**\n   * Reset the {@link BindGroup#entries.bindGroup | bindGroup entries}, recreates them and then recreate the {@link BindGroup#bindGroup | GPU bind group}\n   */\n  resetBindGroup() {\n    this.entries.bindGroup = []\n    this.pipelineCacheKey = ''\n\n    for (const binding of this.bindings) {\n      this.addBindGroupEntry(binding)\n    }\n\n    this.setBindGroup()\n  }\n\n  /**\n   * Add a {@link BindGroup#entries.bindGroup | bindGroup entry}\n   * @param binding - {@link BindGroupBindingElement | binding} to add\n   */\n  addBindGroupEntry(binding: BindGroupBindingElement) {\n    this.entries.bindGroup.push({\n      binding: this.entries.bindGroup.length,\n      resource: binding.resource,\n    })\n\n    this.pipelineCacheKey += binding.cacheKey\n  }\n\n  /**\n   * Reset the {@link BindGroup#entries.bindGroupLayout | bindGroupLayout entries}, recreates them and then recreate the {@link BindGroup#bindGroupLayout | GPU bind group layout}\n   */\n  resetBindGroupLayout() {\n    this.entries.bindGroupLayout = []\n    this.layoutCacheKey = ''\n\n    for (const binding of this.bindings) {\n      this.addBindGroupLayoutEntry(binding)\n    }\n\n    this.setBindGroupLayout()\n  }\n\n  /**\n   * Add a {@link BindGroup#entries.bindGroupLayout | bindGroupLayout entry}\n   * @param binding - {@link BindGroupBindingElement | binding} to add\n   */\n  addBindGroupLayoutEntry(binding: BindGroupBindingElement) {\n    this.entries.bindGroupLayout.push({\n      binding: this.entries.bindGroupLayout.length,\n      ...binding.resourceLayout,\n      visibility: binding.visibility,\n    })\n\n    this.layoutCacheKey += binding.resourceLayoutCacheKey\n  }\n\n  /**\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been lost to prepare everything for restoration\n   */\n  loseContext() {\n    this.resetEntries()\n\n    for (const binding of this.bufferBindings) {\n      binding.buffer.reset()\n\n      if ('parent' in binding && binding.parent) {\n        binding.parent.buffer.reset()\n      }\n\n      if ('resultBuffer' in binding) {\n        binding.resultBuffer.reset()\n      }\n    }\n\n    this.bindGroup = null\n    this.bindGroupLayout = null\n    this.needsPipelineFlush = true\n  }\n\n  /**\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been restored to update our bindings.\n   */\n  restoreContext() {\n    if (this.shouldCreateBindGroup) {\n      this.createBindGroup()\n    }\n\n    // finally re-write all our buffers\n    for (const bufferBinding of this.bufferBindings) {\n      bufferBinding.shouldUpdate = true\n    }\n  }\n\n  /**\n   * Get all {@link BindGroup#bindings | bind group bindings} that handle a {@link GPUBuffer}\n   */\n  get bufferBindings(): BindGroupBufferBindingElement[] {\n    return this.bindings.filter(\n      (binding) => binding instanceof BufferBinding || binding instanceof WritableBufferBinding\n    ) as BindGroupBufferBindingElement[]\n  }\n\n  /**\n   * Creates binding GPUBuffer with correct params.\n   * @param binding - The binding element.\n   * @param optionalLabel - Optional label to use for the {@link GPUBuffer}.\n   */\n  createBindingBuffer(binding: BindGroupBufferBindingElement, optionalLabel = null) {\n    // [Kangz](https://github.com/Kangz) said:\n    // \"In general though COPY_SRC/DST is free (at least in Dawn / Chrome because we add it all the time for our own purpose).\"\n    binding.buffer.createBuffer(this.renderer, {\n      label: optionalLabel || this.options.label + ': ' + binding.bindingType + ' buffer from: ' + binding.label,\n      usage: [...(['copySrc', 'copyDst', binding.bindingType] as BufferUsageKeys[]), ...binding.options.usage],\n    })\n\n    if ('resultBuffer' in binding) {\n      binding.resultBuffer.createBuffer(this.renderer, {\n        label: this.options.label + ': Result buffer from: ' + binding.label,\n        size: binding.arrayBuffer.byteLength,\n        usage: ['copyDst', 'mapRead'],\n      })\n    }\n  }\n\n  /**\n   * Fill in our entries bindGroupLayout and bindGroup arrays with the correct binding resources.\n   * For buffer struct, create a GPUBuffer first if needed\n   */\n  fillEntries() {\n    for (const binding of this.bindings) {\n      // if no visibility specified, just set it to the maximum default capabilities\n      if (!binding.visibility) {\n        binding.visibility = GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE\n      }\n\n      // if it's a buffer binding, create the GPUBuffer\n      if ('buffer' in binding) {\n        // do not create if it has a parent but create parent instead\n        const isChildBuffer = 'parent' in binding && binding.parent\n\n        if (isChildBuffer && !(binding as BufferBindingOffsetChild).parent.buffer.GPUBuffer) {\n          this.createBindingBuffer(\n            (binding as BufferBindingOffsetChild).parent,\n            (binding as BufferBindingOffsetChild).parent.options.label\n          )\n        } else if (!binding.buffer.GPUBuffer && !isChildBuffer) {\n          this.createBindingBuffer(binding)\n        }\n      }\n\n      // now that everything is ready, fill our entries\n      this.addBindGroupLayoutEntry(binding)\n      this.addBindGroupEntry(binding)\n    }\n  }\n\n  /**\n   * Get a bind group binding by name/key\n   * @param bindingName - the binding name or key\n   * @returns - the found binding, or null if not found\n   */\n  getBindingByName(bindingName = ''): BindGroupBindingElement | null {\n    return this.bindings.find((binding) => binding.name === bindingName)\n  }\n\n  /**\n   * Create a GPUBindGroupLayout and set our {@link bindGroupLayout}\n   */\n  setBindGroupLayout() {\n    const bindGroupLayout = this.renderer.deviceManager.bindGroupLayouts.get(this.layoutCacheKey)\n\n    if (bindGroupLayout) {\n      this.bindGroupLayout = bindGroupLayout\n    } else {\n      this.bindGroupLayout = this.renderer.createBindGroupLayout({\n        label: this.options.label + ' layout',\n        entries: this.entries.bindGroupLayout,\n      })\n\n      this.renderer.deviceManager.bindGroupLayouts.set(this.layoutCacheKey, this.bindGroupLayout)\n    }\n  }\n\n  /**\n   * Create a GPUBindGroup and set our {@link bindGroup}\n   */\n  setBindGroup() {\n    this.bindGroup = this.renderer.createBindGroup({\n      label: this.options.label,\n      layout: this.bindGroupLayout,\n      entries: this.entries.bindGroup,\n    })\n  }\n\n  /**\n   * Check whether we should update (write) our {@link GPUBuffer} or not.\n   */\n  updateBufferBindings() {\n    this.bindings.forEach((binding, index) => {\n      if ('buffer' in binding) {\n        // update binding elements\n        binding.update()\n\n        // now write to the GPUBuffer if needed\n        if (binding.shouldUpdate && binding.buffer.GPUBuffer) {\n          // bufferOffset is always equals to 0 in our case\n          if (!binding.useStruct && binding.bufferElements.length > 1) {\n            // we're in a non struct buffer binding with multiple entries\n            // that should not happen but that way we're covered\n            this.renderer.queueWriteBuffer(binding.buffer.GPUBuffer, 0, binding.bufferElements[index].view)\n          } else {\n            this.renderer.queueWriteBuffer(binding.buffer.GPUBuffer, 0, binding.arrayBuffer)\n          }\n\n          // reset update flag\n          binding.shouldUpdate = false\n        }\n      }\n    })\n  }\n\n  /**\n   * Update the {@link BindGroup}, which means update its {@link BindGroup#bufferBindings | buffer bindings} and {@link BindGroup#resetBindGroup | reset it} if needed.\n   * Called at each render from the parentMesh {@link core/materials/Material.Material | material}\n   */\n  update() {\n    this.updateBufferBindings()\n\n    const needBindGroupReset = this.bindings.some((binding) => binding.shouldResetBindGroup)\n    const needBindGroupLayoutReset = this.bindings.some((binding) => binding.shouldResetBindGroupLayout)\n\n    // since other bind groups might be using that binding\n    // wait for the end of the render loop to reset the bindings flags\n    if (needBindGroupReset || needBindGroupLayoutReset) {\n      this.renderer.onAfterCommandEncoderSubmission.add(\n        () => {\n          for (const binding of this.bindings) {\n            binding.shouldResetBindGroup = false\n            binding.shouldResetBindGroupLayout = false\n          }\n        },\n        { once: true }\n      )\n    }\n\n    if (needBindGroupLayoutReset) {\n      this.resetBindGroupLayout()\n      // bind group layout has changed, we have to recreate the pipeline\n      this.needsPipelineFlush = true\n    }\n\n    if (needBindGroupReset) {\n      this.resetBindGroup()\n    }\n  }\n\n  /**\n   * Clones a {@link BindGroup} from a list of {@link bindings}\n   * Useful to create a new bind group with already created buffers, but swapped\n   * @param parameters - parameters to use for cloning\n   * @param parameters.bindings - our input {@link bindings}\n   * @param [parameters.keepLayout=false] - whether we should keep original {@link bindGroupLayout} or not\n   * @returns - the cloned {@link BindGroup}\n   */\n  clone({\n    bindings = [],\n    keepLayout = false,\n  }: {\n    bindings?: BindGroupBindingElement[]\n    keepLayout?: boolean\n  } = {}): AllowedBindGroups {\n    const params = { ...this.options }\n    params.label += ' (copy)'\n\n    const bindGroupCopy = new (this.constructor as typeof BindGroup)(this.renderer, {\n      label: params.label,\n    })\n\n    bindGroupCopy.setIndex(this.index)\n    bindGroupCopy.options = params\n\n    const bindingsRef = bindings.length ? bindings : this.bindings\n\n    for (const binding of bindingsRef) {\n      bindGroupCopy.addBinding(binding)\n\n      // if it's a buffer binding without a GPUBuffer, create it now\n      if ('buffer' in binding) {\n        // do not create if it has a parent but create parent instead\n        const isChildBuffer = 'parent' in binding && binding.parent\n\n        if (isChildBuffer && !(binding as BufferBindingOffsetChild).parent.buffer.GPUBuffer) {\n          this.createBindingBuffer(\n            (binding as BufferBindingOffsetChild).parent,\n            (binding as BufferBindingOffsetChild).parent.options.label\n          )\n          ;(binding as BufferBindingOffsetChild).parent.buffer.consumers.add(bindGroupCopy.uuid)\n        } else if (!binding.buffer.GPUBuffer && !isChildBuffer) {\n          this.createBindingBuffer(binding)\n        }\n\n        if ('resultBuffer' in binding) {\n          binding.resultBuffer.consumers.add(bindGroupCopy.uuid)\n        }\n      }\n\n      // if we should create a new bind group layout, fill it\n      if (!keepLayout) {\n        bindGroupCopy.addBindGroupLayoutEntry(binding)\n      }\n\n      bindGroupCopy.addBindGroupEntry(binding)\n    }\n\n    // if we should copy the given bind group layout\n    if (keepLayout) {\n      bindGroupCopy.entries.bindGroupLayout = [...this.entries.bindGroupLayout]\n      bindGroupCopy.layoutCacheKey = this.layoutCacheKey\n    }\n\n    bindGroupCopy.setBindGroupLayout()\n    bindGroupCopy.setBindGroup()\n\n    return bindGroupCopy\n  }\n\n  /**\n   * Destroy our {@link BindGroup}\n   * Most important is to destroy the GPUBuffers to free the memory\n   */\n  destroy() {\n    this.renderer.removeBindGroup(this)\n\n    for (const binding of this.bufferBindings) {\n      this.destroyBufferBinding(binding)\n    }\n\n    this.bindings = []\n    this.bindGroupLayout = null\n    this.bindGroup = null\n    this.resetEntries()\n  }\n}\n","import { Binding, BindingMemoryAccessType, BindingParams, DOMTextureBindingType } from './Binding'\r\nimport {\r\n  getBindGroupLayoutTextureBindingCacheKey,\r\n  getBindGroupLayoutTextureBindingType,\r\n  getTextureBindingWGSLVarType,\r\n} from './utils'\r\n\r\n/** Defines a {@link TextureBinding} {@link TextureBinding#resource | resource} */\r\nexport type TextureBindingResource = GPUTexture | GPUExternalTexture | null\r\n\r\n/**\r\n * An object defining all possible {@link TextureBinding} class instancing parameters\r\n */\r\nexport interface TextureBindingParams extends BindingParams {\r\n  /** The binding type of the {@link TextureBinding} */\r\n  bindingType?: DOMTextureBindingType\r\n  /** {@link TextureBinding} {@link TextureBinding#resource | resource} */\r\n  texture: TextureBindingResource\r\n  /** The {@link GPUTexture | texture} format to use */\r\n  format?: GPUTextureFormat\r\n  /** The storage {@link GPUTexture | texture} binding memory access types (read only, write only or read/write) */\r\n  access?: BindingMemoryAccessType\r\n  /** The {@link GPUTexture | texture} view dimension to use */\r\n  viewDimension?: GPUTextureViewDimension\r\n  /** Whethe the {@link GPUTexture | texture} is a multisampled texture. Mainly used internally by depth textures if needed. */\r\n  multisampled?: boolean\r\n}\r\n\r\n/**\r\n * Used to handle {@link GPUTexture} and {@link GPUExternalTexture} bindings.\r\n *\r\n * Provide both {@link TextureBinding#resourceLayout | resourceLayout} and {@link TextureBinding#resource | resource} to the {@link GPUBindGroupLayout} and {@link GPUBindGroup}.<br>\r\n * Also create the appropriate WGSL code snippet to add to the shaders.\r\n */\r\nexport class TextureBinding extends Binding {\r\n  /** The binding type of the {@link TextureBinding} */\r\n  bindingType: DOMTextureBindingType\r\n  /** Our {@link TextureBinding} resource, i.e. a {@link GPUTexture} or {@link GPUExternalTexture} */\r\n  texture: TextureBindingResource\r\n  /** An array of strings to append to our shaders code declaring all the WGSL variables representing this {@link TextureBinding} */\r\n  wgslGroupFragment: string[]\r\n  /** Options used to create this {@link TextureBinding} */\r\n  options: TextureBindingParams\r\n\r\n  /**\r\n   * TextureBinding constructor\r\n   * @param parameters - {@link TextureBindingParams | parameters} used to create our {@link TextureBinding}\r\n   */\r\n  constructor({\r\n    label = 'Texture',\r\n    name = 'texture',\r\n    bindingType,\r\n    visibility,\r\n    texture,\r\n    format = 'rgba8unorm',\r\n    access = 'write',\r\n    viewDimension = '2d',\r\n    multisampled = false,\r\n  }: TextureBindingParams) {\r\n    bindingType = bindingType ?? 'texture'\r\n\r\n    if (bindingType === 'storage') {\r\n      visibility = ['compute']\r\n    }\r\n\r\n    super({ label, name, bindingType, visibility })\r\n\r\n    this.options = {\r\n      ...this.options,\r\n      texture,\r\n      format,\r\n      access,\r\n      viewDimension,\r\n      multisampled,\r\n    }\r\n\r\n    this.cacheKey += `${format},${access},${viewDimension},${multisampled},`\r\n\r\n    this.resource = texture // should be a texture or an external texture\r\n\r\n    this.setWGSLFragment()\r\n  }\r\n\r\n  /**\r\n   * Get bind group layout entry resource, either for {@link GPUBindGroupLayoutEntry#texture | texture} or {@link GPUBindGroupLayoutEntry#externalTexture | external texture}\r\n   * @readonly\r\n   */\r\n  get resourceLayout():\r\n    | GPUTextureBindingLayout\r\n    | GPUExternalTextureBindingLayout\r\n    | GPUStorageTextureBindingLayout\r\n    | null {\r\n    return getBindGroupLayoutTextureBindingType(this)\r\n  }\r\n\r\n  /**\r\n   * Get the resource cache key\r\n   * @readonly\r\n   */\r\n  get resourceLayoutCacheKey(): string {\r\n    return getBindGroupLayoutTextureBindingCacheKey(this)\r\n  }\r\n\r\n  /**\r\n   * Get the {@link GPUBindGroupEntry#resource | bind group resource}\r\n   */\r\n  get resource(): GPUExternalTexture | GPUTextureView | null {\r\n    return this.texture instanceof GPUTexture\r\n      ? this.texture.createView({ label: this.options.label + ' view', dimension: this.options.viewDimension })\r\n      : this.texture instanceof GPUExternalTexture\r\n      ? this.texture\r\n      : null\r\n  }\r\n\r\n  /**\r\n   * Set the {@link GPUBindGroupEntry#resource | bind group resource}\r\n   * @param value - new bind group resource\r\n   */\r\n  set resource(value: TextureBindingResource) {\r\n    // resource changed, update bind group!\r\n    if (value || this.texture) this.shouldResetBindGroup = true\r\n    this.texture = value\r\n  }\r\n\r\n  /**\r\n   * Set or update our {@link Binding#bindingType | bindingType} and our WGSL code snippet\r\n   * @param bindingType - the new {@link Binding#bindingType | binding type}\r\n   */\r\n  setBindingType(bindingType: DOMTextureBindingType) {\r\n    if (bindingType !== this.bindingType) {\r\n      // binding type has changed!\r\n      if (bindingType) this.shouldResetBindGroupLayout = true\r\n\r\n      this.bindingType = bindingType\r\n      this.cacheKey = `${this.bindingType},${this.visibility},${this.options.format},${this.options.access},${this.options.viewDimension},${this.options.multisampled},`\r\n      this.setWGSLFragment()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set or update our texture {@link TextureBindingParams#format | format}. Note that if the texture is a `storage` {@link bindingType} and the `format` value is different from the previous one, the associated {@link core/bindGroups/BindGroup.BindGroup#bindGroupLayout | GPU bind group layout} will be recreated.\r\n   * @param format - new texture {@link TextureBindingParams#format | format} value to use\r\n   */\r\n  setFormat(format: GPUTextureFormat) {\r\n    const isNewFormat = format !== this.options.format\r\n    this.options.format = format\r\n\r\n    if (isNewFormat && this.bindingType === 'storage') {\r\n      this.setWGSLFragment()\r\n      this.shouldResetBindGroupLayout = true\r\n      this.cacheKey = `${this.bindingType},${this.visibility},${this.options.format},${this.options.access},${this.options.viewDimension},${this.options.multisampled},`\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set or update our texture {@link TextureBindingParams#multisampled | multisampled}. Note that if the texture is not a `storage` {@link bindingType} and the `multisampled` value is different from the previous one, the associated {@link core/bindGroups/BindGroup.BindGroup#bindGroupLayout | GPU bind group layout} will be recreated.\r\n   * @param multisampled - new texture {@link TextureBindingParams#multisampled | multisampled} value to use\r\n   */\r\n  setMultisampled(multisampled: boolean) {\r\n    const isNewMultisampled = multisampled !== this.options.multisampled\r\n    this.options.multisampled = multisampled\r\n\r\n    if (isNewMultisampled && this.bindingType !== 'storage') {\r\n      this.setWGSLFragment()\r\n      this.shouldResetBindGroupLayout = true\r\n      this.cacheKey = `${this.bindingType},${this.visibility},${this.options.format},${this.options.access},${this.options.viewDimension},${this.options.multisampled},`\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the correct WGSL code snippet.\r\n   */\r\n  setWGSLFragment() {\r\n    this.wgslGroupFragment = [`${getTextureBindingWGSLVarType(this)}`]\r\n  }\r\n}\r\n","import { Vec3 } from './Vec3'\r\nimport { Quat } from './Quat'\r\n\r\nconst xAxis = new Vec3()\r\nconst yAxis = new Vec3()\r\nconst zAxis = new Vec3()\r\n\r\n/** Defines the base parameters to create an orthographic projection {@link Mat4} */\r\nexport interface OrthographicProjectionParams {\r\n  /** Left side of the projection near clipping plane viewport. Default to `-5`. */\r\n  left?: number\r\n  /** Right side of the projection near clipping plane viewport. Default to `5`. */\r\n  right?: number\r\n  /** Bottom side of the projection near clipping plane viewport. Default to `-5`. */\r\n  bottom?: number\r\n  /** Top side of the projection near clipping plane viewport. Default to `5`. */\r\n  top?: number\r\n  /** Projection near plane. Default to `0.1`. */\r\n  near?: number\r\n  /** Projection far plane. Default to `50`. */\r\n  far?: number\r\n}\r\n\r\n/** Defines the base parameters to create a perspective projection {@link Mat4} */\r\nexport interface PerspectiveProjectionParams {\r\n  /** Perspective field of view (in radians). Default to `90`. */\r\n  fov?: number\r\n  /** Perspective aspect ratio (width / height). Default to `1`. */\r\n  aspect?: number\r\n  /** Projection near plane. Default to `0.1`. */\r\n  near?: number\r\n  /** Projection far plane. Default to `150`. */\r\n  far?: number\r\n}\r\n\r\n/**\r\n * Basic 4x4 matrix class used for matrix calculations.\r\n *\r\n * Note that like three.js, the constructor and {@link set} method take arguments in row-major order, while internally they are stored in the {@link elements} array in column-major order.\r\n *\r\n * @see https://github.com/mrdoob/three.js/blob/dev/src/math/Matrix4.js\r\n * @see http://glmatrix.net/docs/mat4.js.html\r\n */\r\nexport class Mat4 {\r\n  /** The type of the {@link Mat4} */\r\n  type: string\r\n  /** Our matrix array */\r\n  elements: Float32Array\r\n\r\n  // prettier-ignore\r\n  /**\r\n   * Mat4 constructor\r\n   * @param elements - initial array to use, default to identity matrix\r\n   */\r\n  constructor(elements: Float32Array = new Float32Array([\r\n    1, 0, 0, 0,\r\n    0, 1, 0, 0,\r\n    0, 0, 1, 0,\r\n    0, 0, 0, 1\r\n  ])) {\r\n    this.type = 'Mat4'\r\n    this.elements = elements\r\n  }\r\n\r\n  /***\r\n   * Sets the matrix from 16 numbers\r\n   *\r\n   * @param n11 - number\r\n   * @param n12 - number\r\n   * @param n13 - number\r\n   * @param n14 - number\r\n   * @param n21 - number\r\n   * @param n22 - number\r\n   * @param n23 - number\r\n   * @param n24 - number\r\n   * @param n31 - number\r\n   * @param n32 - number\r\n   * @param n33 - number\r\n   * @param n34 - number\r\n   * @param n41 - number\r\n   * @param n42 - number\r\n   * @param n43 - number\r\n   * @param n44 - number\r\n   *\r\n   * @returns - this {@link Mat4} after being set\r\n   */\r\n  set(\r\n    n11: number,\r\n    n12: number,\r\n    n13: number,\r\n    n14: number,\r\n    n21: number,\r\n    n22: number,\r\n    n23: number,\r\n    n24: number,\r\n    n31: number,\r\n    n32: number,\r\n    n33: number,\r\n    n34: number,\r\n    n41: number,\r\n    n42: number,\r\n    n43: number,\r\n    n44: number\r\n  ): Mat4 {\r\n    const te = this.elements\r\n\r\n    te[0] = n11\r\n    te[1] = n12\r\n    te[2] = n13\r\n    te[3] = n14\r\n    te[4] = n21\r\n    te[5] = n22\r\n    te[6] = n23\r\n    te[7] = n24\r\n    te[8] = n31\r\n    te[9] = n32\r\n    te[10] = n33\r\n    te[11] = n34\r\n    te[12] = n41\r\n    te[13] = n42\r\n    te[14] = n43\r\n    te[15] = n44\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Sets the {@link Mat4} to an identity matrix\r\n   * @returns - this {@link Mat4} after being set\r\n   */\r\n  identity(): Mat4 {\r\n    // prettier-ignore\r\n    this.set(\r\n      1, 0, 0, 0,\r\n      0, 1, 0, 0,\r\n      0, 0, 1, 0,\r\n      0, 0, 0, 1\r\n    )\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Sets the {@link Mat4} values from an array\r\n   * @param array - array to use\r\n   * @returns - this {@link Mat4} after being set\r\n   */\r\n  // prettier-ignore\r\n  setFromArray(array: Float32Array | number[] = new Float32Array([\r\n    1, 0, 0, 0,\r\n    0, 1, 0, 0,\r\n    0, 0, 1, 0,\r\n    0, 0, 0, 1\r\n  ])): Mat4 {\r\n    for (let i = 0; i < this.elements.length; i++) {\r\n      this.elements[i] = array[i]\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Copy another {@link Mat4}\r\n   * @param matrix - matrix to copy\r\n   * @returns - this {@link Mat4} after being set\r\n   */\r\n  copy(matrix: Mat4 = new Mat4()): Mat4 {\r\n    const array = matrix.elements\r\n    this.elements[0] = array[0]\r\n    this.elements[1] = array[1]\r\n    this.elements[2] = array[2]\r\n    this.elements[3] = array[3]\r\n    this.elements[4] = array[4]\r\n    this.elements[5] = array[5]\r\n    this.elements[6] = array[6]\r\n    this.elements[7] = array[7]\r\n    this.elements[8] = array[8]\r\n    this.elements[9] = array[9]\r\n    this.elements[10] = array[10]\r\n    this.elements[11] = array[11]\r\n    this.elements[12] = array[12]\r\n    this.elements[13] = array[13]\r\n    this.elements[14] = array[14]\r\n    this.elements[15] = array[15]\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Clone a {@link Mat4}\r\n   * @returns - cloned {@link Mat4}\r\n   */\r\n  clone(): Mat4 {\r\n    return new Mat4().copy(this)\r\n  }\r\n\r\n  /**\r\n   * Multiply this {@link Mat4} with another {@link Mat4}\r\n   * @param matrix - {@link Mat4} to multiply with\r\n   * @returns - this {@link Mat4} after multiplication\r\n   */\r\n  multiply(matrix: Mat4 = new Mat4()): Mat4 {\r\n    return this.multiplyMatrices(this, matrix)\r\n  }\r\n\r\n  /**\r\n   * Multiply another {@link Mat4} with this {@link Mat4}\r\n   * @param matrix - {@link Mat4} to multiply with\r\n   * @returns - this {@link Mat4} after multiplication\r\n   */\r\n  premultiply(matrix: Mat4 = new Mat4()): Mat4 {\r\n    return this.multiplyMatrices(matrix, this)\r\n  }\r\n\r\n  /**\r\n   * Multiply two {@link Mat4}\r\n   * @param a - first {@link Mat4}\r\n   * @param b - second {@link Mat4}\r\n   * @returns - {@link Mat4} resulting from the multiplication\r\n   */\r\n  multiplyMatrices(a: Mat4 = new Mat4(), b: Mat4 = new Mat4()): Mat4 {\r\n    const ae = a.elements\r\n    const be = b.elements\r\n    const te = this.elements\r\n\r\n    const a11 = ae[0],\r\n      a12 = ae[4],\r\n      a13 = ae[8],\r\n      a14 = ae[12]\r\n    const a21 = ae[1],\r\n      a22 = ae[5],\r\n      a23 = ae[9],\r\n      a24 = ae[13]\r\n    const a31 = ae[2],\r\n      a32 = ae[6],\r\n      a33 = ae[10],\r\n      a34 = ae[14]\r\n    const a41 = ae[3],\r\n      a42 = ae[7],\r\n      a43 = ae[11],\r\n      a44 = ae[15]\r\n\r\n    const b11 = be[0],\r\n      b12 = be[4],\r\n      b13 = be[8],\r\n      b14 = be[12]\r\n    const b21 = be[1],\r\n      b22 = be[5],\r\n      b23 = be[9],\r\n      b24 = be[13]\r\n    const b31 = be[2],\r\n      b32 = be[6],\r\n      b33 = be[10],\r\n      b34 = be[14]\r\n    const b41 = be[3],\r\n      b42 = be[7],\r\n      b43 = be[11],\r\n      b44 = be[15]\r\n\r\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41\r\n    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42\r\n    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43\r\n    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44\r\n\r\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41\r\n    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42\r\n    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43\r\n    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44\r\n\r\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41\r\n    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42\r\n    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43\r\n    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44\r\n\r\n    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41\r\n    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42\r\n    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43\r\n    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * {@link premultiply} this {@link Mat4} by a translate matrix (i.e. translateMatrix = new Mat4().translate(vector))\r\n   * @param vector - translation {@link Vec3 | vector} to use\r\n   * @returns - this {@link Mat4} after the premultiply translate operation\r\n   */\r\n  premultiplyTranslate(vector: Vec3 = new Vec3()): Mat4 {\r\n    // premultiply by a translateMatrix, ie translateMatrix = new Mat4().translate(vector)\r\n    // where translateMatrix[0] = 1, translateMatrix[5] = 1, scaleMatrix[10] = 1, translateMatrix[15] = 1 from identity\r\n    // and translateMatrix[12] = vector.x, translateMatrix[13] = vector.y, translateMatrix[14] = vector.z from translation\r\n    // equivalent (but faster) to this.multiply(translateMatrix, this)\r\n\r\n    // from identity matrix\r\n    const a11 = 1\r\n    const a22 = 1\r\n    const a33 = 1\r\n    const a44 = 1\r\n\r\n    // from translation\r\n    const a14 = vector.x\r\n    const a24 = vector.y\r\n    const a34 = vector.z\r\n\r\n    const be = this.elements\r\n    const te = this.elements\r\n\r\n    const b11 = be[0],\r\n      b12 = be[4],\r\n      b13 = be[8],\r\n      b14 = be[12]\r\n    const b21 = be[1],\r\n      b22 = be[5],\r\n      b23 = be[9],\r\n      b24 = be[13]\r\n    const b31 = be[2],\r\n      b32 = be[6],\r\n      b33 = be[10],\r\n      b34 = be[14]\r\n    const b41 = be[3],\r\n      b42 = be[7],\r\n      b43 = be[11],\r\n      b44 = be[15]\r\n\r\n    te[0] = a11 * b11 + a14 * b41\r\n    te[4] = a11 * b12 + a14 * b42\r\n    te[8] = a11 * b13 + a14 * b43\r\n    te[12] = a11 * b14 + a14 * b44\r\n\r\n    te[1] = a22 * b21 + a24 * b41\r\n    te[5] = a22 * b22 + a24 * b42\r\n    te[9] = a22 * b23 + a24 * b43\r\n    te[13] = a22 * b24 + a24 * b44\r\n\r\n    te[2] = a33 * b31 + a34 * b41\r\n    te[6] = a33 * b32 + a34 * b42\r\n    te[10] = a33 * b33 + a34 * b43\r\n    te[14] = a33 * b34 + a34 * b44\r\n\r\n    te[3] = a44 * b41\r\n    te[7] = a44 * b42\r\n    te[11] = a44 * b43\r\n    te[15] = a44 * b44\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * {@link premultiply} this {@link Mat4} by a scale matrix (i.e. translateMatrix = new Mat4().scale(vector))\r\n   * @param vector - scale {@link Vec3 | vector} to use\r\n   * @returns - this {@link Mat4} after the premultiply scale operation\r\n   */\r\n  premultiplyScale(vector: Vec3 = new Vec3()): Mat4 {\r\n    // premultiply by a scaleMatrix, ie scaleMatrix = new Mat4().scale(vector)\r\n    // where scaleMatrix[0] = vector.x, scaleMatrix[5] = vector.y, scaleMatrix[10] = vector.z, scaleMatrix[15] = 1\r\n    // equivalent (but faster) to this.multiply(scaleMatrix, this)\r\n\r\n    const be = this.elements\r\n    const te = this.elements\r\n\r\n    const a11 = vector.x\r\n    const a22 = vector.y\r\n    const a33 = vector.z\r\n    const a44 = 1\r\n\r\n    const b11 = be[0],\r\n      b12 = be[4],\r\n      b13 = be[8],\r\n      b14 = be[12]\r\n    const b21 = be[1],\r\n      b22 = be[5],\r\n      b23 = be[9],\r\n      b24 = be[13]\r\n    const b31 = be[2],\r\n      b32 = be[6],\r\n      b33 = be[10],\r\n      b34 = be[14]\r\n    const b41 = be[3],\r\n      b42 = be[7],\r\n      b43 = be[11],\r\n      b44 = be[15]\r\n\r\n    te[0] = a11 * b11\r\n    te[4] = a11 * b12\r\n    te[8] = a11 * b13\r\n    te[12] = a11 * b14\r\n\r\n    te[1] = a22 * b21\r\n    te[5] = a22 * b22\r\n    te[9] = a22 * b23\r\n    te[13] = a22 * b24\r\n\r\n    te[2] = a33 * b31\r\n    te[6] = a33 * b32\r\n    te[10] = a33 * b33\r\n    te[14] = a33 * b34\r\n\r\n    te[3] = a44 * b41\r\n    te[7] = a44 * b42\r\n    te[11] = a44 * b43\r\n    te[15] = a44 * b44\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Get the {@link Mat4} inverse\r\n   * @returns - the inverted {@link Mat4}\r\n   */\r\n  invert() {\r\n    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n    const te = this.elements,\r\n      n11 = te[0],\r\n      n21 = te[1],\r\n      n31 = te[2],\r\n      n41 = te[3],\r\n      n12 = te[4],\r\n      n22 = te[5],\r\n      n32 = te[6],\r\n      n42 = te[7],\r\n      n13 = te[8],\r\n      n23 = te[9],\r\n      n33 = te[10],\r\n      n43 = te[11],\r\n      n14 = te[12],\r\n      n24 = te[13],\r\n      n34 = te[14],\r\n      n44 = te[15],\r\n      t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\r\n      t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\r\n      t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\r\n      t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34\r\n\r\n    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14\r\n\r\n    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\r\n\r\n    const detInv = 1 / det\r\n\r\n    te[0] = t11 * detInv\r\n    te[1] =\r\n      (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) *\r\n      detInv\r\n    te[2] =\r\n      (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) *\r\n      detInv\r\n    te[3] =\r\n      (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) *\r\n      detInv\r\n\r\n    te[4] = t12 * detInv\r\n    te[5] =\r\n      (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) *\r\n      detInv\r\n    te[6] =\r\n      (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) *\r\n      detInv\r\n    te[7] =\r\n      (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) *\r\n      detInv\r\n\r\n    te[8] = t13 * detInv\r\n    te[9] =\r\n      (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) *\r\n      detInv\r\n    te[10] =\r\n      (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) *\r\n      detInv\r\n    te[11] =\r\n      (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) *\r\n      detInv\r\n\r\n    te[12] = t14 * detInv\r\n    te[13] =\r\n      (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) *\r\n      detInv\r\n    te[14] =\r\n      (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) *\r\n      detInv\r\n    te[15] =\r\n      (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) *\r\n      detInv\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Clone and invert the {@link Mat4}\r\n   * @returns - inverted cloned {@link Mat4}\r\n   */\r\n  getInverse(): Mat4 {\r\n    return this.clone().invert()\r\n  }\r\n\r\n  /**\r\n   * Transpose this {@link Mat4}\r\n   * @returns - the transposed {@link Mat4}\r\n   */\r\n  transpose(): Mat4 {\r\n    let t\r\n    const te = this.elements\r\n\r\n    t = te[1]\r\n    te[1] = te[4]\r\n    te[4] = t\r\n\r\n    t = te[2]\r\n    te[2] = te[8]\r\n    te[8] = t\r\n\r\n    t = te[3]\r\n    te[3] = te[12]\r\n    te[12] = t\r\n\r\n    t = te[6]\r\n    te[6] = te[9]\r\n    te[9] = t\r\n\r\n    t = te[7]\r\n    te[7] = te[13]\r\n    te[13] = t\r\n\r\n    t = te[11]\r\n    te[11] = te[14]\r\n    te[14] = t\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Translate a {@link Mat4}\r\n   * @param vector - translation {@link Vec3 | vector} to use\r\n   * @returns - translated {@link Mat4}\r\n   */\r\n  translate(vector: Vec3 = new Vec3()): Mat4 {\r\n    const a = this.elements\r\n\r\n    a[12] = a[0] * vector.x + a[4] * vector.y + a[8] * vector.z + a[12]\r\n    a[13] = a[1] * vector.x + a[5] * vector.y + a[9] * vector.z + a[13]\r\n    a[14] = a[2] * vector.x + a[6] * vector.y + a[10] * vector.z + a[14]\r\n    a[15] = a[3] * vector.x + a[7] * vector.y + a[11] * vector.z + a[15]\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Get the translation {@link Vec3} component of a {@link Mat4}\r\n   * @param position - {@link Vec3} to set\r\n   * @returns - translation {@link Vec3} component of this {@link Mat4}\r\n   */\r\n  getTranslation(position = new Vec3()): Vec3 {\r\n    return position.set(this.elements[12], this.elements[13], this.elements[14])\r\n  }\r\n\r\n  /**\r\n   * Scale a {@link Mat4}\r\n   * @param vector - scale {@link Vec3 | vector} to use\r\n   * @returns - scaled {@link Mat4}\r\n   */\r\n  scale(vector: Vec3 = new Vec3()): Mat4 {\r\n    const a = this.elements\r\n\r\n    a[0] *= vector.x\r\n    a[1] *= vector.x\r\n    a[2] *= vector.x\r\n    a[3] *= vector.x\r\n    a[4] *= vector.y\r\n    a[5] *= vector.y\r\n    a[6] *= vector.y\r\n    a[7] *= vector.y\r\n    a[8] *= vector.z\r\n    a[9] *= vector.z\r\n    a[10] *= vector.z\r\n    a[11] *= vector.z\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Rotate a {@link Mat4} from a {@link Quat | quaternion}\r\n   * @param quaternion - {@link Quat | quaternion} to use\r\n   * @returns - rotated {@link Mat4}\r\n   */\r\n  rotateFromQuaternion(quaternion: Quat = new Quat()): Mat4 {\r\n    const te = this.elements\r\n\r\n    const x = quaternion.elements[0],\r\n      y = quaternion.elements[1],\r\n      z = quaternion.elements[2],\r\n      w = quaternion.elements[3]\r\n\r\n    const x2 = x + x,\r\n      y2 = y + y,\r\n      z2 = z + z\r\n    const xx = x * x2,\r\n      xy = x * y2,\r\n      xz = x * z2\r\n    const yy = y * y2,\r\n      yz = y * z2,\r\n      zz = z * z2\r\n    const wx = w * x2,\r\n      wy = w * y2,\r\n      wz = w * z2\r\n\r\n    te[0] = 1 - (yy + zz)\r\n    te[4] = xy - wz\r\n    te[8] = xz + wy\r\n\r\n    te[1] = xy + wz\r\n    te[5] = 1 - (xx + zz)\r\n    te[9] = yz - wx\r\n\r\n    te[2] = xz - wy\r\n    te[6] = yz + wx\r\n    te[10] = 1 - (xx + yy)\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Get the maximum scale of the {@link Mat4} on all axes\r\n   * @returns - maximum scale of the {@link Mat4}\r\n   */\r\n  getMaxScaleOnAxis(): number {\r\n    const te = this.elements\r\n\r\n    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2]\r\n    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6]\r\n    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10]\r\n\r\n    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq))\r\n  }\r\n\r\n  /**\r\n   * Creates a {@link Mat4} from a {@link Quat | quaternion} rotation, {@link Vec3 | vector} translation and {@link Vec3 | vector} scale\r\n   * Equivalent for applying translation, rotation and scale matrices but much faster\r\n   * Source code from: http://glmatrix.net/docs/mat4.js.html\r\n   *\r\n   * @param translation - translation {@link Vec3 | vector} to use\r\n   * @param quaternion - {@link Quat | quaternion} to use\r\n   * @param scale - translation {@link Vec3 | vector} to use\r\n   * @returns - transformed {@link Mat4}\r\n   */\r\n  compose(translation: Vec3 = new Vec3(), quaternion: Quat = new Quat(), scale: Vec3 = new Vec3(1)): Mat4 {\r\n    const matrix = this.elements\r\n\r\n    // Quaternion math\r\n    const x = quaternion.elements[0],\r\n      y = quaternion.elements[1],\r\n      z = quaternion.elements[2],\r\n      w = quaternion.elements[3]\r\n\r\n    const x2 = x + x\r\n    const y2 = y + y\r\n    const z2 = z + z\r\n    const xx = x * x2\r\n    const xy = x * y2\r\n    const xz = x * z2\r\n    const yy = y * y2\r\n    const yz = y * z2\r\n    const zz = z * z2\r\n    const wx = w * x2\r\n    const wy = w * y2\r\n    const wz = w * z2\r\n    const sx = scale.x\r\n    const sy = scale.y\r\n    const sz = scale.z\r\n\r\n    matrix[0] = (1 - (yy + zz)) * sx\r\n    matrix[1] = (xy + wz) * sx\r\n    matrix[2] = (xz - wy) * sx\r\n    matrix[3] = 0\r\n    matrix[4] = (xy - wz) * sy\r\n    matrix[5] = (1 - (xx + zz)) * sy\r\n    matrix[6] = (yz + wx) * sy\r\n    matrix[7] = 0\r\n    matrix[8] = (xz + wy) * sz\r\n    matrix[9] = (yz - wx) * sz\r\n    matrix[10] = (1 - (xx + yy)) * sz\r\n    matrix[11] = 0\r\n    matrix[12] = translation.x\r\n    matrix[13] = translation.y\r\n    matrix[14] = translation.z\r\n    matrix[15] = 1\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Creates a {@link Mat4} from a {@link Quat | quaternion} rotation, {@link Vec3 | vector} translation and {@link Vec3 | vector} scale, rotating and scaling around the given {@link Vec3 | origin vector}\r\n   * Equivalent for applying translation, rotation and scale matrices but much faster\r\n   * Source code from: http://glmatrix.net/docs/mat4.js.html\r\n   *\r\n   * @param translation - translation {@link Vec3 | vector} to use\r\n   * @param quaternion - {@link Quat | quaternion} to use\r\n   * @param scale - translation {@link Vec3 | vector} to use\r\n   * @param origin - origin {@link Vec3 | vector} around which to scale and rotate\r\n   * @returns - transformed {@link Mat4}\r\n   */\r\n  composeFromOrigin(\r\n    translation: Vec3 = new Vec3(),\r\n    quaternion: Quat = new Quat(),\r\n    scale: Vec3 = new Vec3(1),\r\n    origin: Vec3 = new Vec3()\r\n  ): Mat4 {\r\n    const matrix = this.elements\r\n\r\n    // Quaternion math\r\n    const x = quaternion.elements[0],\r\n      y = quaternion.elements[1],\r\n      z = quaternion.elements[2],\r\n      w = quaternion.elements[3]\r\n\r\n    const x2 = x + x\r\n    const y2 = y + y\r\n    const z2 = z + z\r\n\r\n    const xx = x * x2\r\n    const xy = x * y2\r\n    const xz = x * z2\r\n    const yy = y * y2\r\n    const yz = y * z2\r\n    const zz = z * z2\r\n\r\n    const wx = w * x2\r\n    const wy = w * y2\r\n    const wz = w * z2\r\n\r\n    const sx = scale.x\r\n    const sy = scale.y\r\n    const sz = scale.z\r\n\r\n    const ox = origin.x\r\n    const oy = origin.y\r\n    const oz = origin.z\r\n\r\n    const out0 = (1 - (yy + zz)) * sx\r\n    const out1 = (xy + wz) * sx\r\n    const out2 = (xz - wy) * sx\r\n    const out4 = (xy - wz) * sy\r\n    const out5 = (1 - (xx + zz)) * sy\r\n    const out6 = (yz + wx) * sy\r\n    const out8 = (xz + wy) * sz\r\n    const out9 = (yz - wx) * sz\r\n    const out10 = (1 - (xx + yy)) * sz\r\n\r\n    matrix[0] = out0\r\n    matrix[1] = out1\r\n    matrix[2] = out2\r\n    matrix[3] = 0\r\n    matrix[4] = out4\r\n    matrix[5] = out5\r\n    matrix[6] = out6\r\n    matrix[7] = 0\r\n    matrix[8] = out8\r\n    matrix[9] = out9\r\n    matrix[10] = out10\r\n    matrix[11] = 0\r\n    matrix[12] = translation.x + ox - (out0 * ox + out4 * oy + out8 * oz)\r\n    matrix[13] = translation.y + oy - (out1 * ox + out5 * oy + out9 * oz)\r\n    matrix[14] = translation.z + oz - (out2 * ox + out6 * oy + out10 * oz)\r\n    matrix[15] = 1\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Set this {@link Mat4} as a rotation matrix based on an eye, target and up {@link Vec3 | vectors}\r\n   * @param eye - {@link Vec3 | position vector} of the object that should be rotated\r\n   * @param target - {@link Vec3 | target vector} to look at\r\n   * @param up - up {@link Vec3 | vector}\r\n   * @returns - rotated {@link Mat4}\r\n   */\r\n  lookAt(eye: Vec3 = new Vec3(), target: Vec3 = new Vec3(), up: Vec3 = new Vec3(0, 1, 0)): Mat4 {\r\n    const te = this.elements\r\n\r\n    zAxis.copy(eye).sub(target)\r\n\r\n    if (zAxis.lengthSq() === 0) {\r\n      // eye and target are in the same position\r\n      zAxis.z = 1\r\n    }\r\n\r\n    zAxis.normalize()\r\n    xAxis.crossVectors(up, zAxis)\r\n\r\n    if (xAxis.lengthSq() === 0) {\r\n      // up and z are parallel\r\n      if (Math.abs(up.z) === 1) {\r\n        zAxis.x += 0.0001\r\n      } else {\r\n        zAxis.z += 0.0001\r\n      }\r\n\r\n      zAxis.normalize()\r\n      xAxis.crossVectors(up, zAxis)\r\n    }\r\n\r\n    xAxis.normalize()\r\n    yAxis.crossVectors(zAxis, xAxis)\r\n\r\n    te[0] = xAxis.x\r\n    te[1] = xAxis.y\r\n    te[2] = xAxis.z\r\n    te[3] = 0\r\n    te[4] = yAxis.x\r\n    te[5] = yAxis.y\r\n    te[6] = yAxis.z\r\n    te[7] = 0\r\n    te[8] = zAxis.x\r\n    te[9] = zAxis.y\r\n    te[10] = zAxis.z\r\n    te[11] = 0\r\n    te[12] = eye.x\r\n    te[13] = eye.y\r\n    te[14] = eye.z\r\n    te[15] = 1\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Compute a view {@link Mat4} matrix.\r\n   *\r\n   * This is a view matrix which transforms all other objects\r\n   * to be in the space of the view defined by the parameters.\r\n   *\r\n   * Equivalent to `matrix.lookAt(eye, target, up).invert()` but faster.\r\n   *\r\n   * @param eye - the position of the object.\r\n   * @param target - the position meant to be aimed at.\r\n   * @param up - a vector pointing up.\r\n   * @returns - the view {@link Mat4} matrix.\r\n   */\r\n  makeView(eye: Vec3 = new Vec3(), target: Vec3 = new Vec3(), up: Vec3 = new Vec3(0, 1, 0)): Mat4 {\r\n    const te = this.elements\r\n\r\n    zAxis.copy(eye).sub(target).normalize()\r\n    xAxis.crossVectors(up, zAxis).normalize()\r\n    yAxis.crossVectors(zAxis, xAxis).normalize()\r\n\r\n    te[0] = xAxis.x\r\n    te[1] = yAxis.x\r\n    te[2] = zAxis.x\r\n    te[3] = 0\r\n    te[4] = xAxis.y\r\n    te[5] = yAxis.y\r\n    te[6] = zAxis.y\r\n    te[7] = 0\r\n    te[8] = xAxis.z\r\n    te[9] = yAxis.z\r\n    te[10] = zAxis.z\r\n    te[11] = 0\r\n\r\n    te[12] = -(xAxis.x * eye.x + xAxis.y * eye.y + xAxis.z * eye.z)\r\n    te[13] = -(yAxis.x * eye.x + yAxis.y * eye.y + yAxis.z * eye.z)\r\n    te[14] = -(zAxis.x * eye.x + zAxis.y * eye.y + zAxis.z * eye.z)\r\n    te[15] = 1\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Create an orthographic {@link Mat4} matrix based on the parameters. Transforms from\r\n   *  * the given the left, right, bottom, and top dimensions to -1 +1 in x, and y\r\n   *  * and 0 to +1 in z.\r\n   *\r\n   * @param parameters - {@link OrthographicProjectionParams | parameters} used to create the camera orthographic matrix.\r\n   * @returns - the camera orthographic {@link Mat4} matrix.\r\n   */\r\n  makeOrthographic({\r\n    left = -5,\r\n    right = 5,\r\n    bottom = -5,\r\n    top = 5,\r\n    near = 0.1,\r\n    far = 50,\r\n  }: OrthographicProjectionParams): Mat4 {\r\n    const te = this.elements\r\n\r\n    te[0] = 2 / (right - left)\r\n    te[1] = 0\r\n    te[2] = 0\r\n    te[3] = 0\r\n\r\n    te[4] = 0\r\n    te[5] = 2 / (top - bottom)\r\n    te[6] = 0\r\n    te[7] = 0\r\n\r\n    te[8] = 0\r\n    te[9] = 0\r\n    te[10] = 1 / (near - far)\r\n    te[11] = 0\r\n\r\n    te[12] = (right + left) / (left - right)\r\n    te[13] = (top + bottom) / (bottom - top)\r\n    te[14] = near / (near - far)\r\n    te[15] = 1\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Create a perspective {@link Mat4} matrix based on the parameters.\r\n   *\r\n   * Note, The matrix generated sends the viewing frustum to the unit box.\r\n   * We assume a unit box extending from -1 to 1 in the x and y dimensions and\r\n   * from -1 to 1 in the z dimension, as three.js and more generally WebGL handles it.\r\n   *\r\n   * @param parameters - {@link PerspectiveProjectionParams | parameters} used to create the camera perspective matrix.\r\n   * @returns - the camera perspective {@link Mat4} matrix.\r\n   */\r\n  makePerspective({ fov = 90, aspect = 1, near = 0.1, far = 150 }: PerspectiveProjectionParams): Mat4 {\r\n    const top = near * Math.tan((Math.PI / 180) * 0.5 * fov)\r\n    const height = 2 * top\r\n    const width = aspect * height\r\n    const left = -0.5 * width\r\n\r\n    const right = left + width\r\n    const bottom = top - height\r\n\r\n    const x = (2 * near) / (right - left)\r\n    const y = (2 * near) / (top - bottom)\r\n\r\n    const a = (right + left) / (right - left)\r\n    const b = (top + bottom) / (top - bottom)\r\n\r\n    // this should handle depth from 0 to 1\r\n    // and correct near / far clipping planes\r\n    // see https://github.com/mrdoob/three.js/blob/master/src/math/Matrix4.js#L777\r\n    const c = -far / (far - near)\r\n    const d = (-far * near) / (far - near)\r\n\r\n    // prettier-ignore\r\n    this.set(\r\n      x, 0, 0, 0,\r\n      0, y, 0, 0,\r\n      a, b, c, -1,\r\n      0, 0, d, 0\r\n    )\r\n\r\n    return this\r\n  }\r\n}\r\n","import { Vec3 } from '../../math/Vec3'\r\nimport { Quat } from '../../math/Quat'\r\nimport { Mat4 } from '../../math/Mat4'\r\n\r\nlet objectIndex = 0\r\nconst tempMatrix = new Mat4()\r\n\r\n/** Defines all kind of possible {@link Object3D} matrix types */\r\nexport type Object3DMatricesType = 'model' | 'world'\r\n\r\n/**\r\n * Defines an {@link Object3D} matrix object\r\n */\r\nexport interface Object3DTransformMatrix {\r\n  /** The {@link Mat4 | matrix} used */\r\n  matrix: Mat4\r\n  /** Whether we should update the {@link Mat4 | matrix} */\r\n  shouldUpdate: boolean\r\n  /** Function to update our {@link Mat4 | matrix} */\r\n  onUpdate: () => void\r\n}\r\n\r\n/** Defines all possible {@link Object3DTransformMatrix | matrix object} used by our {@link Object3D} */\r\nexport type Object3DMatrices = Record<Object3DMatricesType, Object3DTransformMatrix>\r\n\r\n/**\r\n * Defines all necessary {@link Vec3 | vectors}/{@link Quat | quaternions} to compute a 3D {@link Mat4 | model matrix}\r\n */\r\nexport interface Object3DTransforms {\r\n  /** Transformation origin object */\r\n  origin: {\r\n    /** Transformation origin {@link Vec3 | vector} relative to the {@link Object3D} */\r\n    model: Vec3\r\n  }\r\n  /** Model {@link Quat | quaternion} defining its rotation in 3D space */\r\n  quaternion: Quat\r\n  /** Model rotation {@link Vec3 | vector} used to compute its {@link Quat | quaternion} */\r\n  rotation: Vec3\r\n  /** Position object */\r\n  position: {\r\n    /** Position {@link Vec3 | vector} relative to the 3D world */\r\n    world: Vec3\r\n  }\r\n  /** Model 3D scale {@link Vec3 | vector} */\r\n  scale: Vec3\r\n}\r\n\r\n/**\r\n * Used to create an object with transformation properties such as position, scale, rotation and transform origin {@link Vec3 | vectors} and a {@link Quat | quaternion} in order to compute the {@link Object3D#modelMatrix | model matrix} and {@link Object3D#worldMatrix | world matrix}.\r\n *\r\n * If an {@link Object3D} does not have any {@link Object3D#parent | parent}, then its {@link Object3D#modelMatrix | model matrix} and {@link Object3D#worldMatrix | world matrix} are the same.\r\n *\r\n * The transformations {@link Vec3 | vectors} are reactive to changes, which mean that updating one of their components will automatically update the {@link Object3D#modelMatrix | model matrix} and {@link Object3D#worldMatrix | world matrix}.\r\n */\r\nexport class Object3D {\r\n  /** {@link Object3DTransforms | Transformation object} of the {@link Object3D} */\r\n  transforms: Object3DTransforms\r\n  /** {@link Object3DMatrices | Matrices object} of the {@link Object3D} */\r\n  matrices: Object3DMatrices\r\n\r\n  /** Parent {@link Object3D} in the scene graph, used to compute the {@link worldMatrix | world matrix} */\r\n  private _parent: null | Object3D\r\n  /** Children {@link Object3D} in the scene graph, used to compute their own {@link worldMatrix | world matrix} */\r\n  children: Object3D[]\r\n\r\n  /** Index (order of creation) of this {@link Object3D}. Used in the {@link parent} / {@link children} relation. */\r\n  object3DIndex: number\r\n\r\n  /** Whether at least one of this {@link Object3D} matrix needs an update. */\r\n  matricesNeedUpdate: boolean\r\n\r\n  /**\r\n   * Object3D constructor\r\n   */\r\n  constructor() {\r\n    this._parent = null\r\n    this.children = []\r\n\r\n    this.matricesNeedUpdate = false\r\n\r\n    Object.defineProperty(this as Object3D, 'object3DIndex', { value: objectIndex++ })\r\n\r\n    this.setMatrices()\r\n    this.setTransforms()\r\n  }\r\n\r\n  /* PARENT */\r\n\r\n  /**\r\n   * Get the parent of this {@link Object3D} if any\r\n   */\r\n  get parent(): Object3D | null {\r\n    return this._parent\r\n  }\r\n\r\n  /**\r\n   * Set the parent of this {@link Object3D}\r\n   * @param value - new parent to set, could be an {@link Object3D} or null\r\n   */\r\n  set parent(value: Object3D | null) {\r\n    if (this._parent && value && this._parent.object3DIndex === value.object3DIndex) {\r\n      return\r\n    }\r\n\r\n    if (this._parent) {\r\n      // if we already have a parent, remove it first\r\n      this._parent.children = this._parent.children.filter((child) => child.object3DIndex !== this.object3DIndex)\r\n    }\r\n\r\n    if (value) {\r\n      this.shouldUpdateWorldMatrix()\r\n    }\r\n\r\n    this._parent = value\r\n    this._parent?.children.push(this)\r\n  }\r\n\r\n  /* TRANSFORMS */\r\n\r\n  /**\r\n   * Set our transforms properties and {@link Vec3#onChange | vectors onChange} callbacks\r\n   */\r\n  setTransforms() {\r\n    this.transforms = {\r\n      origin: {\r\n        model: new Vec3(),\r\n      },\r\n      quaternion: new Quat(),\r\n      rotation: new Vec3(),\r\n      position: {\r\n        world: new Vec3(),\r\n      },\r\n      scale: new Vec3(1),\r\n    }\r\n\r\n    this.rotation.onChange(() => this.applyRotation())\r\n    this.position.onChange(() => this.applyPosition())\r\n    this.scale.onChange(() => this.applyScale())\r\n    this.transformOrigin.onChange(() => this.applyTransformOrigin())\r\n  }\r\n\r\n  /**\r\n   * Get our rotation {@link Vec3 | vector}\r\n   */\r\n  get rotation(): Vec3 {\r\n    return this.transforms.rotation\r\n  }\r\n\r\n  /**\r\n   * Set our rotation {@link Vec3 | vector}\r\n   * @param value - new rotation {@link Vec3 | vector}\r\n   */\r\n  set rotation(value: Vec3) {\r\n    this.transforms.rotation = value\r\n    this.applyRotation()\r\n  }\r\n\r\n  /**\r\n   * Get our {@link Quat | quaternion}\r\n   */\r\n  get quaternion(): Quat {\r\n    return this.transforms.quaternion\r\n  }\r\n\r\n  /**\r\n   * Set our {@link Quat | quaternion}\r\n   * @param value - new {@link Quat | quaternion}\r\n   */\r\n  set quaternion(value: Quat) {\r\n    this.transforms.quaternion = value\r\n  }\r\n\r\n  /**\r\n   * Get our position {@link Vec3 | vector}\r\n   */\r\n  get position(): Vec3 {\r\n    return this.transforms.position.world\r\n  }\r\n\r\n  /**\r\n   * Set our position {@link Vec3 | vector}\r\n   * @param value - new position {@link Vec3 | vector}\r\n   */\r\n  set position(value: Vec3) {\r\n    this.transforms.position.world = value\r\n  }\r\n\r\n  /**\r\n   * Get our scale {@link Vec3 | vector}\r\n   */\r\n  get scale(): Vec3 {\r\n    return this.transforms.scale\r\n  }\r\n\r\n  /**\r\n   * Set our scale {@link Vec3 | vector}\r\n   * @param value - new scale {@link Vec3 | vector}\r\n   */\r\n  set scale(value: Vec3) {\r\n    // force scale to 1 on Z axis\r\n    this.transforms.scale = value\r\n    this.applyScale()\r\n  }\r\n\r\n  /**\r\n   * Get our transform origin {@link Vec3 | vector}\r\n   */\r\n  get transformOrigin(): Vec3 {\r\n    return this.transforms.origin.model\r\n  }\r\n\r\n  /**\r\n   * Set our transform origin {@link Vec3 | vector}\r\n   * @param value - new transform origin {@link Vec3 | vector}\r\n   */\r\n  set transformOrigin(value: Vec3) {\r\n    this.transforms.origin.model = value\r\n  }\r\n\r\n  /**\r\n   * Apply our rotation and tell our {@link modelMatrix | model matrix} to update\r\n   */\r\n  applyRotation() {\r\n    this.quaternion.setFromVec3(this.rotation)\r\n\r\n    this.shouldUpdateModelMatrix()\r\n  }\r\n\r\n  /**\r\n   * Tell our {@link modelMatrix | model matrix} to update\r\n   */\r\n  applyPosition() {\r\n    this.shouldUpdateModelMatrix()\r\n  }\r\n\r\n  /**\r\n   * Tell our {@link modelMatrix | model matrix} to update\r\n   */\r\n  applyScale() {\r\n    this.shouldUpdateModelMatrix()\r\n  }\r\n\r\n  /**\r\n   * Tell our {@link modelMatrix | model matrix} to update\r\n   */\r\n  applyTransformOrigin() {\r\n    this.shouldUpdateModelMatrix()\r\n  }\r\n\r\n  /* MATRICES */\r\n\r\n  /**\r\n   * Set our {@link modelMatrix | model matrix} and {@link worldMatrix | world matrix}\r\n   */\r\n  setMatrices() {\r\n    this.matrices = {\r\n      model: {\r\n        matrix: new Mat4(),\r\n        shouldUpdate: true,\r\n        onUpdate: () => this.updateModelMatrix(),\r\n      },\r\n      world: {\r\n        matrix: new Mat4(),\r\n        shouldUpdate: true,\r\n        onUpdate: () => this.updateWorldMatrix(),\r\n      },\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get our {@link Mat4 | model matrix}\r\n   */\r\n  get modelMatrix(): Mat4 {\r\n    return this.matrices.model.matrix\r\n  }\r\n\r\n  /**\r\n   * Set our {@link Mat4 | model matrix}\r\n   * @param value - new {@link Mat4 | model matrix}\r\n   */\r\n  set modelMatrix(value: Mat4) {\r\n    this.matrices.model.matrix = value\r\n    this.shouldUpdateModelMatrix()\r\n  }\r\n\r\n  /**\r\n   * Set our {@link modelMatrix | model matrix} shouldUpdate flag to true (tell it to update)\r\n   */\r\n  shouldUpdateModelMatrix() {\r\n    this.matrices.model.shouldUpdate = true\r\n    this.shouldUpdateWorldMatrix()\r\n  }\r\n\r\n  /**\r\n   * Get our {@link Mat4 | world matrix}\r\n   */\r\n  get worldMatrix(): Mat4 {\r\n    return this.matrices.world.matrix\r\n  }\r\n\r\n  /**\r\n   * Set our {@link Mat4 | world matrix}\r\n   * @param value - new {@link Mat4 | world matrix}\r\n   */\r\n  set worldMatrix(value: Mat4) {\r\n    this.matrices.world.matrix = value\r\n    this.shouldUpdateWorldMatrix()\r\n  }\r\n\r\n  /**\r\n   * Set our {@link worldMatrix | world matrix} shouldUpdate flag to true (tell it to update)\r\n   */\r\n  shouldUpdateWorldMatrix() {\r\n    this.matrices.world.shouldUpdate = true\r\n  }\r\n\r\n  /**\r\n   * Rotate this {@link Object3D} so it looks at the {@link Vec3 | target}\r\n   * @param target - {@link Vec3 | target} to look at\r\n   * @param position - {@link Vec3 | postion} from which to look at\r\n   */\r\n  lookAt(target: Vec3 = new Vec3(), position = this.position, up = new Vec3(0, 1, 0)) {\r\n    const rotationMatrix = tempMatrix.lookAt(target, position, up)\r\n    this.quaternion.setFromRotationMatrix(rotationMatrix)\r\n    this.shouldUpdateModelMatrix()\r\n  }\r\n\r\n  /**\r\n   * Update our {@link modelMatrix | model matrix}\r\n   */\r\n  updateModelMatrix() {\r\n    // compose our model transformation matrix from custom origin\r\n    this.modelMatrix = this.modelMatrix.composeFromOrigin(\r\n      this.position,\r\n      this.quaternion,\r\n      this.scale,\r\n      this.transformOrigin\r\n    )\r\n\r\n    // tell our world matrix to update\r\n    this.shouldUpdateWorldMatrix()\r\n  }\r\n\r\n  /**\r\n   * Update our {@link worldMatrix | model matrix}\r\n   */\r\n  updateWorldMatrix() {\r\n    if (!this.parent) {\r\n      this.worldMatrix.copy(this.modelMatrix)\r\n    } else {\r\n      this.worldMatrix.multiplyMatrices(this.parent.worldMatrix, this.modelMatrix)\r\n    }\r\n\r\n    // update the children world matrix as well\r\n    for (let i = 0, l = this.children.length; i < l; i++) {\r\n      this.children[i].shouldUpdateWorldMatrix()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check whether at least one of the matrix should be updated\r\n   */\r\n  shouldUpdateMatrices() {\r\n    this.matricesNeedUpdate = !!Object.values(this.matrices).find((matrix) => matrix.shouldUpdate)\r\n  }\r\n\r\n  /**\r\n   * Check at each render whether we should update our matrices, and update them if needed\r\n   */\r\n  updateMatrixStack() {\r\n    this.shouldUpdateMatrices()\r\n\r\n    if (this.matricesNeedUpdate) {\r\n      for (const matrixName in this.matrices) {\r\n        if (this.matrices[matrixName].shouldUpdate) {\r\n          this.matrices[matrixName].onUpdate()\r\n          this.matrices[matrixName].shouldUpdate = false\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let i = 0, l = this.children.length; i < l; i++) {\r\n      this.children[i].updateMatrixStack()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroy this {@link Object3D}. Removes its parent and set its children free.\r\n   */\r\n  destroy() {\r\n    for (let i = 0, l = this.children.length; i < l; i++) {\r\n      if (this.children[i]) this.children[i].parent = null\r\n    }\r\n\r\n    this.parent = null\r\n  }\r\n}\r\n","// texture bitwise flags\r\nimport { WebGPUTextureUsageConstants } from '../../utils/webgpu-constants'\r\nimport { TextureBindingType } from '../bindings/Binding'\r\n\r\n/**  Defines all kinds of allowed texture usages as camel case strings. */\r\nexport type TextureUsageKeys = 'copySrc' | 'copyDst' | 'renderAttachment' | 'storageBinding' | 'textureBinding'\r\n\r\n/**\r\n * Map {@link TextureUsageKeys | texture usage names} with actual {@link GPUTextureUsageFlags | texture usage bitwise flags}.\r\n */\r\nconst textureUsages: Map<TextureUsageKeys, GPUTextureUsageFlags> = new Map([\r\n  ['copySrc', WebGPUTextureUsageConstants.COPY_SRC],\r\n  ['copyDst', WebGPUTextureUsageConstants.COPY_DST],\r\n  ['renderAttachment', WebGPUTextureUsageConstants.RENDER_ATTACHMENT],\r\n  ['storageBinding', WebGPUTextureUsageConstants.STORAGE_BINDING],\r\n  ['textureBinding', WebGPUTextureUsageConstants.TEXTURE_BINDING],\r\n])\r\n\r\n/**\r\n * Get the corresponding {@link GPUTextureUsageFlags | texture usage bitwise flags} based on an array of {@link TextureUsageKeys | texture usage names}.\r\n * @param usages - array of {@link TextureUsageKeys | texture usage names}.\r\n * @returns - corresponding {@link GPUTextureUsageFlags | texture usage bitwise flags}.\r\n */\r\nexport const getTextureUsages = (usages: TextureUsageKeys[] = []): GPUTextureUsageFlags => {\r\n  return usages.reduce((acc, v) => {\r\n    return acc | textureUsages.get(v)\r\n  }, 0)\r\n}\r\n\r\n/**\r\n * Get the corresponding {@link GPUTextureUsageFlags | texture usage bitwise flags} based on an array of {@link TextureUsageKeys | texture usage names} if specified. If not, will try to fall back to a usage based on the {@link TextureBindingType | texture type}.\r\n * @param usages - array of {@link TextureUsageKeys | texture usage names}.\r\n * @param textureType - the {@link TextureBindingType | texture type}.\r\n * @returns - corresponding {@link GPUTextureUsageFlags | texture usage bitwise flags}.\r\n */\r\nexport const getDefaultTextureUsage = (usages: TextureUsageKeys[] = [], textureType: TextureBindingType) => {\r\n  if (usages.length) {\r\n    return getTextureUsages(usages)\r\n  }\r\n\r\n  return textureType !== 'storage'\r\n    ? GPUTextureUsage.TEXTURE_BINDING |\r\n        GPUTextureUsage.COPY_SRC |\r\n        GPUTextureUsage.COPY_DST |\r\n        GPUTextureUsage.RENDER_ATTACHMENT\r\n    : GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST\r\n}\r\n\r\n/**\r\n * Get the number of mip levels create based on {@link types/Textures.TextureSize | size}\r\n * @param sizes - Array containing our texture width, height and depth\r\n * @returns - number of mip levels\r\n */\r\nexport const getNumMipLevels = (...sizes: number[]): number => {\r\n  const maxSize = Math.max(...sizes)\r\n  return (1 + Math.log2(maxSize)) | 0\r\n}\r\n","import { Vec3 } from '../../math/Vec3'\r\nimport { isRenderer, Renderer } from '../renderers/utils'\r\nimport { TextureBinding } from '../bindings/TextureBinding'\r\nimport { BufferBinding } from '../bindings/BufferBinding'\r\nimport { Object3D } from '../objects3D/Object3D'\r\nimport { Mat4 } from '../../math/Mat4'\r\nimport { generateUUID, throwWarning } from '../../utils/utils'\r\nimport { BindGroupBindingElement } from '../../types/BindGroups'\r\nimport { DOMTextureOptions, DOMTextureParams, DOMTextureParent, TextureSize, TextureSource } from '../../types/Textures'\r\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\r\nimport { DOMProjectedMesh } from '../renderers/GPURenderer'\r\nimport { getNumMipLevels } from './utils'\r\n\r\n/** @const - default {@link DOMTexture} parameters */\r\nconst defaultDOMTextureParams: DOMTextureParams = {\r\n  name: 'texture',\r\n  generateMips: false,\r\n  flipY: false,\r\n  format: 'rgba8unorm',\r\n  premultipliedAlpha: false,\r\n  placeholderColor: [0, 0, 0, 255], // default to black\r\n  useExternalTextures: true,\r\n  fromTexture: null,\r\n  viewDimension: '2d',\r\n  visibility: ['fragment'],\r\n  cache: true,\r\n}\r\n\r\n/**\r\n * Used to create {@link GPUTexture} or {@link GPUExternalTexture}, specially made to handle different kinds of DOM elements {@link TextureSource | sources}, like {@link HTMLImageElement}, {@link HTMLVideoElement} or {@link HTMLCanvasElement}.\r\n *\r\n * Handles the various sources loading and uploading, GPU textures creation,{@link BufferBinding | texture model matrix binding} and {@link TextureBinding | GPU texture binding}.\r\n *\r\n * @example\r\n * ```javascript\r\n * // set our main GPUCurtains instance\r\n * const gpuCurtains = new GPUCurtains({\r\n *   container: '#canvas' // selector of our WebGPU canvas container\r\n * })\r\n *\r\n * // set the GPU device\r\n * // note this is asynchronous\r\n * await gpuCurtains.setDevice()\r\n *\r\n * // create a DOM texture\r\n * const imageTexture = new DOMTexture(gpuCurtains, {\r\n *   label: 'My image texture',\r\n *   name: 'imageTexture',\r\n * })\r\n *\r\n * // load an image\r\n * await imageTexture.loadImage(document.querySelector('img'))\r\n * ```\r\n */\r\nexport class DOMTexture extends Object3D {\r\n  /** The type of the {@link DOMTexture} */\r\n  type: string\r\n  /** The universal unique id of this {@link DOMTexture} */\r\n  readonly uuid: string\r\n  /** {@link Renderer} used by this {@link DOMTexture} */\r\n  renderer: Renderer\r\n\r\n  /** The {@link GPUTexture} used if any */\r\n  texture: null | GPUTexture\r\n  /** The {@link GPUExternalTexture} used if any */\r\n  externalTexture: null | GPUExternalTexture\r\n\r\n  /** The {@link DOMTexture} {@link TextureSource | source} to use */\r\n  source: TextureSource\r\n  /** The {@link GPUTexture}, matching the {@link TextureSource | source} {@link core/DOM/DOMElement.RectSize | size} (with 1 for depth) */\r\n  size: TextureSize\r\n\r\n  /** Options used to create this {@link DOMTexture} */\r\n  options: DOMTextureOptions\r\n\r\n  /** A {@link BufferBinding | buffer binding} that will hold the texture model matrix */\r\n  textureMatrix: BufferBinding\r\n  /** The bindings used by this {@link DOMTexture}, i.e. its {@link textureMatrix} and its {@link TextureBinding | GPU texture binding} */\r\n  bindings: BindGroupBindingElement[]\r\n\r\n  /** {@link DOMTexture} parentMesh if any */\r\n  private _parentMesh: DOMTextureParent\r\n\r\n  /** Whether the source has been loaded */\r\n  private _sourceLoaded: boolean\r\n  /** Whether the source has been uploaded to the GPU, handled by the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#texturesQueue | GPUDeviceManager texturesQueue array} */\r\n  private _sourceUploaded: boolean\r\n  /** Whether the texture should be uploaded to the GPU */\r\n  shouldUpdate: boolean\r\n\r\n  /** {@link HTMLVideoElement.requestVideoFrameCallback | requestVideoFrameCallback} returned id if used */\r\n  videoFrameCallbackId: null | number\r\n\r\n  /** Private {@link Vec3 | vector} used for {@link#modelMatrix} calculations, based on {@link parentMesh} {@link core/DOM/DOMElement.RectSize | size} */\r\n  #parentRatio: Vec3 = new Vec3(1)\r\n  /** Private {@link Vec3 | vector} used for {@link modelMatrix} calculations, based on {@link size | source size} */\r\n  #sourceRatio: Vec3 = new Vec3(1)\r\n  /** Private {@link Vec3 | vector} used for {@link modelMatrix} calculations, based on #parentRatio and #sourceRatio */\r\n  #coverScale: Vec3 = new Vec3(1)\r\n  /** Private rotation {@link Mat4 | matrix} based on texture {@link quaternion} */\r\n  #rotationMatrix: Mat4 = new Mat4()\r\n\r\n  // callbacks / events\r\n  /** function assigned to the {@link onSourceLoaded} callback */\r\n  _onSourceLoadedCallback = () => {\r\n    /* allow empty callback */\r\n  }\r\n  /** function assigned to the {@link onSourceUploaded} callback */\r\n  _onSourceUploadedCallback = () => {\r\n    /* allow empty callback */\r\n  }\r\n\r\n  /**\r\n   * DOMTexture constructor\r\n   * @param renderer - {@link Renderer} object or {@link GPUCurtains} class object used to create this {@link DOMTexture}\r\n   * @param parameters - {@link DOMTextureParams | parameters} used to create this {@link DOMTexture}\r\n   */\r\n  constructor(renderer: Renderer | GPUCurtains, parameters = defaultDOMTextureParams) {\r\n    super()\r\n\r\n    this.type = 'Texture'\r\n\r\n    renderer = isRenderer(renderer, parameters.label ? parameters.label + ' ' + this.type : this.type)\r\n\r\n    this.renderer = renderer\r\n\r\n    this.uuid = generateUUID()\r\n\r\n    const defaultOptions = {\r\n      ...defaultDOMTextureParams,\r\n      source: parameters.fromTexture ? parameters.fromTexture.options.source : null,\r\n      sourceType: parameters.fromTexture ? parameters.fromTexture.options.sourceType : null,\r\n    }\r\n\r\n    this.options = { ...defaultOptions, ...parameters }\r\n    // force merge of texture object\r\n    //this.options.texture = { ...defaultOptions.texture, ...parameters.texture }\r\n\r\n    this.options.label = this.options.label ?? this.options.name\r\n\r\n    this.texture = null\r\n    this.externalTexture = null\r\n    this.source = null\r\n\r\n    // sizes\r\n    this.size = {\r\n      width: 1,\r\n      height: 1,\r\n      depth: 1,\r\n    }\r\n\r\n    // we will always declare a texture matrix\r\n    this.textureMatrix = new BufferBinding({\r\n      label: this.options.label + ': model matrix',\r\n      name: this.options.name + 'Matrix',\r\n      useStruct: false,\r\n      struct: {\r\n        [this.options.name + 'Matrix']: {\r\n          type: 'mat4x4f',\r\n          value: this.modelMatrix,\r\n        },\r\n      },\r\n    })\r\n\r\n    this.renderer.deviceManager.bufferBindings.set(this.textureMatrix.cacheKey, this.textureMatrix)\r\n\r\n    this.setBindings()\r\n\r\n    this._parentMesh = null\r\n\r\n    this.sourceLoaded = false\r\n    this.sourceUploaded = false\r\n    this.shouldUpdate = false\r\n\r\n    this.renderer.addDOMTexture(this)\r\n    this.createTexture()\r\n  }\r\n\r\n  /**\r\n   * Set our {@link bindings}\r\n   */\r\n  setBindings() {\r\n    this.bindings = [\r\n      new TextureBinding({\r\n        label: this.options.label + ': texture',\r\n        name: this.options.name,\r\n        bindingType: this.options.sourceType === 'externalVideo' ? 'externalTexture' : 'texture',\r\n        visibility: this.options.visibility,\r\n        texture: this.options.sourceType === 'externalVideo' ? this.externalTexture : this.texture,\r\n        viewDimension: this.options.viewDimension,\r\n      }),\r\n      this.textureMatrix,\r\n    ]\r\n  }\r\n\r\n  /**\r\n   * Get our {@link TextureBinding | GPU texture binding}\r\n   * @readonly\r\n   */\r\n  get textureBinding(): TextureBinding {\r\n    return this.bindings[0] as TextureBinding\r\n  }\r\n\r\n  /**\r\n   * Get our texture {@link parentMesh}\r\n   */\r\n  get parentMesh(): DOMTextureParent {\r\n    return this._parentMesh\r\n  }\r\n\r\n  /**\r\n   * Set our texture {@link parentMesh}\r\n   * @param value - texture {@link parentMesh} to set (i.e. any kind of {@link core/renderers/GPURenderer.RenderedMesh | Mesh}\r\n   */\r\n  set parentMesh(value: DOMTextureParent) {\r\n    this._parentMesh = value\r\n    this.resize()\r\n  }\r\n\r\n  /**\r\n   * Get whether our {@link source} has been loaded\r\n   */\r\n  get sourceLoaded(): boolean {\r\n    return this._sourceLoaded\r\n  }\r\n\r\n  /**\r\n   * Set whether our {@link source} has been loaded\r\n   * @param value - boolean flag indicating if the {@link source} has been loaded\r\n   */\r\n  set sourceLoaded(value: boolean) {\r\n    if (value && !this.sourceLoaded) {\r\n      this._onSourceLoadedCallback && this._onSourceLoadedCallback()\r\n    }\r\n    this._sourceLoaded = value\r\n  }\r\n\r\n  /**\r\n   * Get whether our {@link source} has been uploaded\r\n   */\r\n  get sourceUploaded(): boolean {\r\n    return this._sourceUploaded\r\n  }\r\n\r\n  /**\r\n   * Set whether our {@link source} has been uploaded\r\n   * @param value - boolean flag indicating if the {@link source} has been uploaded\r\n   */\r\n  set sourceUploaded(value: boolean) {\r\n    if (value && !this.sourceUploaded) {\r\n      this._onSourceUploadedCallback && this._onSourceUploadedCallback()\r\n    }\r\n    this._sourceUploaded = value\r\n  }\r\n\r\n  /**\r\n   * Set our texture {@link transforms} object\r\n   */\r\n  setTransforms() {\r\n    super.setTransforms()\r\n\r\n    this.transforms.quaternion.setAxisOrder('ZXY')\r\n\r\n    // reset our model transform origin to reflect CSS transform origins\r\n    this.transforms.origin.model.set(0.5, 0.5, 0)\r\n  }\r\n\r\n  /* TEXTURE MATRIX */\r\n\r\n  /**\r\n   * Update the {@link modelMatrix}\r\n   */\r\n  updateModelMatrix() {\r\n    if (!this.parentMesh) return\r\n\r\n    const parentScale = (this.parentMesh as DOMProjectedMesh).scale\r\n      ? (this.parentMesh as DOMProjectedMesh).scale\r\n      : new Vec3(1, 1, 1)\r\n\r\n    const parentWidth = (this.parentMesh as DOMProjectedMesh).boundingRect\r\n      ? (this.parentMesh as DOMProjectedMesh).boundingRect.width * parentScale.x\r\n      : this.size.width\r\n    const parentHeight = (this.parentMesh as DOMProjectedMesh).boundingRect\r\n      ? (this.parentMesh as DOMProjectedMesh).boundingRect.height * parentScale.y\r\n      : this.size.height\r\n\r\n    const parentRatio = parentWidth / parentHeight\r\n    const sourceRatio = this.size.width / this.size.height\r\n\r\n    // handle the texture rotation\r\n    // huge props to [@grgrdvrt](https://github.com/grgrdvrt) for this solution!\r\n    if (parentWidth > parentHeight) {\r\n      this.#parentRatio.set(parentRatio, 1, 1)\r\n      this.#sourceRatio.set(1 / sourceRatio, 1, 1)\r\n    } else {\r\n      this.#parentRatio.set(1, 1 / parentRatio, 1)\r\n      this.#sourceRatio.set(1, sourceRatio, 1)\r\n    }\r\n\r\n    // cover ratio is a bit tricky!\r\n    const coverRatio =\r\n      parentRatio > sourceRatio !== parentWidth > parentHeight\r\n        ? 1\r\n        : parentWidth > parentHeight\r\n        ? this.#parentRatio.x * this.#sourceRatio.x\r\n        : this.#sourceRatio.y * this.#parentRatio.y\r\n\r\n    this.#coverScale.set(1 / (coverRatio * this.scale.x), 1 / (coverRatio * this.scale.y), 1)\r\n\r\n    this.#rotationMatrix.rotateFromQuaternion(this.quaternion)\r\n\r\n    // here we could create a matrix for each translations / scales and do:\r\n    // this.modelMatrix\r\n    //   .identity()\r\n    //   .premultiply(negativeOriginMatrix)\r\n    //   .premultiply(coverScaleMatrix)\r\n    //   .premultiply(parentRatioMatrix)\r\n    //   .premultiply(rotationMatrix)\r\n    //   .premultiply(textureRatioMatrix)\r\n    //   .premultiply(originMatrix)\r\n    //   .translate(this.position)\r\n\r\n    // but this is faster!\r\n    this.modelMatrix\r\n      .identity()\r\n      .premultiplyTranslate(this.transformOrigin.clone().multiplyScalar(-1))\r\n      .premultiplyScale(this.#coverScale)\r\n      .premultiplyScale(this.#parentRatio)\r\n      .premultiply(this.#rotationMatrix)\r\n      .premultiplyScale(this.#sourceRatio)\r\n      .premultiplyTranslate(this.transformOrigin)\r\n      .translate(this.position)\r\n  }\r\n\r\n  /**\r\n   * If our {@link modelMatrix} has been updated, tell the {@link textureMatrix | texture matrix binding} to update as well\r\n   */\r\n  updateMatrixStack() {\r\n    super.updateMatrixStack()\r\n\r\n    if (this.matricesNeedUpdate) {\r\n      this.textureMatrix.shouldUpdateBinding(this.options.name + 'Matrix')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resize our {@link DOMTexture}\r\n   */\r\n  resize() {\r\n    // this should only happen with canvas textures\r\n    if (\r\n      this.source &&\r\n      this.source instanceof HTMLCanvasElement &&\r\n      (this.source.width !== this.size.width || this.source.height !== this.size.height)\r\n    ) {\r\n      // since the source size has changed, we have to recreate a new texture\r\n      this.setSourceSize()\r\n      this.createTexture()\r\n    }\r\n\r\n    // tell our model matrix to update\r\n    this.shouldUpdateModelMatrix()\r\n  }\r\n\r\n  /**\r\n   * Tell the {@link Renderer} to upload or texture\r\n   */\r\n  uploadTexture() {\r\n    this.renderer.uploadTexture(this)\r\n    this.shouldUpdate = false\r\n  }\r\n\r\n  /**\r\n   * Import a {@link GPUExternalTexture} from the {@link Renderer}, update the  {@link textureBinding} and its {@link core/bindGroups/TextureBindGroup.TextureBindGroup | bind group}\r\n   */\r\n  uploadVideoTexture() {\r\n    this.externalTexture = this.renderer.importExternalTexture(this.source as HTMLVideoElement)\r\n    this.textureBinding.resource = this.externalTexture\r\n    this.textureBinding.setBindingType('externalTexture')\r\n    this.shouldUpdate = false\r\n    this.sourceUploaded = true\r\n  }\r\n\r\n  /**\r\n   * Copy a {@link DOMTexture}\r\n   * @param texture - {@link DOMTexture} to copy\r\n   */\r\n  copy(texture: DOMTexture) {\r\n    if (this.options.sourceType === 'externalVideo' && texture.options.sourceType !== 'externalVideo') {\r\n      throwWarning(`${this.options.label}: cannot copy a GPUTexture to a GPUExternalTexture`)\r\n      return\r\n    } else if (this.options.sourceType !== 'externalVideo' && texture.options.sourceType === 'externalVideo') {\r\n      throwWarning(`${this.options.label}: cannot copy a GPUExternalTexture to a GPUTexture`)\r\n      return\r\n    }\r\n\r\n    this.options.fromTexture = texture\r\n\r\n    // now copy all desired texture options except source\r\n    // const { source, ...optionsToCopy } = texture.options\r\n    // this.options = { ...this.options, ...optionsToCopy }\r\n\r\n    this.options.sourceType = texture.options.sourceType\r\n\r\n    // TODO better way to do that?\r\n    this.options.generateMips = texture.options.generateMips\r\n    this.options.flipY = texture.options.flipY\r\n    this.options.format = texture.options.format\r\n    this.options.premultipliedAlpha = texture.options.premultipliedAlpha\r\n    this.options.placeholderColor = texture.options.placeholderColor\r\n    this.options.useExternalTextures = texture.options.useExternalTextures\r\n\r\n    this.sourceLoaded = texture.sourceLoaded\r\n    this.sourceUploaded = texture.sourceUploaded\r\n\r\n    // TODO external texture?\r\n    if (texture.texture) {\r\n      if (texture.sourceLoaded) {\r\n        this.size = texture.size\r\n        this.source = texture.source\r\n\r\n        this.resize()\r\n      }\r\n\r\n      if (texture.sourceUploaded) {\r\n        // texture to copy is ready, update our texture and binding\r\n        this.texture = texture.texture\r\n        this.textureBinding.resource = this.texture\r\n      } else {\r\n        this.createTexture()\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the {@link texture | GPU texture}\r\n   */\r\n  createTexture() {\r\n    const options = {\r\n      label: this.options.label,\r\n      format: this.options.format,\r\n      size: [this.size.width, this.size.height, this.size.depth], // [1, 1] if no source\r\n      dimensions: this.options.viewDimension === '1d' ? '1d' : this.options.viewDimension === '3d' ? '3d' : '2d',\r\n      //sampleCount: this.source ? this.renderer.sampleCount : 1,\r\n      usage: !!this.source\r\n        ? GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT\r\n        : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\r\n    } as GPUTextureDescriptor\r\n\r\n    if (this.options.sourceType !== 'externalVideo') {\r\n      options.mipLevelCount = this.options.generateMips ? getNumMipLevels(this.size.width, this.size.height) : 1\r\n\r\n      this.texture?.destroy()\r\n\r\n      this.texture = this.renderer.createTexture(options)\r\n\r\n      // update texture binding\r\n      this.textureBinding.resource = this.texture\r\n    }\r\n\r\n    this.shouldUpdate = true\r\n  }\r\n\r\n  /* SOURCES */\r\n\r\n  /**\r\n   * Set the {@link size} based on the {@link source}\r\n   */\r\n  setSourceSize() {\r\n    this.size = {\r\n      width:\r\n        (this.source as HTMLImageElement).naturalWidth ||\r\n        (this.source as HTMLCanvasElement).width ||\r\n        (this.source as HTMLVideoElement).videoWidth,\r\n      height:\r\n        (this.source as HTMLImageElement).naturalHeight ||\r\n        (this.source as HTMLCanvasElement).height ||\r\n        (this.source as HTMLVideoElement).videoHeight,\r\n      depth: 1,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load an {@link HTMLImageElement} from a URL and create an {@link ImageBitmap} to use as a {@link source}\r\n   * @async\r\n   * @param url - URL of the image to load\r\n   * @returns - the newly created {@link ImageBitmap}\r\n   */\r\n  async loadImageBitmap(url: string): Promise<ImageBitmap> {\r\n    const res = await fetch(url)\r\n    const blob = await res.blob()\r\n    return await createImageBitmap(blob, { colorSpaceConversion: 'none' })\r\n  }\r\n\r\n  /**\r\n   * Load and create an {@link ImageBitmap} from a URL or {@link HTMLImageElement}, use it as a {@link source} and create the {@link GPUTexture}\r\n   * @async\r\n   * @param source - the image URL or {@link HTMLImageElement} to load\r\n   * @returns - the newly created {@link ImageBitmap}\r\n   */\r\n  async loadImage(source: string | HTMLImageElement): Promise<void> {\r\n    const url = typeof source === 'string' ? source : source.getAttribute('src')\r\n\r\n    this.options.source = url\r\n    this.options.sourceType = 'image'\r\n\r\n    const cachedTexture = this.renderer.domTextures.find((t) => t.options.source === url)\r\n    if (cachedTexture && cachedTexture.texture && cachedTexture.sourceUploaded) {\r\n      this.copy(cachedTexture)\r\n      return\r\n    }\r\n\r\n    this.sourceLoaded = false\r\n    this.sourceUploaded = false\r\n\r\n    this.source = await this.loadImageBitmap(this.options.source)\r\n\r\n    this.setSourceSize()\r\n    this.resize()\r\n\r\n    this.sourceLoaded = true\r\n    this.createTexture()\r\n  }\r\n\r\n  // weirldy enough, we don't have to do anything in that callback\r\n  // because the <video> is not visible in the viewport, the video playback is throttled\r\n  // and the rendering is janky\r\n  // using requestVideoFrameCallback helps preventing this but is unsupported in Firefox at the moment\r\n  // WebCodecs may be the way to go when time comes!\r\n  // https://developer.chrome.com/blog/new-in-webgpu-113/#use-webcodecs-videoframe-source-in-importexternaltexture\r\n  /**\r\n   * Set our {@link shouldUpdate} flag to true at each new video frame\r\n   */\r\n  onVideoFrameCallback() {\r\n    if (this.videoFrameCallbackId) {\r\n      this.shouldUpdate = true\r\n      ;(this.source as HTMLVideoElement).requestVideoFrameCallback(this.onVideoFrameCallback.bind(this))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback to run when a {@link HTMLVideoElement} has loaded (when it has enough data to play).\r\n   * Set the {@link HTMLVideoElement} as a {@link source} and create the {@link GPUTexture} or {@link GPUExternalTexture}\r\n   * @param video - the newly loaded {@link HTMLVideoElement}\r\n   */\r\n  onVideoLoaded(video: HTMLVideoElement) {\r\n    if (!this.sourceLoaded) {\r\n      this.source = video\r\n\r\n      this.setSourceSize()\r\n      this.resize()\r\n\r\n      if (this.options.useExternalTextures) {\r\n        this.options.sourceType = 'externalVideo'\r\n\r\n        // texture binding will be set when uploading external texture\r\n        // meanwhile, destroy previous texture\r\n        this.texture?.destroy()\r\n      } else {\r\n        this.options.sourceType = 'video'\r\n        this.createTexture()\r\n      }\r\n\r\n      if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {\r\n        this.videoFrameCallbackId = (this.source as HTMLVideoElement).requestVideoFrameCallback(\r\n          this.onVideoFrameCallback.bind(this)\r\n        )\r\n      }\r\n\r\n      this.sourceLoaded = true\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get whether the {@link source} is a video\r\n   * @readonly\r\n   */\r\n  get isVideoSource(): boolean {\r\n    return this.source && (this.options.sourceType === 'video' || this.options.sourceType === 'externalVideo')\r\n  }\r\n\r\n  /**\r\n   * Load a video from a URL or {@link HTMLVideoElement} and register {@link onVideoLoaded} callback\r\n   * @param source - the video URL or {@link HTMLVideoElement} to load\r\n   */\r\n  loadVideo(source: string | HTMLVideoElement) {\r\n    let video\r\n\r\n    if (typeof source === 'string') {\r\n      video = document.createElement('video')\r\n      video.src = source\r\n    } else {\r\n      video = source\r\n    }\r\n\r\n    video.preload = 'auto'\r\n    video.muted = true\r\n    video.loop = true\r\n    video.crossOrigin = 'anonymous'\r\n    video.setAttribute('playsinline', '')\r\n\r\n    this.options.source = video.src\r\n    this.sourceLoaded = false\r\n    this.sourceUploaded = false\r\n\r\n    // If the video is in the cache of the browser,\r\n    // the 'canplaythrough' event might have been triggered\r\n    // before we registered the event handler.\r\n    if (video.readyState >= video.HAVE_ENOUGH_DATA) {\r\n      this.onVideoLoaded(video)\r\n    } else {\r\n      video.addEventListener('canplaythrough', this.onVideoLoaded.bind(this, video), {\r\n        once: true,\r\n      })\r\n    }\r\n\r\n    // if duration is not available, should mean our video has not started loading\r\n    if (isNaN(video.duration)) {\r\n      video.load()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load a {@link HTMLCanvasElement}, use it as a {@link source} and create the {@link GPUTexture}\r\n   * @param source - the {@link HTMLCanvasElement} to use\r\n   */\r\n  loadCanvas(source: HTMLCanvasElement) {\r\n    this.options.source = source\r\n    this.options.sourceType = 'canvas'\r\n    this.sourceLoaded = false\r\n    this.sourceUploaded = false\r\n\r\n    this.source = source\r\n\r\n    this.setSourceSize()\r\n    this.resize()\r\n\r\n    this.sourceLoaded = true\r\n    this.createTexture()\r\n  }\r\n\r\n  /* EVENTS */\r\n\r\n  /**\r\n   * Callback to run when the {@link source} has been loaded\r\n   * @param callback - callback to run when the {@link source} has been loaded\r\n   * @returns - our {@link DOMTexture}\r\n   */\r\n  onSourceLoaded(callback: () => void): DOMTexture {\r\n    if (callback) {\r\n      this._onSourceLoadedCallback = callback\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Callback to run when the {@link source} has been uploaded\r\n   * @param callback - callback to run when the {@link source} been uploaded\r\n   * @returns - our {@link DOMTexture}\r\n   */\r\n  onSourceUploaded(callback: () => void): DOMTexture {\r\n    if (callback) {\r\n      this._onSourceUploadedCallback = callback\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  /* RENDER */\r\n\r\n  /**\r\n   * Render a {@link DOMTexture}:\r\n   * - Update its {@link modelMatrix} and {@link bindings} if needed\r\n   * - Upload the texture if it needs to be done\r\n   */\r\n  render() {\r\n    // update our model matrix if needed\r\n    this.updateMatrixStack()\r\n\r\n    // update uniforms values\r\n    this.textureMatrix.update()\r\n\r\n    // since external texture are destroyed as soon as JavaScript returns to the browser\r\n    // we need to update it at every tick, even if it hasn't changed\r\n    // to ensure we're not sending a stale / destroyed texture\r\n    // anyway, external texture are cached so it is fined to call importExternalTexture at each tick\r\n    if (this.options.sourceType === 'externalVideo') {\r\n      this.shouldUpdate = true\r\n    }\r\n\r\n    // if no videoFrameCallback check if the video is actually really playing\r\n    if (\r\n      this.isVideoSource &&\r\n      !this.videoFrameCallbackId &&\r\n      (this.source as HTMLVideoElement).readyState >= (this.source as HTMLVideoElement).HAVE_CURRENT_DATA &&\r\n      !(this.source as HTMLVideoElement).paused\r\n    ) {\r\n      this.shouldUpdate = true\r\n    }\r\n\r\n    if (this.shouldUpdate && this.options.sourceType && this.options.sourceType !== 'externalVideo') {\r\n      this.uploadTexture()\r\n    }\r\n  }\r\n\r\n  /* DESTROY */\r\n\r\n  /**\r\n   * Destroy the {@link DOMTexture}\r\n   */\r\n  destroy() {\r\n    if (this.videoFrameCallbackId) {\r\n      ;(this.source as HTMLVideoElement).cancelVideoFrameCallback(this.videoFrameCallbackId)\r\n    }\r\n\r\n    if (this.isVideoSource) {\r\n      ;(this.source as HTMLVideoElement).removeEventListener(\r\n        'canplaythrough',\r\n        this.onVideoLoaded.bind(this, this.source),\r\n        {\r\n          once: true,\r\n        } as AddEventListenerOptions & EventListenerOptions\r\n      )\r\n    }\r\n\r\n    this.renderer.removeDOMTexture(this)\r\n\r\n    this.texture?.destroy()\r\n    this.texture = null\r\n  }\r\n}\r\n","import { BindGroup } from './BindGroup'\r\nimport { isRenderer, Renderer } from '../renderers/utils'\r\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\r\nimport { DOMTexture } from '../textures/DOMTexture'\r\nimport { Sampler } from '../samplers/Sampler'\r\nimport { BindGroupParams } from '../../types/BindGroups'\r\nimport { MaterialTexture } from '../../types/Materials'\r\n\r\n/**\r\n * An object defining all possible {@link TextureBindGroup} class instancing parameters\r\n */\r\nexport interface TextureBindGroupParams extends BindGroupParams {\r\n  /** array of {@link MaterialTexture | textures} to add to a {@link TextureBindGroup} */\r\n  textures?: MaterialTexture[]\r\n  /** array of {@link Sampler} to add to a {@link TextureBindGroup} */\r\n  samplers?: Sampler[]\r\n}\r\n\r\n/**\r\n * Used to regroup all {@link types/BindGroups.BindGroupBindingElement | bindings} related to textures (texture, texture matrices buffers and samplers) into one single specific {@link BindGroup}.\r\n *\r\n * Also responsible for uploading video textures if needed.\r\n *\r\n * @example\r\n * ```javascript\r\n * // set our main GPUCurtains instance\r\n * const gpuCurtains = new GPUCurtains({\r\n *   container: '#canvas' // selector of our WebGPU canvas container\r\n * })\r\n *\r\n * // set the GPU device\r\n * // note this is asynchronous\r\n * await gpuCurtains.setDevice()\r\n *\r\n * // create a texture\r\n * const texture = new Texture(gpuCurtains, {\r\n *   label: 'Input texture',\r\n *   name: 'inputTexture',\r\n * })\r\n *\r\n * // create a texture bind group using that texture\r\n * const textureBindGroup = new TextureBindGroup(gpuCurtains, {\r\n *   label: 'My texture bind group',\r\n *   textures: [texture],\r\n *   uniforms: {\r\n *     params: {\r\n *       struct: {\r\n *         opacity: {\r\n *           type: 'f32',\r\n *           value: 1,\r\n *         },\r\n *         mousePosition: {\r\n *           type: 'vec2f',\r\n *           value: new Vec2(),\r\n *         },\r\n *       },\r\n *     },\r\n *   },\r\n * })\r\n *\r\n * // create the GPU buffer, bindGroupLayout and bindGroup\r\n * textureBindGroup.createBindGroup()\r\n * ```\r\n */\r\nexport class TextureBindGroup extends BindGroup {\r\n  /**\r\n   * TextureBindGroup constructor\r\n   * @param  renderer - a {@link Renderer} class object or a {@link GPUCurtains} class object\r\n   * @param parameters - {@link TextureBindGroupParams | parameters} used to create our {@link TextureBindGroup}\r\n   */\r\n  constructor(\r\n    renderer: Renderer | GPUCurtains,\r\n    { label, index = 0, bindings = [], uniforms, storages, textures = [], samplers = [] }: TextureBindGroupParams = {}\r\n  ) {\r\n    const type = 'TextureBindGroup'\r\n\r\n    renderer = isRenderer(renderer, type)\r\n\r\n    super(renderer, { label, index, bindings, uniforms, storages })\r\n\r\n    this.options = {\r\n      ...this.options,\r\n      // will be filled after\r\n      textures: [],\r\n      samplers: [],\r\n    }\r\n\r\n    // add initial textures if any\r\n    if (textures.length) {\r\n      for (const texture of textures) {\r\n        this.addTexture(texture)\r\n      }\r\n    }\r\n\r\n    // add initial samplers if any\r\n    if (samplers.length) {\r\n      for (const sampler of samplers) {\r\n        this.addSampler(sampler)\r\n      }\r\n    }\r\n\r\n    this.type = type\r\n  }\r\n\r\n  /**\r\n   * Adds a texture to the textures array and the struct\r\n   * @param texture - texture to add\r\n   */\r\n  addTexture(texture: MaterialTexture) {\r\n    this.textures.push(texture)\r\n    this.addBindings([...texture.bindings])\r\n  }\r\n\r\n  /**\r\n   * Get the current textures array\r\n   * @readonly\r\n   */\r\n  get textures(): MaterialTexture[] {\r\n    return this.options.textures\r\n  }\r\n\r\n  /**\r\n   * Adds a sampler to the samplers array and the struct\r\n   * @param sampler\r\n   */\r\n  addSampler(sampler: Sampler) {\r\n    this.samplers.push(sampler)\r\n    this.addBindings([sampler.binding])\r\n  }\r\n\r\n  /**\r\n   * Get the current samplers array\r\n   * @readonly\r\n   */\r\n  get samplers(): Sampler[] {\r\n    return this.options.samplers\r\n  }\r\n\r\n  /**\r\n   * Get whether the GPU bind group is ready to be created\r\n   * It can be created if it has {@link BindGroup#bindings} and has not been created yet and all GPU textures and samplers are created\r\n   * @readonly\r\n   */\r\n  get shouldCreateBindGroup(): boolean {\r\n    return (\r\n      !this.bindGroup &&\r\n      !!this.bindings.length &&\r\n      !this.textures.find((texture) => !(texture.texture || (texture as DOMTexture).externalTexture)) &&\r\n      !this.samplers.find((sampler) => !sampler.sampler)\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Update the {@link TextureBindGroup#textures | bind group textures}:\r\n   * - Check if they need to copy their source texture\r\n   * - Upload video texture if needed\r\n   */\r\n  updateTextures() {\r\n    for (const texture of this.textures) {\r\n      // copy textures that need it on first init, but only when original texture is ready\r\n      if (texture instanceof DOMTexture) {\r\n        if (texture.options.fromTexture && texture.options.fromTexture.sourceUploaded && !texture.sourceUploaded) {\r\n          texture.copy(texture.options.fromTexture)\r\n        }\r\n\r\n        if (texture.shouldUpdate && texture.options.sourceType && texture.options.sourceType === 'externalVideo') {\r\n          texture.uploadVideoTexture()\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the {@link TextureBindGroup}, which means update its {@link TextureBindGroup#textures | textures}, then update its {@link TextureBindGroup#bufferBindings | buffer bindings} and finally {@link TextureBindGroup#resetBindGroup | reset it} if needed\r\n   */\r\n  update() {\r\n    this.updateTextures()\r\n    super.update()\r\n  }\r\n\r\n  /**\r\n   * Destroy our {@link TextureBindGroup}\r\n   */\r\n  destroy() {\r\n    super.destroy()\r\n    this.options.textures = []\r\n    this.options.samplers = []\r\n  }\r\n}\r\n","import { Binding, BindingParams, SamplerBindingType } from './Binding'\r\n\r\n/** Defines a {@link SamplerBinding} {@link SamplerBinding#resource | resource} */\r\nexport type SamplerBindingResource = GPUSampler | null\r\n\r\n/**\r\n * An object defining all possible {@link SamplerBinding} class instancing parameters\r\n */\r\nexport interface SamplerBindingParams extends BindingParams {\r\n  /** The binding type of the {@link SamplerBinding} */\r\n  bindingType?: SamplerBindingType\r\n  /** {@link SamplerBinding} {@link GPUBindGroup | GPU bind group} resource */\r\n  sampler: SamplerBindingResource\r\n  /** The bind group layout binding {@link GPUSamplerBindingLayout#type | type} of this {@link GPUSampler | GPU sampler} */\r\n  type: GPUSamplerBindingType\r\n}\r\n\r\n/**\r\n * Used to handle GPUSampler bindings.\r\n *\r\n * Provide both {@link SamplerBinding#resourceLayout | resourceLayout} and {@link SamplerBinding#resource | resource} to the {@link GPUBindGroupLayout} and {@link GPUBindGroup}.<br>\r\n * Also create the appropriate WGSL code snippet to add to the shaders.\r\n */\r\nexport class SamplerBinding extends Binding {\r\n  /** The binding type of the {@link SamplerBinding} */\r\n  bindingType: SamplerBindingType\r\n  /** Our {@link SamplerBinding} resource, i.e. a {@link GPUSampler} */\r\n  sampler: SamplerBindingResource\r\n  /** An array of strings to append to our shaders code declaring all the WGSL variables representing this {@link SamplerBinding} */\r\n  wgslGroupFragment: string[]\r\n  /** Options used to create this {@link SamplerBinding} */\r\n  options: SamplerBindingParams\r\n\r\n  /**\r\n   * SamplerBinding constructor\r\n   * @param parameters - {@link SamplerBindingParams | parameters} used to create our SamplerBindings\r\n   */\r\n  constructor({\r\n    label = 'Sampler',\r\n    name = 'sampler',\r\n    bindingType,\r\n    visibility,\r\n    sampler,\r\n    type = 'filtering',\r\n  }: SamplerBindingParams) {\r\n    bindingType = bindingType ?? 'sampler'\r\n\r\n    super({ label, name, bindingType, visibility })\r\n\r\n    this.cacheKey += `${type},`\r\n\r\n    this.options = {\r\n      ...this.options,\r\n      sampler,\r\n      type,\r\n    }\r\n\r\n    this.resource = sampler // should be a sampler\r\n\r\n    this.setWGSLFragment()\r\n  }\r\n\r\n  /**\r\n   * Get {@link GPUBindGroupLayoutEntry#sampler | bind group layout entry resource}\r\n   * @readonly\r\n   */\r\n  get resourceLayout(): {\r\n    /** {@link GPUBindGroupLayout | bind group layout} resource */\r\n    sampler: GPUSamplerBindingLayout\r\n  } {\r\n    return {\r\n      sampler: {\r\n        type: this.options.type, // TODO set shouldResetBindGroupLayout to true if it changes afterwards\r\n      },\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the resource cache key\r\n   * @readonly\r\n   */\r\n  get resourceLayoutCacheKey(): string {\r\n    return `sampler,${this.options.type},${this.visibility},`\r\n  }\r\n\r\n  /**\r\n   * Get the {@link GPUBindGroupEntry#resource | bind group resource}\r\n   */\r\n  get resource(): SamplerBindingResource {\r\n    return this.sampler\r\n  }\r\n\r\n  /**\r\n   * Set the {@link GPUBindGroupEntry#resource | bind group resource}\r\n   * @param value - new bind group resource\r\n   */\r\n  set resource(value: SamplerBindingResource) {\r\n    // resource changed, update bind group!\r\n    if (value && this.sampler) this.shouldResetBindGroup = true\r\n    this.sampler = value\r\n  }\r\n\r\n  /**\r\n   * Set the correct WGSL code snippet.\r\n   */\r\n  setWGSLFragment() {\r\n    this.wgslGroupFragment = [\r\n      `var ${this.name}: ${this.options.type === 'comparison' ? `${this.bindingType}_comparison` : this.bindingType};`,\r\n    ]\r\n  }\r\n}\r\n","import { Mat4 } from '../../math/Mat4'\r\nimport { Object3D, Object3DMatricesType, Object3DTransformMatrix } from '../objects3D/Object3D'\r\nimport { RectSize } from '../DOM/DOMElement'\r\nimport { Vec3 } from '../../math/Vec3'\r\nimport { generateUUID } from '../../utils/utils'\r\n\r\n/**\r\n * Defines Camera basic perspective options\r\n */\r\nexport interface CameraBasePerspectiveOptions {\r\n  /** {@link Camera} perspective field of view. Should be greater than 0 and lower than 180 */\r\n  fov?: number\r\n  /** {@link Camera} near plane, the closest point where a mesh vertex is drawn */\r\n  near?: number\r\n  /** {@link Camera} far plane, the farthest point where a mesh vertex is drawn */\r\n  far?: number\r\n}\r\n\r\n/**\r\n * Defines all Camera perspective options\r\n */\r\nexport interface CameraPerspectiveOptions extends CameraBasePerspectiveOptions {\r\n  /** {@link Camera} frustum width */\r\n  width?: number\r\n  /** {@link Camera} frustum height */\r\n  height?: number\r\n  /** {@link Camera} pixel ratio */\r\n  pixelRatio?: number\r\n}\r\n\r\n/**\r\n * An object defining all possible {@link Camera} class instancing parameters\r\n */\r\nexport interface CameraParams extends CameraPerspectiveOptions {\r\n  /** callback to execute when one of the {@link Camera#matrices | camera matrices} changed */\r\n  onMatricesChanged?: () => void\r\n}\r\n\r\n/** Defines all kind of possible {@link core/objects3D/ProjectedObject3D.ProjectedObject3D | ProjectedObject3D} matrix types */\r\nexport type CameraObject3DMatricesType = Object3DMatricesType | 'projection' | 'view' | 'viewProjection'\r\n/** Defines all possible {@link Object3DTransformMatrix | matrix object} used by our {@link core/objects3D/ProjectedObject3D.ProjectedObject3D | ProjectedObject3D} */\r\nexport type CameraObject3DMatrices = Record<CameraObject3DMatricesType, Object3DTransformMatrix>\r\n\r\n/**\r\n * Used to create a perspective {@link Camera} and its projection, model and view matrices.\r\n *\r\n * {@link curtains/renderers/GPUCurtainsRenderer.GPUCurtainsRenderer | GPUCurtainsRenderer} and {@link core/renderers/GPUCameraRenderer.GPUCameraRenderer | GPUCameraRenderer} automatically create their own {@link Camera} under the hood, so it is unlikely you'd have to create one by yourself.\r\n *\r\n * {@link Camera} default perspective settings are:\r\n * - {@link Camera#fov | field of view}: 50\r\n * - {@link Camera#near | near plane}: 0.01\r\n * - {@link Camera#far | far plane}: 150\r\n *\r\n * Also note that the {@link Camera} default {@link Camera#position | position} is set at `(0, 0, 10)` so the object created with a default size do not appear too big nor too small.\r\n */\r\nexport class Camera extends Object3D {\r\n  /** The universal unique id of the {@link Camera} */\r\n  uuid: string\r\n  /** {@link CameraObject3DMatrices | Matrices object} of the {@link Camera} */\r\n  matrices: CameraObject3DMatrices\r\n\r\n  /** @ignore */\r\n  #fov: number\r\n  /** @ignore */\r\n  #near: number\r\n  /** @ignore */\r\n  #far: number\r\n\r\n  /** {@link Vec3 | Up vector} used for {@link lookAt} calculations. */\r\n  up: Vec3\r\n\r\n  /** The {@link Camera} frustum width and height */\r\n  size: RectSize\r\n  /** @ignore */\r\n  #pixelRatio: number\r\n\r\n  /** Callback to execute when one of the camera {@link matrices} changed */\r\n  onMatricesChanged?: () => void\r\n\r\n  /** A number representing what CSS perspective value (in pixel) should be used to obtain the same perspective effect as this {@link Camera} */\r\n  CSSPerspective: number\r\n  /** An object containing the visible width / height at a given z-depth from our camera parameters */\r\n  visibleSize: RectSize\r\n\r\n  /**\r\n   * Camera constructor\r\n   * @param parameters - {@link CameraParams | parameters} used to create our {@link Camera}\r\n   */\r\n  constructor(\r\n    {\r\n      fov = 50,\r\n      near = 0.1,\r\n      far = 150,\r\n      width = 1,\r\n      height = 1,\r\n      pixelRatio = 1,\r\n      onMatricesChanged = () => {\r\n        /* allow empty callback */\r\n      },\r\n    } = {} as CameraParams\r\n  ) {\r\n    // Object3D\r\n    super()\r\n\r\n    this.uuid = generateUUID()\r\n\r\n    // camera can't be at position (0, 0, 0), it needs some recoil\r\n    // arbitrarily set to 10 so objects of default size (1, 1, 1) don't appear too big\r\n    this.position.set(0, 0, 10)\r\n    this.up = new Vec3(0, 1, 0)\r\n\r\n    // callback to run if any of the matrices changed\r\n    this.onMatricesChanged = onMatricesChanged\r\n\r\n    // create size object, will be set right after\r\n    this.size = {\r\n      width: 1,\r\n      height: 1,\r\n    }\r\n\r\n    this.setPerspective({ fov, near, far, width, height, pixelRatio })\r\n  }\r\n\r\n  /**\r\n   * Set our transform and projection matrices\r\n   */\r\n  setMatrices() {\r\n    super.setMatrices()\r\n\r\n    this.matrices = {\r\n      ...this.matrices,\r\n      view: {\r\n        matrix: new Mat4(),\r\n        shouldUpdate: true,\r\n        onUpdate: () => {\r\n          this.viewMatrix.copy(this.worldMatrix).invert()\r\n        },\r\n      },\r\n      projection: {\r\n        matrix: new Mat4(),\r\n        shouldUpdate: true,\r\n        onUpdate: () => this.updateProjectionMatrix(),\r\n      },\r\n      viewProjection: {\r\n        matrix: new Mat4(),\r\n        shouldUpdate: true,\r\n        onUpdate: () => this.viewProjectionMatrix.multiplyMatrices(this.projectionMatrix, this.viewMatrix),\r\n      },\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get our view matrix\r\n   * @readonly\r\n   */\r\n  get viewMatrix(): Mat4 {\r\n    return this.matrices.view.matrix\r\n  }\r\n\r\n  set viewMatrix(value: Mat4) {\r\n    this.matrices.view.matrix = value\r\n    this.shouldUpdateViewMatrices()\r\n  }\r\n\r\n  /**\r\n   * Get our projection matrix\r\n   * @readonly\r\n   */\r\n  get projectionMatrix(): Mat4 {\r\n    return this.matrices.projection.matrix\r\n  }\r\n\r\n  set projectionMatrix(value: Mat4) {\r\n    this.matrices.projection.matrix = value\r\n    this.shouldUpdateProjectionMatrices()\r\n  }\r\n\r\n  /**\r\n   * Get our view projection matrix\r\n   * @readonly\r\n   */\r\n  get viewProjectionMatrix(): Mat4 {\r\n    return this.matrices.viewProjection.matrix\r\n  }\r\n\r\n  /**\r\n   * Set our view dependent matrices shouldUpdate flag to true (tell it to update)\r\n   */\r\n  shouldUpdateViewMatrices() {\r\n    this.matrices.view.shouldUpdate = true\r\n    this.matrices.viewProjection.shouldUpdate = true\r\n  }\r\n\r\n  /**\r\n   * Set our projection dependent matrices shouldUpdate flag to true (tell it to update)\r\n   */\r\n  shouldUpdateProjectionMatrices() {\r\n    this.matrices.projection.shouldUpdate = true\r\n    this.matrices.viewProjection.shouldUpdate = true\r\n  }\r\n\r\n  /**\r\n   * Update our model matrix and tell our view matrix to update as well\r\n   */\r\n  updateModelMatrix() {\r\n    super.updateModelMatrix()\r\n    this.setVisibleSize()\r\n    this.shouldUpdateViewMatrices()\r\n  }\r\n\r\n  /**\r\n   * Update our world matrix and tell our view matrix to update as well\r\n   */\r\n  updateWorldMatrix() {\r\n    super.updateWorldMatrix()\r\n    this.shouldUpdateViewMatrices()\r\n  }\r\n\r\n  /**\r\n   * Callback to run when the camera {@link modelMatrix | model matrix} has been updated\r\n   */\r\n  updateMatrixStack() {\r\n    super.updateMatrixStack()\r\n\r\n    if (this.matricesNeedUpdate) {\r\n      this.onMatricesChanged()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the {@link Camera} {@link fov | field of view}\r\n   */\r\n  get fov(): number {\r\n    return this.#fov\r\n  }\r\n\r\n  /**\r\n   * Set the {@link Camera} {@link fov | field of view}. Update the {@link projectionMatrix} only if the field of view actually changed\r\n   * @param fov - new field of view\r\n   */\r\n  set fov(fov: number) {\r\n    // clamp between 1 and 179\r\n    fov = Math.max(1, Math.min(fov ?? this.fov, 179))\r\n\r\n    if (fov !== this.fov) {\r\n      this.#fov = fov\r\n      this.shouldUpdateProjectionMatrices()\r\n    }\r\n\r\n    this.setVisibleSize()\r\n    this.setCSSPerspective()\r\n  }\r\n\r\n  /**\r\n   * Get the {@link Camera} {@link near} plane value.\r\n   */\r\n  get near(): number {\r\n    return this.#near\r\n  }\r\n\r\n  /**\r\n   * Set the {@link Camera} {@link near} plane value. Update the {@link projectionMatrix} only if the near plane actually changed\r\n   * @param near - new near plane value\r\n   */\r\n  set near(near: number) {\r\n    near = Math.max(near ?? this.near, 0.01)\r\n\r\n    if (near !== this.near) {\r\n      this.#near = near\r\n      this.shouldUpdateProjectionMatrices()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get / set the {@link Camera} {@link far} plane value.\r\n   */\r\n  get far(): number {\r\n    return this.#far\r\n  }\r\n\r\n  /**\r\n   * Set the {@link Camera} {@link far} plane value. Update {@link projectionMatrix} only if the far plane actually changed\r\n   * @param far - new far plane value\r\n   */\r\n  set far(far: number) {\r\n    far = Math.max(far ?? this.far, this.near + 1)\r\n\r\n    if (far !== this.far) {\r\n      this.#far = far\r\n      this.shouldUpdateProjectionMatrices()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the {@link Camera} {@link pixelRatio} value.\r\n   */\r\n  get pixelRatio() {\r\n    return this.#pixelRatio\r\n  }\r\n\r\n  /**\r\n   * Set the {@link Camera} {@link pixelRatio} value. Update the {@link CSSPerspective} only if the pixel ratio actually changed\r\n   * @param pixelRatio - new pixel ratio value\r\n   */\r\n  set pixelRatio(pixelRatio: number) {\r\n    this.#pixelRatio = pixelRatio ?? this.pixelRatio\r\n    this.setCSSPerspective()\r\n  }\r\n\r\n  /**\r\n   * Set the {@link Camera} {@link width} and {@link height}. Update the {@link projectionMatrix} only if the width or height actually changed\r\n   * @param size - {@link width} and {@link height} values to use\r\n   */\r\n  setSize({ width, height }: RectSize) {\r\n    if (width !== this.size.width || height !== this.size.height) {\r\n      this.shouldUpdateProjectionMatrices()\r\n    }\r\n\r\n    this.size.width = width\r\n    this.size.height = height\r\n\r\n    this.setVisibleSize()\r\n    this.setCSSPerspective()\r\n  }\r\n\r\n  /**\r\n   * Sets the {@link Camera} perspective. Update the {@link projectionMatrix} if needed.\r\n   * @param parameters - {@link CameraPerspectiveOptions | parameters} to use for the perspective\r\n   */\r\n  setPerspective({\r\n    fov = this.fov,\r\n    near = this.near,\r\n    far = this.far,\r\n    width = this.size.width,\r\n    height = this.size.height,\r\n    pixelRatio = this.pixelRatio,\r\n  }: CameraPerspectiveOptions = {}) {\r\n    this.setSize({ width, height })\r\n    this.pixelRatio = pixelRatio\r\n    this.fov = fov\r\n    this.near = near\r\n    this.far = far\r\n  }\r\n\r\n  /**\r\n   * Sets a {@link CSSPerspective} property based on {@link size}, {@link pixelRatio} and {@link fov}.<br>\r\n   * Used to translate planes along the Z axis using pixel units as CSS would do.<br>\r\n   * {@link https://stackoverflow.com/questions/22421439/convert-field-of-view-value-to-css3d-perspective-value | See reference}\r\n   */\r\n  setCSSPerspective() {\r\n    this.CSSPerspective =\r\n      Math.pow(\r\n        Math.pow(this.size.width / (2 * this.pixelRatio), 2) + Math.pow(this.size.height / (2 * this.pixelRatio), 2),\r\n        0.5\r\n      ) / Math.tan((this.fov * 0.5 * Math.PI) / 180)\r\n  }\r\n\r\n  /**\r\n   * Get visible width / height at a given z-depth from our {@link Camera} parameters.<br>\r\n   * {@link https://discourse.threejs.org/t/functions-to-calculate-the-visible-width-height-at-a-given-z-depth-from-a-perspective-camera/269 | See reference}\r\n   * @param depth - depth to use for calculations\r\n   * @returns - visible width and height at given depth\r\n   */\r\n  getVisibleSizeAtDepth(depth = 0): RectSize {\r\n    // compensate for cameras not positioned at z=0\r\n    const cameraOffset = this.position.z\r\n    if (depth < cameraOffset) {\r\n      depth -= cameraOffset\r\n    } else {\r\n      depth += cameraOffset\r\n    }\r\n\r\n    // vertical fov in radians\r\n    const vFOV = (this.fov * Math.PI) / 180\r\n\r\n    // Math.abs to ensure the result is always positive\r\n    const height = 2 * Math.tan(vFOV / 2) * Math.abs(depth)\r\n\r\n    return {\r\n      width: (height * this.size.width) / this.size.height,\r\n      height,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets visible width / height at a depth of 0.\r\n   */\r\n  setVisibleSize() {\r\n    this.visibleSize = this.getVisibleSizeAtDepth()\r\n  }\r\n\r\n  /**\r\n   * Rotate this {@link Camera} so it looks at the {@link Vec3 | target}\r\n   * @param target - {@link Vec3 | target} to look at\r\n   * @param position - {@link Vec3 | postion} from which to look at\r\n   */\r\n  lookAt(target: Vec3 = new Vec3(), position = this.position) {\r\n    // since we know it's a camera, inverse position and target\r\n    super.lookAt(position, target, this.up)\r\n  }\r\n\r\n  /**\r\n   * Updates the {@link Camera} {@link projectionMatrix}\r\n   */\r\n  updateProjectionMatrix() {\r\n    this.projectionMatrix.makePerspective({\r\n      fov: this.fov,\r\n      aspect: this.size.width / this.size.height,\r\n      near: this.near,\r\n      far: this.far,\r\n    })\r\n  }\r\n}\r\n","import { isRenderer, Renderer } from '../renderers/utils'\r\nimport { SamplerBinding } from '../bindings/SamplerBinding'\r\nimport { generateUUID, throwWarning } from '../../utils/utils'\r\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\r\n\r\n/** Options used to create a {@link Sampler} */\r\nexport interface SamplerOptions extends Partial<GPUSamplerDescriptor>, GPUSamplerBindingLayout {}\r\n\r\n/**\r\n * Parameters used to create a {@link Sampler}\r\n */\r\nexport interface SamplerParams extends SamplerOptions {\r\n  /** Name of the {@link Sampler} to use in the {@link SamplerBinding | binding} */\r\n  name: string\r\n}\r\n\r\n/**\r\n * Used to create a {@link GPUSampler} and its associated {@link SamplerBinding}.\r\n *\r\n * @example\r\n * ```javascript\r\n * // set our main GPUCurtains instance\r\n * const gpuCurtains = new GPUCurtains({\r\n *   container: '#canvas' // selector of our WebGPU canvas container\r\n * })\r\n *\r\n * // set the GPU device\r\n * // note this is asynchronous\r\n * await gpuCurtains.setDevice()\r\n *\r\n * const mirrorSampler = new Sampler(gpuCurtains, {\r\n *   label: 'Mirror sampler',\r\n *   name: 'mirrorSampler',\r\n *   addressModeU: 'mirror-repeat',\r\n *   addressModeV: 'mirror-repeat',\r\n * })\r\n * ```\r\n */\r\nexport class Sampler {\r\n  /** The type of the {@link Sampler} */\r\n  type: string\r\n  /** The universal unique id of this {@link Sampler} */\r\n  readonly uuid: string\r\n  /** {@link Renderer} used by this {@link Sampler} */\r\n  renderer: Renderer\r\n  /** The label of the {@link Sampler}, used to create the {@link GPUSampler} for debugging purpose */\r\n  label: string\r\n  /** Name of the {@link Sampler} to use in the {@link SamplerBinding | binding} */\r\n  name: string\r\n  /** Options used to create this {@link Sampler} */\r\n  options: SamplerOptions\r\n\r\n  /** {@link GPUSampler} */\r\n  sampler: GPUSampler\r\n  /** {@link SamplerBinding | binding} to pass to a {@link core/bindGroups/TextureBindGroup.TextureBindGroup | bind group} */\r\n  binding: SamplerBinding\r\n\r\n  /**\r\n   * Sampler constructor\r\n   * @param renderer - {@link Renderer} object or {@link GPUCurtains} class object used to create this {@link Sampler}\r\n   * @param parameters - {@link SamplerParams | parameters} used to create this {@link Sampler}\r\n   */\r\n  constructor(\r\n    renderer: GPUCurtains | Renderer,\r\n    {\r\n      label = 'Sampler',\r\n      name,\r\n      addressModeU = 'repeat',\r\n      addressModeV = 'repeat',\r\n      magFilter = 'linear',\r\n      minFilter = 'linear',\r\n      mipmapFilter = 'linear',\r\n      maxAnisotropy = 1,\r\n      type = 'filtering',\r\n      compare = null,\r\n    } = {} as SamplerParams\r\n  ) {\r\n    this.type = 'Sampler'\r\n    this.uuid = generateUUID()\r\n\r\n    renderer = isRenderer(renderer, label ? label + ' ' + this.type : this.type)\r\n\r\n    this.renderer = renderer\r\n\r\n    this.label = label\r\n\r\n    if (!name && !this.renderer.production) {\r\n      name = 'sampler' + this.renderer.samplers.length\r\n      throwWarning(\r\n        `Sampler: you are trying to create a sampler without the mandatory name parameter. A default name will be used instead: ${name}`\r\n      )\r\n    }\r\n\r\n    this.name = name\r\n\r\n    this.options = {\r\n      addressModeU,\r\n      addressModeV,\r\n      magFilter,\r\n      minFilter,\r\n      mipmapFilter,\r\n      maxAnisotropy,\r\n      type,\r\n      ...(compare !== null && { compare }),\r\n    } as SamplerOptions\r\n\r\n    this.createSampler()\r\n    this.createBinding()\r\n  }\r\n\r\n  /**\r\n   * Set the {@link GPUSampler}\r\n   */\r\n  createSampler() {\r\n    this.sampler = this.renderer.createSampler(this)\r\n  }\r\n\r\n  /**\r\n   * Set the {@link SamplerBinding | binding}\r\n   */\r\n  createBinding() {\r\n    this.binding = new SamplerBinding({\r\n      label: this.label,\r\n      name: this.name,\r\n      bindingType: 'sampler',\r\n      sampler: this.sampler,\r\n      type: this.options.type,\r\n    })\r\n  }\r\n}\r\n","import { generateMips, isRenderer, Renderer } from '../renderers/utils'\r\nimport { TextureBinding } from '../bindings/TextureBinding'\r\nimport { BindGroupBindingElement } from '../../types/BindGroups'\r\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\r\nimport { BindingMemoryAccessType, BindingParams, TextureBindingType } from '../bindings/Binding'\r\nimport { generateUUID } from '../../utils/utils'\r\nimport { DOMTexture } from './DOMTexture'\r\nimport { ExternalTextureParamsBase, TextureSize } from '../../types/Textures'\r\nimport { getDefaultTextureUsage, getNumMipLevels, TextureUsageKeys } from './utils'\r\n\r\n/**\r\n * Base parameters used to create a {@link Texture}\r\n */\r\nexport interface TextureBaseParams extends ExternalTextureParamsBase {\r\n  /** The label of the {@link Texture}, used to create various GPU objects for debugging purpose */\r\n  label?: string\r\n  /** Name of the {@link Texture} to use in the {@link TextureBinding | texture binding} */\r\n  name?: string\r\n\r\n  /** Optional fixed size of the {@link Texture#texture | texture}. If set, the {@link Texture} will never be resized and always keep that size. */\r\n  fixedSize?: TextureSize\r\n\r\n  /** Force the texture size to be set to the given ratio of the {@link core/renderers/GPURenderer.GPURenderer#canvas | renderer canvas} size or {@link fixedSize}. Used mainly to shrink render target texture definition. */\r\n  qualityRatio?: number\r\n\r\n  /** Whether to use this {@link Texture} as a regular, storage or depth texture */\r\n  type?: TextureBindingType\r\n  /** Optional format of the {@link Texture#texture | texture}, mainly used for storage textures */\r\n  format?: GPUTextureFormat\r\n  /** Optional texture binding memory access type, mainly used for storage textures */\r\n  access?: BindingMemoryAccessType\r\n  /** Optional {@link Texture#texture | texture} view dimension to use */\r\n  viewDimension?: GPUTextureViewDimension\r\n  /** Sample count of the {@link Texture#texture | texture}, used for multisampling */\r\n  sampleCount?: GPUSize32\r\n  /** The {@link Texture} shaders visibility sent to the {@link Texture#textureBinding | texture binding} */\r\n  visibility?: BindingParams['visibility']\r\n  /** Allowed usages for the {@link Texture#texture | GPU texture} as an array of {@link TextureUsageKeys | texture usages names} */\r\n  usage?: TextureUsageKeys[]\r\n\r\n  /** Whether any {@link core/materials/Material.Material | Material} using this {@link Texture} should automatically destroy it upon destruction. Default to `true`. */\r\n  autoDestroy?: boolean\r\n}\r\n\r\n/**\r\n * Parameters used to create a {@link Texture}\r\n */\r\nexport interface TextureParams extends TextureBaseParams {\r\n  /** Optional texture to use as a copy source input. Could be a {@link Texture} or {@link DOMTexture} */\r\n  fromTexture?: Texture | DOMTexture | null\r\n}\r\n\r\n/** @const - default {@link Texture} parameters */\r\nconst defaultTextureParams: TextureParams = {\r\n  label: 'Texture',\r\n  name: 'renderTexture', // default to 'renderTexture' for render target usage\r\n  type: 'texture',\r\n  access: 'write',\r\n  fromTexture: null,\r\n  viewDimension: '2d',\r\n  sampleCount: 1,\r\n  qualityRatio: 1,\r\n  // copy external texture options\r\n  generateMips: false,\r\n  flipY: false,\r\n  premultipliedAlpha: false,\r\n  autoDestroy: true,\r\n}\r\n\r\n/**\r\n * This is the main class used to create and handle {@link GPUTexture | textures} that can be used with {@link core/computePasses/ComputePass.ComputePass | ComputePass} and/or {@link core/meshes/Mesh.Mesh | Mesh}. Also used as copy source/destination for {@link core/renderPasses/RenderPass.RenderPass | RenderPass} and {@link core/renderPasses/RenderTarget.RenderTarget | RenderTarget}.\r\n *\r\n * Basically useful for any kind of textures: for external sources (however in some cases, {@link core/textures/DOMTexture.DOMTexture | DOMTexture} might be preferred), depth, storages or to copy anything outputted to the screen at one point or another.\r\n *\r\n * Will create a {@link GPUTexture} and its associated {@link TextureBinding}.\r\n *\r\n * @example\r\n * ```javascript\r\n * // set our main GPUCurtains instance\r\n * const gpuCurtains = new GPUCurtains({\r\n *   container: '#canvas' // selector of our WebGPU canvas container\r\n * })\r\n *\r\n * // set the GPU device\r\n * // note this is asynchronous\r\n * await gpuCurtains.setDevice()\r\n *\r\n * // create a texture\r\n * const texture = new Texture(gpuCurtains, {\r\n *   label: 'My texture',\r\n *   name: 'myTexture',\r\n * })\r\n * ```\r\n */\r\nexport class Texture {\r\n  /** {@link Renderer | renderer} used by this {@link Texture} */\r\n  renderer: Renderer\r\n  /** The type of the {@link Texture} */\r\n  type: string\r\n  /** The universal unique id of this {@link Texture} */\r\n  readonly uuid: string\r\n\r\n  /** The {@link GPUTexture} used */\r\n  texture: GPUTexture\r\n\r\n  /** Size of the {@link Texture#texture | texture} source, usually our {@link Renderer#canvas | renderer canvas} size */\r\n  size: TextureSize\r\n\r\n  /** Options used to create this {@link Texture} */\r\n  options: TextureParams\r\n\r\n  /** Array of {@link core/bindings/Binding.Binding | bindings} that will actually only hold one {@link TextureBinding | texture binding} */\r\n  bindings: BindGroupBindingElement[]\r\n\r\n  /** Whether this texture should be automatically resized when the {@link Renderer renderer} size changes. Default to true. */\r\n  #autoResize = true\r\n\r\n  /**\r\n   * Texture constructor\r\n   * @param renderer - {@link Renderer | renderer} object or {@link GPUCurtains} class object used to create this {@link Texture}\r\n   * @param parameters - {@link TextureParams | parameters} used to create this {@link Texture}\r\n   */\r\n  constructor(renderer: Renderer | GPUCurtains, parameters = defaultTextureParams) {\r\n    renderer = isRenderer(renderer, parameters.label ? parameters.label + ' Texture' : 'Texture')\r\n\r\n    this.type = 'Texture'\r\n\r\n    this.renderer = renderer\r\n\r\n    this.uuid = generateUUID()\r\n\r\n    this.options = { ...defaultTextureParams, ...parameters }\r\n\r\n    if (\r\n      this.options.format === 'rgba32float' &&\r\n      !(this.renderer.deviceManager.adapter as GPUAdapter).features.has('float32-filterable')\r\n    ) {\r\n      this.options.format = 'rgba16float'\r\n    }\r\n\r\n    if (parameters.fromTexture) {\r\n      this.options.format = parameters.fromTexture.texture.format\r\n      this.options.sampleCount = parameters.fromTexture.texture.sampleCount\r\n      this.options.viewDimension = parameters.fromTexture.options.viewDimension\r\n    }\r\n\r\n    if (!this.options.format) {\r\n      this.options.format = this.renderer.options.preferredFormat\r\n    }\r\n\r\n    // sizes\r\n    this.size = this.options.fixedSize\r\n      ? {\r\n          width: this.options.fixedSize.width * this.options.qualityRatio,\r\n          height: this.options.fixedSize.height * this.options.qualityRatio,\r\n          depth: this.options.fixedSize.depth ?? this.options.viewDimension.indexOf('cube') !== -1 ? 6 : 1,\r\n        }\r\n      : {\r\n          width: Math.floor(this.renderer.canvas.width * this.options.qualityRatio),\r\n          height: Math.floor(this.renderer.canvas.height * this.options.qualityRatio),\r\n          depth: this.options.viewDimension.indexOf('cube') !== -1 ? 6 : 1,\r\n        }\r\n\r\n    if (this.options.fixedSize) {\r\n      this.#autoResize = false\r\n    }\r\n\r\n    // struct\r\n    this.setBindings()\r\n\r\n    // texture\r\n    this.renderer.addTexture(this)\r\n    this.createTexture()\r\n  }\r\n\r\n  /**\r\n   * Copy another {@link Texture} into this {@link Texture}\r\n   * @param texture - {@link Texture} to copy\r\n   */\r\n  copy(texture: Texture | DOMTexture) {\r\n    this.options.fromTexture = texture\r\n    this.createTexture()\r\n  }\r\n\r\n  /**\r\n   * Copy a {@link GPUTexture} directly into this {@link Texture}. Mainly used for depth textures.\r\n   * @param texture - {@link GPUTexture} to copy\r\n   */\r\n  copyGPUTexture(texture: GPUTexture) {\r\n    this.size = {\r\n      width: texture.width,\r\n      height: texture.height,\r\n      depth: texture.depthOrArrayLayers,\r\n    }\r\n\r\n    this.options.format = texture.format\r\n    this.options.sampleCount = texture.sampleCount\r\n\r\n    this.texture = texture\r\n\r\n    this.textureBinding.setFormat(this.options.format)\r\n    this.textureBinding.setMultisampled(this.options.sampleCount > 1)\r\n\r\n    this.textureBinding.resource = this.texture\r\n  }\r\n\r\n  /**\r\n   * Create the {@link GPUTexture | texture} (or copy it from source) and update the {@link TextureBinding#resource | binding resource}\r\n   */\r\n  createTexture() {\r\n    if (!this.size.width || !this.size.height) return\r\n\r\n    if (this.options.fromTexture) {\r\n      // copy the GPU texture\r\n      this.copyGPUTexture(this.options.fromTexture.texture)\r\n      return\r\n    }\r\n\r\n    this.texture?.destroy()\r\n\r\n    this.texture = this.renderer.createTexture({\r\n      label: this.options.label,\r\n      format: this.options.format,\r\n      size: [this.size.width, this.size.height, this.size.depth ?? 1],\r\n      dimensions: this.options.viewDimension,\r\n      sampleCount: this.options.sampleCount,\r\n      mipLevelCount: this.options.generateMips\r\n        ? getNumMipLevels(this.size.width, this.size.height, this.size.depth ?? 1)\r\n        : 1,\r\n      usage: getDefaultTextureUsage(this.options.usage, this.options.type),\r\n    } as GPUTextureDescriptor)\r\n\r\n    // update texture binding\r\n    this.textureBinding.resource = this.texture\r\n  }\r\n\r\n  /**\r\n   * Upload a source to the GPU and use it for our {@link texture}.\r\n   * @param parameters - parameters used to upload the source.\r\n   * @param parameters.source - source to use for our {@link texture}.\r\n   * @param parameters.width - source width.\r\n   * @param parameters.height - source height.\r\n   * @param parameters.depth - source depth.\r\n   * @param parameters.origin - {@link GPUOrigin3D | origin} of the source copy.\r\n   */\r\n  uploadSource({\r\n    source,\r\n    width = this.size.width,\r\n    height = this.size.height,\r\n    depth = this.size.depth,\r\n    origin = [0, 0, 0],\r\n    colorSpace = 'srgb',\r\n  }: {\r\n    source: GPUImageCopyExternalImageSource\r\n    width?: number\r\n    height?: number\r\n    depth?: number\r\n    origin?: GPUOrigin3D\r\n    colorSpace?: PredefinedColorSpace\r\n  }) {\r\n    this.renderer.device.queue.copyExternalImageToTexture(\r\n      { source: source, flipY: this.options.flipY },\r\n      { texture: this.texture, premultipliedAlpha: this.options.premultipliedAlpha, origin, colorSpace },\r\n      [width, height, depth]\r\n    )\r\n\r\n    if (this.texture.mipLevelCount > 1) {\r\n      generateMips(this.renderer.device, this.texture)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Use data as the {@link texture} source and upload it to the GPU.\r\n   * @param parameters - parameters used to upload the source.\r\n   * @param parameters.width - data source width.\r\n   * @param parameters.height - data source height.\r\n   * @param parameters.depth - data source depth.\r\n   * @param parameters.origin - {@link GPUOrigin3D | origin} of the data source copy.\r\n   * @param parameters.data - {@link Float32Array} data to use as source.\r\n   */\r\n  uploadData({\r\n    width = this.size.width,\r\n    height = this.size.height,\r\n    depth = this.size.depth,\r\n    origin = [0, 0, 0],\r\n    data = new Float32Array(width * height * 4),\r\n  }: {\r\n    width?: number\r\n    height?: number\r\n    depth?: number\r\n    origin?: GPUOrigin3D\r\n    data?: Float32Array\r\n  }) {\r\n    this.renderer.device.queue.writeTexture(\r\n      { texture: this.texture, origin },\r\n      data,\r\n      { bytesPerRow: width * data.BYTES_PER_ELEMENT * 4, rowsPerImage: height },\r\n      [width, height, depth]\r\n    )\r\n\r\n    if (this.texture.mipLevelCount > 1) {\r\n      generateMips(this.renderer.device, this.texture)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set our {@link Texture#bindings | bindings}\r\n   */\r\n  setBindings() {\r\n    this.bindings = [\r\n      new TextureBinding({\r\n        label: this.options.label + ': ' + this.options.name + ' texture',\r\n        name: this.options.name,\r\n        bindingType: this.options.type,\r\n        visibility: this.options.visibility,\r\n        texture: this.texture,\r\n        format: this.options.format,\r\n        viewDimension: this.options.viewDimension,\r\n        multisampled: this.options.sampleCount > 1,\r\n      }),\r\n    ]\r\n  }\r\n\r\n  /**\r\n   * Get our {@link TextureBinding | texture binding}\r\n   * @readonly\r\n   */\r\n  get textureBinding(): TextureBinding {\r\n    return this.bindings[0] as TextureBinding\r\n  }\r\n\r\n  /**\r\n   * Resize our {@link Texture}, which means recreate it/copy it again and tell the {@link core/bindGroups/TextureBindGroup.TextureBindGroup | texture bind group} to update\r\n   * @param size - the optional new {@link TextureSize | size} to set\r\n   */\r\n  resize(size: TextureSize | null = null) {\r\n    if (!this.#autoResize) return\r\n\r\n    if (!size) {\r\n      size = {\r\n        width: Math.floor(this.renderer.canvas.width * this.options.qualityRatio),\r\n        height: Math.floor(this.renderer.canvas.height * this.options.qualityRatio),\r\n        depth: 1,\r\n      }\r\n    }\r\n\r\n    // no real resize, bail!\r\n    if (size.width === this.size.width && size.height === this.size.height && size.depth === this.size.depth) {\r\n      return\r\n    }\r\n\r\n    this.size = size\r\n    this.createTexture()\r\n  }\r\n\r\n  /**\r\n   * Destroy our {@link Texture}\r\n   */\r\n  destroy() {\r\n    this.renderer.removeTexture(this)\r\n\r\n    // destroy the GPU texture only if it's not a copy of another texture\r\n    if (!this.options.fromTexture) {\r\n      this.texture?.destroy()\r\n    }\r\n\r\n    this.texture = null\r\n  }\r\n}\r\n","import { isRenderer, Renderer } from '../renderers/utils'\nimport { BindGroup } from '../bindGroups/BindGroup'\nimport { TextureBindGroup } from '../bindGroups/TextureBindGroup'\nimport { Sampler } from '../samplers/Sampler'\nimport { AllowedPipelineEntries, GPUPassTypes } from '../pipelines/PipelineManager'\nimport { BufferBinding, BufferBindingInput } from '../bindings/BufferBinding'\nimport { AllowedBindGroups, BindGroupBindingElement, BindGroupBufferBindingElement } from '../../types/BindGroups'\nimport { DOMTexture } from '../textures/DOMTexture'\nimport { FullShadersType, MaterialOptions, MaterialParams, ShaderOptions } from '../../types/Materials'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\nimport { Texture } from '../textures/Texture'\nimport { Binding } from '../bindings/Binding'\nimport { generateUUID } from '../../utils/utils'\nimport { BufferElement } from '../bindings/bufferElements/BufferElement'\nimport { Buffer } from '../buffers/Buffer'\n\n/**\n * Used as a base to create a {@link Material}.<br>\n * The purpose of {@link Material} is to create and update the {@link BindGroup | bind groups} and their bindings (GPU buffers, textures and samplers), create a {@link core/pipelines/PipelineEntry.PipelineEntry | PipelineEntry} and use them to {@link Material#render | render}.\n *\n * ## Bind groups\n *\n * A {@link Material} automatically creates a {@link TextureBindGroup}, but it is actually added to the active {@link Material#bindGroups | bind groups array} only if necessary, which means if your shaders use a {@link GPUSampler}, a {@link GPUTexture} or a {@link GPUExternalTexture}.\n *\n * Another {@link BindGroup} will be created if you pass any {@link MaterialParams#uniforms | uniforms} or {@link MaterialParams#storages | storages} parameters.\n *\n * Finally, you can also pass already created {@link BindGroup} to a {@link Material} via the {@link MaterialParams#bindGroups | bindGroups} parameter.\n *\n * ----\n *\n * Note that this class is not intended to be used as is, but as a base for {@link core/materials/ComputeMaterial.ComputeMaterial | ComputeMaterial} and {@link core/materials/RenderMaterial.RenderMaterial | RenderMaterial} classes.\n */\nexport class Material {\n  /** The type of the {@link Material} */\n  type: string\n  /** The universal unique id of the {@link Material} */\n  uuid: string\n  /** The {@link Renderer} used */\n  renderer: Renderer\n  /** Options used to create this {@link Material} */\n  options: MaterialOptions\n\n  /** Pipeline entry used by this {@link Material} */\n  pipelineEntry: AllowedPipelineEntries\n\n  /**\n   * Array of {@link BindGroup | bind groups} used by this {@link Material}\n   * This array respects a specific order:\n   * 1. The {@link texturesBindGroup | textures bind groups}\n   * 2. The {@link BindGroup | bind group} created using {@link types/BindGroups.BindGroupInputs#uniforms | uniforms} and {@link types/BindGroups.BindGroupInputs#storages | storages} parameters if any\n   * 3. Additional {@link MaterialParams#bindGroups | bind groups} parameters if any\n   */\n  bindGroups: AllowedBindGroups[]\n  /** Array of {@link TextureBindGroup | texture bind groups} used by this {@link Material} */\n  texturesBindGroups: TextureBindGroup[]\n  /** Array of {@link BindGroup | bind groups} created using the {@link types/BindGroups.BindGroupInputs#uniforms | uniforms} and {@link types/BindGroups.BindGroupInputs#storages | storages} parameters when instancing this {@link Material} */\n  inputsBindGroups: BindGroup[]\n  /** Array of {@link BindGroup | cloned bind groups} created by this {@link Material} */\n  clonedBindGroups: AllowedBindGroups[]\n\n  /** Object containing all uniforms inputs handled by this {@link Material} */\n  uniforms: Record<string, Record<string, BufferBindingInput>>\n  /** Object containing all read only or read/write storages inputs handled by this {@link Material} */\n  storages: Record<string, Record<string, BufferBindingInput>>\n\n  /** Map of {@link Binding | bindings} created using the {@link types/BindGroups.BindGroupInputs#uniforms | uniforms} and {@link types/BindGroups.BindGroupInputs#storages | storages} parameters when instancing this {@link Material} */\n  inputsBindings: Map<string, BindGroupBindingElement>\n\n  /** Array of {@link DOMTexture} handled by this {@link Material} */\n  domTextures: DOMTexture[]\n  /** Array of {@link Texture} handled by this {@link Material} */\n  textures: Texture[]\n  /** Array of {@link Sampler} handled by this {@link Material} */\n  samplers: Sampler[]\n\n  /**\n   * Material constructor\n   * @param renderer - our renderer class object\n   * @param parameters - {@link types/Materials.MaterialParams | parameters} used to create our Material\n   */\n  constructor(renderer: Renderer | GPUCurtains, parameters: MaterialParams) {\n    this.type = 'Material'\n\n    renderer = isRenderer(renderer, this.type)\n\n    this.renderer = renderer\n\n    this.uuid = generateUUID()\n\n    const {\n      shaders,\n      label,\n      useAsyncPipeline,\n      uniforms,\n      storages,\n      bindings,\n      bindGroups,\n      samplers,\n      textures,\n      domTextures,\n    } = parameters\n\n    this.options = {\n      shaders,\n      label,\n      useAsyncPipeline: useAsyncPipeline === undefined ? true : useAsyncPipeline,\n      ...(uniforms !== undefined && { uniforms }),\n      ...(storages !== undefined && { storages }),\n      ...(bindings !== undefined && { bindings }),\n      ...(bindGroups !== undefined && { bindGroups }),\n      ...(samplers !== undefined && { samplers }),\n      ...(textures !== undefined && { textures }),\n      ...(domTextures !== undefined && { domTextures }),\n    }\n\n    this.bindGroups = []\n    this.texturesBindGroups = []\n    this.clonedBindGroups = []\n\n    this.setBindGroups()\n\n    this.setTextures()\n    this.setSamplers()\n  }\n\n  /**\n   * Set or reset this {@link Material} {@link renderer}.\n   * @param renderer - New {@link Renderer} or {@link GPUCurtains} instance to use.\n   */\n  setRenderer(renderer: Renderer | GPUCurtains) {\n    renderer = isRenderer(renderer, this.type)\n    this.renderer = renderer\n  }\n\n  /**\n   * Check if all bind groups are ready, and create them if needed\n   */\n  compileMaterial() {\n    const texturesBindGroupLength = this.texturesBindGroup.bindings.length ? 1 : 0\n    const bindGroupsReady = this.bindGroups.length >= this.inputsBindGroups.length + texturesBindGroupLength\n\n    if (!bindGroupsReady) {\n      this.createBindGroups()\n    }\n  }\n\n  /**\n   * Get whether the renderer is ready, our pipeline entry and pipeline have been created and successfully compiled\n   * @readonly\n   */\n  get ready(): boolean {\n    return !!(this.renderer.ready && this.pipelineEntry && this.pipelineEntry.pipeline && this.pipelineEntry.ready)\n  }\n\n  /**\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been lost to prepare everything for restoration.\n   * Basically set all the {@link GPUBuffer} to null so they will be reset next time we try to render\n   */\n  loseContext() {\n    // start with the textures\n    for (const texture of this.domTextures) {\n      texture.texture = null\n      texture.sourceUploaded = false\n    }\n\n    for (const texture of this.textures) {\n      texture.texture = null\n    }\n\n    // then bind groups and struct\n    ;[...this.bindGroups, ...this.clonedBindGroups, ...this.inputsBindGroups].forEach((bindGroup) =>\n      bindGroup.loseContext()\n    )\n\n    // reset pipeline as well\n    this.pipelineEntry.pipeline = null\n  }\n\n  /**\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been restored to recreate our samplers, textures and bind groups.\n   */\n  restoreContext() {\n    // start with the samplers and textures\n    for (const sampler of this.samplers) {\n      // the samplers have all been recreated by the renderer, just update the reference\n      sampler.createSampler()\n      sampler.binding.resource = sampler.sampler\n    }\n\n    // recreate the textures and resize them\n    for (const texture of this.domTextures) {\n      texture.createTexture()\n      texture.resize()\n    }\n\n    for (const texture of this.textures) {\n      texture.resize(texture.size)\n    }\n\n    // now the bind groups\n    ;[...this.bindGroups, ...this.clonedBindGroups, ...this.inputsBindGroups].forEach((bindGroup) => {\n      bindGroup.restoreContext()\n    })\n  }\n\n  /**\n   * Get the complete code of a given shader including all the WGSL fragment code snippets added by the pipeline\n   * @param [shaderType=\"full\"] - shader to get the code from\n   * @returns - The corresponding shader code\n   */\n  getShaderCode(shaderType: FullShadersType = 'full'): string {\n    if (!this.pipelineEntry) return ''\n\n    shaderType = (() => {\n      switch (shaderType) {\n        case 'vertex':\n        case 'fragment':\n        case 'compute':\n        case 'full':\n          return shaderType\n        default:\n          return 'full'\n      }\n    })()\n\n    return this.pipelineEntry.shaders[shaderType].code\n  }\n\n  /**\n   * Get the added code of a given shader, i.e. all the WGSL fragment code snippets added by the pipeline\n   * @param [shaderType=\"vertex\"] - shader to get the code from\n   * @returns - The corresponding shader code\n   */\n  getAddedShaderCode(shaderType: FullShadersType = 'vertex'): string {\n    if (!this.pipelineEntry) return ''\n\n    shaderType = (() => {\n      switch (shaderType) {\n        case 'vertex':\n        case 'fragment':\n        case 'compute':\n          return shaderType\n        default:\n          return 'vertex'\n      }\n    })()\n\n    return this.pipelineEntry.shaders[shaderType].head\n  }\n\n  /* BIND GROUPS */\n\n  /**\n   * Prepare and set our bind groups based on inputs and bindGroups Material parameters\n   */\n  setBindGroups() {\n    this.uniforms = {}\n    this.storages = {}\n\n    this.inputsBindGroups = []\n    this.inputsBindings = new Map()\n\n    if (this.options.uniforms || this.options.storages || this.options.bindings) {\n      const inputsBindGroup = new BindGroup(this.renderer, {\n        label: this.options.label + ': Bindings bind group',\n        uniforms: this.options.uniforms,\n        storages: this.options.storages,\n        bindings: this.options.bindings,\n      })\n\n      this.processBindGroupBindings(inputsBindGroup)\n      this.inputsBindGroups.push(inputsBindGroup)\n      inputsBindGroup.consumers.add(this.uuid)\n    }\n\n    this.options.bindGroups?.forEach((bindGroup) => {\n      this.processBindGroupBindings(bindGroup)\n      this.inputsBindGroups.push(bindGroup)\n      bindGroup.consumers.add(this.uuid)\n    })\n  }\n\n  /**\n   * Get the main {@link TextureBindGroup | texture bind group} created by this {@link Material} to manage all textures related struct\n   * @readonly\n   */\n  get texturesBindGroup(): TextureBindGroup {\n    return this.texturesBindGroups[0]\n  }\n\n  /**\n   * Process all {@link BindGroup} struct and add them to the corresponding objects based on their binding types. Also store them in a inputsBindings array to facilitate further access to struct.\n   * @param bindGroup - The {@link BindGroup} to process\n   */\n  processBindGroupBindings(bindGroup: BindGroup) {\n    for (const inputBinding of bindGroup.bindings) {\n      if (inputBinding.bindingType === 'uniform')\n        this.uniforms = {\n          ...this.uniforms,\n          [inputBinding.name]: (inputBinding as BindGroupBufferBindingElement).inputs,\n        }\n      if (inputBinding.bindingType === 'storage')\n        this.storages = {\n          ...this.storages,\n          [inputBinding.name]: (inputBinding as BindGroupBufferBindingElement).inputs,\n        }\n\n      this.inputsBindings.set(inputBinding.name, inputBinding)\n    }\n  }\n\n  /**\n   * Create the bind groups if they need to be created\n   */\n  createBindGroups() {\n    // textures first\n    if (this.texturesBindGroup.shouldCreateBindGroup) {\n      this.texturesBindGroup.setIndex(this.bindGroups.length)\n      this.texturesBindGroup.createBindGroup()\n\n      this.bindGroups.push(this.texturesBindGroup)\n    }\n\n    // then uniforms/storages inputs\n    for (const bindGroup of this.inputsBindGroups) {\n      if (bindGroup.shouldCreateBindGroup) {\n        bindGroup.setIndex(this.bindGroups.length)\n        bindGroup.createBindGroup()\n\n        this.bindGroups.push(bindGroup)\n      }\n    }\n\n    // finally, bindGroups inputs\n    this.options.bindGroups?.forEach((bindGroup) => {\n      // it has been created but not been added yet? add it!\n      if (!bindGroup.shouldCreateBindGroup && !this.bindGroups.find((bG) => bG.uuid === bindGroup.uuid)) {\n        bindGroup.setIndex(this.bindGroups.length)\n        this.bindGroups.push(bindGroup)\n      }\n\n      // add it to our textures bind groups as well if needed\n      if (bindGroup instanceof TextureBindGroup && !this.texturesBindGroups.find((bG) => bG.uuid === bindGroup.uuid)) {\n        this.texturesBindGroups.push(bindGroup)\n\n        // also add the textures?\n        for (const texture of bindGroup.textures) {\n          if (texture instanceof DOMTexture && !this.domTextures.find((t) => t.uuid === texture.uuid)) {\n            this.domTextures.push(texture)\n          } else if (texture instanceof Texture && !this.textures.find((t) => t.uuid === texture.uuid)) {\n            this.textures.push(texture)\n          }\n        }\n      }\n    })\n  }\n\n  /**\n   * Clones a {@link BindGroup} from a list of buffers\n   * Useful to create a new bind group with already created buffers, but swapped\n   * @param parameters - parameters used to clone the {@link BindGroup | bind group}\n   * @param parameters.bindGroup - the BindGroup to clone\n   * @param parameters.bindings - our input binding buffers\n   * @param parameters.keepLayout - whether we should keep original bind group layout or not\n   * @returns - the cloned BindGroup\n   */\n  cloneBindGroup({\n    bindGroup,\n    bindings = [],\n    keepLayout = true,\n  }: {\n    bindGroup?: AllowedBindGroups\n    bindings?: BindGroupBindingElement[]\n    keepLayout?: boolean\n  }): AllowedBindGroups | null {\n    if (!bindGroup) return null\n\n    const clone = bindGroup.clone({ bindings, keepLayout })\n    this.clonedBindGroups.push(clone)\n\n    return clone\n  }\n\n  /**\n   * Get a corresponding {@link BindGroup} or {@link TextureBindGroup} from one of its binding name/key\n   * @param bindingName - the binding name/key to look for\n   * @returns - bind group found or null if not found\n   */\n  getBindGroupByBindingName(bindingName: BufferBinding['name'] = ''): AllowedBindGroups | null {\n    return (this.ready ? this.bindGroups : this.inputsBindGroups).find((bindGroup) => {\n      return bindGroup.bindings.find((binding) => binding.name === bindingName)\n    })\n  }\n\n  /**\n   * Destroy a bind group, only if it is not used by another object\n   * @param bindGroup - bind group to eventually destroy\n   */\n  destroyBindGroup(bindGroup: AllowedBindGroups) {\n    // remove this material as a consumer of the bind group\n    bindGroup.consumers.delete(this.uuid)\n\n    // if the bind group does not have another consumer\n    // destroy it\n    if (!bindGroup.consumers.size) {\n      bindGroup.destroy()\n    }\n  }\n\n  /**\n   * Destroy all bind groups\n   */\n  destroyBindGroups() {\n    this.bindGroups.forEach((bindGroup) => this.destroyBindGroup(bindGroup))\n    this.clonedBindGroups.forEach((bindGroup) => this.destroyBindGroup(bindGroup))\n    this.texturesBindGroups.forEach((bindGroup) => this.destroyBindGroup(bindGroup))\n    this.texturesBindGroups = []\n    this.inputsBindGroups = []\n    this.bindGroups = []\n    this.clonedBindGroups = []\n  }\n\n  /**\n   * Update all bind groups.\n   */\n  updateBindGroups() {\n    // now update all bind groups in use and check if they need to flush the pipeline\n    for (const bindGroup of this.bindGroups) {\n      this.updateBindGroup(bindGroup)\n    }\n  }\n\n  /**\n   * {@link BindGroup#update | Update a bind group}:\n   * - Update the textures if it's a {@link texturesBindGroups | textures bind group}.\n   * - Update its {@link BindGroup#bufferBindings | buffer bindings}.\n   * - Check if it eventually needs a {@link BindGroup#resetBindGroup | reset}.\n   * - Check if we need to flush the pipeline.\n   * @param bindGroup - {@link BindGroup} to update.\n   */\n  updateBindGroup(bindGroup: BindGroup) {\n    bindGroup.update()\n\n    // if a bind group needs to flush the pipeline\n    // usually happens if one of the struct bindingType has changed,\n    // which means the shader should be re-patched and recreated\n    if (bindGroup.needsPipelineFlush && this.pipelineEntry.ready) {\n      this.pipelineEntry.flushPipelineEntry(this.bindGroups)\n      bindGroup.needsPipelineFlush = false\n    }\n  }\n\n  /* INPUTS */\n\n  /**\n   * Look for a {@link BindGroupBindingElement | binding} by name in all {@link inputsBindings | input bindings}\n   * @param bindingName - the binding name or key\n   * @returns - the found binding, or null if not found\n   */\n  getBindingByName(bindingName: Binding['name'] = ''): BindGroupBindingElement | undefined {\n    return this.inputsBindings.get(bindingName)\n  }\n\n  /**\n   * Look for a {@link BindGroupBufferBindingElement | buffer binding} by name in all {@link inputsBindings | input bindings}\n   * @param bindingName - the binding name or key\n   * @returns - the found binding, or null if not found\n   */\n  getBufferBindingByName(bindingName: Binding['name'] = ''): BindGroupBufferBindingElement | undefined {\n    const bufferBinding = this.getBindingByName(bindingName)\n    return bufferBinding && 'buffer' in bufferBinding ? bufferBinding : undefined\n  }\n\n  /**\n   * Force setting a given {@link BufferBindingInput | buffer binding} shouldUpdate flag to `true` to update it at next render\n   * @param bufferBindingName - the buffer binding name\n   * @param bindingName - the binding name\n   */\n  shouldUpdateInputsBindings(bufferBindingName?: BufferBinding['name'], bindingName?: BufferBindingInput['name']) {\n    if (!bufferBindingName) return\n\n    const bufferBinding = this.getBindingByName(bufferBindingName)\n    if (bufferBinding) {\n      if (!bindingName) {\n        Object.keys((bufferBinding as BindGroupBufferBindingElement).inputs).forEach((bindingKey) =>\n          (bufferBinding as BindGroupBufferBindingElement).shouldUpdateBinding(bindingKey)\n        )\n      } else {\n        ;(bufferBinding as BindGroupBufferBindingElement).shouldUpdateBinding(bindingName)\n      }\n    }\n  }\n\n  /* SAMPLERS & TEXTURES */\n\n  /**\n   * Prepare our textures array and set the {@link TextureBindGroup}\n   */\n  setTextures() {\n    this.domTextures = []\n    this.textures = []\n    this.texturesBindGroups.push(\n      new TextureBindGroup(this.renderer, {\n        label: this.options.label + ': Textures bind group',\n      })\n    )\n\n    this.texturesBindGroup.consumers.add(this.uuid)\n\n    this.options.domTextures?.forEach((texture) => {\n      this.addTexture(texture)\n    })\n\n    this.options.textures?.forEach((texture) => {\n      this.addTexture(texture)\n    })\n  }\n\n  /**\n   * Add a texture to our array, and add it to the textures bind group only if used in the shaders (avoid binding useless data)\n   * @param texture - texture to add\n   */\n  addTexture(texture: DOMTexture | Texture) {\n    if (texture instanceof DOMTexture) {\n      this.domTextures.push(texture)\n    } else if (texture instanceof Texture) {\n      this.textures.push(texture)\n    }\n\n    // is it used in our shaders?\n    if (\n      (this.options.shaders.vertex && this.options.shaders.vertex.code.indexOf(texture.options.name) !== -1) ||\n      (this.options.shaders.fragment &&\n        (this.options.shaders.fragment as ShaderOptions).code.indexOf(texture.options.name) !== -1) ||\n      (this.options.shaders.compute && this.options.shaders.compute.code.indexOf(texture.options.name) !== -1)\n    ) {\n      this.texturesBindGroup.addTexture(texture)\n    }\n  }\n\n  /**\n   * Destroy a {@link DOMTexture} or {@link Texture}, only if it is not used by another object or cached.\n   * @param texture - {@link DOMTexture} or {@link Texture} to eventually destroy\n   */\n  destroyTexture(texture: DOMTexture | Texture) {\n    // do not destroy a texture that must stay in cache\n    if ((texture as DOMTexture).options.cache) return\n    if (!(texture as Texture).options.autoDestroy) return\n\n    // check if this texture is used by another object before actually destroying it\n    const objectsUsingTexture = this.renderer.getObjectsByTexture(texture)\n\n    const shouldDestroy =\n      !objectsUsingTexture || !objectsUsingTexture.some((object) => object.material.uuid !== this.uuid)\n\n    if (shouldDestroy) {\n      texture.destroy()\n    }\n  }\n\n  /**\n   * Destroy all the Material textures\n   */\n  destroyTextures() {\n    this.domTextures?.forEach((texture) => this.destroyTexture(texture))\n    this.textures?.forEach((texture) => this.destroyTexture(texture))\n    this.domTextures = []\n    this.textures = []\n  }\n\n  /**\n   * Prepare our samplers array and always add a default sampler if not already passed as parameter\n   */\n  setSamplers() {\n    this.samplers = []\n\n    this.options.samplers?.forEach((sampler) => {\n      this.addSampler(sampler)\n    })\n\n    // create our default sampler if needed\n    const hasDefaultSampler = this.samplers.find((sampler) => sampler.name === 'defaultSampler')\n    if (!hasDefaultSampler) {\n      const sampler = new Sampler(this.renderer, { label: 'Default sampler', name: 'defaultSampler' })\n      this.addSampler(sampler)\n    }\n  }\n\n  /**\n   * Add a sampler to our array, and add it to the textures bind group only if used in the shaders (avoid binding useless data)\n   * @param sampler - sampler to add\n   */\n  addSampler(sampler: Sampler) {\n    this.samplers.push(sampler)\n\n    // is it used in our shaders?\n    if (\n      (this.options.shaders.vertex && this.options.shaders.vertex.code.indexOf(sampler.name) !== -1) ||\n      (this.options.shaders.fragment &&\n        (this.options.shaders.fragment as ShaderOptions).code.indexOf(sampler.name) !== -1) ||\n      (this.options.shaders.compute && this.options.shaders.compute.code.indexOf(sampler.name) !== -1)\n    ) {\n      this.texturesBindGroup.addSampler(sampler)\n    }\n  }\n\n  /* BUFFER RESULTS */\n\n  /**\n   * Map a {@link Buffer#GPUBuffer | Buffer's GPU buffer} and put a copy of the data into a {@link Float32Array}\n   * @param buffer - {@link Buffer} to use for mapping\n   * @async\n   * @returns - {@link Float32Array} holding the {@link GPUBuffer} data\n   */\n  async getBufferResult(buffer: Buffer): Promise<Float32Array> {\n    return await buffer.mapBufferAsync()\n  }\n\n  /**\n   * Map the content of a {@link BufferBinding} {@link Buffer#GPUBuffer | GPU buffer} and put a copy of the data into a {@link Float32Array}\n   * @param bindingName - The name of the {@link inputsBindings | input bindings} from which to map the {@link Buffer#GPUBuffer | GPU buffer}\n   * @async\n   * @returns - {@link Float32Array} holding the {@link GPUBuffer} data\n   */\n  async getBufferBindingResultByBindingName(bindingName: Binding['name'] = ''): Promise<Float32Array> {\n    const binding = this.getBufferBindingByName(bindingName)\n    if (binding && 'buffer' in binding) {\n      const dstBuffer = this.renderer.copyBufferToBuffer({\n        srcBuffer: binding.buffer,\n      })\n\n      return await this.getBufferResult(dstBuffer)\n    } else {\n      return new Float32Array(0)\n    }\n  }\n\n  /**\n   * Map the content of a specific {@link BufferElement | buffer element} belonging to a {@link BufferBinding} {@link Buffer#GPUBuffer | GPU buffer} and put a copy of the data into a {@link Float32Array}\n   * @param parameters - parameters used to get the result\n   * @param parameters.bindingName - The name of the {@link inputsBindings | input bindings} from which to map the {@link Buffer#GPUBuffer | GPU buffer}\n   * @param parameters.bufferElementName - The name of the {@link BufferElement | buffer element} from which to extract the data afterwards\n   * @returns - {@link Float32Array} holding {@link GPUBuffer} data\n   */\n  async getBufferElementResultByNames({\n    bindingName,\n    bufferElementName,\n  }: {\n    bindingName: Binding['name']\n    bufferElementName: BufferElement['name']\n  }): Promise<Float32Array> {\n    const result = await this.getBufferBindingResultByBindingName(bindingName)\n\n    if (!bufferElementName || result.length) {\n      return result\n    } else {\n      const binding = this.getBufferBindingByName(bindingName)\n      if (binding) {\n        return binding.extractBufferElementDataFromBufferResult({ result, bufferElementName })\n      } else {\n        return result\n      }\n    }\n  }\n\n  /* RENDER */\n\n  /**\n   * Called before rendering the Material.\n   * First, check if we need to create our bind groups or pipeline\n   * Then render the {@link domTextures}\n   * Finally updates all the {@link bindGroups | bind groups}\n   */\n  onBeforeRender() {\n    // set our material if needed\n    this.compileMaterial()\n\n    // first what needs to be done for all textures\n    for (const texture of this.domTextures) {\n      texture.render()\n    }\n\n    // update bind groups\n    this.updateBindGroups()\n  }\n\n  /**\n   * Set the current pipeline\n   * @param pass - current pass encoder\n   */\n  setPipeline(pass: GPUPassTypes) {\n    this.renderer.pipelineManager.setCurrentPipeline(pass, this.pipelineEntry)\n  }\n\n  /**\n   * Use the {@link Renderer#pipelineManager | renderer pipelineManager} to only set the bind groups that are not already set.\n   * @param pass - current pass encoder\n   */\n  setActiveBindGroups(pass: GPUPassTypes) {\n    this.renderer.pipelineManager.setActiveBindGroups(pass, this.bindGroups)\n  }\n\n  /**\n   * Render the material if it is ready:\n   * Set the current pipeline and set the bind groups\n   * @param pass - current pass encoder\n   */\n  render(pass: GPUPassTypes) {\n    // renderer or pipeline are not ready yet\n    // not really needed since meshes/compute passes do already check it beforehand\n    // mostly here as a safeguard\n    if (!this.ready) return\n\n    // set current pipeline\n    this.setPipeline(pass)\n\n    // only set the bind groups that need to be set\n    this.setActiveBindGroups(pass)\n  }\n\n  /**\n   * Destroy the Material\n   */\n  destroy() {\n    // destroy all buffers created with createBuffer\n    this.destroyBindGroups()\n    this.destroyTextures()\n  }\n}\n","import { Material } from './Material'\r\nimport { ComputeMaterialOptions, ComputeMaterialParams, FullShadersType } from '../../types/Materials'\r\nimport { isRenderer, Renderer } from '../renderers/utils'\r\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\r\nimport { ComputePipelineEntry } from '../pipelines/ComputePipelineEntry'\r\nimport { WritableBufferBinding } from '../bindings/WritableBufferBinding'\r\n\r\n/**\r\n * Create a {@link Material} specifically built to run computations on the GPU. Internally used by {@link core/computePasses/ComputePass.ComputePass | ComputePass}.\r\n *\r\n * ## Compute pipeline\r\n *\r\n * A {@link ComputeMaterial} automatically creates a {@link ComputePipelineEntry}. Once all the {@link core/bindGroups/BindGroup.BindGroup | BindGroup} have been created, they are sent with the compute shader code to the {@link ComputePipelineEntry}, which is in turns responsible for creating the {@link GPUComputePipeline}.\r\n *\r\n * After the {@link GPUComputePipeline} has been successfully compiled, the {@link ComputeMaterial} is considered to be ready and it can start running the compute shader computations.\r\n *\r\n */\r\nexport class ComputeMaterial extends Material {\r\n  /** {@link ComputePipelineEntry | Compute pipeline entry} used by this {@link ComputeMaterial} */\r\n  pipelineEntry: ComputePipelineEntry\r\n  /** Options used to create this {@link ComputeMaterial} */\r\n  options: ComputeMaterialOptions\r\n\r\n  /** Default work group dispatch size to use with this {@link ComputeMaterial} */\r\n  dispatchSize?: number | number[]\r\n\r\n  /** function assigned to the {@link useCustomRender} callback */\r\n  _useCustomRenderCallback: (pass: GPUComputePassEncoder) => void\r\n\r\n  /**\r\n   * ComputeMaterial constructor\r\n   * @param renderer - our {@link Renderer} class object\r\n   * @param parameters - {@link ComputeMaterialParams | parameters} used to create our {@link ComputeMaterial}\r\n   */\r\n  constructor(renderer: Renderer | GPUCurtains, parameters: ComputeMaterialParams) {\r\n    const type = 'ComputeMaterial'\r\n\r\n    renderer = isRenderer(renderer, type)\r\n\r\n    super(renderer, parameters)\r\n\r\n    this.type = type\r\n    this.renderer = renderer\r\n\r\n    let { shaders, dispatchSize } = parameters\r\n\r\n    if (!shaders || !shaders.compute) {\r\n      shaders = {\r\n        compute: {\r\n          code: '',\r\n          entryPoint: 'main',\r\n        },\r\n      }\r\n    }\r\n\r\n    if (!shaders.compute.code) {\r\n      shaders.compute.code = '@compute @workgroup_size(1) fn main(){}'\r\n    }\r\n\r\n    if (!shaders.compute.entryPoint) {\r\n      shaders.compute.entryPoint = 'main'\r\n    }\r\n\r\n    this.options = {\r\n      ...this.options,\r\n      shaders,\r\n      ...(parameters.dispatchSize !== undefined && { dispatchSize: parameters.dispatchSize }),\r\n    }\r\n\r\n    // set default dispatch size\r\n    if (!dispatchSize) {\r\n      dispatchSize = 1\r\n    }\r\n\r\n    if (Array.isArray(dispatchSize)) {\r\n      dispatchSize[0] = Math.ceil(dispatchSize[0] ?? 1)\r\n      dispatchSize[1] = Math.ceil(dispatchSize[1] ?? 1)\r\n      dispatchSize[2] = Math.ceil(dispatchSize[2] ?? 1)\r\n    } else if (!isNaN(dispatchSize)) {\r\n      dispatchSize = [Math.ceil(dispatchSize), 1, 1]\r\n    }\r\n\r\n    this.dispatchSize = dispatchSize\r\n\r\n    // eager pipeline entry creation for compute materials\r\n    // since we do not use cache!\r\n    this.pipelineEntry = this.renderer.pipelineManager.createComputePipeline({\r\n      renderer: this.renderer,\r\n      label: this.options.label + ' compute pipeline',\r\n      shaders: this.options.shaders,\r\n      useAsync: this.options.useAsyncPipeline,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * When all bind groups are created, add them to the {@link ComputePipelineEntry}\r\n   */\r\n  setPipelineEntryProperties() {\r\n    this.pipelineEntry.setPipelineEntryProperties({\r\n      bindGroups: this.bindGroups,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Compile the {@link ComputePipelineEntry}\r\n   * @async\r\n   */\r\n  async compilePipelineEntry(): Promise<void> {\r\n    await this.pipelineEntry.compilePipelineEntry()\r\n  }\r\n\r\n  /**\r\n   * Check if all bind groups are ready, create them if needed, set {@link ComputePipelineEntry} bind group buffers and compile the pipeline\r\n   * @async\r\n   */\r\n  async compileMaterial(): Promise<void> {\r\n    if (this.ready) return\r\n\r\n    super.compileMaterial()\r\n\r\n    if (this.pipelineEntry && this.pipelineEntry.canCompile) {\r\n      this.setPipelineEntryProperties()\r\n      await this.compilePipelineEntry()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the complete code of a given shader including all the WGSL fragment code snippets added by the pipeline\r\n   * @param [shaderType=\"compute\"] - shader to get the code from\r\n   * @returns - The corresponding shader code\r\n   */\r\n  getShaderCode(shaderType: FullShadersType = 'compute'): string {\r\n    return super.getShaderCode(shaderType)\r\n  }\r\n\r\n  /**\r\n   * Get the added code of a given shader, i.e. all the WGSL fragment code snippets added by the pipeline\r\n   * @param [shaderType=\"compute\"] - shader to get the code from\r\n   * @returns - The corresponding shader code\r\n   */\r\n  getAddedShaderCode(shaderType: FullShadersType = 'compute'): string {\r\n    return super.getAddedShaderCode(shaderType)\r\n  }\r\n\r\n  /* RENDER */\r\n\r\n  /**\r\n   * If a custom render function has been defined instead of the default one, register the callback\r\n   * @param callback - callback to run instead of the default render behaviour, which is to set the {@link bindGroups | bind groups} and dispatch the work groups based on the {@link dispatchSize | default dispatch size}. This is where you will have to set all the {@link core/bindGroups/BindGroup.BindGroup | bind groups} and dispatch the workgroups by yourself.\r\n   */\r\n  useCustomRender(callback: (pass: GPUComputePassEncoder) => void) {\r\n    if (callback) {\r\n      this._useCustomRenderCallback = callback\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render the material if it is ready:\r\n   * Set the current pipeline, set the bind groups and dispatch the work groups\r\n   * @param pass - current compute pass encoder\r\n   */\r\n  render(pass: GPUComputePassEncoder) {\r\n    // renderer or pipeline are not ready yet\r\n    // not really needed since compute passes do already check it beforehand\r\n    // mostly here as a safeguard\r\n    if (!this.ready) return\r\n\r\n    // set current pipeline\r\n    this.setPipeline(pass)\r\n\r\n    // if we declared a custom render function, call it\r\n    if (this._useCustomRenderCallback !== undefined) {\r\n      this._useCustomRenderCallback(pass)\r\n    } else {\r\n      // else just set our bind groups and dispatch\r\n      for (const bindGroup of this.bindGroups) {\r\n        pass.setBindGroup(bindGroup.index, bindGroup.bindGroup)\r\n      }\r\n      //this.renderer.pipelineManager.setActiveBindGroups(pass, this.bindGroups)\r\n\r\n      pass.dispatchWorkgroups(this.dispatchSize[0], this.dispatchSize[1], this.dispatchSize[2])\r\n    }\r\n  }\r\n\r\n  /* RESULT BUFFER */\r\n\r\n  /**\r\n   * Copy all writable binding buffers that need it\r\n   * @param commandEncoder - current command encoder\r\n   */\r\n  copyBufferToResult(commandEncoder: GPUCommandEncoder) {\r\n    for (const bindGroup of this.bindGroups) {\r\n      bindGroup.bufferBindings.forEach((binding: WritableBufferBinding) => {\r\n        if (binding.shouldCopyResult) {\r\n          this.renderer.copyBufferToBuffer({\r\n            srcBuffer: binding.buffer,\r\n            dstBuffer: binding.resultBuffer,\r\n            commandEncoder,\r\n          })\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the {@link core/bindings/WritableBufferBinding.WritableBufferBinding#resultBuffer | result GPU buffer} content by {@link core/bindings/WritableBufferBinding.WritableBufferBinding | binding} and {@link core/bindings/bufferElements/BufferElement.BufferElement | buffer element} names\r\n   * @param parameters - parameters used to get the result\r\n   * @param parameters.bindingName - {@link core/bindings/WritableBufferBinding.WritableBufferBinding#name | binding name} from which to get the result\r\n   * @param parameters.bufferElementName - optional {@link core/bindings/bufferElements/BufferElement.BufferElement | buffer element} (i.e. struct member) name if the result needs to be restrained to only one element\r\n   * @async\r\n   * @returns - the mapped content of the {@link GPUBuffer} as a {@link Float32Array}\r\n   */\r\n  async getComputeResult({\r\n    bindingName = '',\r\n    bufferElementName = '',\r\n  }: {\r\n    bindingName?: string\r\n    bufferElementName?: string\r\n  }): Promise<Float32Array> {\r\n    const binding = this.getBufferBindingByName(bindingName)\r\n\r\n    if (binding && 'resultBuffer' in binding) {\r\n      const result = await this.getBufferResult(binding.resultBuffer)\r\n\r\n      if (bufferElementName && result.length) {\r\n        return binding.extractBufferElementDataFromBufferResult({ result, bufferElementName })\r\n      } else {\r\n        return result\r\n      }\r\n    } else {\r\n      return new Float32Array(0)\r\n    }\r\n  }\r\n}\r\n","import { isRenderer, Renderer } from '../renderers/utils'\nimport { generateUUID, throwWarning } from '../../utils/utils'\nimport { ComputeMaterial } from '../materials/ComputeMaterial'\nimport { ComputeMaterialParams, MaterialParams, MaterialShaders } from '../../types/Materials'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\nimport { Texture, TextureParams } from '../textures/Texture'\nimport { DOMTexture } from '../textures/DOMTexture'\nimport { ExternalTextureParams, DOMTextureParams } from '../../types/Textures'\n\n/** Defines {@link ComputePass} options */\nexport interface ComputePassOptions {\n  /** The label of the {@link ComputePass} */\n  label: string\n  /** Controls the order in which this {@link ComputePass} should be rendered by our {@link core/scenes/Scene.Scene | Scene} */\n  renderOrder?: number\n  /** Whether the {@link ComputePass} should be added to our {@link core/scenes/Scene.Scene | Scene} to let it handle the rendering process automatically */\n  autoRender?: boolean\n  /** Compute shader passed to the {@link ComputePass} following the {@link types/Materials.ShaderOptions | shader object} notation */\n  shaders: MaterialShaders\n  /** whether the {@link core/pipelines/ComputePipelineEntry.ComputePipelineEntry#pipeline | compute pipeline} should be compiled asynchronously */\n  useAsyncPipeline?: boolean\n  /** Parameters used by this {@link ComputePass} to create a {@link DOMTexture} */\n  texturesOptions?: ExternalTextureParams\n  /** Default {@link ComputeMaterial} work group dispatch size to use with this {@link ComputePass} */\n  dispatchSize?: number | number[]\n}\n\n/**\n * An object defining all possible {@link ComputePass} class instancing parameters\n */\nexport interface ComputePassParams extends Partial<ComputePassOptions>, MaterialParams {}\n\nlet computePassIndex = 0\n\n/**\n * Used to create a {@link ComputePass}, i.e. run computations on the GPU.<br>\n * A {@link ComputePass} is basically a wrapper around a {@link ComputeMaterial} that handles most of the process.\n *\n * The default render behaviour of a {@link ComputePass} is to set its {@link core/bindGroups/BindGroup.BindGroup | bind groups} and then dispatch the workgroups based on the provided {@link ComputeMaterial#dispatchSize | dispatchSize}.<br>\n * However, most of the time you'd want a slightly more complex behaviour. The {@link ComputePass#useCustomRender | `useCustomRender` hook} lets you define a totally custom behaviour, but you'll have to set all the {@link core/bindGroups/BindGroup.BindGroup | bind groups} and dispatch the workgroups by yourself.\n *\n * @example\n * ```javascript\n * // set our main GPUCurtains instance\n * const gpuCurtains = new GPUCurtains({\n *   container: '#canvas' // selector of our WebGPU canvas container\n * })\n *\n * // set the GPU device\n * // note this is asynchronous\n * await gpuCurtains.setDevice()\n *\n * // let's assume we are going to compute the positions of 100.000 particles\n * const nbParticles = 100_000\n *\n * const computePass = new ComputePass(gpuCurtains, {\n *   label: 'My compute pass',\n *   shaders: {\n *     compute: {\n *       code: computeShaderCode, // assume it is a valid WGSL compute shader\n *     },\n *   },\n *   dispatchSize: Math.ceil(nbParticles / 64),\n *   storages: {\n *     particles: {\n *       access: 'read_write',\n *       struct: {\n *         position: {\n *           type: 'array<vec4f>',\n *           value: new Float32Array(nbParticles * 4),\n *         },\n *       },\n *     },\n *   },\n * })\n * ```\n */\nexport class ComputePass {\n  /** The type of the {@link ComputePass} */\n  type: string\n  /** The universal unique id of the {@link ComputePass} */\n  uuid: string\n  /** The index of the {@link ComputePass}, incremented each time a new one is instanced */\n  index: number\n  /** The {@link Renderer} used */\n  renderer: Renderer\n  /** Controls the order in which this {@link ComputePass} should be rendered by our {@link core/scenes/Scene.Scene | Scene} */\n  renderOrder: number\n\n  /** Options used to create this {@link ComputePass} */\n  options: ComputePassOptions\n\n  /** {@link ComputeMaterial} used by this {@link ComputePass} */\n  material: ComputeMaterial\n\n  /** Flag indicating whether this {@link ComputePass} is ready to be rendered */\n  _ready: boolean\n\n  /** Empty object to store any additional data or custom properties into your {@link ComputePass} */\n  userData: Record<string, unknown>\n\n  /**\n   * Whether this {@link ComputePass} should be added to our {@link core/scenes/Scene.Scene | Scene} to let it handle the rendering process automatically\n   * @private\n   */\n  #autoRender = true\n\n  // callbacks / events\n  /** function assigned to the {@link onReady} callback */\n  _onReadyCallback: () => void = () => {\n    /* allow empty callback */\n  }\n  /** function assigned to the {@link onBeforeRender} callback */\n  _onBeforeRenderCallback: () => void = () => {\n    /* allow empty callback */\n  }\n  /** function assigned to the {@link onRender} callback */\n  _onRenderCallback: () => void = () => {\n    /* allow empty callback */\n  }\n  /** function assigned to the {@link onAfterRender} callback */\n  _onAfterRenderCallback: () => void = () => {\n    /* allow empty callback */\n  }\n  /** function assigned to the {@link onAfterResize} callback */\n  _onAfterResizeCallback: () => void = () => {\n    /* allow empty callback */\n  }\n\n  /**\n   * ComputePass constructor\n   * @param renderer - a {@link Renderer} class object or a {@link GPUCurtains} class object\n   * @param parameters - {@link ComputePassParams | parameters} used to create our {@link ComputePass}\n   */\n  constructor(renderer: Renderer | GPUCurtains, parameters: ComputePassParams = {}) {\n    const type = 'ComputePass'\n\n    renderer = isRenderer(renderer, parameters.label ? `${parameters.label} ${type}` : type)\n\n    parameters.label = parameters.label ?? 'ComputePass ' + renderer.computePasses?.length\n\n    this.renderer = renderer\n    this.type = type\n    this.uuid = generateUUID()\n    Object.defineProperty(this as ComputePass, 'index', { value: computePassIndex++ })\n\n    const {\n      label,\n      shaders,\n      renderOrder,\n      uniforms,\n      storages,\n      bindGroups,\n      samplers,\n      domTextures,\n      textures,\n      autoRender,\n      useAsyncPipeline,\n      texturesOptions,\n      dispatchSize,\n    } = parameters\n\n    this.options = {\n      label,\n      shaders,\n      ...(autoRender !== undefined && { autoRender }),\n      ...(renderOrder !== undefined && { renderOrder }),\n      ...(dispatchSize !== undefined && { dispatchSize }),\n      useAsyncPipeline: useAsyncPipeline === undefined ? true : useAsyncPipeline,\n      texturesOptions, // TODO default\n    }\n\n    this.renderOrder = renderOrder ?? 0\n\n    if (autoRender !== undefined) {\n      this.#autoRender = autoRender\n    }\n\n    this.userData = {}\n\n    this.ready = false\n\n    this.setMaterial({\n      label: this.options.label,\n      shaders: this.options.shaders,\n      uniforms,\n      storages,\n      bindGroups,\n      samplers,\n      textures,\n      domTextures,\n      useAsyncPipeline,\n      dispatchSize,\n    })\n\n    this.addToScene(true)\n  }\n\n  /**\n   * Get or set whether the compute pass is ready to render (the material has been successfully compiled)\n   * @readonly\n   */\n  get ready(): boolean {\n    return this._ready\n  }\n\n  set ready(value: boolean) {\n    if (value) {\n      this._onReadyCallback && this._onReadyCallback()\n    }\n    this._ready = value\n  }\n\n  /**\n   * Add our {@link ComputePass} to the scene and optionally to the renderer.\n   * @param addToRenderer - whether to add this {@link ComputePass} to the {@link Renderer#computePasses | Renderer computePasses array}\n   */\n  addToScene(addToRenderer = false) {\n    if (addToRenderer) {\n      this.renderer.computePasses.push(this)\n    }\n\n    if (this.#autoRender) {\n      this.renderer.scene.addComputePass(this)\n    }\n  }\n\n  /**\n   * Remove our {@link ComputePass} from the scene and optionally from the renderer as well.\n   * @param removeFromRenderer - whether to remove this {@link ComputePass} from the {@link Renderer#computePasses | Renderer computePasses array}.\n   */\n  removeFromScene(removeFromRenderer = false) {\n    if (this.#autoRender) {\n      this.renderer.scene.removeComputePass(this)\n    }\n\n    if (removeFromRenderer) {\n      this.renderer.computePasses = this.renderer.computePasses.filter((computePass) => computePass.uuid !== this.uuid)\n    }\n  }\n\n  /**\n   * Set a new {@link Renderer} for this {@link ComputePass}.\n   * @param renderer - new {@link Renderer} to set.\n   */\n  setRenderer(renderer: Renderer | GPUCurtains) {\n    // we could pass our curtains object OR our curtains renderer object\n    renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as Renderer)\n\n    if (\n      !renderer ||\n      !(\n        renderer.type === 'GPURenderer' ||\n        renderer.type === 'GPUCameraRenderer' ||\n        renderer.type === 'GPUCurtainsRenderer'\n      )\n    ) {\n      throwWarning(\n        `${this.options.label}: Cannot set ${renderer} as a renderer because it is not of a valid Renderer type.`\n      )\n      return\n    }\n\n    this.material?.setRenderer(renderer)\n\n    this.removeFromScene(true)\n    this.renderer = renderer\n    this.addToScene(true)\n  }\n\n  /**\n   * Create the compute pass material\n   * @param computeParameters - {@link ComputeMaterial} parameters\n   */\n  setMaterial(computeParameters: ComputeMaterialParams) {\n    this.useMaterial(new ComputeMaterial(this.renderer, computeParameters))\n  }\n\n  /**\n   * Set or update the {@link ComputePass} {@link ComputeMaterial}\n   * @param material - new {@link ComputeMaterial} to use\n   */\n  useMaterial(material: ComputeMaterial) {\n    this.material = material\n  }\n\n  /**\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been lost to prepare everything for restoration.\n   * Basically set all the {@link GPUBuffer} to null so they will be reset next time we try to render\n   */\n  loseContext() {\n    this.material.loseContext()\n  }\n\n  /**\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been restored\n   */\n  restoreContext() {\n    this.material.restoreContext()\n  }\n\n  /* TEXTURES */\n\n  /**\n   * Get our {@link ComputeMaterial#domTextures | ComputeMaterial domTextures array}\n   * @readonly\n   */\n  get domTextures(): DOMTexture[] {\n    return this.material?.domTextures || []\n  }\n\n  /**\n   * Get our {@link ComputeMaterial#textures | ComputeMaterial textures array}\n   * @readonly\n   */\n  get textures(): Texture[] {\n    return this.material?.textures || []\n  }\n\n  /**\n   * Create a new {@link DOMTexture}\n   * @param options - {@link DOMTextureParams | DOMTexture parameters}\n   * @returns - newly created {@link DOMTexture}\n   */\n  createDOMTexture(options: DOMTextureParams): DOMTexture {\n    if (!options.name) {\n      options.name = 'texture' + (this.textures.length + this.domTextures.length)\n    }\n\n    if (!options.label) {\n      options.label = this.options.label + ' ' + options.name\n    }\n\n    const domTexture = new DOMTexture(this.renderer, { ...options, ...this.options.texturesOptions })\n\n    this.addTexture(domTexture)\n\n    return domTexture\n  }\n\n  /**\n   * Create a new {@link Texture}\n   * @param  options - {@link TextureParams | Texture parameters}\n   * @returns - newly created {@link Texture}\n   */\n  createTexture(options: TextureParams): Texture {\n    if (!options.name) {\n      options.name = 'texture' + (this.textures.length + this.domTextures.length)\n    }\n\n    const texture = new Texture(this.renderer, options)\n\n    this.addTexture(texture)\n\n    return texture\n  }\n\n  /**\n   * Add a {@link Texture} or {@link DOMTexture}\n   * @param texture - {@link Texture} to add\n   */\n  addTexture(texture: Texture | DOMTexture) {\n    this.material.addTexture(texture)\n  }\n\n  /**\n   * Get our {@link ComputeMaterial#uniforms | ComputeMaterial uniforms}\n   * @readonly\n   */\n  get uniforms(): ComputeMaterial['uniforms'] {\n    return this.material?.uniforms\n  }\n\n  /**\n   * Get our {@link ComputeMaterial#storages | ComputeMaterial storages}\n   * @readonly\n   */\n  get storages(): ComputeMaterial['storages'] {\n    return this.material?.storages\n  }\n\n  /**\n   * Called from the renderer, useful to trigger an after resize callback.\n   */\n  resize() {\n    this._onAfterResizeCallback && this._onAfterResizeCallback()\n  }\n\n  /** EVENTS **/\n\n  /**\n   * Callback to run when the {@link ComputePass} is ready\n   * @param callback - callback to run when {@link ComputePass} is ready\n   */\n  onReady(callback: () => void): ComputePass {\n    if (callback) {\n      this._onReadyCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Callback to run before the {@link ComputePass} is rendered\n   * @param callback - callback to run just before {@link ComputePass} will be rendered\n   */\n  onBeforeRender(callback: () => void): ComputePass {\n    if (callback) {\n      this._onBeforeRenderCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Callback to run when the {@link ComputePass} is rendered\n   * @param callback - callback to run when {@link ComputePass} is rendered\n   */\n  onRender(callback: () => void): ComputePass {\n    if (callback) {\n      this._onRenderCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Callback to run after the {@link ComputePass} has been rendered\n   * @param callback - callback to run just after {@link ComputePass} has been rendered\n   */\n  onAfterRender(callback: () => void): ComputePass {\n    if (callback) {\n      this._onAfterRenderCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Callback used to run a custom render function instead of the default one.\n   * @param callback - Your custom render function where you will have to set all the {@link core/bindGroups/BindGroup.BindGroup | bind groups} and dispatch the workgroups by yourself.\n   */\n  useCustomRender(callback: (pass: GPUComputePassEncoder) => void): ComputePass {\n    this.material.useCustomRender(callback)\n    return this\n  }\n\n  /**\n   * Callback to run after the {@link core/renderers/GPURenderer.GPURenderer | renderer} has been resized\n   * @param callback - callback to run just after {@link core/renderers/GPURenderer.GPURenderer | renderer} has been resized\n   */\n  onAfterResize(callback: () => void): ComputePass {\n    if (callback) {\n      this._onAfterResizeCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Called before rendering the ComputePass\n   * Checks if the material is ready and eventually update its struct\n   */\n  onBeforeRenderPass() {\n    if (!this.renderer.ready) return\n\n    if (this.material && this.material.ready && !this.ready) {\n      this.ready = true\n    }\n\n    this._onBeforeRenderCallback && this._onBeforeRenderCallback()\n\n    this.material.onBeforeRender()\n  }\n\n  /**\n   * Render our {@link ComputeMaterial}\n   * @param pass - current compute pass encoder\n   */\n  onRenderPass(pass: GPUComputePassEncoder) {\n    if (!this.material.ready) return\n\n    this._onRenderCallback && this._onRenderCallback()\n\n    this.material.render(pass)\n  }\n\n  /**\n   * Called after having rendered the ComputePass\n   */\n  onAfterRenderPass() {\n    this._onAfterRenderCallback && this._onAfterRenderCallback()\n  }\n\n  /**\n   * Render our compute pass\n   * Basically just check if our {@link core/renderers/GPURenderer.GPURenderer | renderer} is ready, and then render our {@link ComputeMaterial}\n   * @param pass\n   */\n  render(pass: GPUComputePassEncoder) {\n    this.onBeforeRenderPass()\n\n    // no point to render if the WebGPU device is not ready\n    if (!this.renderer.ready) return\n\n    !this.renderer.production && pass.pushDebugGroup(this.options.label)\n\n    this.onRenderPass(pass)\n\n    !this.renderer.production && pass.popDebugGroup()\n\n    this.onAfterRenderPass()\n  }\n\n  /**\n   * Copy the result of our read/write GPUBuffer into our result binding array\n   * @param commandEncoder - current GPU command encoder\n   */\n  copyBufferToResult(commandEncoder: GPUCommandEncoder) {\n    this.material?.copyBufferToResult(commandEncoder)\n  }\n\n  /**\n   * Get the {@link core/bindings/WritableBufferBinding.WritableBufferBinding#resultBuffer | result GPU buffer} content by {@link core/bindings/WritableBufferBinding.WritableBufferBinding | binding} and {@link core/bindings/bufferElements/BufferElement.BufferElement | buffer element} names\n   * @param parameters - parameters used to get the result\n   * @param parameters.bindingName - {@link core/bindings/WritableBufferBinding.WritableBufferBinding#name | binding name} from which to get the result\n   * @param parameters.bufferElementName - optional {@link core/bindings/bufferElements/BufferElement.BufferElement | buffer element} (i.e. struct member) name if the result needs to be restrained to only one element\n   * @async\n   * @returns - the mapped content of the {@link GPUBuffer} as a {@link Float32Array}\n   */\n  async getComputeResult({\n    bindingName,\n    bufferElementName,\n  }: {\n    bindingName?: string\n    bufferElementName?: string\n  }): Promise<Float32Array> {\n    return await this.material?.getComputeResult({ bindingName, bufferElementName })\n  }\n\n  /**\n   * Remove the ComputePass from the scene and destroy it\n   */\n  remove() {\n    this.removeFromScene(true)\n    this.destroy()\n  }\n\n  /**\n   * Destroy the ComputePass\n   */\n  destroy() {\n    this.material?.destroy()\n  }\n}\n","import { Vec3 } from './Vec3'\r\nimport { Mat4 } from './Mat4'\r\n\r\n// declare our corners once should be enough\r\nconst points: Vec3[] = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()]\r\n\r\n/**\r\n * Used to handle bounding boxes in 3D space.\r\n * Basically made of two min and max {@link Vec3 | vectors} that represents the edges of the 3D bounding box.\r\n */\r\nexport class Box3 {\r\n  /** Min {@link Vec3 | vector} of the {@link Box3} */\r\n  min: Vec3\r\n  /** Max {@link Vec3 | vector} of the {@link Box3} */\r\n  max: Vec3\r\n\r\n  /**\r\n   * Box3 constructor\r\n   * @param min - min {@link Vec3 | vector} of the {@link Box3}\r\n   * @param max - max {@link Vec3 | vector} of the {@link Box3}\r\n   */\r\n  constructor(min: Vec3 = new Vec3(Infinity), max: Vec3 = new Vec3(-Infinity)) {\r\n    this.min = min\r\n    this.max = max\r\n  }\r\n\r\n  /**\r\n   * Set a {@link Box3} from two min and max {@link Vec3 | vectors}\r\n   * @param min - min {@link Vec3 | vector} of the {@link Box3}\r\n   * @param max - max {@link Vec3 | vector} of the {@link Box3}\r\n   */\r\n  set(min: Vec3 = new Vec3(Infinity), max: Vec3 = new Vec3(-Infinity)): Box3 {\r\n    this.min.copy(min)\r\n    this.max.copy(max)\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Check whether the {@link Box3} min and max values have actually been set\r\n   */\r\n  isEmpty() {\r\n    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z\r\n  }\r\n\r\n  /**\r\n   * Copy a {@link Box3} into this {@link Box3}.\r\n   * @param box - {@link Box3} to copy\r\n   */\r\n  copy(box: Box3): Box3 {\r\n    this.set(box.min.clone(), box.max.clone())\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Clone this {@link Box3}\r\n   * @returns - cloned {@link Box3}\r\n   */\r\n  clone(): Box3 {\r\n    return new Box3().copy(this)\r\n  }\r\n\r\n  /**\r\n   * Get the {@link Box3} center\r\n   * @readonly\r\n   * @returns - {@link Vec3 | center vector} of the {@link Box3}\r\n   */\r\n  get center(): Vec3 {\r\n    return this.max.clone().add(this.min).multiplyScalar(0.5)\r\n  }\r\n\r\n  /**\r\n   * Get the {@link Box3} size\r\n   * @readonly\r\n   * @returns - {@link Vec3 | size vector} of the {@link Box3}\r\n   */\r\n  get size(): Vec3 {\r\n    return this.max.clone().sub(this.min)\r\n  }\r\n\r\n  /**\r\n   * Get the {@link Box3} radius\r\n   * @readonly\r\n   * @returns - radius of the {@link Box3}\r\n   */\r\n  get radius(): number {\r\n    return this.max.distance(this.min) * 0.5\r\n  }\r\n\r\n  /**\r\n   * Apply a {@link Mat4 | matrix} to a {@link Box3}\r\n   * Useful to apply a transformation {@link Mat4 | matrix} to a {@link Box3}\r\n   * @param matrix - {@link Mat4 | matrix} to use\r\n   * @param transformedBox - {@link Box3 | transformed Box3} to set\r\n   * @returns - the {@link Box3 | transformed Box3} after {@link Mat4 | matrix} application\r\n   */\r\n  applyMat4(matrix: Mat4 = new Mat4(), transformedBox = new Box3()): Box3 {\r\n    if (this.isEmpty()) return this\r\n\r\n    const corners: Vec3[] = []\r\n\r\n    // remember we're essentially dealing with plane geometries\r\n    // so if min Z and max Z are equals, it's actually a plane geometry\r\n    // just apply the matrix to its four corners\r\n    if (this.min.z === this.max.z) {\r\n      corners[0] = points[0].set(this.min.x, this.min.y, this.min.z).applyMat4(matrix)\r\n      corners[1] = points[2].set(this.min.x, this.max.y, this.min.z).applyMat4(matrix)\r\n      corners[2] = points[4].set(this.max.x, this.min.y, this.min.z).applyMat4(matrix)\r\n      corners[3] = points[6].set(this.max.x, this.max.y, this.min.z).applyMat4(matrix)\r\n    } else {\r\n      corners[0] = points[0].set(this.min.x, this.min.y, this.min.z).applyMat4(matrix)\r\n      corners[1] = points[1].set(this.min.x, this.min.y, this.max.z).applyMat4(matrix)\r\n      corners[2] = points[2].set(this.min.x, this.max.y, this.min.z).applyMat4(matrix)\r\n      corners[3] = points[3].set(this.min.x, this.max.y, this.max.z).applyMat4(matrix)\r\n      corners[4] = points[4].set(this.max.x, this.min.y, this.min.z).applyMat4(matrix)\r\n      corners[5] = points[5].set(this.max.x, this.min.y, this.max.z).applyMat4(matrix)\r\n      corners[6] = points[6].set(this.max.x, this.max.y, this.min.z).applyMat4(matrix)\r\n      corners[7] = points[7].set(this.max.x, this.max.y, this.max.z).applyMat4(matrix)\r\n    }\r\n\r\n    for (let i = 0, cornersCount = corners.length; i < cornersCount; i++) {\r\n      transformedBox.min.min(corners[i])\r\n      transformedBox.max.max(corners[i])\r\n    }\r\n\r\n    return transformedBox\r\n  }\r\n}\r\n","import { Box3 } from '../../math/Box3'\r\nimport { Mat4 } from '../../math/Mat4'\r\nimport { DOMElementBoundingRect, RectBBox, RectCoords } from './DOMElement'\r\nimport { Vec3 } from '../../math/Vec3'\r\n\r\n/**\r\n * An object defining all possible {@link DOMFrustum} class instancing parameters\r\n */\r\nexport interface DOMFrustumParams {\r\n  /** our 3D Object bounding box, i.e. size in world space before any transform. Usually defined by a {@link core/geometries/Geometry.Geometry | Geometry} */\r\n  boundingBox?: Box3\r\n  /** {@link core/objects3D/ProjectedObject3D.ProjectedObject3D#modelViewProjectionMatrix | model view projection matrix} to use for frustum calculations */\r\n  modelViewProjectionMatrix?: Mat4\r\n  /** the {@link DOMElementBoundingRect | bounding rectangle} to check against */\r\n  containerBoundingRect?: DOMElementBoundingRect\r\n  /** additional margins to add to {@link containerBoundingRect} */\r\n  DOMFrustumMargins?: RectCoords\r\n  /** callback to run when the {@link DOMFrustum#projectedBoundingRect | projectedBoundingRect} reenters the view frustum */\r\n  onReEnterView?: () => void\r\n  /** callback to run when the {@link DOMFrustum#projectedBoundingRect | projectedBoundingRect} leaves the view frustum */\r\n  onLeaveView?: () => void\r\n}\r\n\r\n/** @constant {RectCoords} - default {@link DOMFrustum#DOMFrustumMargins | DOMFrustumMargins} */\r\nconst defaultDOMFrustumMargins: RectCoords = {\r\n  top: 0,\r\n  right: 0,\r\n  bottom: 0,\r\n  left: 0,\r\n}\r\n\r\n/**\r\n * Used to check if a {@link core/objects3D/ProjectedObject3D.ProjectedObject3D | ProjectedObject3D} is currently contained inside a DOM bounding rectangle.\r\n *\r\n * Uses a {@link core/objects3D/ProjectedObject3D.ProjectedObject3D#modelViewProjectionMatrix | model view projection matrix} that contains both useful {@link core/objects3D/ProjectedObject3D.ProjectedObject3D#transforms | Object3D transforms} and {@link core/camera/Camera.Camera | Camera} projection information.\r\n * The DOM bounding rectangle to check against usually is the {@link core/renderers/GPURenderer.GPURenderer | renderer}'s {@link core/DOM/DOMElement.DOMElement | DOMElement} bounding rectangle, unless frustum margins are specified.\r\n */\r\nexport class DOMFrustum {\r\n  /** Our 3D Object bounding box, i.e. size in world space before any transform. Usually defined by a {@link core/geometries/Geometry.Geometry | Geometry} */\r\n  boundingBox: Box3\r\n\r\n  /** Oriented bounding {@link Box3} in clip space. */\r\n  clipSpaceOBB: Box3\r\n\r\n  /** A model view projection matrix defining transformations, usually from a {@link core/objects3D/ProjectedObject3D.ProjectedObject3D | ProjectedObject3D}, to use for frustum calculations */\r\n  modelViewProjectionMatrix: Mat4\r\n\r\n  /** The DOM bounding rectangle to check against, usually the renderer DOM Element bounding rectangle */\r\n  containerBoundingRect: DOMElementBoundingRect\r\n  /** Additional margins to add to {@link containerBoundingRect} */\r\n  DOMFrustumMargins: RectCoords\r\n  /** Computed {@link RectBBox | rectangle} in clip space/normalized device coordinates. */\r\n  clipSpaceBoundingRect: RectBBox\r\n  /** A DOM Element bounding rectangle representing the result of our {@link boundingBox} with the {@link modelViewProjectionMatrix} applied */\r\n  projectedBoundingRect: DOMElementBoundingRect\r\n\r\n  /** Callback to run when the {@link projectedBoundingRect} reenters the view frustum */\r\n  onReEnterView: () => void\r\n  /** Callback to run when the {@link projectedBoundingRect} leaves the view frustum */\r\n  onLeaveView: () => void\r\n\r\n  /** Flag to indicate whether the given {@link projectedBoundingRect} is intersecting our view frustum */\r\n  isIntersecting: boolean\r\n\r\n  /**\r\n   * DOMFrustum constructor\r\n   * @param {DOMFrustumParams} parameters - {@link DOMFrustumParams | parameters} used to create our {@link DOMFrustum}\r\n   */\r\n  constructor({\r\n    boundingBox = new Box3(),\r\n    modelViewProjectionMatrix = new Mat4(),\r\n    containerBoundingRect = {\r\n      top: 0,\r\n      right: 0,\r\n      bottom: 0,\r\n      left: 0,\r\n      width: 0,\r\n      height: 0,\r\n      x: 0,\r\n      y: 0,\r\n    },\r\n    DOMFrustumMargins = defaultDOMFrustumMargins,\r\n    onReEnterView = () => {\r\n      /* allow empty callbacks */\r\n    },\r\n    onLeaveView = () => {\r\n      /* allow empty callbacks */\r\n    },\r\n  }: DOMFrustumParams) {\r\n    this.boundingBox = boundingBox\r\n    this.clipSpaceOBB = new Box3()\r\n    this.modelViewProjectionMatrix = modelViewProjectionMatrix\r\n    this.containerBoundingRect = containerBoundingRect\r\n    this.DOMFrustumMargins = { ...defaultDOMFrustumMargins, ...DOMFrustumMargins }\r\n\r\n    this.clipSpaceBoundingRect = {\r\n      top: 0,\r\n      left: 0,\r\n      width: 0,\r\n      height: 0,\r\n    }\r\n\r\n    this.projectedBoundingRect = {\r\n      top: 0,\r\n      right: 0,\r\n      bottom: 0,\r\n      left: 0,\r\n      width: 0,\r\n      height: 0,\r\n      x: 0,\r\n      y: 0,\r\n    }\r\n\r\n    this.onReEnterView = onReEnterView\r\n    this.onLeaveView = onLeaveView\r\n\r\n    this.isIntersecting = false\r\n  }\r\n\r\n  /**\r\n   * Set our {@link containerBoundingRect} (called on resize)\r\n   * @param boundingRect - new bounding rectangle\r\n   */\r\n  setContainerBoundingRect(boundingRect: DOMElementBoundingRect) {\r\n    this.containerBoundingRect = boundingRect\r\n  }\r\n\r\n  /**\r\n   * Get our DOM frustum bounding rectangle, i.e. our {@link containerBoundingRect} with the {@link DOMFrustumMargins} applied\r\n   * @readonly\r\n   */\r\n  get DOMFrustumBoundingRect(): RectCoords {\r\n    return {\r\n      top: this.projectedBoundingRect.top - this.DOMFrustumMargins.top,\r\n      right: this.projectedBoundingRect.right + this.DOMFrustumMargins.right,\r\n      bottom: this.projectedBoundingRect.bottom + this.DOMFrustumMargins.bottom,\r\n      left: this.projectedBoundingRect.left - this.DOMFrustumMargins.left,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compute the oriented bounding box in clip space.\r\n   */\r\n  computeClipSpaceOBB() {\r\n    // reset\r\n    this.clipSpaceOBB.set()\r\n    this.boundingBox.applyMat4(this.modelViewProjectionMatrix, this.clipSpaceOBB)\r\n  }\r\n\r\n  /**\r\n   * Applies all {@link modelViewProjectionMatrix} transformations to our {@link boundingBox}, i.e. apply OBB to document coordinates and set {@link projectedBoundingRect}.\r\n   */\r\n  setDocumentCoordsFromClipSpaceOBB() {\r\n    this.computeClipSpaceOBB()\r\n\r\n    this.clipSpaceBoundingRect = {\r\n      top: this.clipSpaceOBB.max.y,\r\n      left: this.clipSpaceOBB.min.x,\r\n      width: this.clipSpaceOBB.max.x - this.clipSpaceOBB.min.x,\r\n      height: this.clipSpaceOBB.max.y - this.clipSpaceOBB.min.y,\r\n    }\r\n\r\n    // normalize [-1, 1] coords to [0, 1]\r\n    const minX = (this.clipSpaceOBB.min.x + 1) * 0.5\r\n    const maxX = (this.clipSpaceOBB.max.x + 1) * 0.5\r\n\r\n    const minY = 1 - (this.clipSpaceOBB.min.y + 1) * 0.5\r\n    const maxY = 1 - (this.clipSpaceOBB.max.y + 1) * 0.5\r\n\r\n    const { width, height, top, left } = this.containerBoundingRect\r\n\r\n    this.projectedBoundingRect = {\r\n      left: minX * width + left,\r\n      x: minX * width + left,\r\n      top: maxY * height + top,\r\n      y: maxY * height + top,\r\n      right: maxX * width + left,\r\n      bottom: minY * height + top,\r\n      width: maxX * width + left - (minX * width + left),\r\n      height: minY * height + top - (maxY * height + top),\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply the bounding sphere in clip space to document coordinates and set {@link projectedBoundingRect}.\r\n   * @param boundingSphere - bounding sphere in clip space.\r\n   */\r\n  setDocumentCoordsFromClipSpaceSphere(\r\n    boundingSphere: { center: Vec3; radius: number } = { center: new Vec3(), radius: 0 }\r\n  ) {\r\n    this.clipSpaceBoundingRect = {\r\n      top: boundingSphere.center.y + boundingSphere.radius,\r\n      left: boundingSphere.center.x - boundingSphere.radius,\r\n      width: boundingSphere.radius * 2,\r\n      height: boundingSphere.radius * 2,\r\n    }\r\n\r\n    // normalize [-1, 1] coords to [0, 1]\r\n    const centerX = (boundingSphere.center.x + 1) * 0.5\r\n    const centerY = 1 - (boundingSphere.center.y + 1) * 0.5\r\n\r\n    const { width, height, top, left } = this.containerBoundingRect\r\n\r\n    this.projectedBoundingRect.width = boundingSphere.radius * height\r\n    this.projectedBoundingRect.height = boundingSphere.radius * height\r\n\r\n    this.projectedBoundingRect.left = centerX * width + left - this.projectedBoundingRect.width * 0.5\r\n    this.projectedBoundingRect.x = this.projectedBoundingRect.left\r\n    this.projectedBoundingRect.top = centerY * height + top - this.projectedBoundingRect.height * 0.5\r\n    this.projectedBoundingRect.y = this.projectedBoundingRect.top\r\n\r\n    this.projectedBoundingRect.right = this.projectedBoundingRect.left + this.projectedBoundingRect.width\r\n    this.projectedBoundingRect.bottom = this.projectedBoundingRect.top + this.projectedBoundingRect.height\r\n  }\r\n\r\n  /**\r\n   * Check whether our {@link projectedBoundingRect} intersects with our {@link DOMFrustumBoundingRect}.\r\n   */\r\n  intersectsContainer() {\r\n    if (\r\n      Math.round(this.DOMFrustumBoundingRect.right) <= this.containerBoundingRect.left ||\r\n      Math.round(this.DOMFrustumBoundingRect.left) >=\r\n        this.containerBoundingRect.left + this.containerBoundingRect.width ||\r\n      Math.round(this.DOMFrustumBoundingRect.bottom) <= this.containerBoundingRect.top ||\r\n      Math.round(this.DOMFrustumBoundingRect.top) >= this.containerBoundingRect.top + this.containerBoundingRect.height\r\n    ) {\r\n      if (this.isIntersecting) {\r\n        this.onLeaveView()\r\n      }\r\n\r\n      this.isIntersecting = false\r\n    } else {\r\n      if (!this.isIntersecting) {\r\n        this.onReEnterView()\r\n      }\r\n\r\n      this.isIntersecting = true\r\n    }\r\n  }\r\n}\r\n","import { Box3 } from '../../math/Box3'\r\nimport { generateUUID, throwError, throwWarning } from '../../utils/utils'\r\nimport {\r\n  GeometryBuffer,\r\n  GeometryOptions,\r\n  GeometryParams,\r\n  VertexBuffer,\r\n  VertexBufferAttribute,\r\n  VertexBufferAttributeParams,\r\n  VertexBufferParams,\r\n} from '../../types/Geometries'\r\nimport { Buffer } from '../buffers/Buffer'\r\nimport { Renderer } from '../renderers/utils'\r\nimport { TypedArrayConstructor } from '../bindings/utils'\r\nimport { GPURenderPassTypes } from '../pipelines/PipelineManager'\r\n\r\n/**\r\n * Used to create a {@link Geometry} from given parameters like instances count or geometry attributes (vertices, uvs, normals).<br>\r\n * Holds all attributes arrays, bounding box and create as WGSL code snippet for the vertex shader input attributes.\r\n *\r\n * During the {@link Geometry#render | render}, the {@link Geometry} is responsible for setting the {@link Geometry#vertexBuffers | vertexBuffers} and drawing the vertices.\r\n *\r\n * @example\r\n * ```javascript\r\n * const vertices = new Float32Array([\r\n *   // first triangle\r\n *    1,  1,  0,\r\n *    1, -1,  0,\r\n *   -1, -1,  0,\r\n *\r\n *   // second triangle\r\n *    1,  1,  0,\r\n *   -1, -1,  0,\r\n *   -1,  1,  0\r\n * ])\r\n *\r\n * // create a quad geometry made of 2 triangles\r\n * const geometry = new Geometry()\r\n *\r\n * geometry.setAttribute({\r\n *   name: 'position',\r\n *   type: 'vec3f',\r\n *   bufferFormat: 'float32x3',\r\n *   size: 3,\r\n *   bufferLength: vertices.length,\r\n *   array: vertices,\r\n * })\r\n * ```\r\n */\r\nexport class Geometry {\r\n  /** Number of vertices defined by this geometry */\r\n  verticesCount: number\r\n  /** Vertices order to be drawn by the {@link core/pipelines/RenderPipelineEntry.RenderPipelineEntry | render pipeline} */\r\n  verticesOrder: GPUFrontFace\r\n  /** {@link https://www.w3.org/TR/webgpu/#enumdef-gpuprimitivetopology | Topology} to use with this {@link Geometry}, i.e. whether to draw triangles or points */\r\n  topology: GPUPrimitiveTopology\r\n  /** Number of instances of this geometry to draw */\r\n  instancesCount: number\r\n  /** Array of {@link VertexBuffer | vertex buffers} to use with this geometry */\r\n  vertexBuffers: VertexBuffer[]\r\n  /** Options used to create this geometry */\r\n  options: GeometryOptions\r\n  /** The type of the geometry */\r\n  type: string\r\n  /** The universal unique id of the geometry */\r\n  uuid: string\r\n\r\n  /** The bounding box of the geometry, i.e. two {@link math/Vec3.Vec3 | Vec3} defining the min and max positions to wrap this geometry in a cube */\r\n  boundingBox: Box3\r\n\r\n  /** A string to append to our shaders code describing the WGSL structure representing this geometry attributes */\r\n  wgslStructFragment: string\r\n\r\n  /** A string representing the {@link vertexBuffers} layout, used for pipelines caching */\r\n  layoutCacheKey: string\r\n\r\n  /** A Set to store this {@link Geometry} consumers (Mesh uuid) */\r\n  consumers: Set<string>\r\n\r\n  /** Whether this geometry is ready to be drawn, i.e. it has been computed and all its vertex buffers have been created */\r\n  ready: boolean\r\n\r\n  /**\r\n   * Geometry constructor\r\n   * @param parameters - {@link GeometryParams | parameters} used to create our Geometry\r\n   */\r\n  constructor({\r\n    verticesOrder = 'ccw',\r\n    topology = 'triangle-list',\r\n    instancesCount = 1,\r\n    vertexBuffers = [],\r\n    mapBuffersAtCreation = true,\r\n  }: GeometryParams = {}) {\r\n    this.verticesCount = 0\r\n    this.verticesOrder = verticesOrder\r\n    this.topology = topology\r\n    this.instancesCount = instancesCount\r\n\r\n    this.ready = false\r\n\r\n    this.boundingBox = new Box3()\r\n\r\n    this.type = 'Geometry'\r\n    this.uuid = generateUUID()\r\n\r\n    this.vertexBuffers = []\r\n\r\n    this.consumers = new Set()\r\n\r\n    this.options = {\r\n      verticesOrder,\r\n      topology,\r\n      instancesCount,\r\n      vertexBuffers,\r\n      mapBuffersAtCreation,\r\n    }\r\n\r\n    // create a default 'attributes' vertex buffer if it has not been passed as parameter\r\n    // should contain our vertex position / uv data at least\r\n    const attributesBuffer = vertexBuffers.find((vertexBuffer) => vertexBuffer.name === 'attributes')\r\n    if (!vertexBuffers.length || !attributesBuffer) {\r\n      this.addVertexBuffer({\r\n        name: 'attributes',\r\n      })\r\n    } else if (attributesBuffer) {\r\n      // always put attributes vertex buffer first\r\n      vertexBuffers.sort((a, b) => {\r\n        const aIndex = a.name !== 'attributes' ? Infinity : -1\r\n        const bIndex = b.name !== 'attributes' ? Infinity : -1\r\n\r\n        return aIndex - bIndex\r\n      })\r\n    }\r\n\r\n    for (const vertexBuffer of vertexBuffers) {\r\n      this.addVertexBuffer({\r\n        stepMode: vertexBuffer.stepMode ?? 'vertex',\r\n        name: vertexBuffer.name,\r\n        attributes: vertexBuffer.attributes,\r\n        ...(vertexBuffer.array && { array: vertexBuffer.array }),\r\n        ...(vertexBuffer.buffer && { buffer: vertexBuffer.buffer }),\r\n        ...(vertexBuffer.bufferOffset && { bufferOffset: vertexBuffer.bufferOffset }),\r\n        ...(vertexBuffer.bufferSize && { bufferSize: vertexBuffer.bufferSize }),\r\n      })\r\n    }\r\n\r\n    // TODO or use a param instead?\r\n    // remember if attributesBuffer already has an array, the geometry won't be computed\r\n    if (attributesBuffer) {\r\n      this.setWGSLFragment()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset all the {@link vertexBuffers | vertex buffers} when the device is lost\r\n   */\r\n  loseContext() {\r\n    this.ready = false\r\n\r\n    for (const vertexBuffer of this.vertexBuffers) {\r\n      vertexBuffer.buffer.destroy()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Restore the {@link Geometry} buffers on context restoration\r\n   * @param renderer - The {@link Renderer} used to recreate the buffers\r\n   */\r\n  restoreContext(renderer: Renderer) {\r\n    // do not try to recreate buffers of a geometry that has already been restored\r\n    if (this.ready) return\r\n\r\n    for (const vertexBuffer of this.vertexBuffers) {\r\n      // do not try to restore a buffer created elsewhere initially (a compute pass for example)\r\n      if (!vertexBuffer.buffer.GPUBuffer && vertexBuffer.buffer.consumers.size === 0) {\r\n        vertexBuffer.buffer.createBuffer(renderer)\r\n\r\n        this.uploadBuffer(renderer, vertexBuffer)\r\n      }\r\n\r\n      vertexBuffer.buffer.consumers.add(this.uuid)\r\n    }\r\n\r\n    this.ready = true\r\n  }\r\n\r\n  /**\r\n   * Add a vertex buffer to our Geometry, set its attributes and return it\r\n   * @param parameters - vertex buffer {@link VertexBufferParams | parameters}\r\n   * @returns - newly created {@link VertexBuffer | vertex buffer}\r\n   */\r\n  addVertexBuffer({\r\n    stepMode = 'vertex',\r\n    name,\r\n    attributes = [],\r\n    buffer = null,\r\n    array = null,\r\n    bufferOffset = 0,\r\n    bufferSize = null,\r\n  }: VertexBufferParams = {}): VertexBuffer {\r\n    buffer = buffer || new Buffer()\r\n\r\n    const vertexBuffer = {\r\n      name: name ?? 'attributes' + this.vertexBuffers.length,\r\n      stepMode,\r\n      arrayStride: 0,\r\n      bufferLength: 0,\r\n      attributes: [],\r\n      buffer,\r\n      array,\r\n      bufferOffset,\r\n      bufferSize,\r\n    }\r\n\r\n    // set attributes right away if possible\r\n    attributes?.forEach((attribute) => {\r\n      this.setAttribute({\r\n        vertexBuffer,\r\n        ...attribute,\r\n      } as VertexBufferAttributeParams)\r\n    })\r\n\r\n    this.vertexBuffers.push(vertexBuffer)\r\n\r\n    return vertexBuffer\r\n  }\r\n\r\n  /**\r\n   * Get a vertex buffer by name\r\n   * @param name - our vertex buffer name\r\n   * @returns - found {@link VertexBuffer | vertex buffer} or null if not found\r\n   */\r\n  getVertexBufferByName(name = ''): VertexBuffer | null {\r\n    return this.vertexBuffers.find((vertexBuffer) => vertexBuffer.name === name)\r\n  }\r\n\r\n  /**\r\n   * Set a vertex buffer attribute\r\n   * @param parameters - attributes {@link VertexBufferAttributeParams | parameters}\r\n   */\r\n  setAttribute({\r\n    vertexBuffer = this.vertexBuffers[0],\r\n    name,\r\n    type = 'vec3f',\r\n    bufferFormat = 'float32x3',\r\n    size = 3,\r\n    array = new Float32Array(this.verticesCount * size),\r\n    verticesStride = 1,\r\n  }: VertexBufferAttributeParams) {\r\n    const attributes = vertexBuffer.attributes\r\n    const attributesLength = attributes.length\r\n\r\n    if (!name) name = 'geometryAttribute' + attributesLength\r\n\r\n    if (name === 'position' && (type !== 'vec3f' || bufferFormat !== 'float32x3' || size !== 3)) {\r\n      throwWarning(\r\n        `Geometry 'position' attribute must have this exact properties set:\\n\\ttype: 'vec3f',\\n\\tbufferFormat: 'float32x3',\\n\\tsize: 3`\r\n      )\r\n      type = 'vec3f'\r\n      bufferFormat = 'float32x3'\r\n      size = 3\r\n    }\r\n\r\n    let arrayLength = array.length\r\n    const attributeCount = arrayLength / size\r\n\r\n    if (name === 'position') {\r\n      this.verticesCount = attributeCount\r\n    }\r\n\r\n    if (\r\n      vertexBuffer.stepMode === 'vertex' &&\r\n      this.verticesCount &&\r\n      this.verticesCount !== attributeCount * verticesStride\r\n    ) {\r\n      throwError(\r\n        `Geometry vertex attribute error. Attribute array of size ${size} must be of length: ${\r\n          this.verticesCount * size\r\n        }, current given: ${array.length}. (${this.verticesCount} vertices).`\r\n      )\r\n    } else if (vertexBuffer.stepMode === 'instance' && attributeCount !== this.instancesCount) {\r\n      if (vertexBuffer.buffer) {\r\n        arrayLength = this.instancesCount * size\r\n      } else {\r\n        throwError(\r\n          `Geometry instance attribute error. Attribute array of size ${size} must be of length: ${\r\n            this.instancesCount * size\r\n          }, current given: ${array.length}. (${this.instancesCount} instances).`\r\n        )\r\n      }\r\n    }\r\n\r\n    // TODO we could force the use of a bufferOffset to 0\r\n    // and use an offset inside the setVertexBuffer call instead\r\n    // it might be needed in some edge cases with glTF geometries\r\n    // see https://toji.dev/webgpu-gltf-case-study/#handling-large-attribute-offsets\r\n    const attribute = {\r\n      name,\r\n      type,\r\n      bufferFormat,\r\n      size,\r\n      bufferLength: arrayLength,\r\n      offset: attributesLength\r\n        ? attributes.reduce((accumulator: number, currentValue) => {\r\n            return accumulator + currentValue.bufferLength\r\n          }, 0)\r\n        : 0,\r\n      bufferOffset: attributesLength\r\n        ? attributes[attributesLength - 1].bufferOffset + attributes[attributesLength - 1].size * 4\r\n        : 0,\r\n      array,\r\n      verticesStride: verticesStride,\r\n    }\r\n\r\n    vertexBuffer.bufferLength += attribute.bufferLength * verticesStride\r\n    vertexBuffer.arrayStride += attribute.size\r\n    vertexBuffer.attributes.push(attribute)\r\n  }\r\n\r\n  /**\r\n   * Get whether this Geometry is ready to compute, i.e. if its first vertex buffer array has not been created yet\r\n   * @readonly\r\n   */\r\n  get shouldCompute(): boolean {\r\n    return this.vertexBuffers.length && !this.vertexBuffers[0].array\r\n  }\r\n\r\n  /**\r\n   * Get an attribute by name\r\n   * @param name - name of the attribute to find\r\n   * @returns - found {@link VertexBufferAttribute | attribute} or null if not found\r\n   */\r\n  getAttributeByName(name: string): VertexBufferAttribute | null {\r\n    let attribute\r\n\r\n    for (const vertexBuffer of this.vertexBuffers) {\r\n      attribute = vertexBuffer.attributes.find((attribute) => attribute.name === name)\r\n      if (attribute) break // Exit once we find the matching attribute\r\n    }\r\n\r\n    return attribute\r\n  }\r\n\r\n  /**\r\n   * Compute a Geometry, which means iterate through all vertex buffers and create the attributes array that will be sent as buffers.\r\n   * Also compute the Geometry bounding box.\r\n   */\r\n  computeGeometry() {\r\n    if (this.ready) return\r\n\r\n    this.vertexBuffers.forEach((vertexBuffer, index) => {\r\n      if (index === 0) {\r\n        const hasPositionAttribute = vertexBuffer.attributes.find(\r\n          (attribute) => attribute.name === 'position'\r\n        ) as VertexBufferAttribute | null\r\n\r\n        if (!hasPositionAttribute) {\r\n          throwError(`Geometry must have a 'position' attribute`)\r\n        }\r\n\r\n        if (\r\n          hasPositionAttribute.type !== 'vec3f' ||\r\n          hasPositionAttribute.bufferFormat !== 'float32x3' ||\r\n          hasPositionAttribute.size !== 3\r\n        ) {\r\n          throwWarning(\r\n            `Geometry 'position' attribute must have this exact properties set:\\n\\ttype: 'vec3f',\\n\\tbufferFormat: 'float32x3',\\n\\tsize: 3`\r\n          )\r\n          hasPositionAttribute.type = 'vec3f'\r\n          hasPositionAttribute.bufferFormat = 'float32x3'\r\n          hasPositionAttribute.size = 3\r\n        }\r\n      }\r\n\r\n      vertexBuffer.array = new Float32Array(vertexBuffer.bufferLength)\r\n\r\n      let currentIndex = 0\r\n      let attributeIndex = 0\r\n      for (let i = 0; i < vertexBuffer.bufferLength; i += vertexBuffer.arrayStride) {\r\n        for (let j = 0; j < vertexBuffer.attributes.length; j++) {\r\n          const { name, size, array, verticesStride } = vertexBuffer.attributes[j]\r\n\r\n          for (let s = 0; s < size; s++) {\r\n            const attributeValue = array[Math.floor(attributeIndex / verticesStride) * size + s]\r\n            vertexBuffer.array[currentIndex] = attributeValue ?? 0\r\n\r\n            // compute bounding box\r\n            if (name === 'position') {\r\n              if (s % 3 === 0) {\r\n                // x\r\n                if (this.boundingBox.min.x > attributeValue) this.boundingBox.min.x = attributeValue\r\n                if (this.boundingBox.max.x < attributeValue) this.boundingBox.max.x = attributeValue\r\n              } else if (s % 3 === 1) {\r\n                // y\r\n                if (this.boundingBox.min.y > attributeValue) this.boundingBox.min.y = attributeValue\r\n                if (this.boundingBox.max.y < attributeValue) this.boundingBox.max.y = attributeValue\r\n              } else if (s % 3 === 2) {\r\n                // z\r\n                if (this.boundingBox.min.z > attributeValue) this.boundingBox.min.z = attributeValue\r\n                if (this.boundingBox.max.z < attributeValue) this.boundingBox.max.z = attributeValue\r\n              }\r\n            }\r\n\r\n            currentIndex++\r\n          }\r\n        }\r\n\r\n        attributeIndex++\r\n      }\r\n    })\r\n\r\n    if (!this.wgslStructFragment) {\r\n      this.setWGSLFragment()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the WGSL code snippet that will be appended to the vertex shader.\r\n   */\r\n  setWGSLFragment() {\r\n    let locationIndex = -1\r\n    this.wgslStructFragment = `struct Attributes {\\n\\t@builtin(vertex_index) vertexIndex : u32,\\n\\t@builtin(instance_index) instanceIndex : u32,${this.vertexBuffers\r\n      .map((vertexBuffer) => {\r\n        return vertexBuffer.attributes.map((attribute) => {\r\n          locationIndex++\r\n          return `\\n\\t@location(${locationIndex}) ${attribute.name}: ${attribute.type}`\r\n        })\r\n      })\r\n      .join(',')}\\n};`\r\n\r\n    // TODO use for pipeline caching\r\n    this.layoutCacheKey =\r\n      this.vertexBuffers\r\n        .map((vertexBuffer) => {\r\n          return (\r\n            vertexBuffer.name +\r\n            ',' +\r\n            vertexBuffer.attributes.map((attribute) => {\r\n              return `${attribute.name},${attribute.size}`\r\n            })\r\n          )\r\n        })\r\n        .join(',') + ','\r\n  }\r\n\r\n  /**\r\n   * Create the {@link Geometry} {@link vertexBuffers | vertex buffers}.\r\n   * @param parameters - parameters used to create the vertex buffers.\r\n   * @param parameters.renderer - {@link Renderer} used to create the vertex buffers.\r\n   * @param parameters.label - label to use for the vertex buffers.\r\n   */\r\n  createBuffers({ renderer, label = this.type }: { renderer: Renderer; label?: string }) {\r\n    if (this.ready) return\r\n\r\n    for (const vertexBuffer of this.vertexBuffers) {\r\n      if (!vertexBuffer.bufferSize) {\r\n        vertexBuffer.bufferSize =\r\n          vertexBuffer.array.length * (vertexBuffer.array.constructor as TypedArrayConstructor).BYTES_PER_ELEMENT\r\n      }\r\n\r\n      if (!vertexBuffer.buffer.GPUBuffer && !vertexBuffer.buffer.consumers.size) {\r\n        vertexBuffer.buffer.createBuffer(renderer, {\r\n          label: label + ': ' + vertexBuffer.name + ' buffer',\r\n          size: vertexBuffer.bufferSize,\r\n          usage: this.options.mapBuffersAtCreation ? ['vertex'] : ['copyDst', 'vertex'],\r\n          mappedAtCreation: this.options.mapBuffersAtCreation,\r\n        })\r\n\r\n        this.uploadBuffer(renderer, vertexBuffer)\r\n      }\r\n\r\n      vertexBuffer.buffer.consumers.add(this.uuid)\r\n    }\r\n\r\n    this.ready = true\r\n  }\r\n\r\n  /**\r\n   * Upload a {@link GeometryBuffer} to the GPU.\r\n   * @param renderer - {@link Renderer} used to upload the buffer.\r\n   * @param buffer - {@link GeometryBuffer} holding a {@link Buffer} and a typed array to upload.\r\n   */\r\n  uploadBuffer(renderer: Renderer, buffer: GeometryBuffer) {\r\n    if (this.options.mapBuffersAtCreation) {\r\n      new (buffer.array.constructor as TypedArrayConstructor)(buffer.buffer.GPUBuffer.getMappedRange()).set(\r\n        buffer.array\r\n      )\r\n\r\n      buffer.buffer.GPUBuffer.unmap()\r\n    } else {\r\n      renderer.queueWriteBuffer(buffer.buffer.GPUBuffer, 0, buffer.array)\r\n    }\r\n  }\r\n\r\n  /** RENDER **/\r\n\r\n  /**\r\n   * Set our render pass geometry vertex buffers\r\n   * @param pass - current render pass\r\n   */\r\n  setGeometryBuffers(pass: GPURenderPassTypes) {\r\n    this.vertexBuffers.forEach((vertexBuffer, index) => {\r\n      pass.setVertexBuffer(index, vertexBuffer.buffer.GPUBuffer, vertexBuffer.bufferOffset, vertexBuffer.bufferSize)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Draw our geometry\r\n   * @param pass - current render pass\r\n   */\r\n  drawGeometry(pass: GPURenderPassTypes) {\r\n    pass.draw(this.verticesCount, this.instancesCount)\r\n  }\r\n\r\n  /**\r\n   * Set our vertex buffers then draw the geometry\r\n   * @param pass - current render pass\r\n   */\r\n  render(pass: GPURenderPassTypes) {\r\n    if (!this.ready) return\r\n\r\n    this.setGeometryBuffers(pass)\r\n    this.drawGeometry(pass)\r\n  }\r\n\r\n  /**\r\n   * Destroy our geometry vertex buffers.\r\n   * @param renderer - current {@link Renderer}, in case we want to remove the {@link VertexBuffer#buffer | buffers} from the cache.\r\n   */\r\n  destroy(renderer: null | Renderer = null) {\r\n    this.ready = false\r\n\r\n    for (const vertexBuffer of this.vertexBuffers) {\r\n      vertexBuffer.buffer.consumers.delete(this.uuid)\r\n      if (!vertexBuffer.buffer.consumers.size) {\r\n        vertexBuffer.buffer.destroy()\r\n      }\r\n\r\n      vertexBuffer.array = null\r\n\r\n      if (renderer) renderer.removeBuffer(vertexBuffer.buffer)\r\n    }\r\n  }\r\n}\r\n","import { Geometry } from './Geometry'\r\nimport { GeometryBuffer, GeometryParams } from '../../types/Geometries'\r\nimport { Buffer } from '../buffers/Buffer'\r\nimport { Renderer } from '../renderers/utils'\r\nimport { TypedArrayConstructor } from '../bindings/utils'\r\nimport { GPURenderPassTypes } from '../pipelines/PipelineManager'\r\n\r\n/**\r\n * Defines the available options to create an {@link IndexedGeometry#indexBuffer | index buffer}\r\n */\r\nexport interface IndexedGeometryIndexBufferOptions extends Partial<GeometryBuffer> {\r\n  /** index buffer format */\r\n  bufferFormat?: GPUIndexFormat\r\n  /** index buffer array */\r\n  array?: Uint16Array | Uint32Array\r\n}\r\n\r\n/**\r\n * Defines an {@link IndexedGeometry#indexBuffer | index buffer}\r\n */\r\nexport interface IndexBuffer extends GeometryBuffer {\r\n  /** index buffer format */\r\n  bufferFormat: GPUIndexFormat\r\n  /** index buffer array */\r\n  array: Uint16Array | Uint32Array\r\n  /** index buffer length */\r\n  bufferLength: number\r\n}\r\n\r\n/**\r\n * Used to create an {@link IndexedGeometry} which holds an index array to use as an index buffer.\r\n *\r\n * The index array represents the order in which the attributes should be processed. This allows to create smaller vertex, uv and normal arrays.\r\n *\r\n * During the {@link IndexedGeometry#render | render}, the {@link IndexedGeometry} is responsible for setting the {@link IndexedGeometry#vertexBuffers | vertexBuffers} and drawing the indexed vertices.\r\n *\r\n * @example\r\n * ```javascript\r\n * const vertices = new Float32Array([\r\n *   -1, -1,  0,\r\n *    1, -1,  0,\r\n *   -1,  1,  0,\r\n *    1,  1,  0\r\n * ])\r\n *\r\n * // vertices index (order in which they should be drawn)\r\n * const indexArray = new Uint16Array([0, 2, 1, 1, 2, 3])\r\n *\r\n * // create an indexed quad geometry made of 4 vertices\r\n * const indexedGeometry = new IndexedGeometry()\r\n *\r\n * indexedGeometry.setAttribute({\r\n *   name: 'position',\r\n *   type: 'vec3f',\r\n *   bufferFormat: 'float32x3',\r\n *   size: 3,\r\n *   bufferLength: vertices.length,\r\n *   array: vertices,\r\n * })\r\n *\r\n * indexedGeometry.setIndexBuffer({\r\n *   array: indexArray,\r\n *   bufferFormat: 'uint16',\r\n * })\r\n * ```\r\n */\r\nexport class IndexedGeometry extends Geometry {\r\n  /** Object containing our index buffer format & length, array and GPUBuffer */\r\n  indexBuffer: IndexBuffer\r\n\r\n  /**\r\n   * IndexedGeometry constructor\r\n   * @param parameters - {@link GeometryParams | parameters} used to create our IndexedGeometry\r\n   */\r\n  constructor({\r\n    verticesOrder = 'ccw',\r\n    topology = 'triangle-list',\r\n    instancesCount = 1,\r\n    vertexBuffers = [],\r\n    mapBuffersAtCreation = true,\r\n  }: GeometryParams = {}) {\r\n    super({ verticesOrder, topology, instancesCount, vertexBuffers, mapBuffersAtCreation })\r\n\r\n    this.type = 'IndexedGeometry'\r\n  }\r\n\r\n  /**\r\n   * Reset all the {@link vertexBuffers | vertex buffers} and {@link indexBuffer | index buffer} when the device is lost\r\n   */\r\n  loseContext() {\r\n    super.loseContext()\r\n\r\n    if (this.indexBuffer) {\r\n      this.indexBuffer.buffer.destroy()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Restore the {@link IndexedGeometry} buffers on context restoration\r\n   * @param renderer - The {@link Renderer} used to recreate the buffers\r\n   */\r\n  restoreContext(renderer: Renderer) {\r\n    if (this.ready) return\r\n\r\n    if (!this.indexBuffer.buffer.GPUBuffer) {\r\n      this.indexBuffer.buffer.createBuffer(renderer)\r\n\r\n      this.uploadBuffer(renderer, this.indexBuffer)\r\n\r\n      this.indexBuffer.buffer.consumers.add(this.uuid)\r\n    }\r\n\r\n    super.restoreContext(renderer)\r\n  }\r\n\r\n  /**\r\n   * If we have less than 65.536 vertices, we should use a Uin16Array to hold our index buffer values\r\n   * @readonly\r\n   */\r\n  get useUint16IndexArray(): boolean {\r\n    return this.verticesCount < 256 * 256\r\n  }\r\n\r\n  /**\r\n   * Set our {@link indexBuffer}\r\n   * @param parameters - {@link IndexedGeometryIndexBufferOptions | parameters} used to create our index buffer\r\n   */\r\n  setIndexBuffer({\r\n    bufferFormat = 'uint32',\r\n    array = new Uint32Array(0),\r\n    buffer = new Buffer(),\r\n    bufferOffset = 0,\r\n    bufferSize = null,\r\n  }: IndexedGeometryIndexBufferOptions) {\r\n    this.indexBuffer = {\r\n      array,\r\n      bufferFormat,\r\n      bufferLength: array.length,\r\n      buffer,\r\n      bufferOffset,\r\n      bufferSize:\r\n        bufferSize !== null\r\n          ? bufferSize\r\n          : array.length * (array.constructor as TypedArrayConstructor).BYTES_PER_ELEMENT,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create the {@link Geometry} {@link vertexBuffers | vertex buffers} and {@link indexBuffer | index buffer}.\r\n   * @param parameters - parameters used to create the vertex buffers.\r\n   * @param parameters.renderer - {@link Renderer} used to create the vertex buffers.\r\n   * @param parameters.label - label to use for the vertex buffers.\r\n   */\r\n  createBuffers({ renderer, label = this.type }: { renderer: Renderer; label?: string }) {\r\n    if (!this.indexBuffer.buffer.GPUBuffer) {\r\n      this.indexBuffer.buffer.createBuffer(renderer, {\r\n        label: label + ': index buffer',\r\n        size: this.indexBuffer.array.byteLength,\r\n        usage: this.options.mapBuffersAtCreation ? ['index'] : ['copyDst', 'index'],\r\n        mappedAtCreation: this.options.mapBuffersAtCreation,\r\n      })\r\n\r\n      this.uploadBuffer(renderer, this.indexBuffer)\r\n    }\r\n\r\n    this.indexBuffer.buffer.consumers.add(this.uuid)\r\n\r\n    super.createBuffers({ renderer, label })\r\n  }\r\n\r\n  /** RENDER **/\r\n\r\n  /**\r\n   * First, set our render pass geometry vertex buffers\r\n   * Then, set our render pass geometry index buffer\r\n   * @param pass - current render pass\r\n   */\r\n  setGeometryBuffers(pass: GPURenderPassTypes) {\r\n    super.setGeometryBuffers(pass)\r\n\r\n    pass.setIndexBuffer(\r\n      this.indexBuffer.buffer.GPUBuffer,\r\n      this.indexBuffer.bufferFormat,\r\n      this.indexBuffer.bufferOffset,\r\n      this.indexBuffer.bufferSize\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Override the parentMesh draw method to draw indexed geometry\r\n   * @param pass - current render pass\r\n   */\r\n  drawGeometry(pass: GPURenderPassTypes) {\r\n    pass.drawIndexed(this.indexBuffer.bufferLength, this.instancesCount)\r\n  }\r\n\r\n  /**\r\n   * Destroy our indexed geometry vertex buffers and index buffer.\r\n   * @param renderer - current {@link Renderer}, in case we want to remove the {@link IndexBuffer#buffer | buffer} from the cache.\r\n   */\r\n  destroy(renderer: null | Renderer = null) {\r\n    super.destroy(renderer)\r\n\r\n    if (this.indexBuffer) {\r\n      this.indexBuffer.buffer.consumers.delete(this.uuid)\r\n      this.indexBuffer.buffer.destroy()\r\n      if (renderer) renderer.removeBuffer(this.indexBuffer.buffer)\r\n    }\r\n  }\r\n}\r\n","import { IndexedGeometry } from './IndexedGeometry'\r\nimport { Geometry } from './Geometry'\r\nimport { GeometryBaseParams, VertexBufferAttributeParams } from '../../types/Geometries'\r\n\r\n/**\r\n * Parameters used to create a {@link PlaneGeometry}\r\n */\r\nexport interface PlaneGeometryParams extends GeometryBaseParams {\r\n  /** Number of segments along the X axis */\r\n  widthSegments?: number\r\n  /** Number of segments along the Y axis */\r\n  heightSegments?: number\r\n}\r\n\r\n/**\r\n * Used to create an indexed plane geometry based on the number of segments along the X and Y axis.\r\n *\r\n * This is how it will look for a 3x2 quad. Indexing will take care of drawing the right vertices in the right order.\r\n *\r\n * <pre>\r\n *  3---2---1---0\r\n *  |  /|  /|  /|\r\n *  |/  |/  |/  |\r\n *  7---6---5---4\r\n *  |  /|  /|  /|\r\n *  |/  |/  |/  |\r\n *  11--10--9---8\r\n * </pre>\r\n *\r\n * @example\r\n * ```javascript\r\n * const planeGeometry = new PlaneGeometry()\r\n * ```\r\n */\r\nexport class PlaneGeometry extends IndexedGeometry {\r\n  /**\r\n   * Defines our {@link PlaneGeometry} definition based on the provided {@link PlaneGeometryParams | parameters}\r\n   */\r\n  definition: {\r\n    /** unique id based on width and height segments, used to get {@link PlaneGeometry} from cache */\r\n    id: number\r\n    /** number of segments along the X axis */\r\n    width: number\r\n    /** number of segments along the Y axis */\r\n    height: number\r\n    /** total number of segments */\r\n    count: number\r\n  }\r\n\r\n  /**\r\n   * PlaneGeometry constructor\r\n   * @param parameters - {@link PlaneGeometryParams | parameters} used to create our PlaneGeometry\r\n   */\r\n  constructor({\r\n    widthSegments = 1,\r\n    heightSegments = 1,\r\n    instancesCount = 1,\r\n    vertexBuffers = [],\r\n    topology,\r\n  }: PlaneGeometryParams = {}) {\r\n    super({ verticesOrder: 'ccw', topology, instancesCount, vertexBuffers, mapBuffersAtCreation: true })\r\n\r\n    this.type = 'PlaneGeometry'\r\n\r\n    widthSegments = Math.floor(widthSegments)\r\n    heightSegments = Math.floor(heightSegments)\r\n\r\n    // unique plane geometry id based on width and height\r\n    // used to get a geometry from cache\r\n    this.definition = {\r\n      id: widthSegments * heightSegments + widthSegments,\r\n      width: widthSegments,\r\n      height: heightSegments,\r\n      count: widthSegments * heightSegments,\r\n    }\r\n\r\n    const verticesCount = (this.definition.width + 1) * (this.definition.height + 1)\r\n    const attributes = this.getIndexedVerticesAndUVs(verticesCount)\r\n\r\n    for (const attribute of Object.values(attributes)) {\r\n      this.setAttribute(attribute as VertexBufferAttributeParams)\r\n    }\r\n\r\n    this.setIndexArray()\r\n  }\r\n\r\n  /**\r\n   * Set our PlaneGeometry index array\r\n   */\r\n  setIndexArray() {\r\n    const indexArray = this.useUint16IndexArray\r\n      ? new Uint16Array(this.definition.count * 6)\r\n      : new Uint32Array(this.definition.count * 6)\r\n\r\n    let index = 0\r\n\r\n    for (let y = 0; y < this.definition.height; y++) {\r\n      for (let x = 0; x < this.definition.width; x++) {\r\n        indexArray[index++] = x + y * (this.definition.width + 1)\r\n        indexArray[index++] = this.definition.width + x + 1 + y * (this.definition.width + 1)\r\n        indexArray[index++] = x + 1 + y * (this.definition.width + 1)\r\n\r\n        indexArray[index++] = x + 1 + y * (this.definition.width + 1)\r\n        indexArray[index++] = this.definition.width + x + 1 + y * (this.definition.width + 1)\r\n        indexArray[index++] = this.definition.width + x + 2 + y * (this.definition.width + 1)\r\n      }\r\n    }\r\n\r\n    this.setIndexBuffer({\r\n      array: indexArray,\r\n      bufferFormat: this.useUint16IndexArray ? 'uint16' : 'uint32',\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Compute the UV and position arrays based on our plane widthSegments and heightSegments values and return the corresponding attributes\r\n   * @param verticesCount - {@link Geometry#verticesCount | number of vertices} of our {@link PlaneGeometry}\r\n   * @returns - our position and uv {@link VertexBufferAttributeParams | attributes}\r\n   */\r\n  getIndexedVerticesAndUVs(verticesCount: Geometry['verticesCount']): Record<string, VertexBufferAttributeParams> {\r\n    // geometry vertices and UVs\r\n    const uv = {\r\n      name: 'uv',\r\n      type: 'vec2f',\r\n      bufferFormat: 'float32x2',\r\n      size: 2,\r\n      array: new Float32Array(verticesCount * 2),\r\n    }\r\n\r\n    const position = {\r\n      name: 'position',\r\n      type: 'vec3f',\r\n      bufferFormat: 'float32x3',\r\n      // nb of triangles * 3 vertices per triangle * 3 coordinates per triangle\r\n      size: 3,\r\n      array: new Float32Array(verticesCount * 3),\r\n    }\r\n\r\n    const normal = {\r\n      name: 'normal',\r\n      type: 'vec3f',\r\n      bufferFormat: 'float32x3',\r\n      // nb of triangles * 3 vertices per triangle * 3 coordinates per triangle\r\n      size: 3,\r\n      array: new Float32Array(verticesCount * 3),\r\n    }\r\n\r\n    let positionOffset = 0\r\n    let normalOffset = 0\r\n    let uvOffset = 0\r\n\r\n    // this is how it will look for a 3x2 quad\r\n    // indexing will take care of drawing the right vertices at the right time\r\n    // remember we're using counter clockwise ordering\r\n    // 3---2---1---0\r\n    // | //| //| //|\r\n    // |// |// |// |\r\n    // 7---6---5---4\r\n    // | //| //| //|\r\n    // |// |// |// |\r\n    // 11--10--9---8\r\n\r\n    for (let y = 0; y <= this.definition.height; y++) {\r\n      for (let x = 0; x <= this.definition.width; x++) {\r\n        // uv\r\n        uv.array[uvOffset++] = 1 - x / this.definition.width\r\n        uv.array[uvOffset++] = 1 - y / this.definition.height\r\n\r\n        // vertex position\r\n        position.array[positionOffset++] = 1 - (x * 2) / this.definition.width\r\n        position.array[positionOffset++] = (y * 2) / this.definition.height - 1\r\n        position.array[positionOffset++] = 0\r\n\r\n        // normals are simple\r\n        normal.array[normalOffset++] = 0\r\n        normal.array[normalOffset++] = 0\r\n        normal.array[normalOffset++] = 1\r\n      }\r\n    }\r\n\r\n    return { position, uv, normal } as Record<string, VertexBufferAttributeParams>\r\n  }\r\n}\r\n","import { Vec3 } from '../../math/Vec3'\nimport { CameraRenderer, isCameraRenderer } from '../renderers/utils'\nimport { BufferBinding } from '../bindings/BufferBinding'\nimport { Object3D } from '../objects3D/Object3D'\nimport { generateUUID } from '../../utils/utils'\nimport { DirectionalLight } from './DirectionalLight'\nimport { PointLight } from './PointLight'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\n\n/** Defines all types of lights. */\nexport type LightsType = 'ambientLights' | 'directionalLights' | 'pointLights'\n/** Defines all types of shadow casting lights. */\nexport type ShadowCastingLights = DirectionalLight | PointLight\n\n/**\n * Base parameters used to create a {@link Light}.\n */\nexport interface LightBaseParams {\n  /** The {@link Light} color. Default to `Vec3(1)`. */\n  color?: Vec3\n  /** The {@link Light} intensity. Default to `1`. */\n  intensity?: number\n}\n\n/**\n * Parameters used to create a {@link Light}.\n */\nexport interface LightParams extends LightBaseParams {\n  /** Index of this {@link Light}, i.e. the number of time a {@link Light} of this type has been created. */\n  type?: string | LightsType\n}\n\n/**\n * Used as a base class to create a light.\n */\nexport class Light extends Object3D {\n  /** {@link LightsType | Type of the light}. */\n  type: string | LightsType\n  /** The universal unique id of this {@link Light} */\n  readonly uuid: string\n  /** Index of this {@link Light}, i.e. the number of time a {@link Light} of this type has been created. */\n  index: number\n  /** {@link CameraRenderer} used by this {@link Light} */\n  renderer: CameraRenderer\n\n  /** Options used to create this {@link Light}. */\n  options: LightBaseParams\n\n  /** Current {@link Vec3 | color} of this {@link Light}. */\n  color: Vec3\n  /** @ignore */\n  #intensity: number\n  /**\n   * A {@link Vec3} holding the {@link Light} {@link color} multiplied by its {@link intensity}.\n   * @private\n   */\n  #intensityColor: Vec3\n\n  /** {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding} that holds all the bindings to send to the shaders. */\n  rendererBinding: BufferBinding | null\n\n  /**\n   * Light constructor\n   * @param renderer - {@link CameraRenderer} used to create this {@link Light}.\n   * @param parameters - {@link LightParams | parameters} used to create this {@link Light}.\n   */\n  constructor(\n    renderer: CameraRenderer | GPUCurtains,\n    { color = new Vec3(1), intensity = 1, type = 'lights' } = {} as LightParams\n  ) {\n    super()\n\n    this.type = type\n\n    this.setRenderer(renderer)\n\n    this.uuid = generateUUID()\n\n    this.options = {\n      color,\n      intensity,\n    }\n\n    this.color = color\n    this.#intensityColor = this.color.clone()\n    this.color.onChange(() =>\n      this.onPropertyChanged('color', this.#intensityColor.copy(this.color).multiplyScalar(this.intensity))\n    )\n\n    this.intensity = intensity\n  }\n\n  /**\n   * Set or reset this light {@link CameraRenderer}.\n   * @param renderer - New {@link CameraRenderer} or {@link GPUCurtains} instance to use.\n   */\n  setRenderer(renderer: CameraRenderer | GPUCurtains) {\n    const hasRenderer = !!this.renderer\n\n    // if there's already a renderer, remove light\n    if (this.renderer) {\n      this.renderer.removeLight(this)\n    }\n\n    // set new renderer\n    renderer = isCameraRenderer(renderer, this.constructor.name)\n    this.renderer = renderer\n\n    this.index = this.renderer.lights.filter((light) => light.type === this.type).length\n\n    // check for overflow\n    if (this.index + 1 > this.renderer.lightsBindingParams[this.type].max) {\n      this.onMaxLightOverflow(this.type as LightsType)\n    }\n\n    // add light back\n    this.renderer.addLight(this)\n\n    // reset binding\n    this.setRendererBinding()\n\n    if (hasRenderer) {\n      this.reset()\n    }\n  }\n\n  /**\n   * Set or reset this {@link Light} {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}.\n   */\n  setRendererBinding() {\n    if (this.renderer.bindings[this.type]) {\n      this.rendererBinding = this.renderer.bindings[this.type]\n    }\n  }\n\n  /**\n   * Resend all properties to the {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}. Called when the maximum number of corresponding {@link Light} has been overflowed.\n   */\n  reset() {\n    this.setRendererBinding()\n    this.onPropertyChanged('color', this.#intensityColor.copy(this.color).multiplyScalar(this.intensity))\n  }\n\n  /**\n   * Get this {@link Light} intensity.\n   * @returns - The {@link Light} intensity.\n   */\n  get intensity(): number {\n    return this.#intensity\n  }\n\n  /**\n   * Set this {@link Light} intensity and update the {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}.\n   * @param value - The new {@link Light} intensity.\n   */\n  set intensity(value: number) {\n    this.#intensity = value\n    this.onPropertyChanged('color', this.#intensityColor.copy(this.color).multiplyScalar(this.intensity))\n  }\n\n  /**\n   * Update the {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding} input value and tell the {@link CameraRenderer#cameraLightsBindGroup | renderer camera, lights and shadows} bind group to update.\n   * @param propertyKey - name of the property to update.\n   * @param value - new value of the property.\n   */\n  onPropertyChanged(propertyKey: string, value: Vec3 | number) {\n    if (this.rendererBinding && this.rendererBinding.inputs[propertyKey]) {\n      if (value instanceof Vec3) {\n        this.rendererBinding.inputs[propertyKey].value[this.index * 3] = value.x\n        this.rendererBinding.inputs[propertyKey].value[this.index * 3 + 1] = value.y\n        this.rendererBinding.inputs[propertyKey].value[this.index * 3 + 2] = value.z\n      } else {\n        this.rendererBinding.inputs[propertyKey].value[this.index] = value\n      }\n\n      this.rendererBinding.inputs[propertyKey].shouldUpdate = true\n      this.renderer.shouldUpdateCameraLightsBindGroup()\n    }\n  }\n\n  /**\n   * Tell the {@link renderer} that the maximum number for this {@link type} of light has been overflown.\n   * @param lightsType - {@link type} of light.\n   */\n  onMaxLightOverflow(lightsType: LightsType) {\n    this.renderer.onMaxLightOverflow(lightsType)\n\n    if (this.rendererBinding) {\n      this.rendererBinding = this.renderer.bindings[lightsType]\n    }\n  }\n\n  /**\n   * Remove this {@link Light} from the {@link renderer} and destroy it.\n   */\n  remove() {\n    this.renderer.removeLight(this)\n    this.destroy()\n  }\n\n  /**\n   * Destroy this {@link Light}.\n   */\n  destroy() {\n    super.destroy()\n  }\n}\n","import { Light, LightBaseParams, LightsType } from './Light'\nimport { Vec3 } from '../../math/Vec3'\nimport { CameraRenderer } from '../renderers/utils'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\n\n/**\n * Create an ambient light that equally illuminates all objects in the scene.\n *\n * This light cannot cast shadows.\n *\n * @example\n * ```javascript\n * // assuming 'renderer' is a valid Camera renderer\n * const ambientLight = new AmbientLight(renderer, {\n *   color: new Vec3(1),\n *   intensity: 0.1,\n * })\n * ```\n */\nexport class AmbientLight extends Light {\n  /**\n   * AmbientLight constructor\n   * @param renderer - {@link CameraRenderer} used to create this {@link AmbientLight}.\n   * @param parameters - {@link LightBaseParams | parameters} used to create this {@link AmbientLight}.\n   */\n  constructor(\n    renderer: CameraRenderer | GPUCurtains,\n    { color = new Vec3(1), intensity = 0.1 } = {} as LightBaseParams\n  ) {\n    const type = 'ambientLights'\n    super(renderer, { color, intensity, type })\n  }\n\n  // explicitly disable all kinds of transformations\n\n  /** @ignore */\n  applyRotation() {}\n\n  /** @ignore */\n  applyPosition() {}\n\n  /** @ignore */\n  applyScale() {}\n\n  /** @ignore */\n  applyTransformOrigin() {}\n}\n","import { isRenderer, Renderer } from '../renderers/utils'\r\nimport { generateUUID } from '../../utils/utils'\r\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\r\nimport { Texture } from '../textures/Texture'\r\n\r\n/** Define the parameters of a color attachment */\r\nexport interface ColorAttachmentParams {\r\n  /** The {@link GPULoadOp | load operation} to perform while drawing this {@link RenderPass} */\r\n  loadOp?: GPULoadOp\r\n  /** The {@link GPUStoreOp | store operation} to perform while drawing this {@link RenderPass} */\r\n  storeOp?: GPUStoreOp\r\n  /** The {@link GPUColor | color values} to clear to before drawing this {@link RenderPass} */\r\n  clearValue?: GPUColor\r\n  /** Optional format of the color attachment texture */\r\n  targetFormat: GPUTextureFormat\r\n}\r\n\r\n/**\r\n * Parameters used to create this {@link RenderPass}\r\n */\r\nexport interface RenderPassParams {\r\n  /** The label of the {@link RenderPass}, sent to various GPU objects for debugging purpose */\r\n  label?: string\r\n\r\n  /** Whether the {@link RenderPass | view and depth textures} should use multisampling or not */\r\n  sampleCount?: GPUSize32\r\n\r\n  /** Force all the {@link RenderPass} textures size to be set to the given ratio of the {@link core/renderers/GPURenderer.GPURenderer#canvas | renderer canvas} size. Used mainly to lower the rendered definition. */\r\n  qualityRatio?: number\r\n\r\n  /** Whether this {@link RenderPass} should handle a view texture */\r\n  useColorAttachments?: boolean\r\n\r\n  /** Whether the main (first {@link colorAttachments}) view texture should use the content of the swap chain and render to it each frame */\r\n  renderToSwapChain?: boolean\r\n\r\n  /** Array of one or multiple (Multiple Render Targets) color attachments parameters. */\r\n  colorAttachments?: ColorAttachmentParams[]\r\n\r\n  /** Whether this {@link RenderPass} should handle a depth texture */\r\n  useDepth?: boolean\r\n  /** Whether this {@link RenderPass} should use an already created depth texture */\r\n  depthTexture?: Texture\r\n  /** The {@link GPULoadOp | depth load operation} to perform while drawing this {@link RenderPass} */\r\n  depthLoadOp?: GPULoadOp\r\n  /** The {@link GPUStoreOp | depth store operation} to perform while drawing this {@link RenderPass} */\r\n  depthStoreOp?: GPUStoreOp\r\n  /** The depth clear value to clear to before drawing this {@link RenderPass} */\r\n  depthClearValue?: number\r\n  /** Optional format of the depth texture */\r\n  depthFormat?: GPUTextureFormat\r\n}\r\n\r\n/**\r\n * Used by {@link core/renderPasses/RenderTarget.RenderTarget | RenderTarget} and the {@link Renderer} to render to one or multiple {@link RenderPass#viewTextures | view textures} (and optionally a {@link RenderPass#depthTexture | depth texture}), using a specific {@link GPURenderPassDescriptor | render pass descriptor}.\r\n */\r\nexport class RenderPass {\r\n  /** {@link Renderer} used by this {@link RenderPass} */\r\n  renderer: Renderer\r\n  /** The type of the {@link RenderPass} */\r\n  type: string\r\n  /** The universal unique id of this {@link RenderPass} */\r\n  readonly uuid: string\r\n\r\n  /** Options used to create this {@link RenderPass} */\r\n  options: RenderPassParams\r\n\r\n  /** Depth {@link Texture} to use with this {@link RenderPass} if it should handle depth */\r\n  depthTexture: Texture | undefined\r\n\r\n  /** Array of {@link Texture} used for this {@link RenderPass} color attachments view textures */\r\n  viewTextures: Texture[]\r\n\r\n  /** Array of {@link Texture} used for this {@link RenderPass} color attachments resolve textures */\r\n  resolveTargets: Array<null | Texture>\r\n\r\n  /** The {@link RenderPass} {@link GPURenderPassDescriptor | descriptor} */\r\n  descriptor: GPURenderPassDescriptor\r\n\r\n  /**\r\n   * RenderPass constructor\r\n   * @param renderer - {@link Renderer} object or {@link GPUCurtains} class object used to create this {@link RenderPass}\r\n   * @param parameters - {@link RenderPassParams | parameters} used to create this {@link RenderPass}\r\n   */\r\n  constructor(\r\n    renderer: Renderer | GPUCurtains,\r\n    {\r\n      label = 'Render Pass',\r\n      sampleCount = 4,\r\n      qualityRatio = 1,\r\n      // color\r\n      useColorAttachments = true,\r\n      renderToSwapChain = true,\r\n      colorAttachments = [],\r\n      // depth\r\n      useDepth = true,\r\n      depthTexture = null,\r\n      depthLoadOp = 'clear' as GPULoadOp,\r\n      depthStoreOp = 'store' as GPUStoreOp,\r\n      depthClearValue = 1,\r\n      depthFormat = 'depth24plus' as GPUTextureFormat,\r\n    } = {} as RenderPassParams\r\n  ) {\r\n    renderer = isRenderer(renderer, 'RenderPass')\r\n\r\n    this.type = 'RenderPass'\r\n    this.uuid = generateUUID()\r\n\r\n    this.renderer = renderer\r\n\r\n    if (useColorAttachments) {\r\n      const defaultColorAttachment = {\r\n        loadOp: 'clear' as GPULoadOp,\r\n        storeOp: 'store' as GPUStoreOp,\r\n        clearValue: [0, 0, 0, 0] as GPUColor,\r\n        targetFormat: this.renderer.options.preferredFormat,\r\n      }\r\n\r\n      if (!colorAttachments.length) {\r\n        colorAttachments = [defaultColorAttachment]\r\n      } else {\r\n        colorAttachments = colorAttachments.map((colorAttachment) => {\r\n          return { ...defaultColorAttachment, ...colorAttachment }\r\n        })\r\n      }\r\n    }\r\n\r\n    this.options = {\r\n      label,\r\n      sampleCount,\r\n      qualityRatio,\r\n      // color\r\n      useColorAttachments,\r\n      renderToSwapChain,\r\n      colorAttachments,\r\n      // depth\r\n      useDepth,\r\n      ...(depthTexture !== undefined && { depthTexture }),\r\n      depthLoadOp,\r\n      depthStoreOp,\r\n      depthClearValue,\r\n      depthFormat,\r\n    }\r\n\r\n    // if needed, create a depth texture before our descriptor\r\n    if (this.options.useDepth) {\r\n      this.createDepthTexture()\r\n    }\r\n\r\n    // if needed, create a view texture before our descriptor\r\n    this.viewTextures = []\r\n    this.resolveTargets = []\r\n    if (this.options.useColorAttachments && (!this.options.renderToSwapChain || this.options.sampleCount > 1)) {\r\n      this.createViewTextures()\r\n      this.createResolveTargets()\r\n    }\r\n\r\n    this.setRenderPassDescriptor()\r\n  }\r\n\r\n  /**\r\n   * Create and set our {@link depthTexture | depth texture}\r\n   */\r\n  createDepthTexture() {\r\n    if (this.options.depthTexture) {\r\n      this.depthTexture = this.options.depthTexture\r\n      // adjust depth format as well\r\n      this.options.depthFormat = this.options.depthTexture.options.format\r\n    } else {\r\n      this.depthTexture = new Texture(this.renderer, {\r\n        label: this.options.label + ' depth texture',\r\n        name: 'depthTexture',\r\n        format: this.options.depthFormat,\r\n        sampleCount: this.options.sampleCount,\r\n        qualityRatio: this.options.qualityRatio,\r\n        type: 'depth',\r\n        usage: ['renderAttachment', 'textureBinding'],\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create and set our {@link viewTextures | view textures}\r\n   */\r\n  createViewTextures() {\r\n    this.options.colorAttachments.forEach((colorAttachment, index) => {\r\n      this.viewTextures.push(\r\n        new Texture(this.renderer, {\r\n          label: `${this.options.label} colorAttachment[${index}] view texture`,\r\n          name: `colorAttachment${index}ViewTexture`,\r\n          format: colorAttachment.targetFormat,\r\n          sampleCount: this.options.sampleCount,\r\n          qualityRatio: this.options.qualityRatio,\r\n          type: 'texture',\r\n          usage: ['copySrc', 'copyDst', 'renderAttachment', 'textureBinding'],\r\n        })\r\n      )\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Create and set our {@link resolveTargets | resolve targets} in case the {@link viewTextures} are multisampled.\r\n   *\r\n   * Note that if this {@link RenderPass} should {@link RenderPassParams#renderToSwapChain | render to the swap chain}, the first resolve target will be set to `null` as the current swap chain texture will be used anyway in the render loop (see {@link updateView}).\r\n   */\r\n  createResolveTargets() {\r\n    if (this.options.sampleCount > 1) {\r\n      this.options.colorAttachments.forEach((colorAttachment, index) => {\r\n        this.resolveTargets.push(\r\n          this.options.renderToSwapChain && index === 0\r\n            ? null\r\n            : new Texture(this.renderer, {\r\n                label: `${this.options.label} resolve target[${index}] texture`,\r\n                name: `resolveTarget${index}Texture`,\r\n                format: colorAttachment.targetFormat,\r\n                sampleCount: 1,\r\n                qualityRatio: this.options.qualityRatio,\r\n                type: 'texture',\r\n              })\r\n        )\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the textures outputted by this {@link RenderPass}, which means the {@link viewTextures} if not multisampled, or their {@link resolveTargets} else (beware that the first resolve target might be `null` if this {@link RenderPass} should {@link RenderPassParams#renderToSwapChain | render to the swap chain}).\r\n   *\r\n   * @readonly\r\n   */\r\n  get outputTextures(): Texture[] {\r\n    return this.options.sampleCount > 1 ? this.resolveTargets : this.viewTextures\r\n  }\r\n\r\n  /**\r\n   * Set our render pass {@link descriptor}\r\n   */\r\n  setRenderPassDescriptor(depthTextureView = null) {\r\n    this.descriptor = {\r\n      label: this.options.label + ' descriptor',\r\n      colorAttachments: this.options.colorAttachments.map((colorAttachment, index) => {\r\n        return {\r\n          // view\r\n          view: this.viewTextures[index]?.texture.createView({\r\n            label: this.viewTextures[index]?.texture.label + ' view',\r\n          }),\r\n          ...(this.resolveTargets.length && {\r\n            resolveTarget: this.resolveTargets[index]?.texture.createView({\r\n              label: this.resolveTargets[index]?.texture.label + ' view',\r\n            }),\r\n          }),\r\n          // clear values\r\n          clearValue: colorAttachment.clearValue,\r\n          // loadOp: 'clear' specifies to clear the texture to the clear value before drawing\r\n          // The other option is 'load' which means load the existing contents of the texture into the GPU so we can draw over what's already there.\r\n          loadOp: colorAttachment.loadOp,\r\n          // storeOp: 'store' means store the result of what we draw.\r\n          // We could also pass 'discard' which would throw away what we draw.\r\n          // see https://webgpufundamentals.org/webgpu/lessons/webgpu-multisampling.html\r\n          storeOp: colorAttachment.storeOp,\r\n        }\r\n      }),\r\n\r\n      ...(this.options.useDepth && {\r\n        depthStencilAttachment: {\r\n          view:\r\n            depthTextureView ||\r\n            this.depthTexture.texture.createView({\r\n              label: this.depthTexture.texture.label + ' view',\r\n            }),\r\n          depthClearValue: this.options.depthClearValue,\r\n          // the same way loadOp is working, we can specify if we want to clear or load the previous depth buffer result\r\n          depthLoadOp: this.options.depthLoadOp,\r\n          depthStoreOp: this.options.depthStoreOp,\r\n        },\r\n      }),\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resize our {@link RenderPass}: reset its {@link Texture}\r\n   */\r\n  resize() {\r\n    // reassign textures\r\n    if (this.options.useDepth) {\r\n      this.descriptor.depthStencilAttachment.view = this.depthTexture.texture.createView({\r\n        label: this.depthTexture.options.label + ' view',\r\n      })\r\n    }\r\n\r\n    this.viewTextures.forEach((viewTexture, index) => {\r\n      this.descriptor.colorAttachments[index].view = viewTexture.texture.createView({\r\n        label: viewTexture.options.label + ' view',\r\n      })\r\n    })\r\n\r\n    this.resolveTargets.forEach((resolveTarget, index) => {\r\n      if (resolveTarget) {\r\n        this.descriptor.colorAttachments[index].resolveTarget = resolveTarget.texture.createView({\r\n          label: resolveTarget.options.label + ' view',\r\n        })\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Set the {@link descriptor} {@link GPULoadOp | load operation}\r\n   * @param loadOp - new {@link GPULoadOp | load operation} to use\r\n   * @param colorAttachmentIndex - index of the color attachment for which to use this load operation\r\n   */\r\n  setLoadOp(loadOp: GPULoadOp = 'clear', colorAttachmentIndex = 0) {\r\n    if (this.options.useColorAttachments) {\r\n      if (this.options.colorAttachments[colorAttachmentIndex]) {\r\n        this.options.colorAttachments[colorAttachmentIndex].loadOp = loadOp\r\n      }\r\n\r\n      if (this.descriptor) {\r\n        if (this.descriptor.colorAttachments && this.descriptor.colorAttachments[colorAttachmentIndex]) {\r\n          this.descriptor.colorAttachments[colorAttachmentIndex].loadOp = loadOp\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the {@link descriptor} {@link GPULoadOp | depth load operation}\r\n   * @param depthLoadOp - new {@link GPULoadOp | depth load operation} to use\r\n   */\r\n  setDepthLoadOp(depthLoadOp: GPULoadOp = 'clear') {\r\n    this.options.depthLoadOp = depthLoadOp\r\n    if (this.options.useDepth && this.descriptor.depthStencilAttachment) {\r\n      this.descriptor.depthStencilAttachment.depthLoadOp = depthLoadOp\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set our {@link GPUColor | clear colors value}.<br>\r\n   * Beware that if the {@link renderer} is using {@link core/renderers/GPURenderer.GPURenderer#alphaMode | premultiplied alpha mode}, your R, G and B channels should be premultiplied by your alpha channel.\r\n   * @param clearValue - new {@link GPUColor | clear colors value} to use\r\n   * @param colorAttachmentIndex - index of the color attachment for which to use this clear value\r\n   */\r\n  setClearValue(clearValue: GPUColor = [0, 0, 0, 0], colorAttachmentIndex = 0) {\r\n    if (this.options.useColorAttachments) {\r\n      if (this.renderer.alphaMode === 'premultiplied') {\r\n        const alpha = clearValue[3]\r\n        clearValue[0] = Math.min(clearValue[0], alpha)\r\n        clearValue[1] = Math.min(clearValue[1], alpha)\r\n        clearValue[2] = Math.min(clearValue[2], alpha)\r\n      }\r\n\r\n      if (this.options.colorAttachments[colorAttachmentIndex]) {\r\n        this.options.colorAttachments[colorAttachmentIndex].clearValue = clearValue\r\n      }\r\n\r\n      if (this.descriptor) {\r\n        if (this.descriptor.colorAttachments && this.descriptor.colorAttachments[colorAttachmentIndex]) {\r\n          this.descriptor.colorAttachments[colorAttachmentIndex].clearValue = clearValue\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the current {@link descriptor} texture {@link GPURenderPassColorAttachment#view | view} and {@link GPURenderPassColorAttachment#resolveTarget | resolveTarget} (depending on whether we're using multisampling)\r\n   * @param renderTexture - {@link GPUTexture} to use, or the {@link core/renderers/GPURenderer.GPURenderer#context | context} {@link GPUTexture | current texture} if null.\r\n   * @returns - the {@link GPUTexture | texture} to render to.\r\n   */\r\n  updateView(renderTexture: GPUTexture | null = null): GPUTexture | null {\r\n    if (!this.options.colorAttachments.length || !this.options.renderToSwapChain) {\r\n      return renderTexture\r\n    }\r\n\r\n    if (!renderTexture) {\r\n      renderTexture = this.renderer.context.getCurrentTexture()\r\n      renderTexture.label = `${this.renderer.type} context current texture`\r\n    }\r\n\r\n    if (this.options.sampleCount > 1) {\r\n      this.descriptor.colorAttachments[0].view = this.viewTextures[0].texture.createView({\r\n        label: this.viewTextures[0].options.label + ' view',\r\n      })\r\n      this.descriptor.colorAttachments[0].resolveTarget = renderTexture.createView({\r\n        label: renderTexture.label + ' resolve target view',\r\n      })\r\n    } else {\r\n      this.descriptor.colorAttachments[0].view = renderTexture.createView({\r\n        label: renderTexture.label + ' view',\r\n      })\r\n    }\r\n\r\n    return renderTexture\r\n  }\r\n\r\n  /**\r\n   * Destroy our {@link RenderPass}\r\n   */\r\n  destroy() {\r\n    this.viewTextures.forEach((viewTexture) => viewTexture.destroy())\r\n    this.resolveTargets.forEach((resolveTarget) => resolveTarget?.destroy())\r\n\r\n    if (!this.options.depthTexture && this.depthTexture) {\r\n      this.depthTexture.destroy()\r\n    }\r\n  }\r\n}\r\n","import { isRenderer, Renderer } from '../renderers/utils'\r\nimport { RenderPass, RenderPassParams } from './RenderPass'\r\nimport { Texture } from '../textures/Texture'\r\nimport { generateUUID } from '../../utils/utils'\r\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\r\n\r\n/**\r\n * Parameters used to create a {@link RenderTarget}\r\n */\r\nexport interface RenderTargetParams extends RenderPassParams {\r\n  /** Whether we should add this {@link RenderTarget} to our {@link core/scenes/Scene.Scene | Scene} to let it handle the rendering process automatically */\r\n  autoRender?: boolean\r\n}\r\n\r\n/**\r\n * Used to draw to {@link RenderPass#viewTextures | RenderPass view textures} (and eventually {@link RenderPass#depthTexture | depth texture}) instead of directly to screen.\r\n *\r\n * The meshes assigned to a {@link RenderTarget} will be drawn before the other objects in the {@link core/scenes/Scene.Scene | Scene} rendering loop.\r\n *\r\n * Can also be assigned as ShaderPass {@link core/renderPasses/ShaderPass.ShaderPass#inputTarget | input} or {@link core/renderPasses/ShaderPass.ShaderPass#outputTarget | output} targets.\r\n *\r\n * If the {@link RenderPass} created handle color attachments, then a {@link RenderTarget#renderTexture | Texture} will be created to update and/or resolve the content of the current view. This {@link RenderTarget#renderTexture | Texture} could therefore usually be used to access the current content of this {@link RenderTarget}.\r\n *\r\n * @example\r\n * ```javascript\r\n * // set our main GPUCurtains instance\r\n * const gpuCurtains = new GPUCurtains({\r\n *   container: '#canvas' // selector of our WebGPU canvas container\r\n * })\r\n *\r\n * // set the GPU device\r\n * // note this is asynchronous\r\n * await gpuCurtains.setDevice()\r\n *\r\n * const outputTarget = new RenderTarget(gpuCurtains, {\r\n *   label: 'My render target',\r\n * })\r\n * ```\r\n */\r\nexport class RenderTarget {\r\n  /** {@link Renderer} used by this {@link RenderTarget} */\r\n  renderer: Renderer\r\n  /** The type of the {@link RenderTarget} */\r\n  type: string\r\n  /** The universal unique id of this {@link RenderTarget} */\r\n  readonly uuid: string\r\n\r\n  /** Options used to create this {@link RenderTarget} */\r\n  options: RenderTargetParams\r\n\r\n  /** {@link RenderPass} used by this {@link RenderTarget} */\r\n  renderPass: RenderPass\r\n  /** {@link Texture} that will be resolved by the {@link renderPass} when {@link RenderPass#updateView | setting the current texture} */\r\n  renderTexture?: Texture\r\n\r\n  /** Whether we should add this {@link RenderTarget} to our {@link core/scenes/Scene.Scene | Scene} to let it handle the rendering process automatically */\r\n  #autoRender = true\r\n\r\n  /**\r\n   * RenderTarget constructor\r\n   * @param renderer - {@link Renderer} object or {@link GPUCurtains} class object used to create this {@link RenderTarget}\r\n   * @param parameters - {@link RenderTargetParams | parameters} use to create this {@link RenderTarget}\r\n   */\r\n  constructor(renderer: Renderer | GPUCurtains, parameters = {} as RenderTargetParams) {\r\n    renderer = isRenderer(renderer, 'RenderTarget')\r\n\r\n    this.type = 'RenderTarget'\r\n    this.renderer = renderer\r\n    this.uuid = generateUUID()\r\n\r\n    const { label, colorAttachments, depthTexture, autoRender, ...renderPassParams } = parameters\r\n\r\n    // use depth texture from params\r\n    // OR renderer render pass depth texture if sample counts match\r\n    const depthTextureToUse = !!depthTexture\r\n      ? depthTexture\r\n      : this.renderer.renderPass.options.sampleCount === (parameters.sampleCount ?? 4)\r\n      ? this.renderer.renderPass.depthTexture\r\n      : null\r\n\r\n    this.options = {\r\n      label,\r\n      ...renderPassParams,\r\n      ...(depthTextureToUse && { depthTexture: depthTextureToUse }),\r\n      ...(colorAttachments && { colorAttachments }),\r\n      autoRender: autoRender === undefined ? true : autoRender,\r\n    } as RenderTargetParams\r\n\r\n    if (autoRender !== undefined) {\r\n      this.#autoRender = autoRender\r\n    }\r\n\r\n    this.renderPass = new RenderPass(this.renderer, {\r\n      label: this.options.label ? `${this.options.label} Render Pass` : 'Render Target Render Pass',\r\n      ...(colorAttachments && { colorAttachments }),\r\n      depthTexture: this.options.depthTexture,\r\n      ...renderPassParams,\r\n    })\r\n\r\n    if (renderPassParams.useColorAttachments !== false) {\r\n      // this is the texture that will be resolved when setting the current render pass texture\r\n      this.renderTexture = new Texture(this.renderer, {\r\n        label: this.options.label ? `${this.options.label} Render Texture` : 'Render Target render texture',\r\n        name: 'renderTexture',\r\n        format:\r\n          colorAttachments && colorAttachments.length && colorAttachments[0].targetFormat\r\n            ? colorAttachments[0].targetFormat\r\n            : this.renderer.options.preferredFormat,\r\n        ...(this.options.qualityRatio !== undefined && { qualityRatio: this.options.qualityRatio }),\r\n        usage: ['copySrc', 'renderAttachment', 'textureBinding'],\r\n      })\r\n    }\r\n\r\n    this.addToScene()\r\n  }\r\n\r\n  /**\r\n   * Get the textures outputted by the {@link renderPass} if any, which means its {@link RenderPass.viewTextures | viewTextures} if not multisampled, or the {@link RenderPass.resolveTargets | resolveTargets} else.\r\n   *\r\n   * Since some {@link RenderPass} might not have any view textures (or in case the first resolve target is `null`), the first element can be the {@link RenderTarget.renderTexture | RenderTarget renderTexture} itself.\r\n   *\r\n   * @readonly\r\n   */\r\n  get outputTextures(): Texture[] {\r\n    return !this.renderPass.outputTextures.length\r\n      ? !this.renderTexture\r\n        ? []\r\n        : [this.renderTexture]\r\n      : this.renderPass.outputTextures.map((texture, index) => {\r\n          return index === 0 && this.renderPass.options.renderToSwapChain ? this.renderTexture : texture\r\n        })\r\n  }\r\n\r\n  /**\r\n   * Add the {@link RenderTarget} to the renderer and the {@link core/scenes/Scene.Scene | Scene}\r\n   */\r\n  addToScene() {\r\n    this.renderer.renderTargets.push(this)\r\n\r\n    if (this.#autoRender) {\r\n      this.renderer.scene.addRenderTarget(this)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove the {@link RenderTarget} from the renderer and the {@link core/scenes/Scene.Scene | Scene}\r\n   */\r\n  removeFromScene() {\r\n    if (this.#autoRender) {\r\n      this.renderer.scene.removeRenderTarget(this)\r\n    }\r\n\r\n    this.renderer.renderTargets = this.renderer.renderTargets.filter((renderTarget) => renderTarget.uuid !== this.uuid)\r\n  }\r\n\r\n  /**\r\n   * Resize our {@link renderPass}\r\n   */\r\n  resize() {\r\n    // reset the newly created depth texture\r\n    if (this.options.depthTexture) {\r\n      this.renderPass.options.depthTexture.texture = this.options.depthTexture.texture\r\n    }\r\n\r\n    this.renderPass?.resize()\r\n  }\r\n\r\n  /**\r\n   * Remove our {@link RenderTarget}. Alias of {@link RenderTarget#destroy}\r\n   */\r\n  remove() {\r\n    this.destroy()\r\n  }\r\n\r\n  /**\r\n   * Destroy our {@link RenderTarget}\r\n   */\r\n  destroy() {\r\n    // release mesh struct\r\n    this.renderer.meshes.forEach((mesh) => {\r\n      if (mesh.outputTarget && mesh.outputTarget.uuid === this.uuid) {\r\n        mesh.setOutputTarget(null)\r\n      }\r\n    })\r\n\r\n    // release shader passes struct\r\n    this.renderer.shaderPasses.forEach((shaderPass) => {\r\n      if (shaderPass.outputTarget && shaderPass.outputTarget.uuid === this.uuid) {\r\n        // force render target to null before removing / re-adding to scene\r\n        shaderPass.outputTarget = null\r\n        shaderPass.setOutputTarget(null)\r\n      }\r\n    })\r\n\r\n    // remove from scene and renderer array\r\n    this.removeFromScene()\r\n\r\n    this.renderPass?.destroy()\r\n    this.renderTexture?.destroy()\r\n  }\r\n}\r\n","import { isRenderer, Renderer } from '../renderers/utils'\nimport { PipelineEntryOptions, PipelineEntryParams, PipelineEntryStatus } from '../../types/PipelineEntries'\nimport { AllowedBindGroups } from '../../types/BindGroups'\nimport { MaterialShadersType } from '../../types/Materials'\n\nlet pipelineId = 0\n\n/**\n * Used as a base class to create a pipeline entry.<br>\n * {@link PipelineEntry} roles are:\n * - Patch the given {@link core/materials/Material.Material | Material} shaders code and create the corresponding {@link GPUShaderModule}.\n * - Create a {@link GPUPipelineLayout | pipeline layout} with the given {@link core/materials/Material.Material#bindGroups | bind groups}\n * - Create a GPU pipeline\n */\nexport class PipelineEntry {\n  /** The type of the {@link PipelineEntry} */\n  type: string\n  /** The {@link Renderer} used to create this {@link PipelineEntry} */\n  renderer: Renderer\n  /** Index of this {@link PipelineEntry}, i.e. creation order */\n  readonly index: number\n  /** {@link GPUPipelineLayout | Pipeline layout} created based on the given {@link bindGroups | bind groups} */\n  layout: GPUPipelineLayout | null\n  /** The GPU pipeline */\n  pipeline: GPURenderPipeline | GPUComputePipeline | null\n  /** The pipeline {@link PipelineEntryStatus | compilation status} */\n  status: PipelineEntryStatus\n  /** Options used to create this {@link PipelineEntry} */\n  options: PipelineEntryOptions\n\n  /** {@link core/materials/Material.Material#bindGroups | bind groups} used to patch the shaders and create the {@link PipelineEntry#layout | pipeline layout} */\n  bindGroups: AllowedBindGroups[]\n\n  /**\n   * PipelineEntry constructor\n   * @param parameters - {@link PipelineEntryParams | parameters} used to create this {@link PipelineEntry}\n   */\n  constructor(parameters: PipelineEntryParams) {\n    this.type = 'PipelineEntry'\n\n    let { renderer } = parameters\n    const { label, shaders, useAsync } = parameters\n\n    renderer = isRenderer(renderer, label ? label + ' ' + this.type : this.type)\n\n    this.renderer = renderer\n\n    Object.defineProperty(this as PipelineEntry, 'index', { value: pipelineId++ })\n\n    this.layout = null\n    this.pipeline = null\n\n    this.status = {\n      compiling: false,\n      compiled: false,\n      error: null,\n    }\n\n    this.options = {\n      label,\n      shaders,\n      useAsync: useAsync !== undefined ? useAsync : true,\n    }\n  }\n\n  /**\n   * Get whether the {@link pipeline} is ready, i.e. successfully compiled\n   * @readonly\n   */\n  get ready(): boolean {\n    return !this.status.compiling && this.status.compiled && !this.status.error\n  }\n\n  /**\n   * Get whether the {@link pipeline} is ready to be compiled, i.e. we have not already tried to compile it, and it's not currently compiling neither\n   * @readonly\n   */\n  get canCompile(): boolean {\n    return !this.status.compiling && !this.status.compiled && !this.status.error\n  }\n\n  /**\n   * Set our {@link PipelineEntry#bindGroups | pipeline entry bind groups}\n   * @param bindGroups - {@link core/materials/Material.Material#bindGroups | bind groups} to use with this {@link PipelineEntry}\n   */\n  setPipelineEntryBindGroups(bindGroups: AllowedBindGroups[]) {\n    this.bindGroups = bindGroups\n  }\n\n  /* SHADERS */\n\n  /**\n   * Create a {@link GPUShaderModule}\n   * @param parameters - Parameters used\n   * @param parameters.code - patched WGSL code string\n   * @param parameters.type - {@link MaterialShadersType | shader type}\n   * @returns - compiled {@link GPUShaderModule} if successful\n   */\n  createShaderModule({ code = '', type = 'vertex' }: { code: string; type: MaterialShadersType }): GPUShaderModule {\n    const shaderModule = this.renderer.createShaderModule({\n      label: this.options.label + ': ' + type + ' shader module',\n      code,\n    })\n\n    if ('getCompilationInfo' in shaderModule && !this.renderer.production) {\n      shaderModule.getCompilationInfo().then((compilationInfo) => {\n        for (const message of compilationInfo.messages) {\n          let formattedMessage = ''\n          if (message.lineNum) {\n            formattedMessage += `Line ${message.lineNum}:${message.linePos} - ${code.substring(\n              message.offset,\n              message.offset + message.length\n            )}\\n`\n          }\n          formattedMessage += message.message\n\n          switch (message.type) {\n            case 'error':\n              // TODO mesh onError?\n              console.error(`${this.options.label} compilation error:\\n${formattedMessage}`)\n              break\n            case 'warning':\n              console.warn(`${this.options.label} compilation warning:\\n${formattedMessage}`)\n              break\n            case 'info':\n              console.log(`${this.options.label} compilation information:\\n${formattedMessage}`)\n              break\n          }\n        }\n      })\n    }\n\n    return shaderModule\n  }\n\n  /* SETUP */\n\n  /**\n   * Create the {@link PipelineEntry} shaders\n   */\n  createShaders() {\n    /* will be overriden */\n  }\n\n  /**\n   * Create the pipeline entry {@link layout}\n   */\n  createPipelineLayout() {\n    this.layout = this.renderer.createPipelineLayout({\n      label: this.options.label + ' layout',\n      bindGroupLayouts: this.bindGroups.map((bindGroup) => bindGroup.bindGroupLayout),\n    })\n  }\n\n  /**\n   * Create the {@link PipelineEntry} descriptor\n   */\n  createPipelineDescriptor() {\n    /* will be overriden */\n  }\n\n  /**\n   * Flush a {@link PipelineEntry}, i.e. reset its {@link bindGroups | bind groups}, {@link layout} and descriptor and recompile the {@link pipeline}\n   * Used when one of the bind group or rendering property has changed\n   * @param newBindGroups - new {@link bindGroups | bind groups} in case they have changed\n   */\n  flushPipelineEntry(newBindGroups: AllowedBindGroups[] = []) {\n    this.status.compiling = false\n    this.status.compiled = false\n    this.status.error = null\n\n    this.setPipelineEntryBindGroups(newBindGroups)\n    this.compilePipelineEntry()\n  }\n\n  /**\n   * Set up a {@link pipeline} by creating the shaders, the {@link layout} and the descriptor\n   */\n  compilePipelineEntry() {\n    this.status.compiling = true\n\n    this.createShaders()\n    this.createPipelineLayout()\n    this.createPipelineDescriptor()\n  }\n}\n","export default /* wgsl */ `\r\nfn getWorldPosition(position: vec3f) -> vec4f {\r\n  return matrices.model * vec4f(position, 1.0);\r\n}\r\n\r\nfn getOutputPosition(position: vec3f) -> vec4f {\r\n  return camera.projection * matrices.modelView * vec4f(position, 1.0);\r\n}`\r\n","export default /* wgsl */ `\r\nfn getWorldNormal(normal: vec3f) -> vec3f {\r\n  return normalize(matrices.normal * normal);\r\n}\r\n\r\nfn getViewNormal(normal: vec3f) -> vec3f {\r\n  return normalize((camera.view * vec4(matrices.normal * normal, 0.0)).xyz);\r\n}`\r\n","export default /* wgsl */ `\r\nfn getUVCover(uv: vec2f, textureMatrix: mat4x4f) -> vec2f {\r\n  return (textureMatrix * vec4f(uv, 0.0, 1.0)).xy;\r\n}`\r\n","export default /* wgsl */ `\r\nfn getVertex2DToUVCoords(vertex: vec2f) -> vec2f {\r\n  return vec2(\r\n    vertex.x * 0.5 + 0.5,\r\n    0.5 - vertex.y * 0.5\r\n  );\r\n}\r\n\r\nfn getVertex3DToUVCoords(vertex: vec3f) -> vec2f {\r\n  return getVertex2DToUVCoords( vec2(vertex.x, vertex.y) );\r\n}\r\n`\r\n","import { RenderMaterialShadersType } from '../../types/Materials'\r\nimport get_output_position from './chunks/helpers/get_output_position.wgsl'\r\nimport get_normals from './chunks/helpers/get_normals.wgsl'\r\nimport get_uv_cover from './chunks/helpers/get_uv_cover.wgsl'\r\nimport get_vertex_to_uv_coords from './chunks/helpers/get_vertex_to_uv_coords.wgsl'\r\n\r\n/** Defines {@link ShaderChunks} object structure */\r\nexport type ShaderChunks = Record<RenderMaterialShadersType, Record<string, string>>\r\n/** Defines {@link ProjectedShaderChunks} object structure */\r\nexport type ProjectedShaderChunks = Record<RenderMaterialShadersType, Record<string, string>>\r\n\r\n/**\r\n * Useful WGSL code chunks added to the vertex and/or fragment shaders\r\n */\r\nexport const ShaderChunks = {\r\n  /** WGSL code chunks added to the vertex shader */\r\n  vertex: {\r\n    /** Applies given texture matrix to given uv coordinates */\r\n    get_uv_cover,\r\n  },\r\n  /** WGSL code chunks added to the fragment shader */\r\n  fragment: {\r\n    /** Applies given texture matrix to given uv coordinates */\r\n    get_uv_cover,\r\n    /** Convert vertex position to uv coordinates */\r\n    get_vertex_to_uv_coords,\r\n  },\r\n} as ShaderChunks\r\n\r\n/**\r\n * Useful WGSL code chunks added to the projected Meshes vertex and/or fragment shaders\r\n */\r\nexport const ProjectedShaderChunks = {\r\n  /** WGSL code chunks added to the vertex shader */\r\n  vertex: {\r\n    /** Get output vec4f position vector by applying model view projection matrix to vec3f attribute position vector */\r\n    get_output_position,\r\n    /** Get vec3f normals in world or view space */\r\n    get_normals,\r\n  },\r\n  /** WGSL code chunks added to the fragment shader */\r\n  fragment: {},\r\n} as ProjectedShaderChunks\r\n","import { PipelineEntry } from './PipelineEntry'\r\nimport { ProjectedShaderChunks, ShaderChunks } from '../shaders/ShaderChunks'\r\nimport { isRenderer, Renderer } from '../renderers/utils'\r\nimport { throwError } from '../../utils/utils'\r\nimport {\r\n  PipelineEntryShaders,\r\n  RenderPipelineEntryOptions,\r\n  RenderPipelineEntryParams,\r\n  RenderPipelineEntryPropertiesParams,\r\n} from '../../types/PipelineEntries'\r\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\r\nimport { AllowedBindGroups, BindGroupBufferBindingElement } from '../../types/BindGroups'\r\nimport { RenderMaterialAttributes, ShaderOptions } from '../../types/Materials'\r\n\r\n/**\r\n * Used to create a {@link PipelineEntry} specifically designed to handle {@link core/materials/RenderMaterial.RenderMaterial | RenderMaterial}.\r\n *\r\n * ## Shaders patching\r\n *\r\n * The {@link RenderPipelineEntry} uses each of its {@link RenderPipelineEntry#bindGroups | bind groups} {@link core/bindings/Binding.Binding | Binding} to patch the given vertex and fragment shaders before creating the {@link GPUShaderModule}.<br>\r\n * It will prepend every {@link core/bindings/Binding.Binding | Binding} WGSL code snippets (or fragments) with the correct bind group and bindings indices.\r\n *\r\n * ## Pipeline compilation\r\n *\r\n * The {@link RenderPipelineEntry} will then create a {@link GPURenderPipeline} (asynchronously by default).\r\n *\r\n * ## Default attributes and uniforms\r\n *\r\n * ### Attributes\r\n *\r\n * Attributes are only added to the vertex shaders. They are generated based on the {@link core/geometries/Geometry.Geometry | Geometry} used and may vary in case you're using a geometry with custom attributes. Here are the default ones:\r\n *\r\n * ```wgsl\r\n * struct Attributes {\r\n *  @builtin(vertex_index) vertexIndex : u32,\r\n *  @builtin(instance_index) instanceIndex : u32,\r\n *  @location(0) position: vec3f,\r\n *  @location(1) uv: vec2f,\r\n *  @location(2) normal: vec3f\r\n * };\r\n *\r\n * // you can safely access them in your vertex shader\r\n * // using attributes.position or attributes.uv for example\r\n * ```\r\n *\r\n * ### Uniforms\r\n *\r\n * If the Mesh is one of {@link core/meshes/Mesh.Mesh | Mesh}, {@link curtains/meshes/DOMMesh.DOMMesh | DOMMesh} or {@link curtains/meshes/Plane.Plane | Plane}, some additional uniforms are added to the shaders.\r\n *\r\n * #### Vertex shaders\r\n *\r\n * ```wgsl\r\n * struct Matrices {\r\n * \tmodel: mat4x4f,\r\n * \tmodelView: mat4x4f,\r\n * \tnormal: mat3x3f\r\n * };\r\n *\r\n * struct Camera {\r\n * \tview: mat4x4f,\r\n * \tprojection: mat4x4f,\r\n * \tposition: vec3f\r\n * };\r\n *\r\n * @group(0) @binding(0) var<uniform> camera: Camera;\r\n *\r\n * // note that matrices uniform @group index might change depending on use cases\r\n * @group(1) @binding(0) var<uniform> matrices: Matrices;\r\n *\r\n * // you can safely access these uniforms in your vertex shader\r\n * // using matrices.modelView or camera.projection for example\r\n * ```\r\n *\r\n * #### Fragment shaders\r\n *\r\n * ```wgsl\r\n * struct Matrices {\r\n * \tmodel: mat4x4f,\r\n * \tmodelView: mat4x4f,\r\n * \tnormal: mat3x3f\r\n * };\r\n *\r\n * // note that matrices uniform @group index might change depending on use cases\r\n * @group(1) @binding(0) var<uniform> matrices: Matrices;\r\n *\r\n * // you can safely access these uniforms in your fragment shader\r\n * // using matrices.model or matrices.modelView for example\r\n * ```\r\n *\r\n * ### Helpers\r\n *\r\n * Finally, some helpers functions are added to the shaders as well.\r\n *\r\n * #### Vertex and fragment shaders\r\n *\r\n * To help you compute scaled UV based on a texture matrix, this function is always added to both vertex and fragment shaders:\r\n *\r\n * ```wgsl\r\n * fn getUVCover(uv: vec2f, textureMatrix: mat4x4f) -> vec2f {\r\n *   return (textureMatrix * vec4f(uv, 0.0, 1.0)).xy;\r\n * }\r\n * ```\r\n *\r\n * #### Vertex shaders\r\n *\r\n * If the Mesh is one of {@link core/meshes/Mesh.Mesh | Mesh}, {@link curtains/meshes/DOMMesh.DOMMesh | DOMMesh} or {@link curtains/meshes/Plane.Plane | Plane}, some functions are added to the vertex shader to help you compute the vertices positions and normals.\r\n *\r\n * ##### Position\r\n *\r\n * Position helper function:\r\n *\r\n * ```wgsl\r\n * fn getOutputPosition(position: vec3f) -> vec4f {\r\n *   return camera.projection * matrices.modelView * vec4f(position, 1.0);\r\n * }\r\n * ```\r\n *\r\n * Note that it is not mandatory to use it. If you want to do these computations yourself, you are free to do it the way you like most. You could for example use this formula instead:\r\n *\r\n * ```wgsl\r\n * var transformed: vec3f = camera.projection * camera.view * matrices.model * vec4f(position, 1.0);\r\n * ```\r\n *\r\n * ##### Normal\r\n *\r\n * The normal matrix provided, available as `matrices.normal`, is computed in world space (i.e. it is the inverse transpose of the world matrix). A couple helpers functions are added to help you compute the normals in the right space:\r\n *\r\n * ```wgsl\r\n * fn getWorldNormal(normal: vec3f) -> vec3f {\r\n *   return normalize(matrices.normal * normal);\r\n * }\r\n *\r\n * fn getViewNormal(normal: vec3f) -> vec3f {\r\n *   return normalize((camera.view * vec4(matrices.normal * normal, 0.0)).xyz);\r\n * }\r\n * ```\r\n *\r\n * #### Fragment shaders\r\n *\r\n * Last but not least, those couple functions are added to the fragment shaders to help you convert vertex positions to UV coordinates:\r\n *\r\n * ```wgsl\r\n * fn getVertex2DToUVCoords(vertex: vec2f) -> vec2f {\r\n *   return vec2(\r\n *     vertex.x * 0.5 + 0.5,\r\n *     0.5 - vertex.y * 0.5\r\n *   );\r\n * }\r\n *\r\n * fn getVertex3DToUVCoords(vertex: vec3f) -> vec2f {\r\n *   return getVertex2DToUVCoords( vec2(vertex.x, vertex.y) );\r\n * }\r\n * ```\r\n */\r\nexport class RenderPipelineEntry extends PipelineEntry {\r\n  /** Shaders to use with this {@link RenderPipelineEntry} */\r\n  shaders: PipelineEntryShaders\r\n  /** {@link RenderMaterialAttributes | Geometry attributes} sent to the {@link RenderPipelineEntry} */\r\n  attributes: RenderMaterialAttributes\r\n  /** {@link GPURenderPipelineDescriptor | Render pipeline descriptor} based on {@link layout} and {@link shaders} */\r\n  descriptor: GPURenderPipelineDescriptor | null\r\n  /** Options used to create this {@link RenderPipelineEntry} */\r\n  options: RenderPipelineEntryOptions\r\n\r\n  /**\r\n   * RenderPipelineEntry constructor\r\n   * @param parameters - {@link RenderPipelineEntryParams | parameters} used to create this {@link RenderPipelineEntry}\r\n   */\r\n  constructor(parameters: RenderPipelineEntryParams) {\r\n    // eslint-disable-next-line prefer-const\r\n    let { renderer, ...pipelineParams } = parameters\r\n    const { label, attributes, bindGroups, cacheKey, ...renderingOptions } = pipelineParams\r\n\r\n    const type = 'RenderPipelineEntry'\r\n\r\n    isRenderer(renderer, label ? label + ' ' + type : type)\r\n\r\n    super(parameters)\r\n\r\n    this.type = type\r\n\r\n    this.shaders = {\r\n      vertex: {\r\n        head: '',\r\n        code: '',\r\n        module: null,\r\n      },\r\n      fragment: {\r\n        head: '',\r\n        code: '',\r\n        module: null,\r\n      },\r\n      full: {\r\n        head: '',\r\n        code: '',\r\n        module: null,\r\n      },\r\n    }\r\n\r\n    this.descriptor = null\r\n\r\n    this.options = {\r\n      ...this.options,\r\n      attributes,\r\n      bindGroups,\r\n      cacheKey,\r\n      ...renderingOptions,\r\n    }\r\n\r\n    this.setPipelineEntryProperties({ attributes, bindGroups })\r\n  }\r\n\r\n  /**\r\n   * Set {@link RenderPipelineEntry} properties (in this case the {@link bindGroups | bind groups} and {@link attributes})\r\n   * @param parameters - the {@link core/materials/RenderMaterial.RenderMaterial#bindGroups | bind groups} and {@link core/materials/RenderMaterial.RenderMaterial#attributes | attributes} to use\r\n   */\r\n  setPipelineEntryProperties(parameters: RenderPipelineEntryPropertiesParams) {\r\n    const { attributes, bindGroups } = parameters\r\n\r\n    this.attributes = attributes\r\n\r\n    this.setPipelineEntryBindGroups(bindGroups)\r\n  }\r\n\r\n  /* SHADERS */\r\n\r\n  /**\r\n   * Patch the shaders by appending all the necessary shader chunks, {@link bindGroups | bind groups}) and {@link attributes} WGSL code fragments to the given {@link types/PipelineEntries.PipelineEntryParams#shaders | parameter shader code}\r\n   */\r\n  patchShaders() {\r\n    this.shaders.vertex.head = ''\r\n    this.shaders.vertex.code = ''\r\n    this.shaders.fragment.head = ''\r\n    this.shaders.fragment.code = ''\r\n    this.shaders.full.head = ''\r\n    this.shaders.full.code = ''\r\n\r\n    // first add chunks\r\n    for (const chunk in ShaderChunks.vertex) {\r\n      this.shaders.vertex.head = `${ShaderChunks.vertex[chunk]}\\n${this.shaders.vertex.head}`\r\n      this.shaders.full.head = `${ShaderChunks.vertex[chunk]}\\n${this.shaders.full.head}`\r\n    }\r\n\r\n    if (this.options.shaders.fragment) {\r\n      for (const chunk in ShaderChunks.fragment) {\r\n        this.shaders.fragment.head = `${ShaderChunks.fragment[chunk]}\\n${this.shaders.fragment.head}`\r\n\r\n        if (this.shaders.full.head.indexOf(ShaderChunks.fragment[chunk]) === -1) {\r\n          this.shaders.full.head = `${ShaderChunks.fragment[chunk]}\\n${this.shaders.full.head}`\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.options.rendering.useProjection) {\r\n      for (const chunk in ProjectedShaderChunks.vertex) {\r\n        this.shaders.vertex.head = `${ProjectedShaderChunks.vertex[chunk]}\\n${this.shaders.vertex.head}`\r\n        this.shaders.full.head = `${ProjectedShaderChunks.vertex[chunk]}\\n${this.shaders.full.head}`\r\n      }\r\n\r\n      if (this.options.shaders.fragment) {\r\n        for (const chunk in ProjectedShaderChunks.fragment) {\r\n          this.shaders.fragment.head = `${ProjectedShaderChunks.fragment[chunk]}\\n${this.shaders.fragment.head}`\r\n\r\n          if (this.shaders.full.head.indexOf(ProjectedShaderChunks.fragment[chunk]) === -1) {\r\n            this.shaders.full.head = `${ProjectedShaderChunks.fragment[chunk]}\\n${this.shaders.full.head}`\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const groupsBindings = []\r\n    for (const bindGroup of this.bindGroups) {\r\n      let bindIndex = 0\r\n      bindGroup.bindings.forEach((binding, bindingIndex) => {\r\n        binding.wgslGroupFragment.forEach((groupFragment, groupFragmentIndex) => {\r\n          groupsBindings.push({\r\n            groupIndex: bindGroup.index,\r\n            visibility: binding.options.visibility,\r\n            bindIndex,\r\n            wgslStructFragment: (binding as BindGroupBufferBindingElement).wgslStructFragment,\r\n            wgslGroupFragment: groupFragment,\r\n            newLine:\r\n              bindingIndex === bindGroup.bindings.length - 1 &&\r\n              groupFragmentIndex === binding.wgslGroupFragment.length - 1,\r\n          })\r\n\r\n          bindIndex++\r\n        })\r\n      })\r\n    }\r\n\r\n    for (const groupBinding of groupsBindings) {\r\n      if (groupBinding.visibility.includes('vertex')) {\r\n        // do not duplicate structs\r\n        if (\r\n          groupBinding.wgslStructFragment &&\r\n          this.shaders.vertex.head.indexOf(groupBinding.wgslStructFragment) === -1\r\n        ) {\r\n          this.shaders.vertex.head = `\\n${groupBinding.wgslStructFragment}\\n${this.shaders.vertex.head}`\r\n        }\r\n\r\n        // do not duplicate struct var as well\r\n        if (this.shaders.vertex.head.indexOf(groupBinding.wgslGroupFragment) === -1) {\r\n          this.shaders.vertex.head = `${this.shaders.vertex.head}\\n@group(${groupBinding.groupIndex}) @binding(${groupBinding.bindIndex}) ${groupBinding.wgslGroupFragment}`\r\n\r\n          if (groupBinding.newLine) this.shaders.vertex.head += `\\n`\r\n        }\r\n      }\r\n\r\n      if (this.options.shaders.fragment && groupBinding.visibility.includes('fragment')) {\r\n        // do not duplicate structs\r\n        if (\r\n          groupBinding.wgslStructFragment &&\r\n          this.shaders.fragment.head.indexOf(groupBinding.wgslStructFragment) === -1\r\n        ) {\r\n          this.shaders.fragment.head = `\\n${groupBinding.wgslStructFragment}\\n${this.shaders.fragment.head}`\r\n        }\r\n\r\n        // do not duplicate struct var as well\r\n        if (this.shaders.fragment.head.indexOf(groupBinding.wgslGroupFragment) === -1) {\r\n          this.shaders.fragment.head = `${this.shaders.fragment.head}\\n@group(${groupBinding.groupIndex}) @binding(${groupBinding.bindIndex}) ${groupBinding.wgslGroupFragment}`\r\n\r\n          if (groupBinding.newLine) this.shaders.fragment.head += `\\n`\r\n        }\r\n      }\r\n\r\n      if (groupBinding.wgslStructFragment && this.shaders.full.head.indexOf(groupBinding.wgslStructFragment) === -1) {\r\n        this.shaders.full.head = `\\n${groupBinding.wgslStructFragment}\\n${this.shaders.full.head}`\r\n      }\r\n\r\n      if (this.shaders.full.head.indexOf(groupBinding.wgslGroupFragment) === -1) {\r\n        this.shaders.full.head = `${this.shaders.full.head}\\n@group(${groupBinding.groupIndex}) @binding(${groupBinding.bindIndex}) ${groupBinding.wgslGroupFragment}`\r\n\r\n        if (groupBinding.newLine) this.shaders.full.head += `\\n`\r\n      }\r\n    }\r\n\r\n    // add attributes to vertex shader only\r\n    this.shaders.vertex.head = `${this.attributes.wgslStructFragment}\\n${this.shaders.vertex.head}`\r\n    this.shaders.full.head = `${this.attributes.wgslStructFragment}\\n${this.shaders.full.head}`\r\n\r\n    this.shaders.vertex.code = this.shaders.vertex.head + this.options.shaders.vertex.code\r\n\r\n    if (typeof this.options.shaders.fragment === 'object')\r\n      this.shaders.fragment.code = this.shaders.fragment.head + this.options.shaders.fragment.code\r\n\r\n    // check if its one shader string with different entry points\r\n    if (typeof this.options.shaders.fragment === 'object') {\r\n      if (\r\n        this.options.shaders.vertex.entryPoint !== this.options.shaders.fragment.entryPoint &&\r\n        this.options.shaders.vertex.code.localeCompare(this.options.shaders.fragment.code) === 0\r\n      ) {\r\n        this.shaders.full.code = this.shaders.full.head + this.options.shaders.vertex.code\r\n      } else {\r\n        this.shaders.full.code =\r\n          this.shaders.full.head + this.options.shaders.vertex.code + this.options.shaders.fragment.code\r\n      }\r\n    }\r\n  }\r\n\r\n  /* SETUP */\r\n\r\n  /**\r\n   * Get whether the shaders modules have been created\r\n   * @readonly\r\n   */\r\n  get shadersModulesReady(): boolean {\r\n    return !(!this.shaders.vertex.module || (this.options.shaders.fragment && !this.shaders.fragment.module))\r\n  }\r\n\r\n  /**\r\n   * Create the {@link shaders}: patch them and create the {@link GPUShaderModule}\r\n   */\r\n  createShaders() {\r\n    this.patchShaders()\r\n\r\n    const isSameShader =\r\n      typeof this.options.shaders.fragment === 'object' &&\r\n      this.options.shaders.vertex.entryPoint !== this.options.shaders.fragment.entryPoint &&\r\n      this.options.shaders.vertex.code.localeCompare(this.options.shaders.fragment.code) === 0\r\n\r\n    this.shaders.vertex.module = this.createShaderModule({\r\n      code: this.shaders[isSameShader ? 'full' : 'vertex'].code,\r\n      type: 'vertex',\r\n    })\r\n\r\n    if (this.options.shaders.fragment) {\r\n      this.shaders.fragment.module = this.createShaderModule({\r\n        code: this.shaders[isSameShader ? 'full' : 'fragment'].code,\r\n        type: 'fragment',\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get default transparency blend state.\r\n   * @returns - The default transparency blend state.\r\n   */\r\n  static getDefaultTransparentBlending(): GPUBlendState {\r\n    return {\r\n      color: {\r\n        srcFactor: 'src-alpha',\r\n        dstFactor: 'one-minus-src-alpha',\r\n      },\r\n      alpha: {\r\n        srcFactor: 'one',\r\n        dstFactor: 'one-minus-src-alpha',\r\n      },\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create the render pipeline {@link descriptor}\r\n   */\r\n  createPipelineDescriptor() {\r\n    if (!this.shadersModulesReady) return\r\n\r\n    let vertexLocationIndex = -1\r\n\r\n    if (this.options.rendering.targets.length) {\r\n      // we will assume our renderer alphaMode is set to 'premultiplied'\r\n      // we either disable blending if mesh if opaque\r\n      // use a custom blending if set\r\n      // or use this blend equation if mesh is transparent (see https://limnu.com/webgl-blending-youre-probably-wrong/)\r\n      if (this.options.rendering.transparent) {\r\n        this.options.rendering.targets[0].blend = this.options.rendering.targets[0].blend\r\n          ? this.options.rendering.targets[0].blend\r\n          : RenderPipelineEntry.getDefaultTransparentBlending()\r\n      }\r\n    } else {\r\n      this.options.rendering.targets = []\r\n    }\r\n\r\n    this.descriptor = {\r\n      label: this.options.label,\r\n      layout: this.layout,\r\n      vertex: {\r\n        module: this.shaders.vertex.module,\r\n        entryPoint: this.options.shaders.vertex.entryPoint,\r\n        buffers: this.attributes.vertexBuffers.map((vertexBuffer) => {\r\n          return {\r\n            stepMode: vertexBuffer.stepMode,\r\n            arrayStride: vertexBuffer.arrayStride * 4, // 4 bytes each\r\n            attributes: vertexBuffer.attributes.map((attribute) => {\r\n              vertexLocationIndex++\r\n              return {\r\n                shaderLocation: vertexLocationIndex,\r\n                offset: attribute.bufferOffset, // previous attribute size * 4\r\n                format: attribute.bufferFormat,\r\n              }\r\n            }),\r\n          }\r\n        }),\r\n      },\r\n      ...(this.options.shaders.fragment && {\r\n        fragment: {\r\n          module: this.shaders.fragment.module,\r\n          entryPoint: (this.options.shaders.fragment as ShaderOptions).entryPoint,\r\n          targets: this.options.rendering.targets,\r\n        },\r\n      }),\r\n      primitive: {\r\n        topology: this.options.rendering.topology,\r\n        frontFace: this.options.rendering.verticesOrder,\r\n        cullMode: this.options.rendering.cullMode,\r\n      },\r\n      ...(this.options.rendering.depth && {\r\n        depthStencil: {\r\n          depthWriteEnabled: this.options.rendering.depthWriteEnabled,\r\n          depthCompare: this.options.rendering.depthCompare,\r\n          format: this.options.rendering.depthFormat,\r\n        },\r\n      }),\r\n      ...(this.options.rendering.sampleCount > 1 && {\r\n        multisample: {\r\n          count: this.options.rendering.sampleCount,\r\n        },\r\n      }),\r\n    } as GPURenderPipelineDescriptor\r\n  }\r\n\r\n  /**\r\n   * Create the render {@link pipeline}\r\n   */\r\n  createRenderPipeline() {\r\n    if (!this.shadersModulesReady) return\r\n\r\n    try {\r\n      this.pipeline = this.renderer.createRenderPipeline(this.descriptor)\r\n    } catch (error) {\r\n      this.status.error = error\r\n      throwError(error)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Asynchronously create the render {@link pipeline}\r\n   * @async\r\n   * @returns - void promise result\r\n   */\r\n  async createRenderPipelineAsync(): Promise<void> {\r\n    if (!this.shadersModulesReady) return\r\n\r\n    try {\r\n      this.pipeline = await this.renderer.createRenderPipelineAsync(this.descriptor)\r\n      this.status.compiled = true\r\n      this.status.compiling = false\r\n      this.status.error = null\r\n    } catch (error) {\r\n      this.status.error = error\r\n      throwError(error)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Call {@link PipelineEntry#compilePipelineEntry | PipelineEntry compilePipelineEntry} method, then create our render {@link pipeline}\r\n   * @async\r\n   */\r\n  async compilePipelineEntry(): Promise<void> {\r\n    super.compilePipelineEntry()\r\n\r\n    if (this.options.useAsync) {\r\n      await this.createRenderPipelineAsync()\r\n    } else {\r\n      this.createRenderPipeline()\r\n      this.status.compiled = true\r\n      this.status.compiling = false\r\n      this.status.error = null\r\n    }\r\n  }\r\n}\r\n","import { RenderMaterialRenderingOptions } from '../../types/Materials'\r\n\r\n/**\r\n * Compare two sets of {@link RenderMaterialRenderingOptions | rendering options} and returns an array of different options keys if any.\r\n * @param newOptions - rendering new options to compare\r\n * @param baseOptions - rendering options to compare with\r\n * @returns - an array with the options keys that differ, if any.\r\n */\r\nexport const compareRenderingOptions = (\r\n  newOptions: Partial<RenderMaterialRenderingOptions> = {},\r\n  baseOptions: Partial<RenderMaterialRenderingOptions> = {}\r\n): Array<keyof RenderMaterialRenderingOptions> => {\r\n  return Object.keys(newOptions).filter((key) => {\r\n    if (Array.isArray(newOptions[key])) {\r\n      // 'targets' property\r\n      return JSON.stringify(newOptions[key]) !== JSON.stringify(baseOptions[key])\r\n    } else {\r\n      return newOptions[key] !== baseOptions[key]\r\n    }\r\n  }) as Array<keyof RenderMaterialRenderingOptions>\r\n}\r\n","export default /* wgsl */ `\r\nstruct VSOutput {\r\n  @builtin(position) position: vec4f,\r\n  @location(0) uv: vec2f,\r\n  @location(1) normal: vec3f,\r\n  @location(2) worldPosition: vec3f,\r\n  @location(3) viewDirection: vec3f,\r\n};\r\n\r\n@vertex fn main(\r\n  attributes: Attributes,\r\n) -> VSOutput {\r\n  var vsOutput: VSOutput;\r\n\r\n  vsOutput.position = getOutputPosition(attributes.position);\r\n  vsOutput.uv = attributes.uv;\r\n  vsOutput.normal = getWorldNormal(attributes.normal);\r\n  vsOutput.worldPosition = getWorldPosition(attributes.position).xyz;\r\n  vsOutput.viewDirection = camera.position - vsOutput.worldPosition;\r\n  \r\n  return vsOutput;\r\n}`\r\n","export default /* wgsl */ `\r\nstruct VSOutput {\r\n  @builtin(position) position: vec4f,\r\n  @location(0) uv: vec2f,\r\n};\r\n\r\n@vertex fn main(\r\n  attributes: Attributes,\r\n) -> VSOutput {\r\n  var vsOutput: VSOutput;\r\n\r\n  vsOutput.position = vec4f(attributes.position, 1.0);\r\n  vsOutput.uv = attributes.uv;\r\n  \r\n  return vsOutput;\r\n}`\r\n","export default /* wgsl */ `\r\n@fragment fn main() -> @location(0) vec4f {\r\n  return vec4(0.0, 0.0, 0.0, 1.0);\r\n}`\r\n","import { Material } from './Material'\nimport { isRenderer, Renderer, CameraRenderer } from '../renderers/utils'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\nimport {\n  AllowedGeometries,\n  RenderMaterialAttributes,\n  RenderMaterialOptions,\n  RenderMaterialParams,\n  RenderMaterialRenderingOptions,\n  ShaderOptions,\n} from '../../types/Materials'\nimport { RenderPipelineEntry } from '../pipelines/RenderPipelineEntry'\nimport { throwWarning } from '../../utils/utils'\nimport { compareRenderingOptions } from './utils'\nimport default_projected_vsWgsl from '../shaders/chunks/default/default_projected_vs.wgsl'\nimport default_vsWgsl from '../shaders/chunks/default/default_vs.wgsl'\nimport default_fsWgsl from '../shaders/chunks/default/default_fs.wgsl'\n\n/**\n * Create a {@link Material} specifically built to draw the vertices of a {@link core/geometries/Geometry.Geometry | Geometry}. Internally used by all kind of Meshes.\n *\n * ## Render pipeline\n *\n * A {@link RenderMaterial} automatically creates a {@link RenderPipelineEntry}. Once all the {@link core/bindGroups/BindGroup.BindGroup | BindGroup} have been created, they are sent with the shaders code and the {@link RenderMaterialOptions#rendering | rendering options} to the {@link RenderPipelineEntry}, which is in turns responsible for creating the {@link GPURenderPipeline}.\n *\n * After the {@link GPURenderPipeline} has been successfully compiled, the {@link RenderMaterial} is considered to be ready.\n */\nexport class RenderMaterial extends Material {\n  /** {@link RenderPipelineEntry | Render pipeline entry} used by this {@link RenderMaterial} */\n  pipelineEntry: RenderPipelineEntry | null\n  /** Mandatory {@link RenderMaterialAttributes | geometry attributes} to pass to the {@link RenderPipelineEntry | render pipeline entry} */\n  attributes: RenderMaterialAttributes | null\n  /** Options used to create this {@link RenderMaterial} */\n  options: RenderMaterialOptions\n\n  /**\n   * RenderMaterial constructor\n   * @param renderer - our renderer class object\n   * @param parameters - {@link RenderMaterialParams | parameters} used to create our RenderMaterial\n   */\n  constructor(renderer: Renderer | GPUCurtains, parameters: RenderMaterialParams) {\n    const type = 'RenderMaterial'\n\n    renderer = isRenderer(renderer, type)\n\n    if (!parameters.shaders) {\n      parameters.shaders = {}\n    }\n\n    if (!parameters.shaders?.vertex) {\n      parameters.shaders.vertex = {\n        code: parameters.useProjection ? default_projected_vsWgsl : default_vsWgsl,\n        entryPoint: 'main',\n      }\n    }\n\n    if (!parameters.shaders.vertex.entryPoint) {\n      parameters.shaders.vertex.entryPoint = 'main'\n    }\n\n    if (parameters.shaders.fragment === undefined) {\n      ;(parameters.shaders.fragment as ShaderOptions) = {\n        entryPoint: 'main',\n        code: default_fsWgsl,\n      }\n    }\n\n    super(renderer, parameters)\n\n    this.type = type\n    this.renderer = renderer\n\n    const { shaders } = parameters\n\n    // rendering options\n    const {\n      useProjection,\n      transparent,\n      depth,\n      depthWriteEnabled,\n      depthCompare,\n      depthFormat,\n      cullMode,\n      sampleCount,\n      verticesOrder,\n      topology,\n    } = parameters\n\n    let { targets } = parameters\n\n    // patch default target format if not set\n    if (targets === undefined) {\n      targets = [\n        {\n          format: this.renderer.options.preferredFormat,\n        },\n      ]\n    }\n    if (targets && targets.length && !targets[0].format) {\n      targets[0].format = this.renderer.options.preferredFormat\n    }\n\n    this.options = {\n      ...this.options,\n      shaders,\n      rendering: {\n        useProjection,\n        transparent,\n        depth,\n        depthWriteEnabled,\n        depthCompare,\n        depthFormat,\n        cullMode,\n        sampleCount,\n        targets,\n        verticesOrder,\n        topology,\n      },\n    } as RenderMaterialOptions\n\n    this.attributes = null\n    // will be set at render if needed\n    this.pipelineEntry = null\n  }\n\n  /**\n   * Set or reset this {@link RenderMaterial} {@link renderer}. Will also update the renderer camera bind group if needed.\n   * @param renderer - New {@link Renderer} or {@link GPUCurtains} instance to use.\n   */\n  setRenderer(renderer: Renderer | GPUCurtains) {\n    // remove old camera bind group\n    if (this.useCameraBindGroup && this.renderer) {\n      ;(this.renderer as CameraRenderer).cameraLightsBindGroup.consumers.delete(this.uuid)\n    }\n\n    super.setRenderer(renderer)\n\n    // update new camera bind group\n    if (this.useCameraBindGroup) {\n      this.bindGroups[0] = (this.renderer as CameraRenderer).cameraLightsBindGroup\n      ;(this.renderer as CameraRenderer).cameraLightsBindGroup.consumers.add(this.uuid)\n    }\n  }\n\n  /**\n   * Set (or reset) the current {@link pipelineEntry}. Use the {@link Renderer#pipelineManager | renderer pipelineManager} to check whether we can get an already created {@link RenderPipelineEntry} from cache or if we should create a new one.\n   */\n  setPipelineEntry() {\n    this.pipelineEntry = this.renderer.pipelineManager.createRenderPipeline({\n      renderer: this.renderer,\n      label: this.options.label + ' render pipeline',\n      shaders: this.options.shaders,\n      useAsync: this.options.useAsyncPipeline,\n      rendering: this.options.rendering,\n      attributes: this.attributes,\n      bindGroups: this.bindGroups,\n    })\n  }\n\n  /**\n   * Compile the {@link RenderPipelineEntry}\n   * @async\n   */\n  async compilePipelineEntry(): Promise<void> {\n    await this.pipelineEntry.compilePipelineEntry()\n  }\n\n  /**\n   * Check if attributes and all bind groups are ready, create them if needed, set {@link RenderPipelineEntry} bind group buffers and compile the pipeline.\n   * @async\n   */\n  async compileMaterial(): Promise<void> {\n    if (this.ready) return\n\n    super.compileMaterial()\n\n    if (this.attributes && !this.pipelineEntry) {\n      this.setPipelineEntry()\n    }\n\n    if (this.pipelineEntry && this.pipelineEntry.canCompile) {\n      await this.compilePipelineEntry()\n    }\n  }\n\n  /**\n   * Set or reset one of the {@link RenderMaterialRenderingOptions | rendering options}. Should be use with great caution, because if the {@link RenderPipelineEntry#pipeline | render pipeline} has already been compiled, it can cause a pipeline flush.\n   * @param renderingOptions - new {@link RenderMaterialRenderingOptions | rendering options} properties to be set\n   */\n  setRenderingOptions(renderingOptions: Partial<RenderMaterialRenderingOptions> = {}) {\n    // patch original transparent blending if it had been lost\n    if (renderingOptions.transparent && renderingOptions.targets.length && !renderingOptions.targets[0].blend) {\n      renderingOptions.targets[0].blend = RenderPipelineEntry.getDefaultTransparentBlending()\n    }\n\n    const newProperties = compareRenderingOptions(renderingOptions, this.options.rendering)\n\n    const oldRenderingOptions = { ...this.options.rendering }\n\n    // apply new options\n    this.options.rendering = { ...this.options.rendering, ...renderingOptions }\n\n    if (this.pipelineEntry) {\n      if (this.pipelineEntry.ready && newProperties.length) {\n        if (!this.renderer.production) {\n          const oldProps = newProperties.map((key) => {\n            return {\n              [key]: Array.isArray(oldRenderingOptions[key])\n                ? (oldRenderingOptions[key] as []).map((optKey) => optKey)\n                : oldRenderingOptions[key],\n            }\n          })\n\n          const newProps = newProperties.map((key) => {\n            return {\n              [key]: Array.isArray(renderingOptions[key])\n                ? (renderingOptions[key] as []).map((optKey) => optKey)\n                : renderingOptions[key],\n            }\n          })\n\n          throwWarning(\n            `${\n              this.options.label\n            }: the change of rendering options is causing this RenderMaterial pipeline to be recompiled. This should be avoided.\\n\\nOld rendering options: ${JSON.stringify(\n              oldProps.reduce((acc, v) => {\n                return { ...acc, ...v }\n              }, {}),\n              null,\n              4\n            )}\\n\\n--------\\n\\nNew rendering options: ${JSON.stringify(\n              newProps.reduce((acc, v) => {\n                return { ...acc, ...v }\n              }, {}),\n              null,\n              4\n            )}`\n          )\n        }\n\n        // recreate the pipeline entry totally\n        // if we're lucky we might get one from the cache\n        this.setPipelineEntry()\n      } else {\n        this.pipelineEntry.options.rendering = { ...this.pipelineEntry.options.rendering, ...this.options.rendering }\n      }\n    }\n  }\n\n  /* ATTRIBUTES */\n\n  /**\n   * Compute geometry if needed and get all useful geometry properties needed to create attributes buffers\n   * @param geometry - the geometry to draw\n   */\n  setAttributesFromGeometry(geometry: AllowedGeometries) {\n    this.attributes = {\n      wgslStructFragment: geometry.wgslStructFragment,\n      vertexBuffers: geometry.vertexBuffers,\n      layoutCacheKey: geometry.layoutCacheKey,\n    }\n  }\n\n  /* BIND GROUPS */\n\n  /**\n   * Get whether this {@link RenderMaterial} uses the renderer camera and lights bind group.\n   * @readonly\n   * */\n  get useCameraBindGroup(): boolean {\n    return 'cameraLightsBindGroup' in this.renderer && this.options.rendering.useProjection\n  }\n\n  /**\n   * Create the bind groups if they need to be created, but first add camera and lights bind group if needed.\n   */\n  createBindGroups() {\n    // camera and lights first!\n    if (this.useCameraBindGroup) {\n      this.bindGroups.push((this.renderer as CameraRenderer).cameraLightsBindGroup)\n      ;(this.renderer as CameraRenderer).cameraLightsBindGroup.consumers.add(this.uuid)\n    }\n\n    super.createBindGroups()\n  }\n\n  /**\n   * Update all bind groups, except for the camera and light bind groups if present, as it is already updated by the renderer itself.\n   */\n  updateBindGroups() {\n    const startBindGroupIndex = this.useCameraBindGroup ? 1 : 0\n    for (let i = startBindGroupIndex; i < this.bindGroups.length; i++) {\n      this.updateBindGroup(this.bindGroups[i])\n    }\n  }\n}\n","import { DirectionalLight } from '../../../lights/DirectionalLight'\nimport { PointLight } from '../../../lights/PointLight'\nimport { CameraRenderer } from '../../../renderers/utils'\n\n/**\n * Chunk to get the right position and normal in world space, depending on whether the mesh uses instancing or not.\n * @param hasInstances - Whether the mesh uses instancing or not.\n */\nconst getPositionAndNormal = (hasInstances = false): string => {\n  if (hasInstances) {\n    return /* wgsl */ `\n  var worldPosition: vec4f = instances[attributes.instanceIndex].modelMatrix * vec4f(attributes.position, 1.0);\n  let normal = (instances[attributes.instanceIndex].normalMatrix * vec4(attributes.normal, 0.0)).xyz;\n    `\n  } else {\n    return /* wgsl */ `\n  var worldPosition: vec4f = matrices.model * vec4(attributes.position, 1.0);\n  let normal = getWorldNormal(attributes.normal);\n    `\n  }\n}\n\n// DIRECTIONAL SHADOWS\n\n/**\n * Get default ({@link DirectionalLight}) shadow map pass vertex shader.\n * @param lightIndex - Index of the {@link DirectionalLight} for which to render the depth pass.\n * @param hasInstances - Whether the mesh uses instancing or not.\n */\nexport const getDefaultShadowDepthVs = (lightIndex = 0, hasInstances = false): string => /* wgsl */ `\n@vertex fn main(\n  attributes: Attributes,\n) -> @builtin(position) vec4f {  \n  let directionalShadow: DirectionalShadowsElement = directionalShadows.directionalShadowsElements[${lightIndex}];\n  \n  ${getPositionAndNormal(hasInstances)}\n  \n  let lightDirection: vec3f = normalize(worldPosition.xyz - directionalLights.elements[${lightIndex}].direction);\n  let NdotL: f32 = dot(normalize(normal), lightDirection);\n  let sinNdotL = sqrt(1.0 - NdotL * NdotL);\n  let normalBias: f32 = directionalShadow.normalBias * sinNdotL;\n  \n  worldPosition = vec4(worldPosition.xyz - normal * normalBias, worldPosition.w);\n  \n  return directionalShadow.projectionMatrix * directionalShadow.viewMatrix * worldPosition;\n}`\n\n/** Helper chunk to get the PCF soft shadow generated by a given {@link DirectionalLight}. */\nexport const getPCFShadowContribution: string = /* wgsl */ `\nfn getPCFShadowContribution(index: i32, worldPosition: vec3f, depthTexture: texture_depth_2d) -> f32 {\n  let directionalShadow: DirectionalShadowsElement = directionalShadows.directionalShadowsElements[index];\n  \n  // get shadow coords\n  var shadowCoords: vec3f = vec3((directionalShadow.projectionMatrix * directionalShadow.viewMatrix * vec4(worldPosition, 1.0)).xyz);\n  \n  // Convert XY to (0, 1)\n  // Y is flipped because texture coords are Y-down.\n  shadowCoords = vec3(\n    shadowCoords.xy * vec2(0.5, -0.5) + vec2(0.5),\n    shadowCoords.z\n  );\n  \n  var visibility = 0.0;\n  \n  let inFrustum: bool = shadowCoords.x >= 0.0 && shadowCoords.x <= 1.0 && shadowCoords.y >= 0.0 && shadowCoords.y <= 1.0;\n  let frustumTest: bool = inFrustum && shadowCoords.z <= 1.0;\n  \n  if(frustumTest) {\n    // Percentage-closer filtering. Sample texels in the region\n    // to smooth the result.\n    let size: vec2f = vec2f(textureDimensions(depthTexture).xy);\n  \n    let texelSize: vec2f = 1.0 / size;\n    \n    let sampleCount: i32 = directionalShadow.pcfSamples;\n    let maxSamples: f32 = f32(sampleCount) - 1.0;\n  \n    for (var x = 0; x < sampleCount; x++) {\n      for (var y = 0; y < sampleCount; y++) {\n        let offset = texelSize * vec2(\n          f32(x) - maxSamples * 0.5,\n          f32(y) - maxSamples * 0.5\n        );\n        \n        visibility += textureSampleCompareLevel(\n          depthTexture,\n          depthComparisonSampler,\n          shadowCoords.xy + offset,\n          shadowCoords.z - directionalShadow.bias\n        );\n      }\n    }\n    visibility /= f32(sampleCount * sampleCount);\n    \n    visibility = clamp(visibility, 1.0 - clamp(directionalShadow.intensity, 0.0, 1.0), 1.0);\n  }\n  else {\n    visibility = 1.0;\n  }\n  \n  return visibility;\n}\n`\n\n/**\n * Get the global PCF soft shadows contributions from all the current {@link CameraRenderer} {@link DirectionalLight}.\n * @param renderer - {@link CameraRenderer} used by the {@link DirectionalLight}.\n */\nexport const getPCFDirectionalShadows = (renderer: CameraRenderer): string => {\n  const directionalLights = renderer.shadowCastingLights.filter(\n    (light) => light.type === 'directionalLights'\n  ) as DirectionalLight[]\n\n  const minDirectionalLights = Math.max(renderer.lightsBindingParams.directionalLights.max, 1)\n\n  return /* wgsl */ `\nfn getPCFDirectionalShadows(worldPosition: vec3f) -> array<f32, ${minDirectionalLights}> {\n  var directionalShadowContribution: array<f32, ${minDirectionalLights}>;\n  \n  var lightDirection: vec3f;\n  \n  ${directionalLights\n    .map((light, index) => {\n      return `lightDirection = worldPosition - directionalLights.elements[${index}].direction;\n      \n      ${\n        light.shadow.isActive\n          ? `\n      if(directionalShadows.directionalShadowsElements[${index}].isActive > 0) {\n        directionalShadowContribution[${index}] = getPCFShadowContribution(\n          ${index},\n          worldPosition,\n          shadowDepthTexture${index}\n        );\n      } else {\n        directionalShadowContribution[${index}] = 1.0;\n      }\n          `\n          : `directionalShadowContribution[${index}] = 1.0;`\n      }`\n    })\n    .join('\\n')}\n  \n  return directionalShadowContribution;\n}\n`\n}\n\n// POINT SHADOWS\n\n/**\n * Get {@link PointLight} shadow map pass vertex shader.\n * @param lightIndex - Index of the {@link PointLight} for which to render the depth pass.\n * @param hasInstances - Whether the mesh uses instancing or not.\n */\nexport const getDefaultPointShadowDepthVs = (lightIndex = 0, hasInstances = false) => /* wgsl */ `\nstruct PointShadowVSOutput {\n  @builtin(position) position: vec4f,\n  @location(0) worldPosition: vec3f,\n}\n\n@vertex fn main(\n  attributes: Attributes,\n) -> PointShadowVSOutput {  \n  var pointShadowVSOutput: PointShadowVSOutput;\n  \n  ${getPositionAndNormal(hasInstances)}\n  \n  let pointShadow: PointShadowsElement = pointShadows.pointShadowsElements[${lightIndex}];\n  \n  let lightDirection: vec3f = normalize(pointLights.elements[${lightIndex}].position - worldPosition.xyz);\n  let NdotL: f32 = dot(normalize(normal), lightDirection);\n  let sinNdotL = sqrt(1.0 - NdotL * NdotL);\n  let normalBias: f32 = pointShadow.normalBias * sinNdotL;\n  \n  worldPosition = vec4(worldPosition.xyz - normal * normalBias, worldPosition.w);\n    \n  var position: vec4f = pointShadow.projectionMatrix * pointShadow.viewMatrices[pointShadow.face] * worldPosition;\n\n  pointShadowVSOutput.position = position;\n  pointShadowVSOutput.worldPosition = worldPosition.xyz;\n\n  return pointShadowVSOutput;\n}`\n\n/**\n * Get {@link PointLight} shadow map pass fragment shader.\n * @param lightIndex - Index of the {@link PointLight} for which to render the depth pass.\n */\nexport const getDefaultPointShadowDepthFs = (lightIndex = 0): string => /* wgsl */ `\nstruct PointShadowVSOutput {\n  @builtin(position) position: vec4f,\n  @location(0) worldPosition: vec3f,\n}\n\n@fragment fn main(fsInput: PointShadowVSOutput) -> @builtin(frag_depth) f32 {\n  // get distance between fragment and light source\n  var lightDistance: f32 = length(fsInput.worldPosition - pointLights.elements[${lightIndex}].position);\n  \n  let pointShadow: PointShadowsElement = pointShadows.pointShadowsElements[${lightIndex}];\n  \n  // map to [0, 1] range by dividing by far plane - near plane\n  lightDistance = (lightDistance - pointShadow.cameraNear) / (pointShadow.cameraFar - pointShadow.cameraNear);\n  \n  // write this as modified depth\n  return clamp(lightDistance, 0.0, 1.0);\n}`\n\n/** Helper chunk to get the PCF soft shadow generated by a given {@link PointLight}. */\nexport const getPCFPointShadowContribution: string = /* wgsl */ `\nfn getPCFPointShadowContribution(index: i32, shadowPosition: vec4f, depthCubeTexture: texture_depth_cube) -> f32 {\n  let pointShadow: PointShadowsElement = pointShadows.pointShadowsElements[index];\n\n  // Percentage-closer filtering. Sample texels in the region\n  // to smooth the result.\n  var visibility = 0.0;\n  var closestDepth = 0.0;\n  let currentDepth: f32 = shadowPosition.w;\n  let cameraRange: f32 = pointShadow.cameraFar - pointShadow.cameraNear;\n  let normalizedDepth: f32 = (shadowPosition.w - pointShadow.cameraNear) / cameraRange;\n\n  let maxSize: f32 = f32(max(textureDimensions(depthCubeTexture).x, textureDimensions(depthCubeTexture).y));\n\n  let texelSize: vec3f = vec3(1.0 / maxSize);\n  let sampleCount: i32 = pointShadow.pcfSamples;\n  let maxSamples: f32 = f32(sampleCount) - 1.0;\n  \n  for (var x = 0; x < sampleCount; x++) {\n    for (var y = 0; y < sampleCount; y++) {\n      for (var z = 0; z < sampleCount; z++) {\n        let offset = texelSize * vec3(\n          f32(x) - maxSamples * 0.5,\n          f32(y) - maxSamples * 0.5,\n          f32(z) - maxSamples * 0.5\n        );\n\n        closestDepth = textureSampleCompareLevel(\n          depthCubeTexture,\n          depthComparisonSampler,\n          shadowPosition.xyz + offset,\n          normalizedDepth - pointShadow.bias\n        );\n\n        closestDepth *= cameraRange;\n\n        visibility += select(0.0, 1.0, currentDepth <= closestDepth);\n      }\n    }\n  }\n  \n  visibility /= f32(sampleCount * sampleCount * sampleCount);\n  \n  visibility = clamp(visibility, 1.0 - clamp(pointShadow.intensity, 0.0, 1.0), 1.0);\n  \n  return visibility;\n}`\n\n/**\n * Get the global PCF soft shadows contributions from all the current {@link CameraRenderer} {@link PointLight}.\n * @param renderer - {@link CameraRenderer} used by the {@link PointLight}.\n */\nexport const getPCFPointShadows = (renderer: CameraRenderer): string => {\n  const pointLights = renderer.shadowCastingLights.filter((light) => light.type === 'pointLights') as PointLight[]\n\n  const minPointLights = Math.max(renderer.lightsBindingParams.pointLights.max, 1)\n\n  return /* wgsl */ `\nfn getPCFPointShadows(worldPosition: vec3f) -> array<f32, ${minPointLights}> {\n  var pointShadowContribution: array<f32, ${minPointLights}>;\n  \n  var lightDirection: vec3f;\n  var lightDistance: f32;\n  var lightColor: vec3f;\n  \n  ${pointLights\n    .map((light, index) => {\n      return `lightDirection = pointLights.elements[${index}].position - worldPosition;\n      \n      lightDistance = length(lightDirection);\n      lightColor = pointLights.elements[${index}].color * rangeAttenuation(pointLights.elements[${index}].range, lightDistance);\n      \n      ${\n        light.shadow.isActive\n          ? `\n      if(pointShadows.pointShadowsElements[${index}].isActive > 0 && length(lightColor) > 0.0001) {\n        pointShadowContribution[${index}] = getPCFPointShadowContribution(\n          ${index},\n          vec4(lightDirection, length(lightDirection)),\n          pointShadowCubeDepthTexture${index}\n        );\n      } else {\n        pointShadowContribution[${index}] = 1.0;\n      }\n            `\n          : `pointShadowContribution[${index}] = 1.0;`\n      }`\n    })\n    .join('\\n')}\n  \n  return pointShadowContribution;\n}\n`\n}\n\n/** Helper chunk to get the PCF soft shadow generated by all the {@link DirectionalLight} and {@link PointLight}. */\nexport const getPCFShadows: string = /* wgsl */ `\n  let pointShadows = getPCFPointShadows(worldPosition);\n  let directionalShadows = getPCFDirectionalShadows(worldPosition);\n`\n\n/** Helper chunk to apply a given {@link DirectionalLight} shadow to its light contribution. */\nexport const applyDirectionalShadows: string = /* wgsl */ `\n    directLight.color *= directionalShadows[i];\n`\n\n/** Helper chunk to apply a given {@link PointLight} shadow to its light contribution. */\nexport const applyPointShadows: string = /* wgsl */ `\n    directLight.color *= pointShadows[i];\n`\n","import { CameraRenderer, isCameraRenderer } from '../renderers/utils'\nimport { Vec2 } from '../../math/Vec2'\nimport { Mat4 } from '../../math/Mat4'\nimport { Texture } from '../textures/Texture'\nimport { RenderTarget } from '../renderPasses/RenderTarget'\nimport { Sampler } from '../samplers/Sampler'\nimport { ProjectedMesh } from '../renderers/GPURenderer'\nimport { RenderMaterial } from '../materials/RenderMaterial'\nimport { DirectionalLight } from '../lights/DirectionalLight'\nimport { PointLight } from '../lights/PointLight'\nimport { getDefaultShadowDepthVs } from '../shaders/chunks/shading/shadows'\nimport { BufferBinding } from '../bindings/BufferBinding'\nimport { RenderMaterialParams, ShaderOptions } from '../../types/Materials'\nimport { Input } from '../../types/BindGroups'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\n\n/** Defines all types of shadows. */\nexport type ShadowsType = 'directionalShadows' | 'pointShadows'\n\n/** @ignore */\nexport const shadowStruct: Record<string, Input> = {\n  isActive: {\n    type: 'i32',\n    value: 0,\n  },\n  pcfSamples: {\n    type: 'i32',\n    value: 0,\n  },\n  bias: {\n    type: 'f32',\n    value: 0,\n  },\n  normalBias: {\n    type: 'f32',\n    value: 0,\n  },\n  intensity: {\n    type: 'f32',\n    value: 0,\n  },\n}\n\n/**\n * Base parameters used to create a {@link Shadow}.\n */\nexport interface ShadowBaseParams {\n  /** Intensity of the shadow in the [0, 1] range. Default to `1`. */\n  intensity?: number\n  /** Shadow map bias. Default to `0`. */\n  bias?: number\n  /** Shadow map normal bias. Default to `0`. */\n  normalBias?: number\n  /** Number of samples to use for Percentage Closer Filtering calculations in the shader. Increase for smoother shadows, at the cost of performance. Default to `1`. */\n  pcfSamples?: number\n  /** Size of the depth {@link Texture} to use. Default to `Vec2(512)`. */\n  depthTextureSize?: Vec2\n  /** Format of the  depth {@link Texture} to use. Default to `depth24plus`. */\n  depthTextureFormat?: GPUTextureFormat\n  /** Whether the shadow should be automatically rendered each frame or not. Should be set to `false` if the scene is static and be rendered manually instead. Default to `true`. */\n  autoRender?: boolean\n  /** The {@link core/lights/Light.Light | light} that will be used to cast shadows. */\n  light: DirectionalLight | PointLight\n}\n\n/**\n * Used as a base class to create a shadow map.\n *\n * A {@link Shadow} creates a {@link depthTexture | depth Texture} (that can vary based on the light type) and a {@link depthComparisonSampler | depth comparison Sampler}.\n *\n * Each {@link ProjectedMesh | Mesh} added to the {@link Shadow} will be rendered beforehand to the {@link depthTexture} using a {@link depthPassTarget | RenderTarget} and a custom {@link RenderMaterial}.\n */\nexport class Shadow {\n  /** The {@link CameraRenderer} used to create this {@link Shadow}. */\n  renderer: CameraRenderer\n  /** Index of this {@link Shadow} used in the corresponding {@link CameraRenderer} shadow buffer binding. */\n  index: number\n\n  /** The {@link core/lights/Light.Light | light} that will be used to cast shadows. */\n  light: DirectionalLight | PointLight\n\n  /** Options used to create this {@link Shadow}. */\n  options: Omit<ShadowBaseParams, 'autoRender'>\n\n  /** Sample count of the {@link depthTexture}. Only `1` is accepted for now. */\n  sampleCount: number\n\n  /** @ignore */\n  #intensity: number\n  /** @ignore */\n  #bias: number\n  /** @ignore */\n  #normalBias: number\n  /** @ignore */\n  #pcfSamples: number\n  /** Size of the depth {@link Texture} to use. Default to `Vec2(512)`. */\n  depthTextureSize: Vec2\n  /** Format of the  depth {@link Texture} to use. Default to `depth24plus`. */\n  depthTextureFormat: GPUTextureFormat\n\n  /** @ignore */\n  #isActive: boolean\n  /** @ignore */\n  #autoRender: boolean\n\n  /** Depth {@link Texture} used to create the shadow map. */\n  depthTexture: null | Texture\n  /** Depth {@link RenderTarget} onto which the {@link meshes} will be rendered. */\n  depthPassTarget: null | RenderTarget\n  /** Depth comparison {@link Sampler} used to compare depth in the shaders. */\n  depthComparisonSampler: null | Sampler\n\n  /** All the current {@link ProjectedMesh | meshes} rendered to the shadow map. */\n  meshes: Map<ProjectedMesh['uuid'], ProjectedMesh>\n  /**\n   * Original {@link meshes} {@link RenderMaterial | materials}.\n   * @private\n   */\n  #materials: Map<ProjectedMesh['uuid'], RenderMaterial>\n  /**\n   * Corresponding depth {@link meshes} {@link RenderMaterial | materials}.\n   * @private\n   */\n  #depthMaterials: Map<ProjectedMesh['uuid'], RenderMaterial>\n  /** @ignore */\n  #depthPassTaskID: null | number\n\n  /** {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding} that holds all the bindings for this type of shadow to send to the shaders. */\n  rendererBinding: BufferBinding | null\n\n  /**\n   * Shadow constructor\n   * @param renderer - {@link CameraRenderer} used to create this {@link Shadow}.\n   * @param parameters - {@link ShadowBaseParams | parameters} used to create this {@link Shadow}.\n   */\n  constructor(\n    renderer: CameraRenderer | GPUCurtains,\n    {\n      light,\n      intensity = 1,\n      bias = 0,\n      normalBias = 0,\n      pcfSamples = 1,\n      depthTextureSize = new Vec2(512),\n      depthTextureFormat = 'depth24plus' as GPUTextureFormat,\n      autoRender = true,\n    } = {} as ShadowBaseParams\n  ) {\n    this.setRenderer(renderer)\n\n    this.light = light\n\n    this.index = this.light.index\n\n    this.options = {\n      light,\n      intensity,\n      bias,\n      normalBias,\n      pcfSamples,\n      depthTextureSize,\n      depthTextureFormat,\n    }\n\n    // mandatory so we could use textureSampleCompare()\n    // if we'd like to use MSAA, we would have to use an additional pass\n    // to manually resolve the depth texture before using it\n    this.sampleCount = 1\n\n    this.meshes = new Map()\n    this.#materials = new Map()\n    this.#depthMaterials = new Map()\n\n    this.#depthPassTaskID = null\n\n    this.#setParameters({ intensity, bias, normalBias, pcfSamples, depthTextureSize, depthTextureFormat, autoRender })\n\n    this.isActive = false\n  }\n\n  /**\n   * Set or reset this shadow {@link CameraRenderer}.\n   * @param renderer - New {@link CameraRenderer} or {@link GPUCurtains} instance to use.\n   */\n  setRenderer(renderer: CameraRenderer | GPUCurtains) {\n    renderer = isCameraRenderer(renderer, this.constructor.name)\n    this.renderer = renderer\n\n    this.setRendererBinding()\n\n    // update depth materials renderer as well\n    this.#depthMaterials?.forEach((depthMaterial) => {\n      depthMaterial.setRenderer(this.renderer)\n    })\n  }\n\n  /** @ignore */\n  setRendererBinding() {\n    this.rendererBinding = null\n  }\n\n  /**\n   * Set the {@link Shadow} parameters.\n   * @param parameters - parameters to use for this {@link Shadow}.\n   * @private\n   */\n  #setParameters(\n    {\n      intensity = 1,\n      bias = 0,\n      normalBias = 0,\n      pcfSamples = 1,\n      depthTextureSize = new Vec2(512),\n      depthTextureFormat = 'depth24plus',\n      autoRender = true,\n    } = {} as Omit<ShadowBaseParams, 'light'>\n  ) {\n    this.intensity = intensity\n    this.bias = bias\n    this.normalBias = normalBias\n    this.pcfSamples = pcfSamples\n    this.depthTextureSize = depthTextureSize\n    this.depthTextureSize.onChange(() => this.onDepthTextureSizeChanged())\n    this.depthTextureFormat = depthTextureFormat as GPUTextureFormat\n    this.#autoRender = autoRender\n  }\n\n  /**\n   * Set the parameters and start casting shadows by setting the {@link isActive} setter to `true`.<br>\n   * Called internally by the associated {@link core/lights/Light.Light | Light} if any shadow parameters are specified when creating it. Can also be called directly.\n   * @param parameters - parameters to use for this {@link Shadow}.\n   */\n  cast(\n    { intensity, bias, normalBias, pcfSamples, depthTextureSize, depthTextureFormat, autoRender } = {} as Omit<\n      ShadowBaseParams,\n      'light'\n    >\n  ) {\n    this.#setParameters({ intensity, bias, normalBias, pcfSamples, depthTextureSize, depthTextureFormat, autoRender })\n    this.isActive = true\n  }\n\n  /**\n   * Resend all properties to the {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}. Called when the maximum number of corresponding {@link core/lights/Light.Light | lights} has been overflowed.\n   */\n  reset() {\n    this.onPropertyChanged('isActive', this.isActive ? 1 : 0)\n    this.onPropertyChanged('intensity', this.intensity)\n    this.onPropertyChanged('bias', this.bias)\n    this.onPropertyChanged('normalBias', this.normalBias)\n    this.onPropertyChanged('pcfSamples', this.pcfSamples)\n  }\n\n  /**\n   * Get whether this {@link Shadow} is actually casting shadows.\n   * @returns - Whether this {@link Shadow} is actually casting shadows.\n   */\n  get isActive(): boolean {\n    return this.#isActive\n  }\n\n  /**\n   * Start or stop casting shadows.\n   * @param value - New active state.\n   */\n  set isActive(value: boolean) {\n    if (!value && this.isActive) {\n      this.destroy()\n    } else if (value && !this.isActive) {\n      this.init()\n    }\n\n    this.#isActive = value\n  }\n\n  /**\n   * Get this {@link Shadow} intensity.\n   * @returns - The {@link Shadow} intensity.\n   */\n  get intensity(): number {\n    return this.#intensity\n  }\n\n  /**\n   * Set this {@link Shadow} intensity and update the {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}.\n   * @param value - The new {@link Shadow} intensity.\n   */\n  set intensity(value: number) {\n    this.#intensity = value\n    this.onPropertyChanged('intensity', this.intensity)\n  }\n\n  /**\n   * Get this {@link Shadow} bias.\n   * @returns - The {@link Shadow} bias.\n   */\n  get bias(): number {\n    return this.#bias\n  }\n\n  /**\n   * Set this {@link Shadow} bias and update the {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}.\n   * @param value - The new {@link Shadow} bias.\n   */\n  set bias(value: number) {\n    this.#bias = value\n    this.onPropertyChanged('bias', this.bias)\n  }\n\n  /**\n   * Get this {@link Shadow} normal bias.\n   * @returns - The {@link Shadow} normal bias.\n   */\n  get normalBias(): number {\n    return this.#normalBias\n  }\n\n  /**\n   * Set this {@link Shadow} normal bias and update the {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}.\n   * @param value - The new {@link Shadow} normal bias.\n   */\n  set normalBias(value: number) {\n    this.#normalBias = value\n    this.onPropertyChanged('normalBias', this.normalBias)\n  }\n\n  /**\n   * Get this {@link Shadow} PCF samples count.\n   * @returns - The {@link Shadow} PCF samples count.\n   */\n  get pcfSamples(): number {\n    return this.#pcfSamples\n  }\n\n  /**\n   * Set this {@link Shadow} PCF samples count and update the {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}.\n   * @param value - The new {@link Shadow} PCF samples count.\n   */\n  set pcfSamples(value: number) {\n    this.#pcfSamples = Math.max(1, Math.ceil(value))\n    this.onPropertyChanged('pcfSamples', this.pcfSamples)\n  }\n\n  /**\n   * Set the {@link depthComparisonSampler}, {@link depthTexture}, {@link depthPassTarget} and start rendering to the shadow map.\n   */\n  init() {\n    if (!this.depthComparisonSampler) {\n      const samplerExists = this.renderer.samplers.find((sampler) => sampler.name === 'depthComparisonSampler')\n\n      this.depthComparisonSampler =\n        samplerExists ||\n        new Sampler(this.renderer, {\n          label: 'Depth comparison sampler',\n          name: 'depthComparisonSampler',\n          // we do not want to repeat the shadows\n          addressModeU: 'clamp-to-edge',\n          addressModeV: 'clamp-to-edge',\n          compare: 'less',\n          minFilter: 'linear',\n          magFilter: 'linear',\n          type: 'comparison',\n        })\n    }\n\n    this.setDepthTexture()\n\n    if (!this.depthPassTarget) {\n      this.createDepthPassTarget()\n    }\n\n    if (this.#depthPassTaskID === null && this.#autoRender) {\n      this.setDepthPass()\n      // do net set active flag if it's not rendered\n      this.onPropertyChanged('isActive', 1)\n    }\n  }\n\n  /**\n   * Reset the {@link depthTexture} when the {@link depthTextureSize} changes.\n   */\n  onDepthTextureSizeChanged() {\n    this.setDepthTexture()\n  }\n\n  /**\n   * Set or resize the {@link depthTexture} and eventually resize the {@link depthPassTarget} as well.\n   */\n  setDepthTexture() {\n    if (\n      this.depthTexture &&\n      (this.depthTexture.size.width !== this.depthTextureSize.x ||\n        this.depthTexture.size.height !== this.depthTextureSize.y)\n    ) {\n      this.depthTexture.options.fixedSize.width = this.depthTextureSize.x\n      this.depthTexture.options.fixedSize.height = this.depthTextureSize.y\n      this.depthTexture.size.width = this.depthTextureSize.x\n      this.depthTexture.size.height = this.depthTextureSize.y\n      this.depthTexture.createTexture()\n\n      if (this.depthPassTarget) {\n        this.depthPassTarget.resize()\n      }\n    } else if (!this.depthTexture) {\n      this.createDepthTexture()\n    }\n  }\n\n  /**\n   * Create the {@link depthTexture}.\n   */\n  createDepthTexture() {\n    this.depthTexture = new Texture(this.renderer, {\n      label: `${this.constructor.name} (index: ${this.light.index}) depth texture`,\n      name: 'shadowDepthTexture' + this.index,\n      type: 'depth',\n      format: this.depthTextureFormat,\n      sampleCount: this.sampleCount,\n      fixedSize: {\n        width: this.depthTextureSize.x,\n        height: this.depthTextureSize.y,\n      },\n      autoDestroy: false, // do not destroy when removing a mesh\n    })\n  }\n\n  /**\n   * Create the {@link depthPassTarget}.\n   */\n  createDepthPassTarget() {\n    this.depthPassTarget = new RenderTarget(this.renderer, {\n      label: 'Depth pass render target for ' + this.constructor.name + ' ' + this.index,\n      useColorAttachments: false,\n      depthTexture: this.depthTexture,\n      sampleCount: this.sampleCount,\n    })\n  }\n\n  /**\n   * Update the {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding} input value and tell the {@link CameraRenderer#cameraLightsBindGroup | renderer camera, lights and shadows} bind group to update.\n   * @param propertyKey - name of the property to update.\n   * @param value - new value of the property.\n   */\n  onPropertyChanged(propertyKey: string, value: Mat4 | number) {\n    if (this.rendererBinding) {\n      if (value instanceof Mat4) {\n        for (let i = 0; i < value.elements.length; i++) {\n          this.rendererBinding.options.bindings[this.index].inputs[propertyKey].value[i] = value.elements[i]\n        }\n\n        this.rendererBinding.options.bindings[this.index].inputs[propertyKey].shouldUpdate = true\n      } else {\n        this.rendererBinding.options.bindings[this.index].inputs[propertyKey].value = value\n      }\n\n      this.renderer.shouldUpdateCameraLightsBindGroup()\n    }\n  }\n\n  /**\n   * Start the depth pass.\n   */\n  setDepthPass() {\n    // add the depth pass (rendered each tick before our main scene)\n    this.#depthPassTaskID = this.render()\n  }\n\n  /**\n   * Remove the depth pass from its {@link utils/TasksQueueManager.TasksQueueManager | task queue manager}.\n   * @param depthPassTaskID - Task queue manager ID to use for removal.\n   */\n  removeDepthPass(depthPassTaskID) {\n    this.renderer.onBeforeRenderScene.remove(depthPassTaskID)\n  }\n\n  /**\n   * Render the depth pass. This happens before rendering the {@link CameraRenderer#scene | scene}.<br>\n   * - Force all the {@link meshes} to use their depth materials\n   * - Render all the {@link meshes}\n   * - Reset all the {@link meshes} materials to their original one.\n   * @param once - Whether to render it only once or not.\n   */\n  render(once = false): number {\n    return this.renderer.onBeforeRenderScene.add(\n      (commandEncoder) => {\n        if (!this.meshes.size) return\n\n        // assign depth material to meshes\n        this.useDepthMaterials()\n\n        this.renderDepthPass(commandEncoder)\n\n        // reset depth meshes material to use the original\n        // so the scene renders them normally\n        this.useOriginalMaterials()\n\n        // reset renderer current pipeline again\n        this.renderer.pipelineManager.resetCurrentPipeline()\n      },\n      {\n        once,\n        order: this.index,\n      }\n    )\n  }\n\n  /**\n   * Render the shadow map only once. Useful with static scenes if autoRender has been set to `false` to only take one snapshot of the shadow map.\n   */\n  async renderOnce(): Promise<void> {\n    // no point if it's already rendered\n    if (!this.#autoRender) {\n      this.onPropertyChanged('isActive', 1)\n\n      this.useDepthMaterials()\n\n      this.meshes.forEach((mesh) => {\n        mesh.setGeometry()\n      })\n\n      await Promise.all(\n        [...this.#depthMaterials.values()].map(async (depthMaterial) => {\n          await depthMaterial.compileMaterial()\n        })\n      )\n\n      this.render(true)\n    }\n  }\n\n  /**\n   * Render all the {@link meshes} into the {@link depthPassTarget}.\n   * @param commandEncoder - {@link GPUCommandEncoder} to use.\n   */\n  renderDepthPass(commandEncoder: GPUCommandEncoder) {\n    // we might need to update render bundles buffer bindings\n    const renderBundles = new Map()\n\n    this.meshes.forEach((mesh) => {\n      if (mesh.options.renderBundle) {\n        renderBundles.set(mesh.options.renderBundle.uuid, mesh.options.renderBundle)\n      }\n    })\n\n    // we can safely update render bundles bindings if needed\n    renderBundles.forEach((bundle) => {\n      bundle.updateBinding()\n    })\n\n    renderBundles.clear()\n\n    // reset renderer current pipeline\n    this.renderer.pipelineManager.resetCurrentPipeline()\n\n    // begin depth pass\n    const depthPass = commandEncoder.beginRenderPass(this.depthPassTarget.renderPass.descriptor)\n\n    if (!this.renderer.production)\n      depthPass.pushDebugGroup(`${this.constructor.name} (index: ${this.index}): depth pass`)\n\n    // render meshes with their depth material\n    this.meshes.forEach((mesh) => {\n      mesh.render(depthPass)\n    })\n\n    if (!this.renderer.production) depthPass.popDebugGroup()\n\n    depthPass.end()\n  }\n\n  /**\n   * Get the default depth pass vertex shader for this {@link Shadow}.\n   * @returns - Depth pass vertex shader.\n   */\n  getDefaultShadowDepthVs(hasInstances = false): ShaderOptions {\n    return {\n      /** Returned code. */\n      code: getDefaultShadowDepthVs(this.index, hasInstances),\n    }\n  }\n\n  /**\n   * Get the default depth pass fragment shader for this {@link Shadow}.\n   * @returns - A {@link ShaderOptions} if a depth pass fragment shader is needed, `false` otherwise.\n   */\n  getDefaultShadowDepthFs(): false | ShaderOptions {\n    return false // we do not need to output to a fragment shader unless we do late Z writing\n  }\n\n  /**\n   * Patch the given {@link ProjectedMesh | mesh} material parameters to create the depth material.\n   * @param mesh - original {@link ProjectedMesh | mesh} to use.\n   * @param parameters - Optional additional parameters to use for the depth material.\n   * @returns - Patched parameters.\n   */\n  patchShadowCastingMeshParams(mesh: ProjectedMesh, parameters: RenderMaterialParams = {}): RenderMaterialParams {\n    parameters = { ...mesh.material.options.rendering, ...parameters }\n\n    // explicitly set empty output targets\n    // we just want to write to the depth texture\n    parameters.targets = []\n\n    parameters.sampleCount = this.sampleCount\n    parameters.depthFormat = this.depthTextureFormat\n\n    if (parameters.bindings) {\n      parameters.bindings = [mesh.material.getBufferBindingByName('matrices'), ...parameters.bindings]\n    } else {\n      parameters.bindings = [mesh.material.getBufferBindingByName('matrices')]\n    }\n\n    const hasInstances = mesh.material.inputsBindings.get('instances') && mesh.geometry.instancesCount > 1\n\n    if (!parameters.shaders) {\n      parameters.shaders = {\n        vertex: this.getDefaultShadowDepthVs(hasInstances),\n        fragment: this.getDefaultShadowDepthFs(),\n      }\n    }\n\n    return parameters\n  }\n\n  /**\n   * Add a {@link ProjectedMesh | mesh} to the shadow map. Internally called by the {@link ProjectedMesh | mesh} if its `castShadows` parameters has been set to `true`, but can also be called externally to selectively cast shadows or to add specific parameters (such as custom depth pass shaders).\n   * - Save the original {@link ProjectedMesh | mesh} material.\n   * - {@link patchShadowCastingMeshParams | Patch} the parameters.\n   * - Create a new depth {@link RenderMaterial} with the patched parameters.\n   * - Add the {@link ProjectedMesh | mesh} to the {@link meshes} Map.\n   * @param mesh - {@link ProjectedMesh | mesh} to add to the shadow map.\n   * @param parameters - Optional {@link RenderMaterialParams | parameters} to use for the depth material.\n   */\n  addShadowCastingMesh(mesh: ProjectedMesh, parameters: RenderMaterialParams = {}) {\n    // already there? bail\n    if (this.meshes.get(mesh.uuid)) return\n\n    mesh.options.castShadows = true\n\n    this.#materials.set(mesh.uuid, mesh.material)\n\n    parameters = this.patchShadowCastingMeshParams(mesh, parameters)\n\n    if (this.#depthMaterials.get(mesh.uuid)) {\n      this.#depthMaterials.get(mesh.uuid).destroy()\n      this.#depthMaterials.delete(mesh.uuid)\n    }\n\n    this.#depthMaterials.set(\n      mesh.uuid,\n      new RenderMaterial(this.renderer, {\n        label: `${this.constructor.name} (index: ${this.index}) ${mesh.options.label} depth render material`,\n        ...parameters,\n      })\n    )\n\n    this.meshes.set(mesh.uuid, mesh)\n  }\n\n  /**\n   * Force all the {@link meshes} to use the depth material.\n   */\n  useDepthMaterials() {\n    this.meshes.forEach((mesh) => {\n      mesh.useMaterial(this.#depthMaterials.get(mesh.uuid))\n    })\n  }\n\n  /**\n   * Force all the {@link meshes} to use their original material.\n   */\n  useOriginalMaterials() {\n    this.meshes.forEach((mesh) => {\n      mesh.useMaterial(this.#materials.get(mesh.uuid))\n    })\n  }\n\n  /**\n   * Remove a {@link ProjectedMesh | mesh} from the shadow map and destroy its depth material.\n   * @param mesh - {@link ProjectedMesh | mesh} to remove.\n   */\n  removeMesh(mesh: ProjectedMesh) {\n    const depthMaterial = this.#depthMaterials.get(mesh.uuid)\n\n    if (depthMaterial) {\n      depthMaterial.destroy()\n      this.#depthMaterials.delete(mesh.uuid)\n    }\n\n    this.meshes.delete(mesh.uuid)\n  }\n\n  /**\n   * Destroy the {@link Shadow}.\n   */\n  destroy() {\n    this.onPropertyChanged('isActive', 0)\n\n    if (this.#depthPassTaskID !== null) {\n      this.removeDepthPass(this.#depthPassTaskID)\n      this.#depthPassTaskID = null\n    }\n\n    this.meshes.forEach((mesh) => this.removeMesh(mesh))\n    this.#materials = new Map()\n    this.#depthMaterials = new Map()\n    this.meshes = new Map()\n\n    this.depthPassTarget?.destroy()\n    this.depthTexture?.destroy()\n  }\n}\n","import { Shadow, ShadowBaseParams, shadowStruct } from './Shadow'\nimport { CameraRenderer } from '../renderers/utils'\nimport { Mat4, OrthographicProjectionParams } from '../../math/Mat4'\nimport { Vec3 } from '../../math/Vec3'\nimport { Input } from '../../types/BindGroups'\nimport { DirectionalLight } from '../lights/DirectionalLight'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\n\n/** Defines the orthographic shadow camera. */\nexport interface OrthographicShadowCamera extends OrthographicProjectionParams {\n  /** @ignore */\n  _left: number\n  /** @ignore */\n  _right: number\n  /** @ignore */\n  _bottom: number\n  /** @ignore */\n  _top: number\n  /** @ignore */\n  _near: number\n  /** @ignore */\n  _far: number\n  /** Orthographic camera projection {@link Mat4}. */\n  projectionMatrix: Mat4\n  /** Orthographic camera view {@link Mat4}. */\n  viewMatrix: Mat4\n  /** Up {@link Vec3} used to compute the view {@link Mat4}. */\n  up: Vec3\n}\n\n/**\n * Base parameters used to create a {@link DirectionalShadow}.\n */\nexport interface DirectionalShadowParams extends ShadowBaseParams {\n  /** {@link DirectionalLight} used to create the {@link DirectionalShadow}. */\n  light: DirectionalLight\n  /** {@link OrthographicProjectionParams | Orthographic projection parameters} to use. */\n  camera?: OrthographicProjectionParams\n}\n\n/** @ignore */\nexport const directionalShadowStruct: Record<string, Input> = {\n  ...shadowStruct,\n  viewMatrix: {\n    type: 'mat4x4f',\n    value: new Float32Array(16),\n  },\n  projectionMatrix: {\n    type: 'mat4x4f',\n    value: new Float32Array(16),\n  },\n}\n\n/**\n * Create a shadow map from a {@link DirectionalLight} by rendering to a depth texture using a view {@link Mat4} based on the {@link DirectionalLight} position and target and an {@link OrthographicShadowCamera | orthographic shadow camera} {@link Mat4}.\n */\nexport class DirectionalShadow extends Shadow {\n  /** {@link DirectionalLight} associated with this {@link DirectionalShadow}. */\n  light: DirectionalLight\n\n  /** {@link OrthographicShadowCamera | Orthographic shadow camera} to use for shadow calculations. */\n  camera: OrthographicShadowCamera\n\n  /** Options used to create this {@link DirectionalShadow}. */\n  options: DirectionalShadowParams\n\n  /**\n   * DirectionalShadow constructor\n   * @param renderer - {@link CameraRenderer} used to create this {@link DirectionalShadow}.\n   * @param parameters - {@link DirectionalShadowParams | parameters} used to create this {@link DirectionalShadow}.\n   */\n  constructor(\n    renderer: CameraRenderer | GPUCurtains,\n    {\n      light,\n      intensity,\n      bias,\n      normalBias,\n      pcfSamples,\n      depthTextureSize,\n      depthTextureFormat,\n      autoRender,\n      camera = {\n        left: -10,\n        right: 10,\n        bottom: -10,\n        top: 10,\n        near: 0.1,\n        far: 50,\n      },\n    } = {} as DirectionalShadowParams\n  ) {\n    super(renderer, {\n      light,\n      intensity,\n      bias,\n      normalBias,\n      pcfSamples,\n      depthTextureSize,\n      depthTextureFormat,\n      autoRender,\n    })\n\n    this.options = {\n      ...this.options,\n      camera,\n    }\n\n    this.camera = {\n      projectionMatrix: new Mat4(),\n      viewMatrix: new Mat4(),\n      up: new Vec3(0, 1, 0),\n      _left: camera.left,\n      _right: camera.right,\n      _bottom: camera.bottom,\n      _top: camera.top,\n      _near: camera.near,\n      _far: camera.far,\n    }\n\n    // camera props getters and setters\n    const _self = this\n    const cameraProps = ['left', 'right', 'bottom', 'top', 'near', 'far'] as Array<keyof OrthographicProjectionParams>\n\n    cameraProps.forEach((prop) => {\n      Object.defineProperty(_self.camera, prop, {\n        get() {\n          return _self.camera['_' + prop]\n        },\n        set(v) {\n          _self.camera['_' + prop] = v\n          _self.updateProjectionMatrix()\n        },\n      })\n    })\n\n    // this.camera.up.onChange(() => {\n    //   this.updateProjectionMatrix()\n    // })\n  }\n\n  /**\n   * Set or reset this {@link DirectionalShadow} {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}.\n   */\n  setRendererBinding() {\n    this.rendererBinding = this.renderer.bindings.directionalShadows\n  }\n\n  /**\n   * Set the parameters and start casting shadows by setting the {@link isActive} setter to `true`.<br>\n   * Called internally by the associated {@link DirectionalLight} if any shadow parameters are specified when creating it. Can also be called directly.\n   * @param parameters - parameters to use for this {@link DirectionalShadow}.\n   */\n  cast(\n    { intensity, bias, normalBias, pcfSamples, depthTextureSize, depthTextureFormat, autoRender, camera } = {} as Omit<\n      DirectionalShadowParams,\n      'light'\n    >\n  ) {\n    if (camera) {\n      this.camera.left = camera.left ?? -10\n      this.camera.right = camera.right ?? 10\n      this.camera.bottom = camera.bottom ?? -10\n      this.camera.top = camera.right ?? 10\n      this.camera.near = camera.near ?? 0.1\n      this.camera.far = camera.far ?? 50\n    }\n\n    super.cast({ intensity, bias, normalBias, pcfSamples, depthTextureSize, depthTextureFormat, autoRender })\n  }\n\n  /**\n   * Set the {@link depthComparisonSampler}, {@link depthTexture}, {@link depthPassTarget}, compute the {@link DirectionalShadow#camera.projectionMatrix | camera projection matrix} and start rendering to the shadow map.\n   */\n  init() {\n    super.init()\n    this.updateProjectionMatrix()\n  }\n\n  /**\n   * Resend all properties to the {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}. Called when the maximum number of corresponding {@link DirectionalLight} has been overflowed.\n   */\n  reset() {\n    this.setRendererBinding()\n    super.reset()\n    this.onPropertyChanged('projectionMatrix', this.camera.projectionMatrix)\n    this.onPropertyChanged('viewMatrix', this.camera.viewMatrix)\n  }\n\n  /**\n   * Update the {@link DirectionalShadow#camera.projectionMatrix | camera orthographic projection matrix} and update the {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}.\n   */\n  updateProjectionMatrix() {\n    this.camera.projectionMatrix.identity().makeOrthographic({\n      left: this.camera.left,\n      right: this.camera.right,\n      bottom: this.camera.bottom,\n      top: this.camera.top,\n      near: this.camera.near,\n      far: this.camera.far,\n    })\n\n    this.onPropertyChanged('projectionMatrix', this.camera.projectionMatrix)\n  }\n\n  /**\n   * Update the {@link DirectionalShadow#camera.viewMatrix | camera view matrix} and update the {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}.\n   * @param position - {@link Vec3} to use as position for the {@link DirectionalShadow#camera.viewMatrix | camera view matrix}, based on the {@link light} position.\n   * @param target - {@link Vec3} to use as target for the {@link DirectionalShadow#camera.viewMatrix | camera view matrix}, based on the {@link light} target.\n   */\n  updateViewMatrix(position = new Vec3(), target = new Vec3()) {\n    // avoid direction and up being parallel\n    if (position.x === 0 && position.z === 0) {\n      this.camera.up.set(0, 0, 1)\n    } else {\n      this.camera.up.set(0, 1, 0)\n    }\n\n    this.camera.viewMatrix.makeView(position, target, this.camera.up)\n    this.onPropertyChanged('viewMatrix', this.camera.viewMatrix)\n  }\n}\n","import { Light, LightBaseParams, LightsType } from './Light'\nimport { Vec3 } from '../../math/Vec3'\nimport { DirectionalShadow, DirectionalShadowParams } from '../shadows/DirectionalShadow'\nimport { CameraRenderer } from '../renderers/utils'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\n\n/**\n * Base parameters used to create a {@link DirectionalLight}.\n */\nexport interface DirectionalLightBaseParams extends LightBaseParams {\n  /** The {@link DirectionalLight} {@link Vec3 | position}. Default to `Vec3(1)`. */\n  position?: Vec3\n  /** The {@link DirectionalLight} {@link Vec3 | target}. Default to `Vec3(0)`. */\n  target?: Vec3\n  /** The {@link DirectionalLight} shadow parameters used to create a {@link DirectionalShadow}. If not set, the {@link DirectionalShadow} won't be set as active and won't cast any shadows. On the other hand, if anything is passed (even an empty object), the {@link DirectionalShadow} will start casting shadows, so use with caution. Default to `null` (which means the {@link DirectionalLight} will not cast shadows). */\n  shadow?: DirectionalShadowParams\n}\n\n/**\n * Create a directional light, that is emitted in a single direction without any attenuation. A common use case for this type of light is to simulate the sun.\n *\n * This light can cast {@link DirectionalShadow}.\n *\n * @example\n * ```javascript\n * // assuming 'renderer' is a valid Camera renderer\n *\n * // this directional light will not cast any shadows\n * const directionalLight = new DirectionalLight(renderer, {\n *   color: new Vec3(1),\n *   intensity: 1,\n *   position: new Vec3(5, 2, 3),\n * })\n *\n * // this directional light will cast shadows\n * const directionalLightWithShadows = new DirectionalLight(renderer, {\n *   color: new Vec3(1),\n *   intensity: 1,\n *   position: new Vec3(-10, 10, -5),\n *   shadow: {\n *     intensity: 1\n *   },\n * })\n *\n * // this directional light will ALSO cast shadows!\n * const anotherDirectionalLightWithShadows = new DirectionalLight(renderer, {\n *   color: new Vec3(1),\n *   intensity: 2,\n *   position: new Vec3(12, 0.5, 5),\n *   target: new Vec3(3),\n *   shadow: {}, // that's enough to start casting shadows\n * })\n *\n * // this directional light will cast shadows as well...\n * const lastDirectionalLightWithShadows = new DirectionalLight(renderer, {\n *   color: new Vec3(1),\n *   intensity: 1,\n *   position: new Vec3(10),\n * })\n *\n * // ... because we're telling it here to start casting shadows\n * lastDirectionalLightWithShadows.shadow.cast()\n * ```\n */\nexport class DirectionalLight extends Light {\n  /** The {@link DirectionalLight} {@link Vec3 | target}. */\n  target: Vec3\n  /** @ignore */\n  #actualPosition: Vec3\n  /**\n   * The {@link Vec3 | direction} of the {@link DirectionalLight} is the {@link target} minus the actual {@link position}.\n   * @private\n   */\n  #direction: Vec3\n\n  /** Options used to create this {@link DirectionalLight}. */\n  options: DirectionalLightBaseParams\n  /** {@link DirectionalShadow} associated with this {@link DirectionalLight}. */\n  shadow: DirectionalShadow\n\n  /**\n   * DirectionalLight constructor\n   * @param renderer - {@link CameraRenderer} used to create this {@link DirectionalLight}.\n   * @param parameters - {@link DirectionalLightBaseParams | parameters} used to create this {@link DirectionalLight}.\n   */\n  constructor(\n    renderer: CameraRenderer | GPUCurtains,\n    {\n      color = new Vec3(1),\n      intensity = 1,\n      position = new Vec3(1),\n      target = new Vec3(),\n      shadow = null,\n    } = {} as DirectionalLightBaseParams\n  ) {\n    const type = 'directionalLights'\n    super(renderer, { color, intensity, type })\n\n    this.options = {\n      ...this.options,\n      position,\n      target,\n      shadow,\n    }\n\n    this.#direction = new Vec3()\n    this.#actualPosition = new Vec3()\n    this.target = target\n    this.target.onChange(() => this.setDirection())\n    this.position.copy(position)\n\n    this.parent = this.renderer.scene\n\n    this.shadow = new DirectionalShadow(this.renderer, {\n      autoRender: false, // will be set by calling cast()\n      light: this,\n    })\n\n    if (shadow) {\n      this.shadow.cast(shadow)\n    }\n  }\n\n  /**\n   * Set or reset this {@link DirectionalLight} {@link CameraRenderer}.\n   * @param renderer - New {@link CameraRenderer} or {@link GPUCurtains} instance to use.\n   */\n  setRenderer(renderer: CameraRenderer | GPUCurtains) {\n    this.shadow?.setRenderer(renderer)\n\n    super.setRenderer(renderer)\n  }\n\n  /**\n   * Resend all properties to the {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}. Called when the maximum number of {@link DirectionalLight} has been overflowed.\n   */\n  reset() {\n    super.reset()\n    this.setDirection()\n\n    this.shadow?.reset()\n  }\n\n  /**\n   * Set the {@link DirectionalLight} direction based on the {@link target} and the {@link worldMatrix} translation and update the {@link DirectionalShadow} view matrix.\n   */\n  setDirection() {\n    this.#direction.copy(this.target).sub(this.worldMatrix.getTranslation(this.#actualPosition))\n    this.onPropertyChanged('direction', this.#direction)\n\n    this.shadow?.updateViewMatrix(this.#actualPosition, this.target)\n  }\n\n  // explicitly disable scale and transform origin transformations\n\n  /** @ignore */\n  applyScale() {}\n\n  /** @ignore */\n  applyTransformOrigin() {}\n\n  /**\n   * If the {@link modelMatrix | model matrix} has been updated, set the new direction from the {@link worldMatrix} translation.\n   */\n  updateMatrixStack() {\n    super.updateMatrixStack()\n\n    if (this.matricesNeedUpdate) {\n      this.setDirection()\n    }\n  }\n\n  /**\n   * Tell the {@link renderer} that the maximum number of {@link DirectionalLight} has been overflown.\n   * @param lightsType - {@link type} of this light.\n   */\n  onMaxLightOverflow(lightsType: LightsType) {\n    super.onMaxLightOverflow(lightsType)\n    this.shadow?.setRendererBinding()\n  }\n\n  /**\n   * Destroy this {@link DirectionalLight} and associated {@link DirectionalShadow}.\n   */\n  destroy() {\n    super.destroy()\n    this.shadow.destroy()\n  }\n}\n","import { Shadow, ShadowBaseParams, shadowStruct } from './Shadow'\nimport { CameraRenderer } from '../renderers/utils'\nimport { Mat4, PerspectiveProjectionParams } from '../../math/Mat4'\nimport { Vec3 } from '../../math/Vec3'\nimport { Texture } from '../textures/Texture'\nimport { getDefaultPointShadowDepthFs, getDefaultPointShadowDepthVs } from '../shaders/chunks/shading/shadows'\nimport { PointLight } from '../lights/PointLight'\nimport { Input } from '../../types/BindGroups'\nimport { ShaderOptions } from '../../types/Materials'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\n\n/** Defines the perspective shadow camera params. */\nexport type PerspectiveShadowCameraParams = Omit<PerspectiveProjectionParams, 'fov' | 'aspect'>\n\n/** Defines the perspective shadow camera. */\nexport interface PerspectiveShadowCamera extends PerspectiveShadowCameraParams {\n  /** @ignore */\n  _near: number\n  /** @ignore */\n  _far: number\n  /** Perspective camera projection {@link Mat4}. */\n  projectionMatrix: Mat4\n  /** Array of 6 view {@link Mat4} corresponding to each faces of a cube. */\n  viewMatrices: Mat4[]\n}\n\n/**\n * Base parameters used to create a {@link PointShadow}.\n */\nexport interface PointShadowParams extends ShadowBaseParams {\n  /** {@link PointLight} used to create the {@link PointShadow}. */\n  light: PointLight\n  /** {@link PerspectiveShadowCameraParams | Perspective projection parameters} to use. */\n  camera?: PerspectiveShadowCameraParams\n}\n\n/** @ignore */\nexport const pointShadowStruct: Record<string, Input> = {\n  face: {\n    type: 'i32',\n    value: 0,\n  },\n  ...shadowStruct,\n  cameraNear: {\n    type: 'f32',\n    value: 0,\n  },\n  cameraFar: {\n    type: 'f32',\n    value: 0,\n  },\n  projectionMatrix: {\n    type: 'mat4x4f',\n    value: new Float32Array(16),\n  },\n  viewMatrices: {\n    type: 'array<mat4x4f>',\n    value: new Float32Array(16 * 6),\n  },\n}\n\n/**\n * Create a shadow map from a {@link PointLight} by rendering to a depth cube texture using an array of view {@link Mat4} based on the {@link PointLight} position and a {@link PerspectiveShadowCamera | perspective shadow camera} {@link Mat4}.\n *\n * This type of shadow is more expensive than {@link core/shadows/DirectionalShadow.DirectionalShadow | DirectionalShadow} since its scene needs to be rendered 6 times to each face of a depth cube texture instead of once.\n */\nexport class PointShadow extends Shadow {\n  /** {@link PointLight} associated with this {@link PointShadow}. */\n  light: PointLight\n\n  /** {@link PerspectiveShadowCamera | Perspective shadow camera} to use for shadow calculations. */\n  camera: PerspectiveShadowCamera\n\n  /** Options used to create this {@link PointShadow}. */\n  options: PointShadowParams\n\n  /** Array of {@link Vec3} representing each cube face up directions to compute the {@link PointShadow#camera.viewMatrices | camera view matrices}. */\n  cubeUps: Vec3[]\n  /** Array of {@link Vec3} representing each cube face directions to compute the {@link PointShadow#camera.viewMatrices | camera view matrices}. */\n  cubeDirections: Vec3[]\n  /**\n   * {@link Vec3} used to calculate the actual current direction based on the {@link PointLight} position.\n   * @private\n   */\n  #tempCubeDirection: Vec3\n\n  /**\n   * PointShadow constructor\n   * @param renderer - {@link CameraRenderer} used to create this {@link PointShadow}.\n   * @param parameters - {@link PointShadowParams | parameters} used to create this {@link PointShadow}.\n   */\n  constructor(\n    renderer: CameraRenderer | GPUCurtains,\n    {\n      light,\n      intensity,\n      bias,\n      normalBias,\n      pcfSamples,\n      depthTextureSize,\n      depthTextureFormat,\n      autoRender,\n      camera = {\n        near: 0.1,\n        far: 150,\n      },\n    } = {} as PointShadowParams\n  ) {\n    super(renderer, {\n      light,\n      intensity,\n      bias,\n      normalBias,\n      pcfSamples,\n      depthTextureSize,\n      depthTextureFormat,\n      autoRender,\n    })\n\n    this.options = {\n      ...this.options,\n      camera,\n    }\n\n    //this.setRendererBinding()\n\n    this.cubeDirections = [\n      new Vec3(-1, 0, 0),\n      new Vec3(1, 0, 0),\n      new Vec3(0, -1, 0),\n      new Vec3(0, 1, 0),\n      new Vec3(0, 0, -1),\n      new Vec3(0, 0, 1),\n    ]\n\n    this.#tempCubeDirection = new Vec3()\n\n    this.cubeUps = [\n      new Vec3(0, -1, 0),\n      new Vec3(0, -1, 0),\n      new Vec3(0, 0, 1),\n      new Vec3(0, 0, -1),\n      new Vec3(0, -1, 0),\n      new Vec3(0, -1, 0),\n    ]\n\n    if (camera.far <= 0) {\n      camera.far = 150\n    }\n\n    this.camera = {\n      projectionMatrix: new Mat4(),\n      viewMatrices: [],\n      _near: camera.near,\n      _far: camera.far,\n    }\n\n    for (let i = 0; i < 6; i++) {\n      this.camera.viewMatrices.push(new Mat4())\n    }\n\n    // camera props getters and setters\n    const _self = this\n    const cameraProps = ['near', 'far'] as Array<keyof PerspectiveShadowCameraParams>\n\n    cameraProps.forEach((prop) => {\n      Object.defineProperty(_self.camera, prop, {\n        get() {\n          return _self.camera['_' + prop]\n        },\n        set(v) {\n          _self.camera['_' + prop] = v\n          _self.updateProjectionMatrix()\n        },\n      })\n    })\n  }\n\n  /**\n   * Set or reset this {@link PointShadow} {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}.\n   */\n  setRendererBinding() {\n    this.rendererBinding = this.renderer.bindings.pointShadows\n  }\n\n  /**\n   * Set the parameters and start casting shadows by setting the {@link isActive} setter to `true`.<br>\n   * Called internally by the associated {@link PointLight} if any shadow parameters are specified when creating it. Can also be called directly.\n   * @param parameters - parameters to use for this {@link PointShadow}.\n   */\n  cast(\n    { intensity, bias, normalBias, pcfSamples, depthTextureSize, depthTextureFormat, autoRender, camera } = {} as Omit<\n      PointShadowParams,\n      'light'\n    >\n  ) {\n    if (camera) {\n      this.camera.near = camera.near ?? 0.1\n      this.camera.far = camera.far !== undefined ? camera.far : this.light.range > 0 ? this.light.range : 150\n    }\n\n    super.cast({ intensity, bias, normalBias, pcfSamples, depthTextureSize, depthTextureFormat, autoRender })\n  }\n\n  /**\n   * Set the {@link depthComparisonSampler}, {@link depthTexture}, {@link depthPassTarget}, compute the {@link PointShadow#camera.projectionMatrix | camera projection matrix} and start rendering to the shadow map.\n   */\n  init() {\n    super.init()\n    this.updateProjectionMatrix()\n  }\n\n  /**\n   * Resend all properties to the {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}. Called when the maximum number of corresponding {@link PointLight} has been overflowed.\n   */\n  reset() {\n    this.setRendererBinding()\n    super.reset()\n    // no need to update view matrices, they are handled by the parent PointLight reset call\n    this.updateProjectionMatrix()\n  }\n\n  /**\n   * Update the {@link PointShadow#camera.projectionMatrix | camera perspective projection matrix} and update the {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}.\n   */\n  updateProjectionMatrix() {\n    this.camera.projectionMatrix.identity().makePerspective({\n      near: this.camera.near,\n      far: this.camera.far,\n      fov: 90,\n      aspect: 1,\n    })\n\n    this.onPropertyChanged('projectionMatrix', this.camera.projectionMatrix)\n    this.onPropertyChanged('cameraNear', this.camera.near)\n    this.onPropertyChanged('cameraFar', this.camera.far)\n  }\n\n  /**\n   * Update the {@link PointShadow#camera.viewMatrices | camera view matrices} and update the {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}.\n   * @param position - {@link Vec3} to use as position for the {@link PointShadow#camera.viewMatrices | camera view matrices}, based on the {@link light} position.\n   */\n  updateViewMatrices(position = new Vec3()) {\n    for (let i = 0; i < 6; i++) {\n      this.#tempCubeDirection.copy(this.cubeDirections[i]).add(position)\n      this.camera.viewMatrices[i].makeView(position, this.#tempCubeDirection, this.cubeUps[i])\n\n      for (let j = 0; j < 16; j++) {\n        this.rendererBinding.options.bindings[this.index].inputs.viewMatrices.value[i * 16 + j] =\n          this.camera.viewMatrices[i].elements[j]\n      }\n    }\n\n    this.rendererBinding.options.bindings[this.index].inputs.viewMatrices.shouldUpdate = true\n  }\n\n  /**\n   * Set or resize the {@link depthTexture} and eventually resize the {@link depthPassTarget} as well.\n   */\n  setDepthTexture() {\n    if (\n      this.depthTexture &&\n      (this.depthTexture.size.width !== this.depthTextureSize.x ||\n        this.depthTexture.size.height !== this.depthTextureSize.y)\n    ) {\n      const maxSize = Math.max(this.depthTextureSize.x, this.depthTextureSize.y)\n      this.depthTexture.options.fixedSize.width = maxSize\n      this.depthTexture.options.fixedSize.height = maxSize\n      this.depthTexture.size.width = maxSize\n      this.depthTexture.size.height = maxSize\n      this.depthTexture.createTexture()\n\n      if (this.depthPassTarget) {\n        this.depthPassTarget.resize()\n      }\n    } else if (!this.depthTexture) {\n      this.createDepthTexture()\n    }\n  }\n\n  /**\n   * Create the cube {@link depthTexture}.\n   */\n  createDepthTexture() {\n    const maxSize = Math.max(this.depthTextureSize.x, this.depthTextureSize.y)\n    this.depthTexture = new Texture(this.renderer, {\n      label: `${this.constructor.name} (index: ${this.index}) depth texture`,\n      name: 'pointShadowCubeDepthTexture' + this.index,\n      type: 'depth',\n      format: this.depthTextureFormat,\n      viewDimension: 'cube',\n      sampleCount: this.sampleCount,\n      fixedSize: {\n        width: maxSize,\n        height: maxSize,\n      },\n      autoDestroy: false, // do not destroy when removing a mesh\n    })\n  }\n\n  /**\n   * Remove the depth pass from its {@link utils/TasksQueueManager.TasksQueueManager | task queue manager}.\n   * @param depthPassTaskID - Task queue manager ID to use for removal.\n   */\n  removeDepthPass(depthPassTaskID) {\n    this.renderer.onBeforeCommandEncoderCreation.remove(depthPassTaskID)\n  }\n\n  /**\n   * Render the depth pass. This happens before creating the {@link CameraRenderer} command encoder.<br>\n   * - Force all the {@link meshes} to use their depth materials\n   * - For each face of the depth cube texture:\n   *   - Create a command encoder.\n   *   - Set the {@link depthPassTarget} descriptor depth texture view to our depth cube texture current face.\n   *   - Update the face index\n   *   - Render all the {@link meshes}\n   *   - Submit the command encoder\n   * - Reset all the {@link meshes} materials to their original one.\n   * @param once - Whether to render it only once or not.\n   */\n  render(once = false): number {\n    return this.renderer.onBeforeCommandEncoderCreation.add(\n      () => {\n        if (!this.meshes.size) return\n\n        // since we're not inside the main loop,\n        // we need to be sure the renderer camera & lights bind group has been created\n        this.renderer.setCameraBindGroup()\n\n        // assign depth material to meshes\n        this.useDepthMaterials()\n\n        for (let i = 0; i < 6; i++) {\n          const commandEncoder = this.renderer.device.createCommandEncoder()\n\n          if (!this.renderer.production)\n            commandEncoder.pushDebugGroup(\n              `${this.constructor.name} (index: ${this.index}): depth pass command encoder for face ${i}`\n            )\n\n          this.depthPassTarget.renderPass.setRenderPassDescriptor(\n            this.depthTexture.texture.createView({\n              label: this.depthTexture.texture.label + ' cube face view ' + i,\n              dimension: '2d',\n              arrayLayerCount: 1,\n              baseArrayLayer: i,\n            })\n          )\n\n          // update face index\n          this.rendererBinding.options.bindings[this.index].inputs.face.value = i\n          // again, we're not inside the main loop,\n          // we need to explicitly update the renderer camera & lights bind group\n          this.renderer.cameraLightsBindGroup.update()\n\n          this.renderDepthPass(commandEncoder)\n\n          if (!this.renderer.production) commandEncoder.popDebugGroup()\n\n          const commandBuffer = commandEncoder.finish()\n          this.renderer.device.queue.submit([commandBuffer])\n        }\n\n        // reset depth meshes material to use the original\n        // so the scene renders them normally\n        this.useOriginalMaterials()\n\n        // reset renderer current pipeline again\n        this.renderer.pipelineManager.resetCurrentPipeline()\n      },\n      {\n        once,\n        order: this.index,\n      }\n    )\n  }\n\n  /**\n   * Get the default depth pass vertex shader for this {@link PointShadow}.\n   * @returns - Depth pass vertex shader.\n   */\n  getDefaultShadowDepthVs(hasInstances = false): ShaderOptions {\n    return {\n      /** Returned code. */\n      code: getDefaultPointShadowDepthVs(this.index, hasInstances),\n    }\n  }\n\n  /**\n   * Get the default depth pass {@link types/Materials.ShaderOptions | fragment shader options} for this {@link PointShadow}.\n   * @returns - A {@link types/Materials.ShaderOptions | ShaderOptions} with the depth pass fragment shader.\n   */\n  getDefaultShadowDepthFs(): ShaderOptions {\n    return {\n      /** Returned code. */\n      code: getDefaultPointShadowDepthFs(this.index),\n    }\n  }\n}\n","import { Light, LightBaseParams, LightsType } from './Light'\nimport { Vec3 } from '../../math/Vec3'\nimport { PointShadow, PointShadowParams } from '../shadows/PointShadow'\nimport { CameraRenderer } from '../renderers/utils'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\n\n/**\n * Base parameters used to create a {@link PointLight}.\n */\nexport interface PointLightBaseParams extends LightBaseParams {\n  /** The {@link PointLight} {@link Vec3 | position}. Default to `Vec3(0)`. */\n  position?: Vec3\n  /** The {@link PointLight} range, used to compute the {@link PointLight} attenuation over distance. Default to `0`. */\n  range?: number\n  /** The {@link PointLight} shadow parameters used to create a {@link PointShadow}. If not set, the {@link PointShadow} won't be set as active and won't cast any shadows. On the other hand, if anything is passed (even an empty object), the {@link PointShadow} will start casting shadows, so use with caution. Default to `null` (which means the {@link PointLight} will not cast shadows). */\n  shadow?: PointShadowParams\n}\n\n/**\n * Create a point light, that is emitted from a point to all directions with an attenuation. A common use case for this type of light is to replicate the light emitted from a bare light bulb.\n *\n * This light can cast {@link PointShadow}.\n *\n * @example\n * ```javascript\n * // assuming 'renderer' is a valid Camera renderer\n *\n * // this point light will not cast any shadows\n * const pointLight = new PointLight(renderer, {\n *   color: new Vec3(1),\n *   intensity: 1,\n *   position: new Vec3(5, 2, 3),\n * })\n *\n * // this point light will cast shadows\n * const pointLightWithShadows = new PointLight(renderer, {\n *   color: new Vec3(1),\n *   intensity: 10,\n *   range: 3,\n *   position: new Vec3(-10, 10, -5),\n *   shadow: {\n *     intensity: 1\n *   },\n * })\n *\n * // this point light will ALSO cast shadows!\n * const anotherPointLightWithShadows = new PointLight(renderer, {\n *   color: new Vec3(1),\n *   intensity: 5,\n *   range: 100,\n *   position: new Vec3(12, 0.5, 5),\n *   shadow: {}, // that's enough to start casting shadows\n * })\n *\n * // this point light will cast shadows as well...\n * const lastPointLightWithShadows = new PointLight(renderer, {\n *   color: new Vec3(1),\n *   intensity: 1,\n *   position: new Vec3(10),\n * })\n *\n * // ... because we're telling it here to start casting shadows\n * lastPointLightWithShadows.shadow.cast()\n * ```\n */\nexport class PointLight extends Light {\n  /** @ignore */\n  #range: number\n  /** @ignore */\n  #actualPosition: Vec3\n\n  /** Options used to create this {@link PointLight}. */\n  options: PointLightBaseParams\n\n  /** {@link PointShadow} associated with this {@link PointLight}. */\n  shadow: PointShadow\n\n  /**\n   * PointLight constructor\n   * @param renderer - {@link CameraRenderer | CameraRenderer} used to create this {@link PointLight}.\n   * @param parameters - {@link PointLightBaseParams | parameters} used to create this {@link PointLight}.\n   */\n  constructor(\n    renderer: CameraRenderer | GPUCurtains,\n    { color = new Vec3(1), intensity = 1, position = new Vec3(), range = 0, shadow = null } = {} as PointLightBaseParams\n  ) {\n    const type = 'pointLights'\n    super(renderer, { color, intensity, type })\n\n    this.options = {\n      ...this.options,\n      position,\n      range,\n      shadow,\n    }\n\n    this.#actualPosition = new Vec3()\n    this.position.copy(position)\n\n    this.range = range\n\n    this.parent = this.renderer.scene\n\n    this.shadow = new PointShadow(this.renderer, {\n      autoRender: false, // will be set by calling cast()\n      light: this,\n    })\n\n    if (shadow) {\n      this.shadow.cast(shadow)\n    }\n  }\n\n  /**\n   * Set or reset this {@link PointLight} {@link CameraRenderer}.\n   * @param renderer - New {@link CameraRenderer} or {@link GPUCurtains} instance to use.\n   */\n  setRenderer(renderer: CameraRenderer | GPUCurtains) {\n    if (this.shadow) {\n      this.shadow.setRenderer(renderer)\n    }\n\n    super.setRenderer(renderer)\n  }\n\n  /**\n   * Resend all properties to the {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}. Called when the maximum number of {@link PointLight} has been overflowed.\n   */\n  reset() {\n    super.reset()\n    this.onPropertyChanged('range', this.range)\n    this.setPosition()\n    this.shadow?.reset()\n  }\n\n  /**\n   * Get this {@link PointLight} range.\n   * @returns - The {@link PointLight} range.\n   */\n  get range(): number {\n    return this.#range\n  }\n\n  /**\n   * Set this {@link PointLight} range and update the {@link CameraRenderer} corresponding {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}.\n   * @param value - The new {@link PointLight} range.\n   */\n  set range(value: number) {\n    this.#range = value\n    this.onPropertyChanged('range', this.range)\n  }\n\n  /**\n   * Set the {@link PointLight} position based on the {@link worldMatrix} translation and update the {@link PointShadow} view matrices.\n   */\n  setPosition() {\n    this.onPropertyChanged('position', this.worldMatrix.getTranslation(this.#actualPosition))\n    this.shadow?.updateViewMatrices(this.#actualPosition)\n  }\n\n  // explicitly disable scale and transform origin transformations\n\n  /** @ignore */\n  applyScale() {}\n\n  /** @ignore */\n  applyTransformOrigin() {}\n\n  /**\n   * If the {@link modelMatrix | model matrix} has been updated, set the new position from the {@link worldMatrix} translation.\n   */\n  updateMatrixStack() {\n    super.updateMatrixStack()\n\n    if (this.matricesNeedUpdate) {\n      this.setPosition()\n    }\n  }\n\n  /**\n   * Tell the {@link renderer} that the maximum number of {@link PointLight} has been overflown.\n   * @param lightsType - {@link type} of this light.\n   */\n  onMaxLightOverflow(lightsType: LightsType) {\n    super.onMaxLightOverflow(lightsType)\n    this.shadow?.setRendererBinding()\n  }\n\n  /**\n   * Destroy this {@link PointLight} and associated {@link PointShadow}.\n   */\n  destroy() {\n    super.destroy()\n    this.shadow.destroy()\n  }\n}\n","import { generateUUID, throwWarning } from '../../../utils/utils'\nimport { isRenderer, Renderer } from '../../renderers/utils'\nimport { RenderMaterial } from '../../materials/RenderMaterial'\nimport { DOMTexture } from '../../textures/DOMTexture'\nimport { Geometry } from '../../geometries/Geometry'\nimport { Texture, TextureParams } from '../../textures/Texture'\nimport { ExternalTextureParams, DOMTextureParams, DOMTextureParent } from '../../../types/Textures'\nimport { RenderTarget } from '../../renderPasses/RenderTarget'\nimport { GPUCurtains } from '../../../curtains/GPUCurtains'\nimport { ProjectedMesh, SceneStackedMesh } from '../../renderers/GPURenderer'\nimport { Material } from '../../materials/Material'\nimport { DOMElementBoundingRect } from '../../DOM/DOMElement'\nimport { AllowedGeometries, RenderMaterialParams, ShaderOptions } from '../../../types/Materials'\nimport { ProjectedMeshBaseClass } from './ProjectedMeshBaseMixin'\nimport default_vsWgsl from '../../shaders/chunks/default/default_vs.wgsl'\nimport default_fsWgsl from '../../shaders/chunks/default/default_fs.wgsl'\nimport { RenderPass } from '../../renderPasses/RenderPass'\nimport { RenderBundle } from '../../renderPasses/RenderBundle'\n\nlet meshIndex = 0\n\n/**\n * Base render params used to create a Mesh.\n */\nexport interface MeshBaseRenderParams extends Omit<RenderMaterialParams, 'targets'> {\n  /** Whether we should add this Mesh to our {@link core/scenes/Scene.Scene | Scene} to let it handle the rendering process automatically. */\n  autoRender?: boolean\n  /** Flag indicating whether to draw this Mesh or not. */\n  visible?: boolean\n  /** Controls the order in which this Mesh should be rendered by our {@link core/scenes/Scene.Scene | Scene}. */\n  renderOrder?: number\n  /** Optional {@link RenderTarget} to render this Mesh to instead of the canvas context. */\n  outputTarget?: RenderTarget\n  /** Parameters used by this Mesh to create a {@link DOMTexture}. */\n  texturesOptions?: ExternalTextureParams\n  /** Optional {@link https://developer.mozilla.org/en-US/docs/Web/API/GPUDevice/createRenderPipeline#targets | targets} properties. */\n  targets?: Partial<GPUColorTargetState>[]\n  /** Optional {@link RenderBundle} into which this Mesh should be added. */\n  renderBundle?: RenderBundle\n}\n\n/**\n * Base parameters used to create a Mesh.\n */\nexport interface MeshBaseParams extends MeshBaseRenderParams {\n  /** Geometry to use */\n  geometry?: AllowedGeometries\n}\n\n/**\n *  Base options used to create this Mesh.\n */\nexport interface MeshBaseOptions extends Omit<MeshBaseRenderParams, 'renderOrder' | 'visible'> {\n  /** The label of this Mesh, sent to various GPU objects for debugging purpose. */\n  label?: MeshBaseParams['label']\n  //targets?: RenderMaterialParams['targets']\n}\n\n/** @const - Default Mesh parameters to merge with user defined parameters. */\nconst defaultMeshBaseParams = {\n  // material\n  autoRender: true,\n  useProjection: false,\n  useAsyncPipeline: true,\n  // rendering\n  cullMode: 'back',\n  depth: true,\n  depthWriteEnabled: true,\n  depthCompare: 'less',\n  depthFormat: 'depth24plus',\n  transparent: false,\n  visible: true,\n  renderOrder: 0,\n  // textures\n  texturesOptions: {},\n  renderBundle: null,\n} as MeshBaseParams\n\n// based on https://stackoverflow.com/a/75673107/13354068\n// we declare first a class, and then the mixin with a return type\n/**\n * This class describes the properties and methods to set up a basic Mesh, implemented in the {@link MeshBaseMixin}:\n * - Set and render the {@link Geometry} and {@link RenderMaterial}\n * - Add helpers to create {@link DOMTexture} and {@link Texture}\n * - Handle resizing, device lost/restoration and destroying the resources\n */\nexport declare class MeshBaseClass {\n  /** The type of the {@link MeshBaseClass} */\n  type: string\n  /** The universal unique id of the {@link MeshBaseClass} */\n  readonly uuid: string\n  /** Index of this {@link MeshBaseClass}, i.e. creation order */\n  readonly index: number\n  /** The {@link Renderer} used */\n  renderer: Renderer\n\n  /** Options used to create this {@link MeshBaseClass} */\n  options: MeshBaseOptions\n\n  /** {@link RenderMaterial} used by this {@link MeshBaseClass} */\n  material: RenderMaterial\n  /** {@link AllowedGeometries | Geometry} used by this {@link MeshBaseClass} */\n  geometry: MeshBaseParams['geometry']\n\n  /** {@link RenderTarget} to render this Mesh to instead of the canvas context, if any. */\n  outputTarget: null | RenderTarget\n\n  /** {@link RenderBundle} used to render this Mesh, if any. */\n  renderBundle: null | RenderBundle\n\n  /** Controls the order in which this {@link MeshBaseClass} should be rendered by our {@link core/scenes/Scene.Scene | Scene} */\n  renderOrder: number\n  /** Whether this {@link MeshBaseClass} should be treated as transparent. Impacts the {@link core/pipelines/RenderPipelineEntry.RenderPipelineEntry#pipeline | render pipeline} blend properties */\n  _transparent: boolean\n\n  /** Flag indicating whether to draw this {@link MeshBaseClass} or not */\n  _visible: boolean\n  /** Flag indicating whether this {@link MeshBaseClass} is ready to be drawn */\n  _ready: boolean\n\n  /** Empty object to store any additional data or custom properties into your Mesh. */\n  userData: Record<string, unknown>\n\n  // callbacks\n  /** function assigned to the {@link onReady} callback */\n  _onReadyCallback: () => void\n  /** function assigned to the {@link onBeforeRender} callback */\n  _onBeforeRenderCallback: () => void\n  /** function assigned to the {@link onRender} callback */\n  _onRenderCallback: () => void\n  /** function assigned to the {@link onAfterRender} callback */\n  _onAfterRenderCallback: () => void\n  /** function assigned to the {@link onAfterResize} callback */\n  _onAfterResizeCallback: () => void\n\n  /**\n   * Callback to execute when a Mesh is ready - i.e. its {@link material} and {@link geometry} are ready.\n   * @param callback - callback to run when {@link MeshBaseClass} is ready\n   * @returns - our Mesh\n   */\n  onReady: (callback: () => void) => MeshBaseClass | ProjectedMeshBaseClass\n\n  /**\n   * Callback to execute before updating the {@link core/scenes/Scene.Scene | Scene} matrix stack. This means it is called early and allows to update transformations values before actually setting the Mesh matrices (if any). This also means it won't be called if the Mesh has not been added to the {@link core/scenes/Scene.Scene | Scene}. The callback won't be called if the {@link Renderer} is not ready or the Mesh itself is neither {@link ready} nor {@link visible}.\n   * @param callback - callback to run just before updating the {@link core/scenes/Scene.Scene | Scene} matrix stack.\n   * @returns - our Mesh\n   */\n  onBeforeRender: (callback: () => void) => MeshBaseClass | ProjectedMeshBaseClass\n\n  /**\n   * Callback to execute right before actually rendering the Mesh. Useful to update uniforms for example. The callback won't be called if the {@link Renderer} is not ready or the Mesh itself is neither {@link ready} nor {@link visible}.\n   * @param callback - callback to run just before rendering the {@link MeshBaseClass}.\n   * @returns - our Mesh\n   */\n  onRender: (callback: () => void) => MeshBaseClass | ProjectedMeshBaseClass\n\n  /**\n   * Callback to execute just after a Mesh has been rendered. The callback won't be called if the {@link Renderer} is not ready or the Mesh itself is neither {@link ready} nor {@link visible}.\n   * @param callback - callback to run just after {@link MeshBaseClass} has been rendered\n   * @returns - our Mesh\n   */\n  onAfterRender: (callback: () => void) => MeshBaseClass | ProjectedMeshBaseClass\n\n  /**\n   * Callback to execute just after a Mesh has been resized.\n   * @param callback - callback to run just after {@link MeshBaseClass} has been resized\n   * @returns - our Mesh\n   */\n  onAfterResize: (callback: () => void) => MeshBaseClass | ProjectedMeshBaseClass\n\n  /**\n   * {@link MeshBaseClass} constructor\n   * @param renderer - our {@link Renderer} class object\n   * @param element - a DOM HTML Element that can be bound to a Mesh\n   * @param parameters - {@link MeshBaseParams | Mesh base parameters}\n   */\n  constructor(renderer: Renderer, element: HTMLElement | null, parameters: MeshBaseParams)\n\n  /**\n   * Get private #autoRender value\n   * @readonly\n   */\n  get autoRender(): boolean // allow to read value from child classes\n\n  /**\n   * Get/set whether a Mesh is ready or not\n   * @readonly\n   */\n  get ready(): boolean\n  set ready(value: boolean)\n\n  /**\n   * Add a Mesh to the renderer and the {@link core/scenes/Scene.Scene | Scene}\n   */\n  addToScene(addToRenderer: boolean): void\n\n  /**\n   * Remove a Mesh from the renderer and the {@link core/scenes/Scene.Scene | Scene}\n   */\n  removeFromScene(removeFromRenderer: boolean): void\n\n  /**\n   * Set a new {@link Renderer} for this Mesh\n   * @param renderer - new {@link Renderer} to set\n   */\n  setRenderer(renderer: Renderer | GPUCurtains): void\n\n  /**\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been lost to prepare everything for restoration.\n   * Basically set all the {@link GPUBuffer} to null so they will be reset next time we try to draw the Mesh\n   */\n  loseContext(): void\n\n  /**\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been restored\n   */\n  restoreContext(): void\n\n  /**\n   * Set default shaders if one or both of them are missing\n   */\n  setShaders(): void\n\n  /**\n   * Set or update the Mesh {@link Geometry}\n   * @param geometry - new {@link Geometry} to use\n   */\n  useGeometry(geometry: Geometry): void\n\n  /**\n   * Compute the Mesh geometry if needed\n   */\n  computeGeometry(): void\n\n  /**\n   * Set our Mesh geometry: create buffers and add attributes to material\n   */\n  setGeometry(): void\n\n  /**\n   * Set or update the {@link RenderMaterial} {@link types/Materials.RenderMaterialRenderingOptions | rendering options} to match the {@link RenderPass#descriptor | RenderPass descriptor} used to draw this Mesh.\n   * @param renderPass - {@link RenderPass | RenderPass} used to draw this Mesh, default to the {@link core/renderers/GPURenderer.GPURenderer#renderPass | renderer renderPass}.\n   */\n  setRenderingOptionsForRenderPass(renderPass: RenderPass): void\n\n  /**\n   * Hook used to clean up parameters before sending them to the material.\n   * @param parameters - parameters to clean before sending them to the {@link RenderMaterial}\n   * @returns - cleaned parameters\n   */\n  cleanupRenderMaterialParameters(parameters: MeshBaseRenderParams): MeshBaseRenderParams\n\n  /**\n   * Set or update the Mesh {@link RenderMaterial}\n   * @param material - new {@link RenderMaterial} to use\n   */\n  useMaterial(material: RenderMaterial): void\n\n  /**\n   * Set a Mesh transparent property, then set its material\n   * @param meshParameters - {@link RenderMaterialParams | RenderMaterial parameters}\n   */\n  setMaterial(meshParameters: RenderMaterialParams): void\n\n  /**\n   * Set Mesh material attributes\n   */\n  setMaterialGeometryAttributes(): void\n\n  /**\n   * Get the transparent property value\n   */\n  get transparent(): boolean | undefined\n\n  /**\n   * Set the transparent property value. Update the {@link RenderMaterial} rendering options and {@link core/scenes/Scene.Scene | Scene} stack if needed.\n   * @param value - new transparency value\n   */\n  set transparent(value: boolean)\n\n  /**\n   * Get the visible property value\n   */\n  get visible(): boolean\n\n  /**\n   * Set the visible property value\n   * @param value - new visibility value\n   */\n  set visible(value: boolean)\n\n  /**\n   * Get our {@link RenderMaterial#domTextures | RenderMaterial domTextures array}\n   * @readonly\n   */\n  get domTextures(): DOMTexture[]\n\n  /**\n   * Get our {@link RenderMaterial#textures | RenderMaterial textures array}\n   * @readonly\n   */\n  get textures(): Texture[]\n\n  /**\n   * Create a new {@link DOMTexture}\n   * @param options - {@link DOMTextureParams | DOMTexture parameters}\n   * @returns - newly created DOMTexture\n   */\n  createDOMTexture(options: DOMTextureParams): DOMTexture\n\n  /**\n   * Add a {@link DOMTexture}\n   * @param domTexture - {@link DOMTexture} to add\n   */\n  addDOMTexture(domTexture: DOMTexture)\n\n  /**\n   * Callback run when a new {@link DOMTexture} has been created\n   * @param domTexture - newly created DOMTexture\n   */\n  onDOMTextureAdded(domTexture: DOMTexture): void\n\n  /**\n   * Create a new {@link Texture}\n   * @param  options - {@link TextureParams | Texture parameters}\n   * @returns - newly created Texture\n   */\n  createTexture(options: TextureParams): Texture\n\n  /**\n   * Add a {@link Texture}\n   * @param texture - {@link Texture} to add\n   */\n  addTexture(texture: Texture)\n\n  /**\n   * Assign or remove a {@link RenderTarget} to this Mesh\n   * Since this manipulates the {@link core/scenes/Scene.Scene | Scene} stacks, it can be used to remove a RenderTarget as well.\n   * @param outputTarget - the RenderTarget to assign or null if we want to remove the current RenderTarget\n   */\n  setOutputTarget(outputTarget: RenderTarget | null): void\n\n  /**\n   * Assign or remove a {@link RenderBundle} to this Mesh.\n   * @param renderBundle - the {@link RenderBundle} to assign or null if we want to remove the current {@link RenderBundle}.\n   * @param updateScene - Whether to remove and then re-add the Mesh from the {@link core/scenes/Scene.Scene | Scene} or not.\n   */\n  setRenderBundle(renderBundle?: RenderBundle | null, updateScene?: boolean): void\n\n  /**\n   * Get the current {@link RenderMaterial} uniforms\n   * @readonly\n   */\n  get uniforms(): Material['uniforms']\n\n  /**\n   * Get the current {@link RenderMaterial} storages\n   * @readonly\n   */\n  get storages(): Material['storages']\n\n  /**\n   * Resize the Mesh's textures\n   * @param boundingRect\n   */\n  resize(boundingRect?: DOMElementBoundingRect): void\n\n  /**\n   * Execute {@link onBeforeRender} callback if needed. Called by the {@link core/scenes/Scene.Scene | Scene} before updating the matrix stack.\n   */\n  onBeforeRenderScene(): void\n\n  /**\n   * Called before rendering the Mesh\n   * Set the geometry if needed (create buffers and add attributes to the {@link RenderMaterial})\n   * Then executes {@link RenderMaterial#onBeforeRender}: create its bind groups and pipeline if needed and eventually update its bindings\n   */\n  onBeforeRenderPass(): void\n\n  /**\n   * Render our {@link MeshBaseClass} if the {@link RenderMaterial} is ready\n   * @param pass - current render pass encoder\n   */\n  onRenderPass(pass: GPURenderPassEncoder): void\n\n  /**\n   * Called after having rendered the Mesh\n   */\n  onAfterRenderPass(): void\n\n  /**\n   * Render our Mesh\n   * - Execute {@link onBeforeRenderPass}\n   * - Stop here if {@link Renderer} is not ready or Mesh is not {@link visible}\n   * - Execute super render call if it exists\n   * - {@link onRenderPass | render} our {@link material} and {@link geometry}\n   * - Execute {@link onAfterRenderPass}\n   * @param pass - current render pass encoder\n   */\n  render(pass: GPURenderPassEncoder): void\n\n  /**\n   * Remove the Mesh from the {@link core/scenes/Scene.Scene | Scene} and destroy it\n   */\n  remove(): void\n\n  /**\n   * Destroy the Mesh\n   */\n  destroy(): void\n}\n\n/**\n * Constructor function, that creates a new instance of the given type.\n * @constructor\n * @template T - the base constructor\n * @param args - The arguments passed to the constructor.\n * @returns - An instance of the mixin.\n */\nexport type MixinConstructor<T = {}> = new (...args: any[]) => T\n\n/**\n * Used to mix the basic Mesh properties and methods defined in {@link MeshBaseClass} (basically, set a {@link Geometry} and a {@link RenderMaterial} and render them, add helpers to create {@link DOMTexture} and {@link Texture}) with a given Base of type {@link core/objects3D/Object3D.Object3D | Object3D}, {@link core/objects3D/ProjectedObject3D.ProjectedObject3D | ProjectedObject3D}, {@link curtains/objects3D/DOMObject3D.DOMObject3D | DOMObject3D} or an empty class.\n * @exports MeshBaseMixin\n * @param Base - the class to mix onto\n * @returns - the mixed classes, creating a basic Mesh.\n */\nfunction MeshBaseMixin<TBase extends MixinConstructor>(Base: TBase): MixinConstructor<MeshBaseClass> & TBase {\n  /**\n   * MeshBase defines our base properties and methods\n   */\n  return class MeshBase extends Base implements MeshBaseClass {\n    /** The type of the {@link MeshBase} */\n    type: string\n    /** The universal unique id of the {@link MeshBase} */\n    readonly uuid: string\n    /** Index of this {@link MeshBase}, i.e. creation order */\n    readonly index: number\n    /** The {@link Renderer} used */\n    renderer: Renderer\n\n    /** Options used to create this {@link MeshBase} */\n    options: MeshBaseOptions\n\n    /** {@link RenderMaterial} used by this {@link MeshBase} */\n    material: RenderMaterial\n    /** {@link AllowedGeometries | Geometry} used by this {@link MeshBase} */\n    geometry: MeshBaseParams['geometry']\n\n    /** {@link RenderTarget} to render this Mesh to, if any */\n    outputTarget: null | RenderTarget\n\n    /** {@link RenderBundle} used to render this Mesh, if any. */\n    renderBundle: null | RenderBundle\n\n    /** Controls the order in which this {@link MeshBase} should be rendered by our {@link core/scenes/Scene.Scene | Scene} */\n    renderOrder: number\n    /** Whether this {@link MeshBase} should be treated as transparent. Impacts the {@link core/pipelines/RenderPipelineEntry.RenderPipelineEntry#pipeline | render pipeline} blend properties */\n    _transparent: boolean\n\n    /** Flag indicating whether to draw this {@link MeshBase} or not */\n    _visible: boolean\n    /** Flag indicating whether this {@link MeshBase} is ready to be drawn */\n    _ready: boolean\n\n    /** Empty object to store any additional data or custom properties into your {@link MeshBase}. */\n    userData: Record<string, unknown>\n\n    /** Whether we should add this {@link MeshBase} to our {@link core/scenes/Scene.Scene | Scene} to let it handle the rendering process automatically */\n    #autoRender = true\n\n    // callbacks / events\n    /** function assigned to the {@link onReady} callback */\n    _onReadyCallback: () => void = () => {\n      /* allow empty callback */\n    }\n    /** function assigned to the {@link onBeforeRender} callback */\n    _onBeforeRenderCallback: () => void = () => {\n      /* allow empty callback */\n    }\n    /** function assigned to the {@link onRender} callback */\n    _onRenderCallback: () => void = () => {\n      /* allow empty callback */\n    }\n    /** function assigned to the {@link onAfterRender} callback */\n    _onAfterRenderCallback: () => void = () => {\n      /* allow empty callback */\n    }\n    /** function assigned to the {@link onAfterResize} callback */\n    _onAfterResizeCallback: () => void = () => {\n      /* allow empty callback */\n    }\n\n    /**\n     * MeshBase constructor\n     *\n     * @typedef MeshBaseArrayParams\n     * @type {array}\n     * @property {(Renderer|GPUCurtains)} 0 - our {@link Renderer} class object\n     * @property {(string|HTMLElement|null)} 1 - a DOM HTML Element that can be bound to a Mesh\n     * @property {MeshBaseParams} 2 - {@link MeshBaseParams | Mesh base parameters}\n     *\n     * @param {MeshBaseArrayParams} params - our MeshBaseMixin parameters\n     */\n    constructor(...params: any[]) {\n      super(\n        params[0] as Renderer | GPUCurtains,\n        params[1] as HTMLElement | string | null,\n        { ...defaultMeshBaseParams, ...params[2] } as MeshBaseParams\n      )\n\n      let renderer = params[0]\n      const parameters = { ...defaultMeshBaseParams, ...params[2] }\n\n      this.type = 'MeshBase'\n\n      this.uuid = generateUUID()\n      Object.defineProperty(this as MeshBase, 'index', { value: meshIndex++ })\n\n      renderer = isRenderer(renderer, parameters.label ? parameters.label + ' ' + this.type : this.type)\n\n      this.renderer = renderer\n\n      const {\n        label,\n        shaders,\n        geometry,\n        visible,\n        renderOrder,\n        outputTarget,\n        renderBundle,\n        texturesOptions,\n        autoRender,\n        ...meshParameters\n      } = parameters\n\n      this.outputTarget = outputTarget ?? null\n      this.renderBundle = renderBundle ?? null\n\n      // set default sample count\n      meshParameters.sampleCount = !!meshParameters.sampleCount\n        ? meshParameters.sampleCount\n        : this.outputTarget\n        ? this.outputTarget.renderPass.options.sampleCount\n        : this.renderer && this.renderer.renderPass\n        ? this.renderer.renderPass.options.sampleCount\n        : 1\n\n      this.options = {\n        ...(this.options ?? {}), // merge possible lower options?\n        label: label ?? 'Mesh ' + this.renderer.meshes.length,\n        ...(shaders !== undefined ? { shaders } : {}),\n        ...(outputTarget !== undefined && { outputTarget }),\n        ...(renderBundle !== undefined && { renderBundle }),\n        texturesOptions,\n        ...(autoRender !== undefined && { autoRender }),\n        ...meshParameters,\n      }\n\n      if (autoRender !== undefined) {\n        this.#autoRender = autoRender\n      }\n\n      this.visible = visible\n      this.renderOrder = renderOrder\n      this.ready = false\n\n      this.userData = {}\n\n      if (geometry) {\n        this.useGeometry(geometry)\n      }\n\n      this.setMaterial({\n        ...this.cleanupRenderMaterialParameters({ ...this.options }),\n        ...(geometry && { verticesOrder: geometry.verticesOrder, topology: geometry.topology }),\n      } as RenderMaterialParams)\n\n      this.addToScene(true)\n    }\n\n    /**\n     * Get private #autoRender value\n     * @readonly\n     */\n    get autoRender(): boolean {\n      return this.#autoRender\n    }\n\n    /**\n     * Get/set whether a Mesh is ready or not\n     * @readonly\n     */\n    get ready(): boolean {\n      return this._ready\n    }\n\n    set ready(value: boolean) {\n      if (value && !this._ready) {\n        this._onReadyCallback && this._onReadyCallback()\n      }\n      this._ready = value\n    }\n\n    /* SCENE */\n\n    /**\n     * Add a Mesh to the {@link core/scenes/Scene.Scene | Scene} and optionally to the renderer. Can patch the {@link RenderMaterial} render options to match the {@link RenderPass} used to draw this Mesh.\n     * @param addToRenderer - whether to add this Mesh to the {@link Renderer#meshes | Renderer meshes array}\n     */\n    addToScene(addToRenderer = false) {\n      if (addToRenderer) {\n        this.renderer.meshes.push(this as unknown as SceneStackedMesh)\n      }\n\n      this.setRenderingOptionsForRenderPass(this.outputTarget ? this.outputTarget.renderPass : this.renderer.renderPass)\n\n      if (this.#autoRender) {\n        this.renderer.scene.addMesh(this as unknown as SceneStackedMesh)\n      }\n    }\n\n    /**\n     * Remove a Mesh from the {@link core/scenes/Scene.Scene | Scene} and optionally from the renderer as well.\n     * @param removeFromRenderer - whether to remove this Mesh from the {@link Renderer#meshes | Renderer meshes array}\n     */\n    removeFromScene(removeFromRenderer = false) {\n      if (this.#autoRender) {\n        this.renderer.scene.removeMesh(this as unknown as ProjectedMesh)\n      }\n\n      if (removeFromRenderer) {\n        this.renderer.meshes = this.renderer.meshes.filter((m) => m.uuid !== this.uuid)\n      }\n    }\n\n    /**\n     * Set a new {@link Renderer} for this Mesh\n     * @param renderer - new {@link Renderer} to set\n     */\n    setRenderer(renderer: Renderer | GPUCurtains) {\n      // we could pass our curtains object OR our curtains renderer object\n      renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as Renderer)\n\n      if (\n        !renderer ||\n        !(\n          renderer.type === 'GPURenderer' ||\n          renderer.type === 'GPUCameraRenderer' ||\n          renderer.type === 'GPUCurtainsRenderer'\n        )\n      ) {\n        throwWarning(\n          `${this.options.label}: Cannot set ${renderer} as a renderer because it is not of a valid Renderer type.`\n        )\n        return\n      }\n\n      this.material?.setRenderer(renderer)\n\n      const oldRenderer = this.renderer\n      this.removeFromScene(true)\n      this.renderer = renderer\n      this.addToScene(true)\n\n      // if old renderer does not contain any meshes any more\n      // clear it\n      if (!oldRenderer.meshes.length) {\n        oldRenderer.onBeforeRenderScene.add(\n          (commandEncoder) => {\n            oldRenderer.forceClear(commandEncoder)\n          },\n          { once: true }\n        )\n      }\n    }\n\n    /**\n     * Assign or remove a {@link RenderTarget} to this Mesh.\n     * Since this manipulates the {@link core/scenes/Scene.Scene | Scene} stacks, it can be used to remove a {@link RenderTarget} as well.\n     * @param outputTarget - the {@link RenderTarget} to assign or null if we want to remove the current {@link RenderTarget}.\n     */\n    setOutputTarget(outputTarget: RenderTarget | null) {\n      if (outputTarget && outputTarget.type !== 'RenderTarget') {\n        throwWarning(`${this.options.label ?? this.type}: outputTarget is not a RenderTarget: ${outputTarget.type}`)\n        return\n      }\n\n      // ensure the mesh is in the correct scene stack\n      this.removeFromScene()\n      this.outputTarget = outputTarget\n      this.addToScene()\n    }\n\n    /**\n     * Assign or remove a {@link RenderBundle} to this Mesh.\n     * @param renderBundle - the {@link RenderBundle} to assign or null if we want to remove the current {@link RenderBundle}.\n     * @param updateScene - Whether to remove and then re-add the Mesh from the {@link core/scenes/Scene.Scene | Scene} or not.\n     */\n    setRenderBundle(renderBundle: RenderBundle | null, updateScene = true) {\n      // ensure the mesh is in the correct scene stack\n      if (updateScene) {\n        this.removeFromScene()\n        this.renderBundle = renderBundle\n        this.addToScene()\n      } else {\n        this.renderBundle = renderBundle\n      }\n    }\n\n    /**\n     * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been lost to prepare everything for restoration.\n     * Basically set all the {@link GPUBuffer} to null so they will be reset next time we try to draw the Mesh\n     */\n    loseContext() {\n      // we're obviously not ready anymore\n      this.ready = false\n\n      // first the geometry\n      this.geometry.loseContext()\n\n      // then the material\n      this.material.loseContext()\n    }\n\n    /**\n     * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been restored\n     */\n    restoreContext() {\n      this.geometry.restoreContext(this.renderer)\n      this.material.restoreContext()\n    }\n\n    /* SHADERS */\n\n    /**\n     * Set default shaders if one or both of them are missing\n     */\n    setShaders() {\n      const { shaders } = this.options\n\n      if (!shaders) {\n        this.options.shaders = {\n          vertex: {\n            code: default_vsWgsl,\n            entryPoint: 'main',\n          },\n          fragment: {\n            code: default_fsWgsl,\n            entryPoint: 'main',\n          },\n        }\n      } else {\n        if (!shaders.vertex || !shaders.vertex.code) {\n          shaders.vertex = {\n            code: default_vsWgsl,\n            entryPoint: 'main',\n          }\n        }\n\n        if (shaders.fragment === undefined || (shaders.fragment && !(shaders.fragment as ShaderOptions).code)) {\n          shaders.fragment = {\n            code: default_fsWgsl,\n            entryPoint: 'main',\n          }\n        }\n      }\n    }\n\n    /* GEOMETRY */\n\n    /**\n     * Set or update the Mesh {@link Geometry}\n     * @param geometry - new {@link Geometry} to use\n     */\n    useGeometry(geometry: Geometry) {\n      if (this.geometry) {\n        // compute right away to compare geometries\n        if (geometry.shouldCompute) {\n          geometry.computeGeometry()\n        }\n\n        if (this.geometry.layoutCacheKey !== geometry.layoutCacheKey) {\n          throwWarning(\n            `${this.options.label} (${this.type}): the current and new geometries do not have the same vertexBuffers layout, causing a probable pipeline recompilation. This should be avoided.\\n\\nCurrent geometry layout:\\n\\n${this.geometry.wgslStructFragment}\\n\\n--------\\n\\nNew geometry layout:\\n\\n${geometry.wgslStructFragment}`\n          )\n\n          this.material.setAttributesFromGeometry(geometry)\n          this.material.setPipelineEntry()\n        }\n\n        this.geometry.consumers.delete(this.uuid)\n      }\n\n      this.geometry = geometry\n      this.geometry.consumers.add(this.uuid)\n\n      this.computeGeometry()\n\n      if (this.material) {\n        const renderingOptions = {\n          ...this.material.options.rendering,\n          ...{ verticesOrder: geometry.verticesOrder, topology: geometry.topology },\n        }\n\n        this.material.setRenderingOptions(renderingOptions)\n      }\n    }\n\n    /**\n     * Compute the Mesh geometry if needed\n     */\n    computeGeometry() {\n      if (this.geometry.shouldCompute) {\n        this.geometry.computeGeometry()\n      }\n    }\n\n    /**\n     * Set our Mesh geometry: create buffers and add attributes to material\n     */\n    setGeometry() {\n      if (this.geometry) {\n        if (!this.geometry.ready) {\n          this.geometry.createBuffers({\n            renderer: this.renderer,\n            label: this.options.label + ' geometry',\n          })\n        }\n\n        this.setMaterialGeometryAttributes()\n      }\n    }\n\n    /* MATERIAL */\n\n    /**\n     * Set or update the {@link RenderMaterial} {@link types/Materials.RenderMaterialRenderingOptions | rendering options} to match the {@link RenderPass#descriptor | RenderPass descriptor} used to draw this Mesh.\n     * @param renderPass - {@link RenderPass | RenderPass} used to draw this Mesh, default to the {@link core/renderers/GPURenderer.GPURenderer#renderPass | renderer renderPass}.\n     */\n    setRenderingOptionsForRenderPass(renderPass: RenderPass) {\n      // a Mesh render material rendering options MUST match the render pass descriptor used to draw it!\n      const renderingOptions = {\n        // transparency (blend)\n        transparent: this.transparent,\n        // sample count\n        sampleCount: renderPass.options.sampleCount,\n        // color attachments\n        ...(renderPass.options.colorAttachments.length && {\n          targets: renderPass.options.colorAttachments.map((colorAttachment, index) => {\n            return {\n              // patch format...\n              format: colorAttachment.targetFormat,\n              // ...but keep original blend values if any\n              ...(this.options.targets?.length &&\n                this.options.targets[index] &&\n                this.options.targets[index].blend && {\n                  blend: this.options.targets[index].blend,\n                }),\n            }\n          }),\n        }),\n        // depth\n        depth: renderPass.options.useDepth,\n        ...(renderPass.options.useDepth && {\n          depthFormat: renderPass.options.depthFormat,\n        }),\n      }\n\n      this.material?.setRenderingOptions(renderingOptions)\n    }\n\n    /**\n     * Hook used to clean up parameters before sending them to the {@link RenderMaterial}.\n     * @param parameters - parameters to clean before sending them to the {@link RenderMaterial}\n     * @returns - cleaned parameters\n     */\n    cleanupRenderMaterialParameters(parameters: MeshBaseRenderParams): MeshBaseRenderParams {\n      // patch and set options, return mesh parameters\n      delete parameters.texturesOptions\n      delete parameters.outputTarget\n      delete parameters.autoRender\n\n      return parameters\n    }\n\n    /**\n     * Set or update the Mesh {@link RenderMaterial}\n     * @param material - new {@link RenderMaterial} to use\n     */\n    useMaterial(material: RenderMaterial) {\n      this.material = material\n\n      // update transparent property\n      this.transparent = this.material.options.rendering.transparent\n\n      // add eventual textures passed as parameters\n      this.material.options.domTextures\n        ?.filter((texture) => texture instanceof DOMTexture)\n        .forEach((texture) => this.onDOMTextureAdded(texture))\n    }\n\n    /**\n     * Patch the shaders if needed, then set the Mesh material\n     * @param meshParameters - {@link RenderMaterialParams | RenderMaterial parameters}\n     */\n    setMaterial(meshParameters: RenderMaterialParams) {\n      this.setShaders()\n      meshParameters.shaders = this.options.shaders\n      meshParameters.label = meshParameters.label + ' material'\n\n      this.useMaterial(new RenderMaterial(this.renderer, meshParameters))\n    }\n\n    /**\n     * Set Mesh material attributes\n     */\n    setMaterialGeometryAttributes() {\n      if (this.material && !this.material.attributes) {\n        this.material.setAttributesFromGeometry(this.geometry)\n      }\n    }\n\n    /**\n     * Get the transparent property value\n     */\n    get transparent(): boolean | undefined {\n      return this._transparent\n    }\n\n    /**\n     * Set the transparent property value. Update the {@link RenderMaterial} rendering options and {@link core/scenes/Scene.Scene | Scene} stack if needed.\n     * @param value\n     */\n    set transparent(value: boolean) {\n      const switchTransparency = this.transparent !== undefined && value !== this.transparent\n\n      if (switchTransparency) {\n        this.removeFromScene()\n      }\n\n      this._transparent = value\n\n      if (switchTransparency) {\n        this.addToScene()\n      }\n    }\n\n    /**\n     * Get the visible property value\n     */\n    get visible(): boolean {\n      return this._visible\n    }\n\n    /**\n     * Set the visible property value\n     * @param value - new visibility value\n     */\n    set visible(value: boolean) {\n      this._visible = value\n    }\n\n    /* TEXTURES */\n\n    /**\n     * Get our {@link RenderMaterial#domTextures | RenderMaterial domTextures array}\n     * @readonly\n     */\n    get domTextures(): DOMTexture[] {\n      return this.material?.domTextures || []\n    }\n\n    /**\n     * Get our {@link RenderMaterial#textures | RenderMaterial textures array}\n     * @readonly\n     */\n    get textures(): Texture[] {\n      return this.material?.textures || []\n    }\n\n    /**\n     * Create a new {@link DOMTexture}\n     * @param options - {@link DOMTextureParams | DOMTexture parameters}\n     * @returns - newly created {@link DOMTexture}\n     */\n    createDOMTexture(options: DOMTextureParams): DOMTexture {\n      if (!options.name) {\n        options.name = 'texture' + (this.textures.length + this.domTextures.length)\n      }\n\n      if (!options.label) {\n        options.label = this.options.label + ' ' + options.name\n      }\n\n      const texturesOptions: DOMTextureParams = { ...options, ...this.options.texturesOptions }\n\n      if (this.renderBundle) {\n        // do not allow external video textures if we have a render bundle\n        texturesOptions.useExternalTextures = false\n      }\n\n      const domTexture = new DOMTexture(this.renderer, texturesOptions)\n\n      this.addDOMTexture(domTexture)\n\n      return domTexture\n    }\n\n    /**\n     * Add a {@link DOMTexture}\n     * @param domTexture - {@link DOMTexture} to add\n     */\n    addDOMTexture(domTexture: DOMTexture) {\n      if (this.renderBundle) {\n        // if we create a new texture, invalidate the render bundle\n        this.renderBundle.ready = false\n      }\n\n      this.material.addTexture(domTexture)\n      this.onDOMTextureAdded(domTexture)\n    }\n\n    /**\n     * Callback run when a new {@link DOMTexture} has been added\n     * @param domTexture - newly created DOMTexture\n     */\n    onDOMTextureAdded(domTexture: DOMTexture) {\n      domTexture.parentMesh = this as unknown as DOMTextureParent\n    }\n\n    /**\n     * Create a new {@link Texture}\n     * @param  options - {@link TextureParams | Texture parameters}\n     * @returns - newly created {@link Texture}\n     */\n    createTexture(options: TextureParams): Texture {\n      if (!options.name) {\n        options.name = 'texture' + (this.textures.length + this.domTextures.length)\n      }\n\n      const texture = new Texture(this.renderer, options)\n\n      this.addTexture(texture)\n\n      return texture\n    }\n\n    /**\n     * Add a {@link Texture}\n     * @param texture - {@link Texture} to add\n     */\n    addTexture(texture: Texture) {\n      if (this.renderBundle) {\n        // if we create a new texture, invalidate the render bundle\n        this.renderBundle.ready = false\n      }\n\n      this.material.addTexture(texture)\n    }\n\n    /* BINDINGS */\n\n    /**\n     * Get the current {@link RenderMaterial} uniforms\n     * @readonly\n     */\n    get uniforms(): Material['uniforms'] {\n      return this.material?.uniforms\n    }\n\n    /**\n     * Get the current {@link RenderMaterial} storages\n     * @readonly\n     */\n    get storages(): Material['storages'] {\n      return this.material?.storages\n    }\n\n    /* RESIZE */\n\n    /**\n     * Resize the Mesh's textures\n     * @param boundingRect\n     */\n    resize(boundingRect?: DOMElementBoundingRect | null) {\n      // @ts-ignore\n      if (super.resize) {\n        // @ts-ignore\n        super.resize(boundingRect)\n      }\n\n      this.textures?.forEach((texture) => {\n        // copy from original textures again if needed\n        if (texture.options.fromTexture) {\n          texture.copy(texture.options.fromTexture)\n        }\n      })\n\n      // resize textures\n      this.domTextures?.forEach((texture) => {\n        texture.resize()\n      })\n\n      this._onAfterResizeCallback && this._onAfterResizeCallback()\n    }\n\n    /* EVENTS */\n\n    /**\n     * Callback to execute when a Mesh is ready - i.e. its {@link material} and {@link geometry} are ready.\n     * @param callback - callback to run when {@link MeshBase} is ready\n     * @returns - our Mesh\n     */\n    onReady(callback: () => void): MeshBase | ProjectedMeshBaseClass {\n      if (callback) {\n        this._onReadyCallback = callback\n      }\n\n      return this\n    }\n\n    /**\n     * Callback to execute before updating the {@link core/scenes/Scene.Scene | Scene} matrix stack. This means it is called early and allows to update transformations values before actually setting the Mesh matrices (if any). This also means it won't be called if the Mesh has not been added to the {@link core/scenes/Scene.Scene | Scene}. The callback won't be called if the {@link Renderer} is not ready or the Mesh itself is neither {@link ready} nor {@link visible}.\n     * @param callback - callback to run just before updating the {@link core/scenes/Scene.Scene | Scene} matrix stack.\n     * @returns - our Mesh\n     */\n    onBeforeRender(callback: () => void): MeshBase | ProjectedMeshBaseClass {\n      if (callback) {\n        this._onBeforeRenderCallback = callback\n      }\n\n      return this\n    }\n\n    /**\n     * Callback to execute right before actually rendering the Mesh. Useful to update uniforms for example. The callback won't be called if the {@link Renderer} is not ready or the Mesh itself is neither {@link ready} nor {@link visible}.\n     * @param callback - callback to run just before rendering the {@link MeshBase}\n     * @returns - our Mesh\n     */\n    onRender(callback: () => void): MeshBase | ProjectedMeshBaseClass {\n      if (callback) {\n        this._onRenderCallback = callback\n      }\n\n      return this\n    }\n\n    /**\n     * Callback to execute just after a Mesh has been rendered. The callback won't be called if the {@link Renderer} is not ready or the Mesh itself is neither {@link ready} nor {@link visible}.\n     * @param callback - callback to run just after {@link MeshBase} has been rendered\n     * @returns - our Mesh\n     */\n    onAfterRender(callback: () => void): MeshBase | ProjectedMeshBaseClass {\n      if (callback) {\n        this._onAfterRenderCallback = callback\n      }\n\n      return this\n    }\n\n    /**\n     * Callback to execute just after a Mesh has been resized.\n     * @param callback - callback to run just after {@link MeshBase} has been resized\n     * @returns - our Mesh\n     */\n    onAfterResize(callback: () => void): MeshBase | ProjectedMeshBaseClass {\n      if (callback) {\n        this._onAfterResizeCallback = callback\n      }\n\n      return this\n    }\n\n    /* RENDER */\n\n    /**\n     * Execute {@link onBeforeRender} callback if needed. Called by the {@link core/scenes/Scene.Scene | Scene} before updating the matrix stack.\n     */\n    onBeforeRenderScene() {\n      if (!this.renderer.ready || !this.ready || !this.visible) return\n\n      this._onBeforeRenderCallback && this._onBeforeRenderCallback()\n    }\n\n    /**\n     * Called before rendering the Mesh\n     * Set the geometry if needed (create buffers and add attributes to the {@link RenderMaterial})\n     * Then executes {@link RenderMaterial#onBeforeRender}: create its bind groups and pipeline if needed and eventually update its bindings\n     */\n    onBeforeRenderPass() {\n      if (!this.renderer.ready) return\n\n      this.setGeometry()\n\n      if (this.visible) {\n        this._onRenderCallback && this._onRenderCallback()\n      }\n\n      this.material.onBeforeRender()\n\n      this.ready = this.material && this.material.ready && this.geometry && this.geometry.ready\n    }\n\n    /**\n     * Render our {@link MeshBase} if the {@link RenderMaterial} is ready\n     * @param pass - current render pass encoder\n     */\n    onRenderPass(pass: GPURenderPassEncoder) {\n      if (!this.ready) return\n\n      // render ou material\n      this.material.render(pass)\n      // then render our geometry\n      this.geometry.render(pass)\n    }\n\n    /**\n     * Called after having rendered the Mesh\n     */\n    onAfterRenderPass() {\n      this._onAfterRenderCallback && this._onAfterRenderCallback()\n    }\n\n    /**\n     * Render our Mesh\n     * - Execute {@link onBeforeRenderPass}\n     * - Stop here if {@link Renderer} is not ready or Mesh is not {@link visible}\n     * - Execute super render call if it exists\n     * - {@link onRenderPass | render} our {@link material} and {@link geometry}\n     * - Execute {@link onAfterRenderPass}\n     * @param pass - current render pass encoder\n     */\n    render(pass: GPURenderPassEncoder) {\n      this.onBeforeRenderPass()\n\n      // no point to render if the WebGPU device is not ready\n      if (!this.renderer.ready || !this.visible) return\n\n      !this.renderer.production && pass.pushDebugGroup(this.options.label)\n\n      this.onRenderPass(pass)\n\n      !this.renderer.production && pass.popDebugGroup()\n\n      this.onAfterRenderPass()\n    }\n\n    /* DESTROY */\n\n    /**\n     * Remove the Mesh from the {@link core/scenes/Scene.Scene | Scene} and destroy it\n     */\n    remove() {\n      this.removeFromScene(true)\n      this.destroy()\n\n      // if the renderer does not contain any meshes any more\n      // clear it\n      if (!this.renderer.meshes.length) {\n        this.renderer.onBeforeRenderScene.add(\n          (commandEncoder) => {\n            this.renderer.forceClear(commandEncoder)\n          },\n          { once: true }\n        )\n      }\n    }\n\n    /**\n     * Destroy the Mesh\n     */\n    destroy() {\n      // @ts-ignore\n      if (super.destroy) {\n        // @ts-ignore\n        super.destroy()\n      }\n\n      this.material?.destroy()\n\n      // destroy geometry and remove buffers from device cache\n      this.geometry.consumers.delete(this.uuid)\n      if (!this.geometry.consumers.size) {\n        this.geometry?.destroy(this.renderer)\n      }\n    }\n  }\n}\n\nexport { MeshBaseMixin }\n","import { PlaneGeometry } from '../core/geometries/PlaneGeometry'\r\n\r\n/**\r\n * Used to cache {@link PlaneGeometry} and avoid as many large array computations as possible.<br>\r\n * Could be improved to handle other caches.\r\n */\r\nexport class CacheManager {\r\n  /** Array of cached {@link PlaneGeometry} */\r\n  planeGeometries: PlaneGeometry[]\r\n\r\n  /**\r\n   * CacheManager constructor\r\n   */\r\n  constructor() {\r\n    this.planeGeometries = []\r\n  }\r\n\r\n  /**\r\n   * Check if a given {@link PlaneGeometry} is already cached based on its {@link PlaneGeometry#definition.id | definition id}\r\n   * @param planeGeometry - {@link PlaneGeometry} to check\r\n   * @returns - {@link PlaneGeometry} found or null if not found\r\n   */\r\n  getPlaneGeometry(planeGeometry: PlaneGeometry): PlaneGeometry | null {\r\n    return this.planeGeometries.find((element) => element.definition.id === planeGeometry.definition.id)\r\n  }\r\n\r\n  /**\r\n   * Check if a given {@link PlaneGeometry} is already cached based on its {@link PlaneGeometry#definition | definition id}\r\n   * @param planeGeometryID - {@link PlaneGeometry#definition.id | PlaneGeometry definition id}\r\n   * @returns - {@link PlaneGeometry} found or null if not found\r\n   */\r\n  getPlaneGeometryByID(planeGeometryID: number): PlaneGeometry | null {\r\n    return this.planeGeometries.find((element) => element.definition.id === planeGeometryID)\r\n  }\r\n\r\n  /**\r\n   * Add a {@link PlaneGeometry} to our cache {@link planeGeometries} array\r\n   * @param planeGeometry\r\n   */\r\n  addPlaneGeometry(planeGeometry: PlaneGeometry) {\r\n    this.planeGeometries.push(planeGeometry)\r\n  }\r\n\r\n  /**\r\n   * Destroy our {@link CacheManager}\r\n   */\r\n  destroy() {\r\n    this.planeGeometries = []\r\n  }\r\n}\r\n\r\n/** @exports @const cacheManager - {@link CacheManager} class object */\r\nexport const cacheManager = new CacheManager() as CacheManager\r\n","import { MeshBaseMixin, MeshBaseRenderParams } from './mixins/MeshBaseMixin'\r\nimport { isRenderer, Renderer } from '../renderers/utils'\r\nimport { PlaneGeometry } from '../geometries/PlaneGeometry'\r\nimport { DOMElementBoundingRect, RectBBox } from '../DOM/DOMElement'\r\nimport { Vec2 } from '../../math/Vec2'\r\nimport { cacheManager } from '../../utils/CacheManager'\r\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\r\nimport { BufferBindingParams } from '../bindings/BufferBinding'\r\n\r\n/**\r\n * Create a 1x1 quad (or plane) covering the full viewport, useful for postprocessing or background effects.\r\n *\r\n * It consists of a {@link PlaneGeometry} and {@link core/materials/RenderMaterial.RenderMaterial | RenderMaterial} and a few utilities method to help create {@link core/textures/DOMTexture.DOMTexture | DOMTexture} and {@link core/textures/Texture.Texture | Texture}.\r\n *\r\n * ### Default shaders\r\n *\r\n * If one or all shaders are missing, the library will use default ones.\r\n *\r\n * #### Default vertex shader:\r\n *\r\n * ```wgsl\r\n * struct VSOutput {\r\n *   @builtin(position) position: vec4f,\r\n *   @location(0) uv: vec2f,\r\n * };\r\n *\r\n * @vertex fn main(\r\n *   attributes: Attributes,\r\n * ) -> VSOutput {\r\n *   var vsOutput: VSOutput;\r\n *\r\n *   vsOutput.position = vec4f(attributes.position, 1.0);\r\n *   vsOutput.uv = attributes.uv;\r\n *\r\n *   return vsOutput;\r\n * }\r\n * ```\r\n *\r\n * #### Default fragment shader:\r\n *\r\n * ```wgsl\r\n * @fragment fn main() -> @location(0) vec4f {\r\n *   return vec4(0.0, 0.0, 0.0, 1.0);\r\n * }\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // set our main GPUCurtains instance\r\n * const gpuCurtains = new GPUCurtains({\r\n *   container: '#canvas' // selector of our WebGPU canvas container\r\n * })\r\n *\r\n * // set the GPU device\r\n * // note this is asynchronous\r\n * await gpuCurtains.setDevice()\r\n *\r\n * // create a fullscreen plane\r\n * const fullscreenPlane = new FullscreenPlane(gpuCurtains, {\r\n *   label: 'My fullscreen plane',\r\n *   shaders: {\r\n *     fragment: {\r\n *       code: fragmentCode, // assume it is a valid WGSL fragment shader\r\n *     },\r\n *   },\r\n * })\r\n * ```\r\n */\r\nexport class FullscreenPlane extends MeshBaseMixin(class {}) {\r\n  /** The type of the {@link FullscreenPlane} */\r\n  type: string\r\n  /** Object defining the  {@link FullscreenPlane} size */\r\n  size: {\r\n    /** document HTML size */\r\n    document: RectBBox\r\n  }\r\n\r\n  /**\r\n   * FullscreenPlane constructor\r\n   * @param renderer - {@link Renderer} or {@link GPUCurtains} class object used to create this {@link FullscreenPlane}\r\n   * @param parameters - {@link MeshBaseRenderParams | parameters} use to create this {@link FullscreenPlane}\r\n   */\r\n  constructor(renderer: Renderer | GPUCurtains, parameters = {} as MeshBaseRenderParams) {\r\n    renderer = isRenderer(renderer, parameters.label ? parameters.label + ' FullscreenQuadMesh' : 'FullscreenQuadMesh')\r\n\r\n    // can we get a cached geometry?\r\n    let geometry = cacheManager.getPlaneGeometryByID(2) // 1 * 1 + 1\r\n\r\n    if (!geometry) {\r\n      // we need to create a new plane geometry\r\n      geometry = new PlaneGeometry({ widthSegments: 1, heightSegments: 1 })\r\n      cacheManager.addPlaneGeometry(geometry)\r\n    }\r\n\r\n    // no vertex shader? patch uniforms/storages visibility\r\n    if (!parameters.shaders || !parameters.shaders.vertex) {\r\n      ;['uniforms', 'storages'].forEach((bindingType) => {\r\n        Object.values(parameters[bindingType] ?? {}).forEach(\r\n          (binding: BufferBindingParams) => (binding.visibility = ['fragment'])\r\n        )\r\n      })\r\n    }\r\n\r\n    // we don't want to write to the depth buffer for fullscreen quads\r\n    parameters.depthWriteEnabled = false\r\n    if (!parameters.label) {\r\n      parameters.label = 'FullscreenQuadMesh'\r\n    }\r\n\r\n    // @ts-ignore\r\n    super(renderer, null, { geometry, ...parameters })\r\n\r\n    this.size = {\r\n      document: {\r\n        width: this.renderer.boundingRect.width,\r\n        height: this.renderer.boundingRect.height,\r\n        top: this.renderer.boundingRect.top,\r\n        left: this.renderer.boundingRect.left,\r\n      },\r\n    }\r\n\r\n    this.type = 'FullscreenQuadMesh'\r\n  }\r\n\r\n  /**\r\n   * Resize our {@link FullscreenPlane}\r\n   * @param boundingRect - the new bounding rectangle\r\n   */\r\n  resize(boundingRect: DOMElementBoundingRect | null = null) {\r\n    this.size.document = boundingRect ?? this.renderer.boundingRect\r\n\r\n    super.resize(boundingRect)\r\n  }\r\n\r\n  /**\r\n   * Take the pointer {@link Vec2 | vector} position relative to the document and returns it relative to our {@link FullscreenPlane}\r\n   * It ranges from -1 to 1 on both axis\r\n   * @param mouseCoords - pointer {@link Vec2 | vector} coordinates\r\n   * @returns - the mapped {@link Vec2 | vector} coordinates in the [-1, 1] range\r\n   */\r\n  mouseToPlaneCoords(mouseCoords: Vec2 = new Vec2()): Vec2 {\r\n    // mouse position conversion from document to plane space\r\n    return new Vec2(\r\n      ((mouseCoords.x - this.size.document.left) / this.size.document.width) * 2 - 1,\r\n      1 - ((mouseCoords.y - this.size.document.top) / this.size.document.height) * 2\r\n    )\r\n  }\r\n}\r\n","import { Mat4 } from './Mat4'\r\n\r\n/**\r\n * Basic 3x3 matrix class used for matrix calculations.\r\n *\r\n * Note that like three.js, the constructor and {@link set} method take arguments in row-major order, while internally they are stored in the {@link elements} array in column-major order.\r\n *\r\n * @see https://github.com/mrdoob/three.js/blob/dev/src/math/Matrix3.js\r\n * @see http://glmatrix.net/docs/mat3.js.html\r\n */\r\nexport class Mat3 {\r\n  /** The type of the {@link Mat3} */\r\n  type: string\r\n  /** Our matrix array */\r\n  elements: Float32Array\r\n\r\n  // prettier-ignore\r\n  /**\r\n   * Mat3 constructor\r\n   * @param elements - initial array to use, default to identity matrix\r\n   */\r\n  constructor(elements: Float32Array = new Float32Array([\r\n    1, 0, 0,\r\n    0, 1, 0,\r\n    0, 0, 1,\r\n  ])) {\r\n    this.type = 'Mat3'\r\n    this.elements = elements\r\n  }\r\n\r\n  /**\r\n   * Sets the matrix from 9 numbers\r\n   *\r\n   * @param n11 - number\r\n   * @param n12 - number\r\n   * @param n13 - number\r\n   * @param n21 - number\r\n   * @param n22 - number\r\n   * @param n23 - number\r\n   * @param n31 - number\r\n   * @param n32 - number\r\n   * @param n33 - number\r\n   * @returns - this {@link Mat3} after being set\r\n   */\r\n  set(\r\n    n11: number,\r\n    n12: number,\r\n    n13: number,\r\n    n21: number,\r\n    n22: number,\r\n    n23: number,\r\n    n31: number,\r\n    n32: number,\r\n    n33: number\r\n  ): Mat3 {\r\n    const te = this.elements\r\n\r\n    te[0] = n11\r\n    te[1] = n21\r\n    te[2] = n31\r\n    te[3] = n12\r\n    te[4] = n22\r\n    te[5] = n32\r\n    te[6] = n13\r\n    te[7] = n23\r\n    te[8] = n33\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Sets the {@link Mat3} to an identity matrix\r\n   * @returns - this {@link Mat3} after being set\r\n   */\r\n  identity(): Mat3 {\r\n    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1)\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Sets the {@link Mat3} values from an array\r\n   * @param array - array to use\r\n   * @returns - this {@link Mat3} after being set\r\n   */\r\n  // prettier-ignore\r\n  setFromArray(array: Float32Array | number[] = new Float32Array([\r\n    1, 0, 0,\r\n    0, 1, 0,\r\n    0, 0, 1,\r\n  ])): Mat3 {\r\n    for (let i = 0; i < this.elements.length; i++) {\r\n      this.elements[i] = array[i]\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Copy another {@link Mat3}\r\n   * @param matrix - matrix to copy\r\n   * @returns - this {@link Mat3} after being set\r\n   */\r\n  copy(matrix: Mat3 = new Mat3()): Mat3 {\r\n    const array = matrix.elements\r\n    this.elements[0] = array[0]\r\n    this.elements[1] = array[1]\r\n    this.elements[2] = array[2]\r\n    this.elements[3] = array[3]\r\n    this.elements[4] = array[4]\r\n    this.elements[5] = array[5]\r\n    this.elements[6] = array[6]\r\n    this.elements[7] = array[7]\r\n    this.elements[8] = array[8]\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Clone a {@link Mat3}\r\n   * @returns - cloned {@link Mat3}\r\n   */\r\n  clone(): Mat3 {\r\n    return new Mat3().copy(this)\r\n  }\r\n\r\n  /**\r\n   * Set a {@link Mat3} from a {@link Mat4}.\r\n   * @param matrix - {@link Mat4} to use.\r\n   * @returns - this {@link Mat3} after being set.\r\n   */\r\n  setFromMat4(matrix: Mat4 = new Mat4()) {\r\n    const me = matrix.elements\r\n\r\n    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10])\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Multiply this {@link Mat3} with another {@link Mat3}\r\n   * @param matrix - {@link Mat3} to multiply with\r\n   * @returns - this {@link Mat3} after multiplication\r\n   */\r\n  multiply(matrix: Mat3 = new Mat3()): Mat3 {\r\n    return this.multiplyMatrices(this, matrix)\r\n  }\r\n\r\n  /**\r\n   * Multiply another {@link Mat3} with this {@link Mat3}\r\n   * @param matrix - {@link Mat3} to multiply with\r\n   * @returns - this {@link Mat3} after multiplication\r\n   */\r\n  premultiply(matrix: Mat3 = new Mat3()): Mat3 {\r\n    return this.multiplyMatrices(matrix, this)\r\n  }\r\n\r\n  /**\r\n   * Multiply two {@link Mat3}\r\n   * @param a - first {@link Mat3}\r\n   * @param b - second {@link Mat3}\r\n   * @returns - {@link Mat3} resulting from the multiplication\r\n   */\r\n  multiplyMatrices(a: Mat3 = new Mat3(), b: Mat3 = new Mat3()): Mat3 {\r\n    const ae = a.elements\r\n    const be = b.elements\r\n    const te = this.elements\r\n\r\n    const a11 = ae[0],\r\n      a12 = ae[3],\r\n      a13 = ae[6]\r\n    const a21 = ae[1],\r\n      a22 = ae[4],\r\n      a23 = ae[7]\r\n    const a31 = ae[2],\r\n      a32 = ae[5],\r\n      a33 = ae[8]\r\n\r\n    const b11 = be[0],\r\n      b12 = be[3],\r\n      b13 = be[6]\r\n    const b21 = be[1],\r\n      b22 = be[4],\r\n      b23 = be[7]\r\n    const b31 = be[2],\r\n      b32 = be[5],\r\n      b33 = be[8]\r\n\r\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31\r\n    te[3] = a11 * b12 + a12 * b22 + a13 * b32\r\n    te[6] = a11 * b13 + a12 * b23 + a13 * b33\r\n\r\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31\r\n    te[4] = a21 * b12 + a22 * b22 + a23 * b32\r\n    te[7] = a21 * b13 + a22 * b23 + a23 * b33\r\n\r\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31\r\n    te[5] = a31 * b12 + a32 * b22 + a33 * b32\r\n    te[8] = a31 * b13 + a32 * b23 + a33 * b33\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Invert this {@link Mat3}.\r\n   * @returns - this {@link Mat3} after being inverted\r\n   */\r\n  invert(): Mat3 {\r\n    const te = this.elements,\r\n      n11 = te[0],\r\n      n21 = te[1],\r\n      n31 = te[2],\r\n      n12 = te[3],\r\n      n22 = te[4],\r\n      n32 = te[5],\r\n      n13 = te[6],\r\n      n23 = te[7],\r\n      n33 = te[8],\r\n      t11 = n33 * n22 - n32 * n23,\r\n      t12 = n32 * n13 - n33 * n12,\r\n      t13 = n23 * n12 - n22 * n13,\r\n      det = n11 * t11 + n21 * t12 + n31 * t13\r\n\r\n    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0)\r\n\r\n    const detInv = 1 / det\r\n\r\n    te[0] = t11 * detInv\r\n    te[1] = (n31 * n23 - n33 * n21) * detInv\r\n    te[2] = (n32 * n21 - n31 * n22) * detInv\r\n\r\n    te[3] = t12 * detInv\r\n    te[4] = (n33 * n11 - n31 * n13) * detInv\r\n    te[5] = (n31 * n12 - n32 * n11) * detInv\r\n\r\n    te[6] = t13 * detInv\r\n    te[7] = (n21 * n13 - n23 * n11) * detInv\r\n    te[8] = (n22 * n11 - n21 * n12) * detInv\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Transpose this {@link Mat3}.\r\n   * @returns - this {@link Mat3} after being transposed\r\n   */\r\n  transpose(): Mat3 {\r\n    let tmp\r\n    const m = this.elements\r\n\r\n    tmp = m[1]\r\n    m[1] = m[3]\r\n    m[3] = tmp\r\n    tmp = m[2]\r\n    m[2] = m[6]\r\n    m[6] = tmp\r\n    tmp = m[5]\r\n    m[5] = m[7]\r\n    m[7] = tmp\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Compute a normal {@link Mat3} matrix from a {@link Mat4} transformation matrix.\r\n   * @param matrix - {@link Mat4} transformation matrix\r\n   * @returns - this {@link Mat3} after being inverted and transposed\r\n   */\r\n  getNormalMatrix(matrix: Mat4 = new Mat4()): Mat3 {\r\n    return this.setFromMat4(matrix).invert().transpose()\r\n  }\r\n}\r\n","import { Object3D, Object3DMatricesType, Object3DTransformMatrix } from './Object3D'\r\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\r\nimport { CameraRenderer, isCameraRenderer } from '../renderers/utils'\r\nimport { Mat4 } from '../../math/Mat4'\r\nimport { Camera } from '../camera/Camera'\r\nimport { Mat3 } from '../../math/Mat3'\r\n\r\n/**\r\n * Defines an {@link Object3D} normal matrix object\r\n */\r\nexport interface Object3DNormalMatrix {\r\n  /** The {@link Mat3} matrix used */\r\n  matrix: Mat3\r\n  /** Whether we should update the {@link Mat3} matrix */\r\n  shouldUpdate: boolean\r\n  /** Function to update our {@link Mat3} matrix */\r\n  onUpdate: () => void\r\n}\r\n\r\n/** Defines all kind of possible {@link ProjectedObject3D} matrix types */\r\nexport type ProjectedObject3DMatricesType = Object3DMatricesType | 'modelView' | 'modelViewProjection'\r\n/** Defines the special {@link ProjectedObject3D} normal matrix type */\r\nexport type ProjectedObject3DNormalMatrix = Record<'normal', Object3DNormalMatrix>\r\n\r\n/** Defines all possible {@link Object3DTransformMatrix | matrix object} used by our {@link ProjectedObject3D} */\r\nexport type ProjectedObject3DMatrices =\r\n  | Record<ProjectedObject3DMatricesType, Object3DTransformMatrix> & ProjectedObject3DNormalMatrix\r\n\r\n/**\r\n * Used to apply the {@link Camera#projectionMatrix | projection} and {@link Camera#viewMatrix | view} matrices of a {@link Camera} to an {@link Object3D}, in order to compute {@link ProjectedObject3D#modelViewMatrix | modelView} and {@link ProjectedObject3D#modelViewProjectionMatrix | modelViewProjection} matrices.\r\n */\r\nexport class ProjectedObject3D extends Object3D {\r\n  /** {@link Camera | Camera} object used to compute {@link ProjectedObject3D#modelViewMatrix | model view} and {@link ProjectedObject3D#modelViewProjectionMatrix | model view projection} matrices */\r\n  camera: Camera\r\n\r\n  /** {@link ProjectedObject3DMatrices | Matrices object} of the {@link ProjectedObject3D} */\r\n  matrices: ProjectedObject3DMatrices\r\n\r\n  /**\r\n   * ProjectedObject3D constructor\r\n   * @param renderer - {@link CameraRenderer} object or {@link GPUCurtains} class object used to create this {@link ProjectedObject3D}\r\n   */\r\n  constructor(renderer: CameraRenderer | GPUCurtains) {\r\n    super()\r\n\r\n    renderer = isCameraRenderer(renderer, 'ProjectedObject3D')\r\n\r\n    this.camera = renderer.camera\r\n  }\r\n\r\n  /**\r\n   * Tell our projection matrix stack to update\r\n   */\r\n  applyPosition() {\r\n    super.applyPosition()\r\n    this.shouldUpdateProjectionMatrixStack()\r\n  }\r\n\r\n  /**\r\n   * Tell our projection matrix stack to update\r\n   */\r\n  applyRotation() {\r\n    super.applyRotation()\r\n    this.shouldUpdateProjectionMatrixStack()\r\n  }\r\n\r\n  /**\r\n   * Tell our projection matrix stack to update\r\n   */\r\n  applyScale() {\r\n    super.applyScale()\r\n    this.shouldUpdateProjectionMatrixStack()\r\n  }\r\n\r\n  /**\r\n   * Tell our projection matrix stack to update\r\n   */\r\n  applyTransformOrigin() {\r\n    super.applyTransformOrigin()\r\n    this.shouldUpdateProjectionMatrixStack()\r\n  }\r\n\r\n  /**\r\n   * Set our transform and projection matrices\r\n   */\r\n  setMatrices() {\r\n    super.setMatrices()\r\n\r\n    this.matrices = {\r\n      ...this.matrices,\r\n      modelView: {\r\n        matrix: new Mat4(),\r\n        shouldUpdate: true,\r\n        onUpdate: () => {\r\n          // our model view matrix is our model matrix multiplied with our camera view matrix\r\n          this.modelViewMatrix.multiplyMatrices(this.viewMatrix, this.worldMatrix)\r\n        },\r\n      },\r\n      modelViewProjection: {\r\n        matrix: new Mat4(),\r\n        shouldUpdate: true,\r\n        onUpdate: () => {\r\n          //console.log(this.projectionMatrix.elements)\r\n          // our modelViewProjection matrix, useful for bounding box calculations and frustum culling\r\n          // this is the result of our projection matrix multiplied by our modelView matrix\r\n          this.modelViewProjectionMatrix.multiplyMatrices(this.projectionMatrix, this.modelViewMatrix)\r\n        },\r\n      },\r\n      normal: {\r\n        matrix: new Mat3(),\r\n        shouldUpdate: true,\r\n        onUpdate: () => {\r\n          // or normal matrix is the inverse transpose of the world matrix\r\n          this.normalMatrix.getNormalMatrix(this.worldMatrix)\r\n        },\r\n      },\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get our {@link modelViewMatrix | model view matrix}\r\n   */\r\n  get modelViewMatrix(): Mat4 {\r\n    return this.matrices.modelView.matrix\r\n  }\r\n\r\n  /**\r\n   * Set our {@link modelViewMatrix | model view matrix}\r\n   * @param value - new {@link modelViewMatrix | model view matrix}\r\n   */\r\n  set modelViewMatrix(value: Mat4) {\r\n    this.matrices.modelView.matrix = value\r\n    this.matrices.modelView.shouldUpdate = true\r\n  }\r\n\r\n  /**\r\n   * Get our {@link Camera#viewMatrix | camera view matrix}\r\n   * @readonly\r\n   */\r\n  get viewMatrix(): Mat4 {\r\n    return this.camera.viewMatrix\r\n  }\r\n\r\n  /**\r\n   * Get our {@link Camera#projectionMatrix | camera projection matrix}\r\n   * @readonly\r\n   */\r\n  get projectionMatrix(): Mat4 {\r\n    return this.camera.projectionMatrix\r\n  }\r\n\r\n  /**\r\n   * Get our {@link modelViewProjectionMatrix | model view projection matrix}\r\n   */\r\n  get modelViewProjectionMatrix(): Mat4 {\r\n    return this.matrices.modelViewProjection.matrix\r\n  }\r\n\r\n  /**\r\n   * Set our {@link modelViewProjectionMatrix | model view projection matrix}\r\n   * @param value - new {@link modelViewProjectionMatrix | model view projection matrix}s\r\n   */\r\n  set modelViewProjectionMatrix(value: Mat4) {\r\n    this.matrices.modelViewProjection.matrix = value\r\n    this.matrices.modelViewProjection.shouldUpdate = true\r\n  }\r\n\r\n  /**\r\n   * Get our {@link normalMatrix | normal matrix}\r\n   */\r\n  get normalMatrix(): Mat3 {\r\n    return this.matrices.normal.matrix\r\n  }\r\n\r\n  /**\r\n   * Set our {@link normalMatrix | normal matrix}\r\n   * @param value - new {@link normalMatrix | normal matrix}\r\n   */\r\n  set normalMatrix(value: Mat3) {\r\n    this.matrices.normal.matrix = value\r\n    this.matrices.normal.shouldUpdate = true\r\n  }\r\n\r\n  /**\r\n   * Set our projection matrices shouldUpdate flags to true (tell them to update)\r\n   */\r\n  shouldUpdateProjectionMatrixStack() {\r\n    this.matrices.modelView.shouldUpdate = true\r\n    this.matrices.modelViewProjection.shouldUpdate = true\r\n  }\r\n\r\n  /**\r\n   * When the world matrix update, tell our projection matrix to update as well\r\n   */\r\n  shouldUpdateWorldMatrix() {\r\n    super.shouldUpdateWorldMatrix()\r\n    this.shouldUpdateProjectionMatrixStack()\r\n    this.matrices.normal.shouldUpdate = true\r\n  }\r\n\r\n  /**\r\n   * Tell all our matrices to update\r\n   */\r\n  shouldUpdateMatrixStack() {\r\n    this.shouldUpdateModelMatrix()\r\n    this.shouldUpdateProjectionMatrixStack()\r\n  }\r\n}\r\n","export default /* wgsl */ `\r\nstruct VSOutput {\r\n  @builtin(position) position: vec4f,\r\n  @location(0) uv: vec2f,\r\n  @location(1) normal: vec3f,\r\n};\r\n\r\n@fragment fn main(fsInput: VSOutput) -> @location(0) vec4f {\r\n  // normals\r\n  return vec4(normalize(fsInput.normal) * 0.5 + 0.5, 1.0);\r\n}`\r\n","import { BufferBindingParams, BufferBinding } from './BufferBinding'\r\nimport { getBindGroupLayoutBindingType } from './utils'\r\n\r\n/** Options used to create a {@link BufferBindingOffsetChild}. */\r\nexport interface BufferBindingOffsetChildOptions extends BufferBindingParams {\r\n  /** The minimum {@link GPUDevice} buffer offset alignment. */\r\n  minOffset?: number\r\n  /** Offset of the {@link BufferBindingOffsetChild} in the {@link BufferBindingOffsetChild#parent | parent BufferBinding} (as an index - not in bytes). */\r\n  offset?: number\r\n}\r\n\r\n/** Parameters used to create a {@link BufferBindingOffsetChild}. */\r\nexport interface BufferBindingOffsetChildParams extends BufferBindingOffsetChildOptions {\r\n  /** The parent {@link BufferBinding} that will actually handle the {@link GPUBuffer}. */\r\n  parent?: BufferBinding\r\n}\r\n\r\n/**\r\n * A special {@link BufferBinding} that can use a {@link parent | parent BufferBinding} buffer portion defined by an offset and a size. Useful to drastically reduce the number of WebGPU `writeBuffer` calls by updating a single big parent buffer containing multiple children.\r\n *\r\n * When a {@link parent} is set, then this {@link BufferBindingOffsetChild} won't create a {@link GPUBuffer} but will instead update its parent {@link arrayBuffer} at the given offset, and let the parent handle the {@link GPUBuffer}.\r\n *\r\n * If no {@link parent} is set, then it acts as a regular {@link BufferBinding}.\r\n */\r\nexport class BufferBindingOffsetChild extends BufferBinding {\r\n  /** Options used to create this {@link BufferBindingOffsetChild}. */\r\n  options: BufferBindingOffsetChildOptions\r\n\r\n  /** @ignore */\r\n  #parent: BufferBinding | null\r\n\r\n  /** {@link DataView} inside the {@link arrayBuffer | parent arrayBuffer} if set. */\r\n  parentView: DataView | null\r\n  /** Array of view set functions to use with the various {@link bufferElements} if the {@link parent} is set. */\r\n  viewSetFunctions: Array<\r\n    DataView['setInt32'] | DataView['setUint16'] | DataView['setUint32'] | DataView['setFloat32']\r\n  > | null\r\n\r\n  /**\r\n   * BufferBindingOffsetChild constructor\r\n   * @param parameters - {@link BufferBindingOffsetChildParams | parameters} used to create this {@link BufferBindingOffsetChild}.\r\n   */\r\n  constructor({\r\n    label = 'Uniform',\r\n    name = 'uniform',\r\n    bindingType,\r\n    visibility,\r\n    useStruct = true,\r\n    access = 'read',\r\n    usage = [],\r\n    struct = {},\r\n    bindings = [],\r\n    parent = null,\r\n    minOffset = 256,\r\n    offset = 0,\r\n  }: BufferBindingOffsetChildParams) {\r\n    super({ label, name, bindingType, visibility, useStruct, access, usage, struct, bindings })\r\n\r\n    this.options = {\r\n      ...this.options,\r\n      minOffset,\r\n      offset,\r\n    }\r\n\r\n    this.parent = parent\r\n  }\r\n\r\n  /**\r\n   * Get the {@link BufferBinding} parent if any.\r\n   * @readonly\r\n   * @returns - The {@link BufferBinding} parent if any.\r\n   */\r\n  get parent(): BufferBinding {\r\n    return this.#parent\r\n  }\r\n\r\n  /**\r\n   * Set the new {@link BufferBinding} parent.\r\n   * @param value - New {@link BufferBinding} parent to set if any.\r\n   */\r\n  set parent(value: BufferBinding | null) {\r\n    this.#parent = value\r\n\r\n    if (!!value) {\r\n      this.parentView = new DataView(value.arrayBuffer, this.offset, this.getMinOffsetSize(this.arrayBufferSize))\r\n\r\n      this.viewSetFunctions = this.bufferElements.map((bufferElement) => {\r\n        switch (bufferElement.bufferLayout.View) {\r\n          case Int32Array:\r\n            return this.parentView.setInt32.bind(this.parentView) as DataView['setInt32']\r\n          case Uint16Array:\r\n            return this.parentView.setUint16.bind(this.parentView) as DataView['setUint16']\r\n          case Uint32Array:\r\n            return this.parentView.setUint32.bind(this.parentView) as DataView['setUint32']\r\n          case Float32Array:\r\n          default:\r\n            return this.parentView.setFloat32.bind(this.parentView) as DataView['setFloat32']\r\n        }\r\n      })\r\n    } else {\r\n      // TODO handle the case where this binding had a GPU buffer?\r\n      this.parentView = null\r\n      this.viewSetFunctions = null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Round the given size value to the nearest minimum {@link GPUDevice} buffer offset alignment.\r\n   * @param value - Size to round.\r\n   */\r\n  getMinOffsetSize(value: number): number {\r\n    return Math.ceil(value / this.options.minOffset) * this.options.minOffset\r\n  }\r\n\r\n  /**\r\n   * Get this {@link BufferBindingOffsetChild} offset in bytes inside the {@link arrayBuffer | parent arrayBuffer}.\r\n   * @readonly\r\n   * @returns - The offset in bytes inside the {@link arrayBuffer | parent arrayBuffer}\r\n   */\r\n  get offset(): number {\r\n    return this.getMinOffsetSize(this.options.offset * this.getMinOffsetSize(this.arrayBufferSize))\r\n  }\r\n\r\n  /**\r\n   * Get {@link GPUBindGroupLayoutEntry#buffer | bind group layout entry resource}.\r\n   * @readonly\r\n   */\r\n  get resourceLayout(): {\r\n    /** {@link GPUBindGroupLayout | bind group layout} resource */\r\n    buffer: GPUBufferBindingLayout\r\n    /** Offset in bytes in the {@link parent} buffer if set. */\r\n    offset?: number\r\n    /** Size in bytes in the {@link parent} buffer if set. */\r\n    size?: number\r\n  } {\r\n    return {\r\n      buffer: {\r\n        type: getBindGroupLayoutBindingType(this),\r\n      },\r\n      ...(this.parent && { offset: this.offset, size: this.arrayBufferSize }),\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get {@link GPUBindGroupEntry#resource | bind group resource}\r\n   * @readonly\r\n   */\r\n  get resource(): {\r\n    /** {@link GPUBindGroup | bind group} resource */\r\n    buffer: GPUBuffer | null\r\n    /** Offset in bytes in the {@link parent} buffer if set. */\r\n    offset?: number\r\n    /** Size in bytes in the {@link parent} buffer if set. */\r\n    size?: number\r\n  } {\r\n    return {\r\n      buffer: this.parent ? this.parent.buffer.GPUBuffer : this.buffer.GPUBuffer,\r\n      ...(this.parent && { offset: this.offset, size: this.arrayBufferSize }),\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the {@link BufferBindingOffsetChild} at the beginning of a Material render call.\r\n   *\r\n   * If a {@link parent} is set, then update its {@link arrayBuffer | arrayBuffer} using our {@link viewSetFunctions}.\r\n   */\r\n  update() {\r\n    super.update()\r\n\r\n    if (this.shouldUpdate && this.parent && this.viewSetFunctions) {\r\n      let index = 0\r\n      this.bufferElements.forEach((bufferElement, i) => {\r\n        bufferElement.view.forEach((value) => {\r\n          this.viewSetFunctions[i](index * bufferElement.view.BYTES_PER_ELEMENT, value, true)\r\n          index++\r\n        })\r\n      })\r\n\r\n      this.parent.shouldUpdate = true\r\n\r\n      // reset the should update flag\r\n      // this binding GPU buffer is not going to be used anyway\r\n      this.shouldUpdate = false\r\n    }\r\n  }\r\n}\r\n","import { CameraRenderer, isCameraRenderer } from '../../renderers/utils'\nimport { DOMFrustum } from '../../DOM/DOMFrustum'\nimport {\n  MeshBaseClass,\n  MeshBaseMixin,\n  MeshBaseOptions,\n  MeshBaseParams,\n  MeshBaseRenderParams,\n  MixinConstructor,\n} from './MeshBaseMixin'\nimport { GPUCurtains } from '../../../curtains/GPUCurtains'\nimport { DOMElementBoundingRect, RectCoords } from '../../DOM/DOMElement'\nimport { RenderMaterialParams, ShaderOptions } from '../../../types/Materials'\nimport { ProjectedObject3D } from '../../objects3D/ProjectedObject3D'\nimport default_projected_vsWgsl from '../../shaders/chunks/default/default_projected_vs.wgsl'\nimport default_normal_fsWgsl from '../../shaders/chunks/default/default_normal_fs.wgsl'\nimport { Vec3 } from '../../../math/Vec3'\nimport {\n  getPCFDirectionalShadows,\n  getPCFPointShadowContribution,\n  getPCFPointShadows,\n  getPCFShadowContribution,\n} from '../../shaders/chunks/shading/shadows'\nimport { BufferBindingOffsetChild, BufferBindingOffsetChildParams } from '../../bindings/BufferBindingOffsetChild'\nimport { RenderBundle } from '../../renderPasses/RenderBundle'\n\n/** Define all possible frustum culling checks. */\nexport type FrustumCullingCheck = 'OBB' | 'sphere' | false\n\n/**\n * Base parameters used to create a ProjectedMesh\n */\nexport interface ProjectedMeshBaseParams {\n  /** Frustum culling check to use. Accepts `OBB`, `sphere` or a boolean. Default to `OBB`. When set to `true`, `OBB` is used. */\n  frustumCulling?: FrustumCullingCheck\n  /** Margins (in pixels) to applied to the {@link ProjectedMeshBaseClass#domFrustum | DOM Frustum} to determine if this ProjectedMesh should be frustum culled or not. */\n  DOMFrustumMargins?: RectCoords\n\n  /** Whether the mesh should receive the shadows from shadow casting lights. If set to `true`, the lights shadow map textures and sampler will be added to the material, and some shader chunks helpers will be added. Default to `false`. */\n  receiveShadows?: boolean\n  /** Whether the mesh should cast shadows from shadow casting lights. If set to `true`, the mesh will be automatically added to all shadow maps. If you want to cast only specific shadows, see {@link core/shadows/Shadow.Shadow#addShadowCastingMesh | shadow's addShadowCastingMesh} method. Default to `false`. */\n  castShadows?: boolean\n}\n\n/** Parameters used to create a ProjectedMesh */\nexport interface ProjectedMeshParameters extends MeshBaseParams, ProjectedMeshBaseParams {}\n\n/** Parameters used to create a Projected Render Material */\nexport interface ProjectedRenderMaterialParams extends RenderMaterialParams, ProjectedMeshBaseParams {}\n\n/** @const - Default ProjectedMesh parameters to merge with user defined parameters */\nconst defaultProjectedMeshParams: ProjectedMeshBaseParams = {\n  // frustum culling and visibility\n  frustumCulling: 'OBB',\n  DOMFrustumMargins: {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n  },\n  receiveShadows: false,\n  castShadows: false,\n}\n\n/** Base options used to create this ProjectedMesh */\nexport interface ProjectedMeshBaseOptions extends MeshBaseOptions, ProjectedMeshBaseParams {}\n\n/**\n * This class describes the properties and methods to set up a Projected Mesh (i.e. a basic {@link MeshBaseClass | Mesh} with {@link ProjectedObject3D} transformations matrices and a {@link core/camera/Camera.Camera | Camera} to use for projection), implemented in the {@link ProjectedMeshBaseMixin}:\n * - Handle the frustum culling (check if the {@link ProjectedObject3D} currently lies inside the {@link core/camera/Camera.Camera | Camera} frustum)\n * - Add callbacks for when the Mesh enters or leaves the {@link core/camera/Camera.Camera | Camera} frustum\n */\nexport declare class ProjectedMeshBaseClass extends MeshBaseClass {\n  /** The {@link CameraRenderer} used */\n  renderer: CameraRenderer\n  /** The ProjectedMesh {@link DOMFrustum} class object */\n  domFrustum: DOMFrustum\n  /** Frustum culling check to use. Accepts `OBB`, `sphere` or a boolean. Default to `OBB`. When set to `true`, `OBB` is used. */\n  frustumCulling: FrustumCullingCheck\n  /** Margins (in pixels) to applied to the {@link ProjectedMeshBaseClass#domFrustum | DOM Frustum} to determine if this ProjectedMesh should be frustum culled or not */\n  DOMFrustumMargins: RectCoords\n\n  /** Options used to create this {@link ProjectedMeshBaseClass} */\n  options: ProjectedMeshBaseOptions\n\n  // callbacks\n  /** function assigned to the {@link onReEnterView} callback */\n  _onReEnterViewCallback: () => void\n  /** function assigned to the {@link onLeaveView} callback */\n  _onLeaveViewCallback: () => void\n\n  /**\n   * {@link ProjectedMeshBaseClass} constructor\n   * @param renderer - our {@link CameraRenderer} class object\n   * @param element - a DOM HTML Element that can be bound to a Mesh\n   * @param parameters - {@link ProjectedMeshParameters | Projected Mesh base parameters}\n   */\n  constructor(renderer: CameraRenderer, element: HTMLElement | null, parameters: ProjectedMeshParameters)\n\n  /**\n   * Set or reset this Mesh {@link renderer}.\n   * @param renderer - New {@link CameraRenderer} or {@link GPUCurtains} instance to use.\n   */\n  setRenderer(renderer: CameraRenderer | GPUCurtains): void\n\n  /**\n   * Assign or remove a {@link RenderBundle} to this Mesh.\n   * @param renderBundle - the {@link RenderBundle} to assign or null if we want to remove the current {@link RenderBundle}.\n   * @param updateScene - Whether to remove and then re-add the Mesh from the {@link core/scenes/Scene.Scene | Scene} or not.\n   */\n  setRenderBundle(renderBundle?: RenderBundle | null, updateScene?: boolean): void\n\n  /**\n   * Reset the {@link BufferBindingOffsetChild | matrices buffer binding} parent and offset and tell its bind group to update.\n   * @param offset - New offset to use in the parent {@link RenderBundle#binding | RenderBundle binding}.\n   */\n  patchRenderBundleBinding(offset?: number): void\n\n  /**\n   * Set default shaders if one or both of them are missing\n   */\n  setShaders(): void\n\n  /**\n   * Set a Mesh matrices uniforms inputs then call {@link MeshBaseClass} super method\n   * @param meshParameters - {@link RenderMaterialParams | RenderMaterial parameters}\n   */\n  setMaterial(meshParameters: ProjectedRenderMaterialParams): void\n\n  /**\n   * Get the visible property value\n   */\n  get visible(): boolean\n\n  /**\n   * Set the visible property value\n   * @param value - new visibility value\n   */\n  set visible(value: boolean)\n\n  /**\n   * Resize our Mesh\n   * @param boundingRect - the new bounding rectangle\n   */\n  resize(boundingRect: DOMElementBoundingRect | null): void\n\n  /**\n   * Apply scale and resize textures\n   */\n  applyScale(): void\n\n  /**\n   * Get our {@link DOMFrustum} projected bounding rectangle\n   * @readonly\n   */\n  get projectedBoundingRect(): DOMElementBoundingRect\n\n  /**\n   * Callback to execute when a Mesh is reentering the view frustum.\n   * @param callback - callback to run when {@link ProjectedMeshBaseClass} is reentering the view frustum\n   * @returns - our Mesh\n   */\n  onReEnterView: (callback: () => void) => ProjectedMeshBaseClass\n\n  /**\n   * Callback to execute when a Mesh is leaving the view frustum.\n   * @param callback - callback to run when {@link ProjectedMeshBaseClass} is leaving the view frustum\n   * @returns - our Mesh\n   */\n  onLeaveView: (callback: () => void) => ProjectedMeshBaseClass\n\n  /**\n   * Get the geometry bounding sphere in clip space.\n   * @readonly\n   */\n  get clipSpaceBoundingSphere(): {\n    /** Center of the bounding sphere. */\n    center: Vec3\n    /** Radius of the bounding sphere. */\n    radius: number\n  }\n\n  /**\n   * Check if the Mesh lies inside the {@link CameraRenderer#camera | camera} view frustum or not.\n   */\n  checkFrustumCulling(): void\n\n  /**\n   * Tell our matrices bindings to update if needed and call {@link MeshBaseClass#onBeforeRenderPass | Mesh base onBeforeRenderPass} super.\n   */\n  onBeforeRenderPass(): void\n\n  /**\n   * Only render the Mesh if it is in view frustum.\n   * Since render() is actually called before onRenderPass(), we are sure to have fresh frustum bounding rectangle values here.\n   * @param pass - current render pass\n   */\n  onRenderPass(pass: GPURenderPassEncoder): void\n}\n\n/**\n * Used to add the properties and methods defined in {@link ProjectedMeshBaseClass} to the {@link MeshBaseClass} and mix it with a given Base of type {@link ProjectedObject3D} or {@link curtains/objects3D/DOMObject3D.DOMObject3D | DOMObject3D}.\n * @exports\n * @param Base - the class to mix onto, should be of {@link ProjectedObject3D} or {@link curtains/objects3D/DOMObject3D.DOMObject3D | DOMObject3D} type\n * @returns - the mixed classes, creating a Projected Mesh.\n */\nfunction ProjectedMeshBaseMixin<TBase extends MixinConstructor<ProjectedObject3D>>(\n  Base: TBase\n): MixinConstructor<ProjectedMeshBaseClass> & TBase {\n  /**\n   * ProjectedMeshBase defines our base properties and methods\n   */\n  return class ProjectedMeshBase extends MeshBaseMixin(Base) {\n    /** The {@link CameraRenderer} used */\n    renderer: CameraRenderer\n    /** The ProjectedMesh {@link DOMFrustum} class object */\n    domFrustum: DOMFrustum\n    /** Frustum culling check to use. Accepts `OBB`, `sphere` or a boolean. Default to `OBB`. When set to `true`, `OBB` is used. */\n    frustumCulling: FrustumCullingCheck\n    /** Margins (in pixels) to applied to the {@link ProjectedMeshBaseClass#domFrustum | DOM Frustum} to determine if this ProjectedMesh should be frustum culled or not */\n    DOMFrustumMargins: RectCoords\n\n    /** Options used to create this {@link ProjectedMeshBaseClass} */\n    options: ProjectedMeshBaseOptions\n\n    // callbacks / events\n    /** function assigned to the {@link onReEnterView} callback */\n    _onReEnterViewCallback: () => void = () => {\n      /* allow empty callback */\n    }\n    /** function assigned to the {@link onLeaveView} callback */\n    _onLeaveViewCallback: () => void = () => {\n      /* allow empty callback */\n    }\n\n    /**\n     * ProjectedMeshBase constructor\n     *\n     * @typedef MeshBaseArrayParams\n     * @type {array}\n     * @property {(CameraRenderer|GPUCurtains)} 0 - our renderer class object\n     * @property {(string|HTMLElement|null)} 1 - the DOM HTML Element that can be bound to a Mesh\n     * @property {ProjectedMeshParameters} 2 - Projected Mesh parameters\n     *\n     * @param {MeshBaseArrayParams} params - our MeshBaseMixin parameters\n     */\n    constructor(...params: any[]) {\n      super(\n        params[0] as CameraRenderer | GPUCurtains,\n        params[1] as HTMLElement | string,\n        { ...defaultProjectedMeshParams, ...params[2], ...{ useProjection: true } } as ProjectedMeshParameters\n      )\n\n      let renderer = params[0]\n\n      // force this mesh to use projection!\n      const parameters = {\n        ...defaultProjectedMeshParams,\n        ...params[2],\n        ...{ useProjection: true },\n      } as ProjectedMeshParameters\n\n      this.type = 'MeshTransformed'\n\n      renderer = isCameraRenderer(renderer, parameters.label ? parameters.label + ' ' + this.type : this.type)\n\n      this.renderer = renderer\n\n      const { frustumCulling, DOMFrustumMargins, receiveShadows, castShadows } = parameters\n\n      this.options = {\n        ...(this.options ?? {}), // merge possible lower options?\n        frustumCulling,\n        DOMFrustumMargins,\n        receiveShadows,\n        castShadows,\n      }\n\n      if (this.options.castShadows) {\n        this.renderer.shadowCastingLights.forEach((light) => {\n          if (light.shadow.isActive) {\n            light.shadow.addShadowCastingMesh(this)\n          }\n        })\n      }\n\n      this.setDOMFrustum()\n    }\n\n    /**\n     * Set or reset this Mesh {@link renderer}.\n     * @param renderer - New {@link CameraRenderer} or {@link GPUCurtains} instance to use.\n     */\n    setRenderer(renderer: CameraRenderer | GPUCurtains) {\n      super.setRenderer(renderer)\n\n      // force update of new camera\n      this.camera = this.renderer.camera\n\n      if (this.options.castShadows) {\n        this.renderer.shadowCastingLights.forEach((light) => {\n          if (light.shadow.isActive) {\n            light.shadow.addShadowCastingMesh(this)\n          }\n        })\n      }\n    }\n\n    /**\n     * Assign or remove a {@link RenderBundle} to this Mesh.\n     * @param renderBundle - The {@link RenderBundle} to assign or null if we want to remove the current {@link RenderBundle}.\n     * @param updateScene - Whether to remove and then re-add the Mesh from the {@link core/scenes/Scene.Scene | Scene} or not.\n     */\n    setRenderBundle(renderBundle: RenderBundle | null, updateScene = true) {\n      const bindGroup = this.material.getBindGroupByBindingName('matrices')\n      const matrices = this.material.getBufferBindingByName('matrices') as BufferBindingOffsetChild\n\n      if (!this.renderBundle && renderBundle && renderBundle.binding) {\n        // if we did not have a render bundle, but now we have one with a buffer\n        // destroy current matrices binding\n        bindGroup.destroyBufferBinding(matrices)\n      } else if (this.renderBundle && !renderBundle && matrices.parent) {\n        // if we did have a render bundle, reset the parent and bind group\n        matrices.parent = null\n        matrices.shouldResetBindGroup = true\n        bindGroup.createBindingBuffer(matrices)\n      }\n\n      super.setRenderBundle(renderBundle, updateScene)\n\n      if (this.renderBundle && this.renderBundle.binding) {\n        matrices.options.offset = this.renderBundle.meshes.size - 1\n        matrices.parent = this.renderBundle.binding\n\n        matrices.shouldResetBindGroup = true\n      }\n    }\n\n    /**\n     * Reset the {@link BufferBindingOffsetChild | matrices buffer binding} parent and offset and tell its bind group to update.\n     * @param offset - New offset to use in the parent {@link RenderBundle#binding | RenderBundle binding}.\n     */\n    patchRenderBundleBinding(offset = 0) {\n      const matrices = this.material.getBufferBindingByName('matrices') as BufferBindingOffsetChild\n\n      matrices.options.offset = offset\n      matrices.parent = this.renderBundle.binding\n\n      matrices.shouldResetBindGroup = true\n    }\n\n    /* SHADERS */\n\n    /**\n     * Set default shaders if one or both of them are missing\n     */\n    setShaders() {\n      const { shaders } = this.options\n\n      if (!shaders) {\n        this.options.shaders = {\n          vertex: {\n            code: default_projected_vsWgsl,\n            entryPoint: 'main',\n          },\n          fragment: {\n            code: default_normal_fsWgsl,\n            entryPoint: 'main',\n          },\n        }\n      } else {\n        if (!shaders.vertex || !shaders.vertex.code) {\n          shaders.vertex = {\n            code: default_projected_vsWgsl,\n            entryPoint: 'main',\n          }\n        }\n\n        if (shaders.fragment === undefined || (shaders.fragment && !(shaders.fragment as ShaderOptions).code)) {\n          shaders.fragment = {\n            code: default_normal_fsWgsl,\n            entryPoint: 'main',\n          }\n        }\n      }\n    }\n\n    /* GEOMETRY */\n\n    /**\n     * Set or update the Projected Mesh {@link Geometry}\n     * @param geometry - new {@link Geometry} to use\n     */\n    useGeometry(geometry) {\n      super.useGeometry(geometry)\n\n      // update DOM Frustum bounding box\n      if (this.domFrustum) {\n        this.domFrustum.boundingBox = this.geometry.boundingBox\n      }\n\n      // tell the model and projection matrices to update right away\n      this.shouldUpdateMatrixStack()\n    }\n\n    /**\n     * Set the Mesh frustum culling\n     */\n    setDOMFrustum() {\n      this.domFrustum = new DOMFrustum({\n        boundingBox: this.geometry?.boundingBox,\n        modelViewProjectionMatrix: this.modelViewProjectionMatrix,\n        containerBoundingRect: this.renderer.boundingRect,\n        DOMFrustumMargins: this.options.DOMFrustumMargins,\n        onReEnterView: () => {\n          this._onReEnterViewCallback && this._onReEnterViewCallback()\n        },\n        onLeaveView: () => {\n          this._onLeaveViewCallback && this._onLeaveViewCallback()\n        },\n      })\n\n      this.DOMFrustumMargins = this.domFrustum.DOMFrustumMargins\n      this.frustumCulling = this.options.frustumCulling\n    }\n\n    /* MATERIAL */\n\n    /**\n     * Hook used to clean up parameters before sending them to the material.\n     * @param parameters - parameters to clean before sending them to the {@link core/materials/RenderMaterial.RenderMaterial | RenderMaterial}\n     * @returns - cleaned parameters\n     */\n    cleanupRenderMaterialParameters(parameters: ProjectedRenderMaterialParams): MeshBaseRenderParams {\n      // patch mesh parameters\n      delete parameters.frustumCulling\n      delete parameters.DOMFrustumMargins\n\n      if (this.options.receiveShadows) {\n        const depthTextures = []\n        let depthSamplers = []\n\n        this.renderer.shadowCastingLights.forEach((light) => {\n          if (light.shadow.isActive) {\n            depthTextures.push(light.shadow.depthTexture)\n            depthSamplers.push(light.shadow.depthComparisonSampler)\n          }\n        })\n\n        // add chunks to shaders\n        // TODO what if we change the mesh renderer?\n        const hasActiveShadows = this.renderer.shadowCastingLights.find((light) => light.shadow.isActive)\n\n        if (hasActiveShadows && parameters.shaders.fragment && typeof parameters.shaders.fragment === 'object') {\n          parameters.shaders.fragment.code =\n            getPCFDirectionalShadows(this.renderer) +\n            getPCFShadowContribution +\n            getPCFPointShadows(this.renderer) +\n            getPCFPointShadowContribution +\n            parameters.shaders.fragment.code\n        }\n\n        // filter duplicate depth comparison samplers\n        depthSamplers = depthSamplers.filter(\n          (sampler, i, array) => array.findIndex((s) => s.uuid === sampler.uuid) === i\n        )\n\n        if (parameters.textures) {\n          parameters.textures = [...parameters.textures, ...depthTextures]\n        } else {\n          parameters.textures = depthTextures\n        }\n\n        if (parameters.samplers) {\n          parameters.samplers = [...parameters.samplers, ...depthSamplers]\n        } else {\n          parameters.samplers = depthSamplers\n        }\n      }\n\n      return super.cleanupRenderMaterialParameters(parameters)\n    }\n\n    /**\n     * Set a Mesh matrices uniforms inputs then call {@link MeshBaseClass} super method\n     * @param meshParameters - {@link RenderMaterialParams | RenderMaterial parameters}\n     */\n    setMaterial(meshParameters: RenderMaterialParams) {\n      // add matrices uniforms\n      // https://threejs.org/docs/#api/en/renderers/webgl/WebGLProgram\n      // https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/introToShaders#built-in-variables\n      const matricesUniforms: BufferBindingOffsetChildParams = {\n        label: 'Matrices',\n        name: 'matrices',\n        visibility: ['vertex'],\n        minOffset: this.renderer.device.limits.minUniformBufferOffsetAlignment,\n        struct: {\n          model: {\n            type: 'mat4x4f',\n            value: this.worldMatrix,\n          },\n          modelView: {\n            // model view matrix (world matrix multiplied by camera view matrix)\n            type: 'mat4x4f',\n            value: this.modelViewMatrix,\n          },\n          normal: {\n            // normal matrix\n            type: 'mat3x3f',\n            value: this.normalMatrix,\n          },\n        },\n      }\n\n      if (this.options.renderBundle && this.options.renderBundle.binding) {\n        matricesUniforms.parent = this.options.renderBundle.binding\n        matricesUniforms.offset = this.options.renderBundle.meshes.size\n      }\n\n      const transformationBinding = new BufferBindingOffsetChild(matricesUniforms)\n      if (!meshParameters.bindings) meshParameters.bindings = []\n      meshParameters.bindings.unshift(transformationBinding)\n\n      super.setMaterial(meshParameters)\n    }\n\n    /**\n     * Get the visible property value\n     */\n    get visible(): boolean {\n      return this._visible\n    }\n\n    /**\n     * Set the visible property value\n     * @param value - new visibility value\n     */\n    set visible(value: boolean) {\n      this.shouldUpdateMatrixStack()\n      this._visible = value\n    }\n\n    /* SIZE & TRANSFORMS */\n\n    /**\n     * Resize our {@link ProjectedMeshBaseClass}\n     * @param boundingRect - the new bounding rectangle\n     */\n    resize(boundingRect?: DOMElementBoundingRect | null) {\n      if (this.domFrustum) this.domFrustum.setContainerBoundingRect(this.renderer.boundingRect)\n\n      super.resize(boundingRect)\n    }\n\n    /**\n     * Apply scale and resize textures\n     */\n    applyScale() {\n      super.applyScale()\n\n      // resize textures on scale change!\n      for (const texture of this.domTextures) {\n        texture.resize()\n      }\n    }\n\n    /**\n     * Get our {@link DOMFrustum} projected bounding rectangle\n     * @readonly\n     */\n    get projectedBoundingRect(): DOMElementBoundingRect {\n      return this.domFrustum?.projectedBoundingRect\n    }\n\n    /* EVENTS */\n\n    /**\n     * Assign a callback function to _onReEnterViewCallback\n     * @param callback - callback to run when {@link ProjectedMeshBaseClass} is reentering the view frustum\n     * @returns - our Mesh\n     */\n    onReEnterView(callback: () => void): ProjectedMeshBaseClass {\n      if (callback) {\n        this._onReEnterViewCallback = callback\n      }\n\n      return this\n    }\n\n    /**\n     * Assign a callback function to _onLeaveViewCallback\n     * @param callback - callback to run when {@link ProjectedMeshBaseClass} is leaving the view frustum\n     * @returns - our Mesh\n     */\n    onLeaveView(callback: () => void): ProjectedMeshBaseClass {\n      if (callback) {\n        this._onLeaveViewCallback = callback\n      }\n\n      return this\n    }\n\n    /* RENDER */\n\n    /**\n     * Get the geometry bounding sphere in clip space.\n     * @readonly\n     */\n    get clipSpaceBoundingSphere(): {\n      /** Center of the bounding sphere. */\n      center: Vec3\n      /** Radius of the bounding sphere. */\n      radius: number\n    } {\n      const { center, radius, min, max } = this.geometry.boundingBox\n\n      // get actual translation and max scale\n      const translation = this.worldMatrix.getTranslation()\n      const maxWorldRadius = radius * this.worldMatrix.getMaxScaleOnAxis()\n\n      // get the center on the back face\n      const cMin = center.clone().add(translation)\n      cMin.z += min.z\n\n      // get the center on the front face\n      const cMax = center.clone().add(translation)\n      cMax.z += max.z\n\n      // get a point on the back face sphere\n      // use Y because the projection is dependent of the Y axis\n      const sMin = cMin.clone()\n      sMin.y += maxWorldRadius\n\n      // get a point on the front face sphere\n      const sMax = cMax.clone()\n      sMax.y += maxWorldRadius\n\n      // apply view projection matrix\n      cMin.applyMat4(this.camera.viewProjectionMatrix)\n      cMax.applyMat4(this.camera.viewProjectionMatrix)\n      sMin.applyMat4(this.camera.viewProjectionMatrix)\n      sMax.applyMat4(this.camera.viewProjectionMatrix)\n\n      // now get the bounding rectangle of the back and front face rectangles\n      const rMin = cMin.distance(sMin)\n      const rMax = cMax.distance(sMax)\n\n      const rectMin = {\n        xMin: cMin.x - rMin,\n        xMax: cMin.x + rMin,\n        yMin: cMin.y - rMin,\n        yMax: cMin.y + rMin,\n      }\n\n      const rectMax = {\n        xMin: cMax.x - rMax,\n        xMax: cMax.x + rMax,\n        yMin: cMax.y - rMax,\n        yMax: cMax.y + rMax,\n      }\n\n      // compute final rectangle\n      const rect = {\n        xMin: Math.min(rectMin.xMin, rectMax.xMin),\n        yMin: Math.min(rectMin.yMin, rectMax.yMin),\n        xMax: Math.max(rectMin.xMax, rectMax.xMax),\n        yMax: Math.max(rectMin.yMax, rectMax.yMax),\n      }\n\n      // get sphere center\n      const sphereCenter = cMax.add(cMin).multiplyScalar(0.5).clone()\n      sphereCenter.x = (rect.xMax + rect.xMin) / 2\n      sphereCenter.y = (rect.yMax + rect.yMin) / 2\n\n      // get sphere radius\n      const sphereRadius = Math.max(rect.xMax - rect.xMin, rect.yMax - rect.yMin) * 0.5\n\n      return {\n        center: sphereCenter,\n        radius: sphereRadius,\n      }\n    }\n\n    /**\n     * Check if the Mesh lies inside the {@link camera} view frustum or not using the test defined by {@link frustumCulling}.\n     */\n    checkFrustumCulling() {\n      if (this.matricesNeedUpdate) {\n        if (this.domFrustum && this.frustumCulling) {\n          if (this.frustumCulling === 'sphere') {\n            this.domFrustum.setDocumentCoordsFromClipSpaceSphere(this.clipSpaceBoundingSphere)\n          } else {\n            this.domFrustum.setDocumentCoordsFromClipSpaceOBB()\n          }\n\n          this.domFrustum.intersectsContainer()\n        }\n      }\n    }\n\n    /**\n     * Tell our matrices bindings to update if needed and call {@link MeshBaseClass#onBeforeRenderPass | Mesh base onBeforeRenderPass} super.\n     */\n    onBeforeRenderPass() {\n      if (this.material && this.matricesNeedUpdate) {\n        this.material.shouldUpdateInputsBindings('matrices')\n      }\n\n      super.onBeforeRenderPass()\n    }\n\n    /**\n     * Render our Mesh if the {@link RenderMaterial} is ready and if it is not frustum culled.\n     * @param pass - current render pass\n     */\n    onRenderPass(pass: GPURenderPassEncoder) {\n      if (!this.ready) return\n\n      this._onRenderCallback && this._onRenderCallback()\n\n      if ((this.domFrustum && this.domFrustum.isIntersecting) || !this.frustumCulling) {\n        // render our material\n        this.material.render(pass)\n        // then render our geometry\n        this.geometry.render(pass)\n      }\n    }\n\n    destroy() {\n      if (this.options.castShadows) {\n        this.renderer.shadowCastingLights.forEach((light) => {\n          if (light.shadow.isActive) {\n            light.shadow.removeMesh(this)\n          }\n        })\n      }\n\n      super.destroy()\n    }\n  }\n}\n\nexport { ProjectedMeshBaseMixin }\n","import { CameraRenderer, isCameraRenderer } from '../renderers/utils'\r\nimport { ProjectedObject3D } from '../objects3D/ProjectedObject3D'\r\nimport { ProjectedMeshBaseMixin, ProjectedMeshParameters } from './mixins/ProjectedMeshBaseMixin'\r\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\r\n\r\n/**\r\n * Create a 3D Mesh.\r\n *\r\n * A 3D Mesh is a basically a {@link ProjectedObject3D} with a {@link core/geometries/Geometry.Geometry | Geometry} and a {@link core/materials/RenderMaterial.RenderMaterial | RenderMaterial}.\r\n *\r\n * You need to pass at least a valid {@link core/geometries/Geometry.Geometry | Geometry} as parameter.<br>\r\n * If no shaders are provided, it will use the normals colors as default shading.\r\n *\r\n * ## Shaders bindings and default attributes and uniforms\r\n *\r\n * The shaders are automatically patched with the input {@link core/bindGroups/BindGroup.BindGroup | bind groups} and {@link core/bindings/BufferBinding.BufferBinding | bindings} defined in your parameters object, as well as some default attributes and uniforms (see {@link core/pipelines/RenderPipelineEntry.RenderPipelineEntry | RenderPipelineEntry}).\r\n *\r\n * ### Default shaders\r\n *\r\n * If one or all shaders are missing, the library will use default ones.\r\n *\r\n * #### Default vertex shader:\r\n *\r\n * ```wgsl\r\n * struct VSOutput {\r\n *   @builtin(position) position: vec4f,\r\n *   @location(0) uv: vec2f,\r\n *   @location(1) normal: vec3f,\r\n *   @location(2) worldPosition: vec3f,\r\n *   @location(3) viewDirection: vec3f,\r\n * };\r\n *\r\n * @vertex fn main(\r\n *   attributes: Attributes,\r\n * ) -> VSOutput {\r\n *   var vsOutput: VSOutput;\r\n *\r\n *   vsOutput.position = getOutputPosition(attributes.position);\r\n *   vsOutput.uv = attributes.uv;\r\n *   vsOutput.normal = getWorldNormal(attributes.normal);\r\n *   vsOutput.worldPosition = getWorldPosition(attributes.position).xyz;\r\n *   vsOutput.viewDirection = camera.position - vsOutput.worldPosition;\r\n *\r\n *   return vsOutput;\r\n * }\r\n * ```\r\n *\r\n * #### Default fragment shader:\r\n *\r\n * ```wgsl\r\n * struct VSOutput {\r\n *   @builtin(position) position: vec4f,\r\n *   @location(0) uv: vec2f,\r\n *   @location(1) normal: vec3f,\r\n * };\r\n *\r\n * @fragment fn main(fsInput: VSOutput) -> @location(0) vec4f {\r\n *   // normals\r\n *   return vec4(normalize(fsInput.normal) * 0.5 + 0.5, 1.0);\r\n * }\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // set our main GPUCurtains instance\r\n * const gpuCurtains = new GPUCurtains({\r\n *   container: '#canvas' // selector of our WebGPU canvas container\r\n * })\r\n *\r\n * // set the GPU device\r\n * // note this is asynchronous\r\n * await gpuCurtains.setDevice()\r\n *\r\n * // create a mesh with a box geometry\r\n * // will use the normals colors as default shading\r\n * const mesh = new Mesh(gpuCurtains, {\r\n *   label: 'My mesh',\r\n *   geometry: new BoxGeometry(),\r\n * })\r\n * ```\r\n */\r\nexport class Mesh extends ProjectedMeshBaseMixin(ProjectedObject3D) {\r\n  /**\r\n   * Mesh constructor\r\n   * @param renderer - {@link CameraRenderer} object or {@link GPUCurtains} class object used to create this {@link Mesh}\r\n   * @param parameters - {@link ProjectedMeshParameters | parameters} use to create this {@link Mesh}\r\n   */\r\n  constructor(renderer: CameraRenderer | GPUCurtains, parameters: ProjectedMeshParameters = {}) {\r\n    // we could pass our curtains object OR our curtains renderer object\r\n    renderer = isCameraRenderer(renderer, parameters.label ? parameters.label + ' Mesh' : 'Mesh')\r\n\r\n    // @ts-ignore\r\n    super(renderer, null, parameters)\r\n\r\n    this.type = 'Mesh'\r\n  }\r\n}\r\n","import { PipelineEntry } from './PipelineEntry'\r\nimport { isRenderer, Renderer } from '../renderers/utils'\r\nimport { throwError } from '../../utils/utils'\r\nimport { PipelineEntryParams, PipelineEntryPropertiesParams, PipelineEntryShaders } from '../../types/PipelineEntries'\r\nimport { BindGroupBufferBindingElement } from '../../types/BindGroups'\r\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\r\n\r\n/**\r\n * Used to create a {@link PipelineEntry} specifically designed to handle {@link core/materials/ComputeMaterial.ComputeMaterial | ComputeMaterial}.\r\n *\r\n * ## Shaders patching\r\n *\r\n * The {@link ComputePipelineEntry} uses each of its {@link ComputePipelineEntry#bindGroups | bind groups} {@link core/bindings/Binding.Binding | Binding} to patch the given compute shader before creating the {@link GPUShaderModule}.<br>\r\n * It will prepend every {@link core/bindings/Binding.Binding | Binding} WGSL code snippets (or fragments) with the correct bind group and bindings indices.\r\n *\r\n * ## Pipeline compilation\r\n *\r\n * The {@link ComputePipelineEntry} will then create a {@link GPUComputePipeline} (asynchronously by default).\r\n */\r\nexport class ComputePipelineEntry extends PipelineEntry {\r\n  /** Shaders to use with this {@link ComputePipelineEntry} */\r\n  shaders: PipelineEntryShaders\r\n  /** {@link GPUComputePipelineDescriptor | Compute pipeline descriptor} based on {@link layout} and {@link shaders} */\r\n  descriptor: GPUComputePipelineDescriptor | null\r\n\r\n  /**\r\n   * ComputePipelineEntry constructor\r\n   * @param parameters - {@link PipelineEntryParams | parameters} used to create this {@link ComputePipelineEntry}\r\n   */\r\n  constructor(parameters: PipelineEntryParams) {\r\n    const { renderer } = parameters\r\n    const { label } = parameters\r\n\r\n    const type = 'ComputePipelineEntry'\r\n\r\n    isRenderer(renderer, label ? label + ' ' + type : type)\r\n\r\n    super(parameters)\r\n\r\n    this.type = type\r\n\r\n    this.shaders = {\r\n      compute: {\r\n        head: '',\r\n        code: '',\r\n        module: null,\r\n      },\r\n    }\r\n\r\n    this.descriptor = null\r\n  }\r\n\r\n  /**\r\n   * Set {@link ComputePipelineEntry} properties (in this case the {@link bindGroups | bind groups})\r\n   * @param parameters - the {@link core/materials/ComputeMaterial.ComputeMaterial#bindGroups | bind groups} to use\r\n   */\r\n  setPipelineEntryProperties(parameters: PipelineEntryPropertiesParams) {\r\n    const { bindGroups } = parameters\r\n\r\n    this.setPipelineEntryBindGroups(bindGroups)\r\n  }\r\n\r\n  /* SHADERS */\r\n\r\n  /**\r\n   * Patch the shaders by appending all the {@link bindGroups | bind groups}) WGSL code fragments to the given {@link PipelineEntryParams#shaders | parameter shader code}\r\n   */\r\n  patchShaders() {\r\n    this.shaders.compute.head = ''\r\n    this.shaders.compute.code = ''\r\n\r\n    const groupsBindings = []\r\n    for (const bindGroup of this.bindGroups) {\r\n      let bindIndex = 0\r\n      bindGroup.bindings.forEach((binding, bindingIndex) => {\r\n        binding.wgslGroupFragment.forEach((groupFragment, groupFragmentIndex) => {\r\n          groupsBindings.push({\r\n            groupIndex: bindGroup.index,\r\n            bindIndex,\r\n            wgslStructFragment: (binding as BindGroupBufferBindingElement).wgslStructFragment,\r\n            wgslGroupFragment: groupFragment,\r\n            newLine:\r\n              bindingIndex === bindGroup.bindings.length - 1 &&\r\n              groupFragmentIndex === binding.wgslGroupFragment.length - 1,\r\n          })\r\n\r\n          bindIndex++\r\n        })\r\n      })\r\n    }\r\n\r\n    for (const groupBinding of groupsBindings) {\r\n      // do not duplicate structs\r\n      if (\r\n        groupBinding.wgslStructFragment &&\r\n        this.shaders.compute.head.indexOf(groupBinding.wgslStructFragment) === -1\r\n      ) {\r\n        this.shaders.compute.head = `\\n${groupBinding.wgslStructFragment}\\n${this.shaders.compute.head}`\r\n      }\r\n\r\n      // do not duplicate struct var as well\r\n      if (this.shaders.compute.head.indexOf(groupBinding.wgslGroupFragment) === -1) {\r\n        this.shaders.compute.head = `${this.shaders.compute.head}\\n@group(${groupBinding.groupIndex}) @binding(${groupBinding.bindIndex}) ${groupBinding.wgslGroupFragment}`\r\n      }\r\n\r\n      if (groupBinding.newLine) this.shaders.compute.head += `\\n`\r\n    }\r\n\r\n    this.shaders.compute.code = this.shaders.compute.head + this.options.shaders.compute.code\r\n  }\r\n\r\n  /* SETUP */\r\n\r\n  /**\r\n   * Create the {@link shaders}: patch them and create the {@link GPUShaderModule}\r\n   */\r\n  createShaders() {\r\n    this.patchShaders()\r\n\r\n    this.shaders.compute.module = this.createShaderModule({\r\n      code: this.shaders.compute.code,\r\n      type: 'compute',\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Create the compute pipeline {@link descriptor}\r\n   */\r\n  createPipelineDescriptor() {\r\n    if (!this.shaders.compute.module) return\r\n\r\n    this.descriptor = {\r\n      label: this.options.label,\r\n      layout: this.layout,\r\n      compute: {\r\n        module: this.shaders.compute.module,\r\n        entryPoint: this.options.shaders.compute.entryPoint,\r\n      },\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create the compute {@link pipeline}\r\n   */\r\n  createComputePipeline() {\r\n    if (!this.shaders.compute.module) return\r\n\r\n    try {\r\n      this.pipeline = this.renderer.createComputePipeline(this.descriptor)\r\n    } catch (error) {\r\n      this.status.error = error\r\n      throwError(error)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Asynchronously create the compute {@link pipeline}\r\n   * @async\r\n   * @returns - void promise result\r\n   */\r\n  async createComputePipelineAsync(): Promise<void> {\r\n    if (!this.shaders.compute.module) return\r\n\r\n    try {\r\n      this.pipeline = await this.renderer.createComputePipelineAsync(this.descriptor)\r\n      this.status.compiled = true\r\n      this.status.compiling = false\r\n      this.status.error = null\r\n    } catch (error) {\r\n      this.status.error = error\r\n      throwError(error)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Call {@link PipelineEntry#compilePipelineEntry | PipelineEntry compilePipelineEntry} method, then create our compute {@link pipeline}\r\n   * @async\r\n   */\r\n  async compilePipelineEntry(): Promise<void> {\r\n    super.compilePipelineEntry()\r\n\r\n    if (this.options.useAsync) {\r\n      await this.createComputePipelineAsync()\r\n    } else {\r\n      this.createComputePipeline()\r\n      this.status.compiled = true\r\n      this.status.compiling = false\r\n      this.status.error = null\r\n    }\r\n  }\r\n}\r\n","import { RenderPipelineEntry } from './RenderPipelineEntry'\r\nimport { ComputePipelineEntry } from './ComputePipelineEntry'\r\nimport {\r\n  PipelineEntryParams,\r\n  PipelineManagerRenderPipelineEntryParams,\r\n  RenderPipelineEntryParams,\r\n} from '../../types/PipelineEntries'\r\nimport { ShaderOptions } from '../../types/Materials'\r\nimport { compareRenderingOptions } from '../materials/utils'\r\nimport { BindGroup } from '../bindGroups/BindGroup'\r\n\r\n/** Defines all types of allowed {@link core/pipelines/PipelineEntry.PipelineEntry | PipelineEntry} class objects */\r\nexport type AllowedPipelineEntries = RenderPipelineEntry | ComputePipelineEntry\r\n\r\n/** Defines all the types of render passes allowed. */\r\nexport type GPURenderPassTypes = GPURenderPassEncoder | GPURenderBundleEncoder\r\n/** Defines all the types of passes allowed. */\r\nexport type GPUPassTypes = GPURenderPassTypes | GPUComputePassEncoder\r\n\r\n/**\r\n * Used to create and keep track of both {@link ComputePipelineEntry} and {@link RenderPipelineEntry}.<br>\r\n * Perform checks to eventually use a cached pipeline entry instead of creating a new one.<br>\r\n * The end goal is to cache pipelines and reuse them (as well as bind groups).<br>\r\n * Also responsible for setting the current pass encoder pipeline in order to avoid redundant setPipeline calls.<br>\r\n * Created internally by the {@link core/renderers/GPUDeviceManager.GPUDeviceManager | GPUDeviceManager}.<br>\r\n * @see {@link https://toji.dev/webgpu-best-practices/bind-groups#grouping-resources-based-on-frequency-of-change | WebGPU Bind Group best practices}\r\n */\r\nexport class PipelineManager {\r\n  /** The type of the {@link PipelineManager} */\r\n  type: string\r\n  /** Keep track of the current bound pipeline in order to avoid redundant setPipeline calls */\r\n  currentPipelineIndex: number | null\r\n  /** Array of already created {@link ComputePipelineEntry} and {@link RenderPipelineEntry} */\r\n  pipelineEntries: AllowedPipelineEntries[]\r\n  /** Array of current pass (used by {@link GPURenderPassEncoder} at the moment, but can be extended to {@link GPUComputePassEncoder} as well) already set {@link core/bindGroups/BindGroup.BindGroup | bind groups}. */\r\n  activeBindGroups: BindGroup[]\r\n\r\n  constructor() {\r\n    this.type = 'PipelineManager'\r\n\r\n    this.currentPipelineIndex = null\r\n    this.pipelineEntries = []\r\n    this.activeBindGroups = []\r\n  }\r\n\r\n  /**\r\n   * Compare two {@link ShaderOptions | shader objects}\r\n   * @param shaderA - first {@link ShaderOptions | shader object} to compare\r\n   * @param shaderB - second {@link ShaderOptions | shader object} to compare\r\n   * @returns - whether the two {@link ShaderOptions | shader objects} code and entryPoint match\r\n   */\r\n  compareShaders(shaderA: ShaderOptions, shaderB: ShaderOptions): boolean {\r\n    // store shader code in a Set map?\r\n    // https://www.measurethat.net/Benchmarks/Show/30363/0/shaders-strings-comparisons\r\n    return shaderA.code === shaderB.code && shaderA.entryPoint === shaderB.entryPoint\r\n    //return shaderA.code?.localeCompare(shaderB.code) === 0 && shaderA.entryPoint === shaderB.entryPoint\r\n  }\r\n\r\n  /**\r\n   * Checks if the provided {@link RenderPipelineEntryParams | RenderPipelineEntry parameters} belongs to an already created {@link RenderPipelineEntry}.\r\n   * @param parameters - {@link RenderPipelineEntryParams | RenderPipelineEntry parameters}\r\n   * @returns - the found {@link RenderPipelineEntry}, or null if not found\r\n   */\r\n  isSameRenderPipeline(parameters: RenderPipelineEntryParams): RenderPipelineEntry | null {\r\n    return this.pipelineEntries\r\n      .filter((pipelineEntry) => pipelineEntry instanceof RenderPipelineEntry)\r\n      .find((pipelineEntry: RenderPipelineEntry) => {\r\n        const { options } = pipelineEntry\r\n        const { shaders, rendering, cacheKey } = parameters\r\n\r\n        const sameCacheKey = cacheKey === options.cacheKey\r\n\r\n        const sameVertexShader = this.compareShaders(shaders.vertex, options.shaders.vertex)\r\n        const sameFragmentShader =\r\n          (!shaders.fragment && !options.shaders.fragment) ||\r\n          this.compareShaders(shaders.fragment as ShaderOptions, options.shaders.fragment as ShaderOptions)\r\n\r\n        const differentParams = compareRenderingOptions(rendering, options.rendering)\r\n\r\n        return sameCacheKey && !differentParams.length && sameVertexShader && sameFragmentShader\r\n      }) as RenderPipelineEntry | null\r\n  }\r\n\r\n  /**\r\n   * Check if a {@link RenderPipelineEntry} has already been created with the given {@link RenderPipelineEntryParams | parameters}.\r\n   * Use it if found, else create a new one and add it to the {@link pipelineEntries} array.\r\n   * @param parameters - {@link RenderPipelineEntryParams | RenderPipelineEntry parameters}\r\n   * @returns - {@link RenderPipelineEntry}, either from cache or newly created\r\n   */\r\n  createRenderPipeline(parameters: PipelineManagerRenderPipelineEntryParams): RenderPipelineEntry {\r\n    const { attributes, bindGroups } = parameters\r\n    let cacheKey = attributes.layoutCacheKey\r\n    bindGroups.forEach((bindGroup) => {\r\n      bindGroup.bindings.forEach((binding) => {\r\n        cacheKey += binding.name + ','\r\n      })\r\n      cacheKey += bindGroup.pipelineCacheKey\r\n    })\r\n\r\n    // render pipeline cache is based on 3 things:\r\n    // 1. geometry and bind groups buffers layout comparison, via the cacheKey\r\n    // 2. same rendering options via compareRenderingOptions()\r\n    // 3. same vertex and fragment shaders code and entry points\r\n    // see https://toji.dev/webgpu-gltf-case-study/#part-3-pipeline-caching\r\n    const existingPipelineEntry = this.isSameRenderPipeline({ ...parameters, cacheKey })\r\n\r\n    if (existingPipelineEntry) {\r\n      return existingPipelineEntry\r\n    } else {\r\n      const pipelineEntry = new RenderPipelineEntry({ ...parameters, cacheKey })\r\n\r\n      this.pipelineEntries.push(pipelineEntry)\r\n\r\n      return pipelineEntry\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a {@link ComputePipelineEntry} has already been created with the given {@link PipelineEntryParams | parameters}.\r\n   * Use it if found, else create a new one and add it to the {@link pipelineEntries} array.\r\n   * @param parameters - {@link PipelineEntryParams | PipelineEntry parameters}\r\n   * @returns - newly created {@link ComputePipelineEntry}\r\n   */\r\n  createComputePipeline(parameters: PipelineEntryParams): ComputePipelineEntry {\r\n    const pipelineEntry = new ComputePipelineEntry(parameters)\r\n\r\n    this.pipelineEntries.push(pipelineEntry)\r\n\r\n    return pipelineEntry\r\n  }\r\n\r\n  /**\r\n   * Check if the given {@link AllowedPipelineEntries | PipelineEntry} is already set, if not set it\r\n   * @param pass - current pass encoder\r\n   * @param pipelineEntry - the {@link AllowedPipelineEntries | PipelineEntry} to set\r\n   */\r\n  setCurrentPipeline(pass: GPUPassTypes, pipelineEntry: AllowedPipelineEntries) {\r\n    if (pipelineEntry.index !== this.currentPipelineIndex) {\r\n      pass.setPipeline(pipelineEntry.pipeline as GPURenderPipeline & GPUComputePipeline)\r\n      this.currentPipelineIndex = pipelineEntry.index\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Track the active/already set {@link core/bindGroups/BindGroup.BindGroup | bind groups} to avoid `setBindGroup()` redundant calls.\r\n   * @param pass - current pass encoder.\r\n   * @param bindGroups - array {@link core/bindGroups/BindGroup.BindGroup | bind groups} passed by the {@link core/materials/RenderMaterial.RenderMaterial | RenderMaterial}.\r\n   */\r\n  setActiveBindGroups(pass: GPUPassTypes, bindGroups: BindGroup[]) {\r\n    bindGroups.forEach((bindGroup, index) => {\r\n      if (\r\n        !this.activeBindGroups[index] ||\r\n        this.activeBindGroups[index].uuid !== bindGroup.uuid ||\r\n        this.activeBindGroups[index].index !== bindGroup.index // the same bind group might be used at different indices\r\n      ) {\r\n        this.activeBindGroups[index] = bindGroup\r\n        pass.setBindGroup(bindGroup.index, bindGroup.bindGroup)\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Reset the {@link PipelineManager#currentPipelineIndex | current pipeline index} and {@link activeBindGroups} so the next {@link AllowedPipelineEntries | PipelineEntry} will be set for sure\r\n   */\r\n  resetCurrentPipeline() {\r\n    this.currentPipelineIndex = null\r\n    this.activeBindGroups = []\r\n  }\r\n}\r\n","import { DOMElement } from '../core/DOM/DOMElement'\r\n\r\n/**\r\n * Defines a {@link ResizeManager} entry\r\n */\r\nexport interface ResizeManagerEntry {\r\n  /** {@link HTMLElement} to track */\r\n  element: DOMElement['element'] | Element\r\n  /** Priority in which to call the callback function */\r\n  priority?: number\r\n  /** Function to execute when the {@link element} is resized */\r\n  callback: () => void | null\r\n}\r\n\r\n/**\r\n * Tiny wrapper around {@link ResizeObserver} used to execute callbacks when given {@link HTMLElement} size changes.\r\n */\r\nexport class ResizeManager {\r\n  /** Whether we should add elements to our {@link resizeObserver} or not */\r\n  shouldWatch: boolean\r\n  /** Array of {@link ResizeManagerEntry | entries} */\r\n  entries: ResizeManagerEntry[]\r\n  /** {@link ResizeObserver} used */\r\n  resizeObserver: ResizeObserver | undefined\r\n\r\n  /**\r\n   * ResizeManager constructor\r\n   */\r\n  constructor() {\r\n    // default to true\r\n    this.shouldWatch = true\r\n\r\n    this.entries = []\r\n\r\n    // do not throw an error if we're using the lib inside a worker\r\n    if (typeof window === 'object' && 'ResizeObserver' in window) {\r\n      this.resizeObserver = new ResizeObserver((observedEntries) => {\r\n        // get all entries corresponding to that element, and sort them by priority\r\n        const allEntries = observedEntries\r\n          .map((observedEntry) => {\r\n            return this.entries.filter((e) => e.element.isSameNode(observedEntry.target))\r\n          })\r\n          .flat()\r\n          .sort((a, b) => b.priority - a.priority)\r\n\r\n        allEntries?.forEach((entry) => {\r\n          if (entry && entry.callback) {\r\n            entry.callback()\r\n          }\r\n        })\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set {@link shouldWatch}\r\n   * @param shouldWatch - whether to watch or not\r\n   */\r\n  useObserver(shouldWatch = true) {\r\n    this.shouldWatch = shouldWatch\r\n  }\r\n\r\n  /**\r\n   * Track an {@link HTMLElement} size change and execute a callback function when it happens\r\n   * @param entry - {@link ResizeManagerEntry | entry} to watch\r\n   */\r\n  observe({ element, priority, callback }: ResizeManagerEntry) {\r\n    if (!element || !this.shouldWatch) return\r\n\r\n    this.resizeObserver?.observe(element)\r\n\r\n    const entry = {\r\n      element,\r\n      priority,\r\n      callback,\r\n    }\r\n\r\n    this.entries.push(entry)\r\n  }\r\n\r\n  /**\r\n   * Unobserve an {@link HTMLElement} and remove it from our {@link entries} array\r\n   * @param element - {@link HTMLElement} to unobserve\r\n   */\r\n  unobserve(element: DOMElement['element'] | Element) {\r\n    this.resizeObserver?.unobserve(element)\r\n    this.entries = this.entries.filter((e) => !e.element.isSameNode(element))\r\n  }\r\n\r\n  /**\r\n   * Destroy our {@link ResizeManager}\r\n   */\r\n  destroy() {\r\n    this.resizeObserver?.disconnect()\r\n  }\r\n}\r\n\r\n/** @exports @const resizeManager - {@link ResizeManager} class object */\r\nexport const resizeManager = new ResizeManager() as ResizeManager\r\n","import { resizeManager, ResizeManager, ResizeManagerEntry } from '../../utils/ResizeManager'\r\nimport { throwError } from '../../utils/utils'\r\n\r\n/**\r\n * Defines a rectangular coordinates object\r\n */\r\nexport interface RectCoords {\r\n  /** top position */\r\n  top: number\r\n  /** right position */\r\n  right: number\r\n  /** bottom position */\r\n  bottom: number\r\n  /** left position */\r\n  left: number\r\n}\r\n\r\n/**\r\n * Defines a size object\r\n */\r\nexport interface RectSize {\r\n  /** width of the rectangle */\r\n  width: number\r\n  /** height of the rectangle */\r\n  height: number\r\n}\r\n\r\n/**\r\n * Defines a rectangular bounding box object\r\n */\r\nexport interface RectBBox extends RectSize {\r\n  /** top position of the bounding box */\r\n  top: number\r\n  /** left position of the bounding box */\r\n  left: number\r\n}\r\n\r\n/**\r\n * Defines a DOM position object\r\n */\r\nexport interface DOMPosition {\r\n  /** X position */\r\n  x: number\r\n  /** Y position */\r\n  y: number\r\n}\r\n\r\n/**\r\n * Defines a complete DOM Element bounding rect object, similar to a {@link DOMRect}\r\n */\r\nexport interface DOMElementBoundingRect extends RectCoords, RectBBox, DOMPosition {}\r\n\r\n/**\r\n * Parameters used to create a {@link DOMElement}\r\n */\r\nexport interface DOMElementParams {\r\n  /** {@link HTMLElement} or string representing an {@link HTMLElement} selector of the element the resize observer should track */\r\n  element?: string | Element\r\n  /** Order in which the {@link resizeManager} callback is executed */\r\n  priority?: ResizeManagerEntry['priority']\r\n  /** Callback to tun when the {@link DOMElement#element | element} size changed */\r\n  onSizeChanged?: (boundingRect: DOMElementBoundingRect | null) => void | null\r\n  /** Callback to tun when the {@link DOMElement#element | element} position changed */\r\n  onPositionChanged?: (boundingRect: DOMElementBoundingRect | null) => void | null\r\n}\r\n\r\n/**\r\n * Used to track a DOM Element size and position by using a resize observer provided by {@link ResizeManager}.<br>\r\n * Execute callbacks when the bounding rectangle of the DOM Element changes, which means when its size and/or position change.\r\n */\r\nexport class DOMElement {\r\n  /** The HTML element to track */\r\n  element: HTMLElement\r\n  /** Priority at which this element {@link onSizeChanged} function must be called */\r\n  priority: ResizeManagerEntry['priority']\r\n  /** Flag indicating whether the timeout is still running and we should avoid a new computation */\r\n  isResizing: boolean\r\n  /** Callback to run whenever the {@link element} size changed */\r\n  onSizeChanged: (boundingRect: DOMElementBoundingRect | null) => void | null\r\n  /** Callback to run whenever the {@link element} position changed */\r\n  onPositionChanged: (boundingRect: DOMElementBoundingRect | null) => void | null\r\n  /** The {@link ResizeManager} used, basically a wrapper around a {@link ResizeObserver} */\r\n  resizeManager: ResizeManager\r\n  /** Current  {@link element} bounding rectangle */\r\n  _boundingRect: DOMElementBoundingRect\r\n\r\n  /**\r\n   * DOMElement constructor\r\n   * @param parameters - {@link DOMElementParams | parameters} used to create our DOMElement\r\n   */\r\n  constructor(\r\n    {\r\n      element = document.body,\r\n      priority = 1,\r\n      onSizeChanged = (boundingRect = null) => {\r\n        /* allow empty callback */\r\n      },\r\n      onPositionChanged = (boundingRect = null) => {\r\n        /* allow empty callback */\r\n      },\r\n    } = {} as DOMElementParams\r\n  ) {\r\n    if (typeof element === 'string') {\r\n      this.element = document.querySelector(element)\r\n\r\n      if (!this.element) {\r\n        const notFoundEl = typeof element === 'string' ? `'${element}' selector` : `${element} HTMLElement`\r\n        throwError(`DOMElement: corresponding ${notFoundEl} not found.`)\r\n      }\r\n    } else {\r\n      this.element = element as HTMLElement\r\n    }\r\n\r\n    this.priority = priority\r\n\r\n    this.isResizing = false\r\n\r\n    this.onSizeChanged = onSizeChanged\r\n    this.onPositionChanged = onPositionChanged\r\n\r\n    this.resizeManager = resizeManager\r\n\r\n    this.resizeManager.observe({\r\n      element: this.element,\r\n      priority: this.priority,\r\n      callback: () => {\r\n        this.setSize()\r\n      },\r\n    })\r\n\r\n    // set size right away on init\r\n    this.setSize()\r\n  }\r\n\r\n  /**\r\n   * Check whether 2 bounding rectangles are equals\r\n   * @param rect1 - first bounding rectangle\r\n   * @param rect2 - second bounding rectangle\r\n   * @returns - whether the rectangles are equals or not\r\n   */\r\n  compareBoundingRect(rect1: DOMRect | DOMElementBoundingRect, rect2: DOMRect | DOMElementBoundingRect): boolean {\r\n    return !['x', 'y', 'left', 'top', 'right', 'bottom', 'width', 'height'].some((k) => rect1[k] !== rect2[k])\r\n  }\r\n\r\n  /**\r\n   * Get our element bounding rectangle\r\n   */\r\n  get boundingRect(): DOMElementBoundingRect {\r\n    return this._boundingRect\r\n  }\r\n\r\n  /**\r\n   * Set our element bounding rectangle\r\n   * @param boundingRect - new bounding rectangle\r\n   */\r\n  set boundingRect(boundingRect: DOMElementBoundingRect) {\r\n    const isSameRect = !!this.boundingRect && this.compareBoundingRect(boundingRect, this.boundingRect)\r\n\r\n    this._boundingRect = {\r\n      top: boundingRect.top,\r\n      right: boundingRect.right,\r\n      bottom: boundingRect.bottom,\r\n      left: boundingRect.left,\r\n      width: boundingRect.width,\r\n      height: boundingRect.height,\r\n      x: boundingRect.x,\r\n      y: boundingRect.y,\r\n    }\r\n\r\n    if (!isSameRect) {\r\n      this.onSizeChanged(this.boundingRect)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update our element bounding rectangle because the scroll position has changed\r\n   * @param delta - scroll delta values along X and Y axis\r\n   */\r\n  updateScrollPosition(delta: DOMPosition = { x: 0, y: 0 }) {\r\n    if (this.isResizing) return\r\n\r\n    this._boundingRect.top += delta.y\r\n    this._boundingRect.left += delta.x\r\n\r\n    if (delta.x || delta.y) {\r\n      this.onPositionChanged(this.boundingRect)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set our element bounding rectangle, either by a value or a getBoundingClientRect call\r\n   * @param boundingRect - new bounding rectangle\r\n   */\r\n  setSize(boundingRect: DOMElementBoundingRect | null = null) {\r\n    if (!this.element || this.isResizing) return\r\n\r\n    this.isResizing = true\r\n\r\n    this.boundingRect = boundingRect ?? this.element.getBoundingClientRect()\r\n\r\n    setTimeout(() => {\r\n      this.isResizing = false\r\n    }, 10)\r\n  }\r\n\r\n  /**\r\n   * Destroy our DOMElement - remove from resize observer and clear throttle timeout\r\n   */\r\n  destroy() {\r\n    this.resizeManager.unobserve(this.element)\r\n  }\r\n}\r\n","import { isRenderer, Renderer } from '../renderers/utils'\nimport { SceneStackedMesh, RenderedMesh, ProjectedMesh, SceneStackedObject } from '../renderers/GPURenderer'\nimport { ShaderPass } from '../renderPasses/ShaderPass'\nimport { PingPongPlane } from '../../extras/meshes/PingPongPlane'\nimport { ComputePass } from '../computePasses/ComputePass'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\nimport { RenderTarget } from '../renderPasses/RenderTarget'\nimport { RenderPass } from '../renderPasses/RenderPass'\nimport { Texture } from '../textures/Texture'\nimport { Object3D } from '../objects3D/Object3D'\nimport { Vec3 } from '../../math/Vec3'\nimport { RenderBundle } from '../renderPasses/RenderBundle'\nimport { throwWarning } from '../../utils/utils'\n\n// used to sort transparent meshes\nconst camPosA = new Vec3()\nconst camPosB = new Vec3()\nconst posA = new Vec3()\nconst posB = new Vec3()\n\n/**\n * Meshes rendering order is dependant of their transparency setting.\n */\nexport interface ProjectionStack {\n  /** opaque Meshes or {@link RenderBundle} will be drawn first */\n  opaque: SceneStackedObject[]\n  /** transparent Meshes or {@link RenderBundle} will be drawn last */\n  transparent: SceneStackedObject[]\n}\n\n/** Meshes or render bundles will be stacked in 2 different objects whether they are projected (use a {@link core/camera/Camera.Camera | Camera}) or not. */\nexport type ProjectionType = 'unProjected' | 'projected'\n\n/** Meshes or render bundles will be put into two stacks of projected/unprojected transparent and opaques objects arrays. */\nexport type Stack = Record<ProjectionType, ProjectionStack>\n\n/**\n * A RenderPassEntry object is used to group Meshes or {@link RenderBundle} based on their rendering target.\n */\nexport interface RenderPassEntry {\n  /** {@link RenderPass} target used onto which render. */\n  renderPass: RenderPass\n  /** {@link Texture} to render to if any (if not specified then this {@link RenderPassEntry} Meshes will be rendered directly to screen). */\n  renderTexture: Texture | null\n  /** Optional function to execute just before rendering the Meshes, useful for eventual texture copy. */\n  onBeforeRenderPass: ((commandEncoder?: GPUCommandEncoder, swapChainTexture?: GPUTexture) => void) | null\n  /** Optional function to execute just after rendering the Meshes, useful for eventual texture copy. */\n  onAfterRenderPass: ((commandEncoder?: GPUCommandEncoder, swapChainTexture?: GPUTexture) => void) | null\n  /** If this {@link RenderPassEntry} needs to render only one Mesh. */\n  element: PingPongPlane | ShaderPass | null\n  /** If this {@link RenderPassEntry} needs to render multiple Meshes or {@link RenderBundle}, then use a {@link Stack} object. */\n  stack: Stack | null\n}\n\n/** Defines all our possible render targets. */\nexport type RenderPassEntriesType = 'pingPong' | 'renderTarget' | 'screen'\n/** Defines our render pass entries object. */\nexport type RenderPassEntries = Record<RenderPassEntriesType, RenderPassEntry[]>\n\n/**\n * Used to by the {@link Renderer} to render everything that needs to be rendered (compute passes, meshes and/or render bundles) in the right order with the right pass descriptors and target textures, perform textures copy at the right time, etc.\n *\n * ## Render order\n *\n * - Run all the {@link ComputePass} first, sorted by their {@link ComputePass#renderOrder | renderOrder}\n * - Then render all {@link renderPassEntries} pingPong entries Meshes or {@link RenderBundle}, sorted by their {@link PingPongPlane#renderOrder | renderOrder}.\n * - Then all Meshes that need to be rendered into specific {@link renderPassEntries} outputTarget entries:\n *   - First, the opaque unprojected Meshes (i.e. opaque {@link core/meshes/FullscreenPlane.FullscreenPlane | FullscreenPlane}  or {@link RenderBundle}, if any), sorted by their {@link core/meshes/FullscreenPlane.FullscreenPlane#renderOrder | renderOrder}.\n *   - Then, the transparent unprojected Meshes (i.e. transparent {@link core/meshes/FullscreenPlane.FullscreenPlane | FullscreenPlane} or {@link RenderBundle}, if any), sorted by their {@link core/meshes/FullscreenPlane.FullscreenPlane#renderOrder | renderOrder}.\n *   - Then, the opaque projected Meshes (i.e. opaque {@link core/meshes/Mesh.Mesh | Mesh}, {@link curtains/meshes/DOMMesh.DOMMesh | DOMMesh}, {@link curtains/meshes/Plane.Plane | Plane}) or {@link RenderBundle}, sorted by their {@link core/meshes/Mesh.Mesh#renderOrder | renderOrder}.\n *   - Finally, the transparent projected Meshes (i.e. transparent {@link core/meshes/Mesh.Mesh | Mesh}, {@link curtains/meshes/DOMMesh.DOMMesh | DOMMesh}, {@link curtains/meshes/Plane.Plane | Plane} or {@link RenderBundle}), sorted by their Z position and then their {@link core/meshes/Mesh.Mesh#renderOrder | renderOrder}.\n * - Finally all Meshes that need to be rendered directly to the {@link renderPassEntries} screen (the {@link Renderer} current texture), in the same order than above.\n */\nexport class Scene extends Object3D {\n  /** {@link Renderer} used by this {@link Scene} */\n  renderer: Renderer\n  /** Array of {@link ComputePass} to render, ordered by {@link ComputePass#renderOrder | renderOrder} */\n  computePassEntries: ComputePass[]\n  /**\n   * A {@link RenderPassEntries} object that will contain every Meshes or {@link RenderBundle} that need to be drawn, put inside each one of our three entries type arrays: `pingPong`, `renderTarget` and `screen`.\n   * - The {@link Scene} will first render all {@link renderPassEntries} pingPong entries Meshes.\n   * - Then all Meshes that need to be rendered into specific {@link renderPassEntries} renderTarget entries.\n   * - Finally all Meshes that need to be rendered to the {@link renderPassEntries} screen.\n   */\n  renderPassEntries: RenderPassEntries\n\n  /**\n   * Scene constructor\n   * @param renderer - {@link Renderer} object or {@link GPUCurtains} class object used to create this {@link Scene}\n   */\n  constructor({ renderer }: { renderer: Renderer | GPUCurtains }) {\n    super()\n\n    renderer = isRenderer(renderer, 'Scene')\n\n    this.renderer = renderer\n\n    this.computePassEntries = []\n\n    this.renderPassEntries = {\n      /** Array of {@link RenderPassEntry} that will handle {@link PingPongPlane}. Each {@link PingPongPlane} will be added as a distinct {@link RenderPassEntry} here */\n      pingPong: [] as RenderPassEntry[],\n      /** Array of {@link RenderPassEntry} that will render to a specific {@link RenderTarget}. Each {@link RenderTarget} will be added as a distinct {@link RenderPassEntry} here */\n      renderTarget: [] as RenderPassEntry[],\n      /** Array of {@link RenderPassEntry} that will render directly to the screen. Our first entry will contain all the Meshes that do not have any {@link RenderTarget} assigned. Following entries will be created for every global {@link ShaderPass} */\n      screen: [] as RenderPassEntry[],\n    }\n  }\n\n  /**\n   * Set the main {@link Renderer} render pass entry.\n   */\n  setMainRenderPassEntry() {\n    // add our basic scene entry\n    this.renderPassEntries.screen.push({\n      renderPass: this.renderer.renderPass,\n      renderTexture: null,\n      onBeforeRenderPass: null,\n      onAfterRenderPass: null,\n      element: null, // explicitly set to null\n      stack: {\n        unProjected: {\n          opaque: [],\n          transparent: [],\n        },\n        projected: {\n          opaque: [],\n          transparent: [],\n        },\n      },\n    } as RenderPassEntry)\n  }\n\n  /**\n   * Get the number of meshes a {@link RenderPassEntry | render pass entry} should draw.\n   * @param renderPassEntry - The {@link RenderPassEntry | render pass entry} to test\n   */\n  getRenderPassEntryLength(renderPassEntry: RenderPassEntry): number {\n    if (!renderPassEntry) {\n      return 0\n    } else {\n      return renderPassEntry.element\n        ? renderPassEntry.element.visible\n          ? 1\n          : 0\n        : renderPassEntry.stack.unProjected.opaque.length +\n            renderPassEntry.stack.unProjected.transparent.length +\n            renderPassEntry.stack.projected.opaque.length +\n            renderPassEntry.stack.projected.transparent.length\n    }\n  }\n\n  /**\n   * Add a {@link ComputePass} to our scene {@link computePassEntries} array\n   * @param computePass - {@link ComputePass} to add\n   */\n  addComputePass(computePass: ComputePass) {\n    this.computePassEntries.push(computePass)\n    this.computePassEntries.sort((a, b) => {\n      if (a.renderOrder !== b.renderOrder) {\n        return a.renderOrder - b.renderOrder\n      } else {\n        return a.index - b.index\n      }\n    })\n  }\n\n  /**\n   * Remove a {@link ComputePass} from our scene {@link computePassEntries} array\n   * @param computePass - {@link ComputePass} to remove\n   */\n  removeComputePass(computePass: ComputePass) {\n    this.computePassEntries = this.computePassEntries.filter((cP) => cP.uuid !== computePass.uuid)\n  }\n\n  /**\n   * Add a {@link RenderTarget} to our scene {@link renderPassEntries} outputTarget array.\n   * Every Meshes later added to this {@link RenderTarget} will be rendered to the {@link RenderTarget#renderTexture | RenderTarget Texture} using the {@link RenderTarget#renderPass.descriptor | RenderTarget RenderPass descriptor}\n   * @param renderTarget - {@link RenderTarget} to add\n   */\n  addRenderTarget(renderTarget: RenderTarget) {\n    // if RT is not already in the render pass entries\n    if (!this.renderPassEntries.renderTarget.find((entry) => entry.renderPass.uuid === renderTarget.renderPass.uuid))\n      this.renderPassEntries.renderTarget.push({\n        renderPass: renderTarget.renderPass,\n        renderTexture: renderTarget.renderTexture,\n        onBeforeRenderPass: null,\n        onAfterRenderPass: null,\n        element: null, // explicitly set to null\n        stack: {\n          unProjected: {\n            opaque: [],\n            transparent: [],\n          },\n          projected: {\n            opaque: [],\n            transparent: [],\n          },\n        },\n      } as RenderPassEntry)\n  }\n\n  /**\n   * Remove a {@link RenderTarget} from our scene {@link renderPassEntries} outputTarget array.\n   * @param renderTarget - {@link RenderTarget} to add\n   */\n  removeRenderTarget(renderTarget: RenderTarget) {\n    this.renderPassEntries.renderTarget = this.renderPassEntries.renderTarget.filter(\n      (entry) => entry.renderPass.uuid !== renderTarget.renderPass.uuid\n    )\n  }\n\n  /**\n   * Get the correct {@link renderPassEntries | render pass entry} (either {@link renderPassEntries} outputTarget or {@link renderPassEntries} screen) {@link Stack} onto which this Mesh should be added, depending on whether it's projected or not\n   * @param mesh - Mesh to check\n   * @returns - the corresponding render pass entry {@link Stack}\n   */\n  getMeshProjectionStack(mesh: RenderedMesh): ProjectionStack {\n    // first get correct render pass enty and stack\n    const renderPassEntry = mesh.outputTarget\n      ? this.renderPassEntries.renderTarget.find(\n          (passEntry) => passEntry.renderPass.uuid === mesh.outputTarget.renderPass.uuid\n        )\n      : this.renderPassEntries.screen[0]\n\n    const { stack } = renderPassEntry\n\n    return mesh.material.options.rendering.useProjection ? stack.projected : stack.unProjected\n  }\n\n  /**\n   * Order a {@link SceneStackedObject} array by using the {@link SceneStackedObject#renderOrder | renderOrder} or {@link SceneStackedObject#index | index} properties.\n   * @param stack - {@link SceneStackedObject} to sort, filled with {@link RenderedMesh} or {@link RenderBundle}.\n   */\n  orderStack(stack: SceneStackedObject[]) {\n    // sort by their render order or natural index\n    stack.sort((a, b) => {\n      return a.renderOrder - b.renderOrder || a.index - b.index\n    })\n  }\n\n  /**\n   * Test whether a {@link SceneStackedObject} is a {@link RenderBundle} or not.\n   * @param object - Object to test.\n   * @returns - Whether the {@link object} is a {@link RenderBundle} or not.\n   */\n  isStackObjectRenderBundle(object: SceneStackedObject): object is RenderBundle {\n    return object.type === 'RenderBundle'\n  }\n\n  /**\n   * Add a Mesh to the correct {@link renderPassEntries | render pass entry} {@link Stack} array.\n   * Meshes are then ordered by their {@link core/meshes/mixins/MeshBaseMixin.MeshBaseClass#index | indexes (order of creation]}, {@link core/pipelines/RenderPipelineEntry.RenderPipelineEntry#index | pipeline entry indexes} and then {@link core/meshes/mixins/MeshBaseMixin.MeshBaseClass#renderOrder | renderOrder}\n   * @param mesh - Mesh to add\n   */\n  addMesh(mesh: SceneStackedMesh) {\n    const projectionStack = this.getMeshProjectionStack(mesh)\n    const isTransparent = !!mesh.transparent\n    const { useProjection } = mesh.material.options.rendering\n\n    if (mesh.renderBundle) {\n      const { renderBundle } = mesh\n\n      renderBundle.addMesh(mesh, mesh.outputTarget ? mesh.outputTarget.renderPass : this.renderer.renderPass)\n\n      if (mesh.renderBundle) {\n        // first mesh of the render bundle?\n        // add the render bundle to the correct stack\n        if (renderBundle.meshes.size === 1) {\n          if (renderBundle.transparent === null) {\n            renderBundle.transparent = isTransparent\n          }\n\n          // TODO is this really needed?\n          if (renderBundle.useProjection === null) {\n            renderBundle.useProjection = useProjection\n          }\n\n          this.addRenderBundle(renderBundle, projectionStack)\n        }\n      }\n    }\n\n    if (!mesh.renderBundle) {\n      // rebuild stack\n      const similarMeshes = isTransparent ? projectionStack.transparent : projectionStack.opaque\n\n      similarMeshes.push(mesh)\n\n      this.orderStack(similarMeshes)\n    }\n\n    if ('parent' in mesh && !mesh.parent && useProjection) {\n      mesh.parent = this\n    }\n  }\n\n  /**\n   * Remove a Mesh from our {@link Scene}.\n   * @param mesh - Mesh to remove.\n   */\n  removeMesh(mesh: SceneStackedMesh) {\n    const projectionStack = this.getMeshProjectionStack(mesh)\n    const isTransparent = !!mesh.transparent\n\n    if (mesh.renderBundle) {\n      mesh.renderBundle.removeMesh(mesh, false)\n    } else {\n      if (isTransparent) {\n        projectionStack.transparent = projectionStack.transparent.filter((m) => m.uuid !== mesh.uuid)\n      } else {\n        projectionStack.opaque = projectionStack.opaque.filter((m) => m.uuid !== mesh.uuid)\n      }\n    }\n\n    if ('parent' in mesh && mesh.parent && mesh.parent.object3DIndex === this.object3DIndex) {\n      mesh.parent = null\n    }\n  }\n\n  /**\n   * Add a {@link RenderBundle} to the correct {@link renderPassEntries | render pass entry} {@link Stack} array.\n   * @param renderBundle - {@link RenderBundle} to add.\n   * @param projectionStack - {@link ProjectionStack} onto which to add the {@link RenderBundle}.\n   */\n  addRenderBundle(renderBundle: RenderBundle, projectionStack: ProjectionStack) {\n    // rebuild stack\n    const similarObjects = !!renderBundle.transparent ? projectionStack.transparent : projectionStack.opaque\n\n    similarObjects.push(renderBundle)\n\n    this.orderStack(similarObjects)\n  }\n\n  /**\n   * Remove a {@link RenderBundle} from our {@link Scene}.\n   * @param renderBundle - {@link RenderBundle} to remove.\n   */\n  removeRenderBundle(renderBundle: RenderBundle) {\n    // first get correct render pass enty and stack\n    const renderPassEntry = this.renderPassEntries.renderTarget.find(\n      (passEntry) => passEntry.renderPass.uuid === renderBundle.options.renderPass?.uuid\n    )\n\n    const { stack } = renderPassEntry || this.renderPassEntries.screen[0]\n\n    const isProjected = !!renderBundle.useProjection\n    const projectionStack = isProjected ? stack.projected : stack.unProjected\n\n    const isTransparent = !!renderBundle.transparent\n\n    if (isTransparent) {\n      projectionStack.transparent = projectionStack.transparent.filter((bundle) => bundle.uuid !== renderBundle.uuid)\n    } else {\n      projectionStack.opaque = projectionStack.opaque.filter((bundle) => bundle.uuid !== renderBundle.uuid)\n    }\n  }\n\n  /**\n   * Add a {@link ShaderPass} to our scene {@link renderPassEntries} screen array.\n   * Before rendering the {@link ShaderPass}, we will copy the correct input texture into its {@link ShaderPass#renderTexture | renderTexture}\n   * This also handles the {@link renderPassEntries} screen array entries order: We will first draw selective passes, then our main screen pass and finally global post processing passes.\n   * @see {@link https://codesandbox.io/p/sandbox/webgpu-render-to-2-textures-without-texture-copy-c4sx4s?file=%2Fsrc%2Findex.js%3A10%2C4 | minimal code example}\n   * @param shaderPass - {@link ShaderPass} to add\n   */\n  addShaderPass(shaderPass: ShaderPass) {\n    const onBeforeRenderPass =\n      shaderPass.inputTarget || shaderPass.outputTarget\n        ? null\n        : (commandEncoder, swapChainTexture) => {\n            // draw the content into our render texture\n            // if it's a global postprocessing pass, copy the context current texture into its renderTexture\n            // we don't need to do that if it has an inputTarget\n            // because in this case its renderTexture is already a copy of the render target content\n            if (shaderPass.renderTexture && swapChainTexture) {\n              commandEncoder.copyTextureToTexture(\n                {\n                  texture: swapChainTexture,\n                },\n                {\n                  texture: shaderPass.renderTexture.texture,\n                },\n                [shaderPass.renderTexture.size.width, shaderPass.renderTexture.size.height]\n              )\n            }\n\n            // if we want to post process the whole scene, clear render pass content\n            this.renderer.postProcessingPass.setLoadOp('clear')\n          }\n\n    const onAfterRenderPass =\n      !shaderPass.outputTarget && shaderPass.options.copyOutputToRenderTexture\n        ? (commandEncoder, swapChainTexture) => {\n            // if we rendered to the screen,\n            // copy the context current texture result back into the shaderPass renderTexture\n            if (shaderPass.renderTexture && swapChainTexture) {\n              commandEncoder.copyTextureToTexture(\n                {\n                  texture: swapChainTexture,\n                },\n                {\n                  texture: shaderPass.renderTexture.texture,\n                },\n                [shaderPass.renderTexture.size.width, shaderPass.renderTexture.size.height]\n              )\n            }\n          }\n        : null\n\n    const outputPass = shaderPass.outputTarget ? shaderPass.outputTarget.renderPass : this.renderer.postProcessingPass\n\n    const shaderPassEntry = {\n      // use output target or postprocessing render pass\n      renderPass: outputPass,\n      // render to output target renderTexture or directly to screen\n      renderTexture: shaderPass.outputTarget ? shaderPass.outputTarget.renderTexture : null,\n      onBeforeRenderPass,\n      onAfterRenderPass,\n      element: shaderPass,\n      stack: null, // explicitly set to null\n    }\n\n    if (shaderPass.renderBundle) {\n      const isTransparent = !!shaderPass.transparent\n      const { renderBundle } = shaderPass\n\n      if (renderBundle.meshes.size < 1) {\n        renderBundle.addMesh(shaderPass, outputPass)\n        // force render bundle size to 1\n        renderBundle.size = 1\n      } else {\n        throwWarning(\n          `${renderBundle.options.label} (${renderBundle.type}): Cannot add more than 1 ShaderPass to a render bundle. This ShaderPass will not be added: ${shaderPass.options.label}`\n        )\n\n        shaderPass.renderBundle = null\n      }\n\n      if (shaderPass.renderBundle) {\n        // add the render bundle to the correct stack\n        shaderPass.renderBundle.renderOrder = shaderPass.renderOrder\n        renderBundle.transparent = isTransparent\n\n        renderBundle.useProjection = false\n      }\n    }\n\n    this.renderPassEntries.screen.push(shaderPassEntry)\n\n    // screen passes are sorted by 2 criteria\n    // first we draw render passes that have an output target OR our main render pass, ordered by renderOrder\n    // then we draw our full postprocessing pass, ordered by renderOrder\n    this.renderPassEntries.screen.sort((a, b) => {\n      const isPostProA = a.element && !a.element.outputTarget\n      const renderOrderA = a.element ? a.element.renderOrder : 0\n      const indexA = a.element ? a.element.index : 0\n\n      const isPostProB = b.element && !b.element.outputTarget\n      const renderOrderB = b.element ? b.element.renderOrder : 0\n      const indexB = b.element ? b.element.index : 0\n\n      if (isPostProA && !isPostProB) {\n        return 1\n      } else if (!isPostProA && isPostProB) {\n        return -1\n      } else if (renderOrderA !== renderOrderB) {\n        return renderOrderA - renderOrderB\n      } else {\n        return indexA - indexB\n      }\n    })\n  }\n\n  /**\n   * Remove a {@link ShaderPass} from our scene {@link renderPassEntries} screen array\n   * @param shaderPass - {@link ShaderPass} to remove\n   */\n  removeShaderPass(shaderPass: ShaderPass) {\n    if (shaderPass.renderBundle) {\n      shaderPass.renderBundle.empty()\n    }\n\n    this.renderPassEntries.screen = this.renderPassEntries.screen.filter(\n      (entry) => !entry.element || entry.element.uuid !== shaderPass.uuid\n    )\n  }\n\n  /**\n   * Add a {@link PingPongPlane} to our scene {@link renderPassEntries} pingPong array.\n   * After rendering the {@link PingPongPlane}, we will copy the context current texture into its {@link PingPongPlane#renderTexture | renderTexture} so we'll be able to use it as an input for the next pass\n   * @see {@link https://codesandbox.io/p/sandbox/webgpu-render-ping-pong-to-texture-use-in-quad-gwjx9p | minimal code example}\n   * @param pingPongPlane\n   */\n  addPingPongPlane(pingPongPlane: PingPongPlane) {\n    this.renderPassEntries.pingPong.push({\n      renderPass: pingPongPlane.outputTarget.renderPass,\n      renderTexture: pingPongPlane.outputTarget.renderTexture,\n      onBeforeRenderPass: null,\n      onAfterRenderPass: (commandEncoder, swapChainTexture) => {\n        // Copy the rendering results from the swapChainTexture into our |pingPongPlane texture|.\n        commandEncoder.copyTextureToTexture(\n          {\n            texture: swapChainTexture,\n          },\n          {\n            texture: pingPongPlane.renderTexture.texture,\n          },\n          [pingPongPlane.renderTexture.size.width, pingPongPlane.renderTexture.size.height]\n        )\n      },\n      element: pingPongPlane,\n      stack: null, // explicitly set to null\n    } as RenderPassEntry)\n\n    if (pingPongPlane.renderBundle) {\n      const isTransparent = !!pingPongPlane.transparent\n      const { renderBundle } = pingPongPlane\n\n      if (renderBundle.meshes.size < 1) {\n        renderBundle.addMesh(pingPongPlane, pingPongPlane.outputTarget.renderPass)\n        // force render bundle size to 1\n        renderBundle.size = 1\n      } else {\n        throwWarning(\n          `${renderBundle.options.label} (${renderBundle.type}): Cannot add more than 1 PingPongPlane to a render bundle. This PingPongPlane will not be added: ${pingPongPlane.options.label}`\n        )\n\n        pingPongPlane.renderBundle = null\n      }\n\n      if (pingPongPlane.renderBundle) {\n        // add the render bundle to the correct stack\n        pingPongPlane.renderBundle.renderOrder = pingPongPlane.renderOrder\n        renderBundle.transparent = isTransparent\n\n        renderBundle.useProjection = false\n      }\n    }\n\n    // sort by their render order\n    this.renderPassEntries.pingPong.sort((a, b) => a.element.renderOrder - b.element.renderOrder)\n  }\n\n  /**\n   * Remove a {@link PingPongPlane} from our scene {@link renderPassEntries} pingPong array.\n   * @param pingPongPlane - {@link PingPongPlane} to remove\n   */\n  removePingPongPlane(pingPongPlane: PingPongPlane) {\n    if (pingPongPlane.renderBundle) {\n      pingPongPlane.renderBundle.empty()\n    }\n\n    this.renderPassEntries.pingPong = this.renderPassEntries.pingPong.filter(\n      (entry) => entry.element.uuid !== pingPongPlane.uuid\n    )\n  }\n\n  /**\n   * Get any rendered object or {@link RenderTarget} {@link RenderPassEntry}. Useful to override a {@link RenderPassEntry#onBeforeRenderPass | RenderPassEntry onBeforeRenderPass} or {@link RenderPassEntry#onAfterRenderPass | RenderPassEntry onAfterRenderPass} default behavior.\n   * @param object - The object from which we want to get the parentMesh {@link RenderPassEntry}\n   * @returns - the {@link RenderPassEntry} if found\n   */\n  getObjectRenderPassEntry(object: RenderedMesh | RenderTarget): RenderPassEntry | undefined {\n    if (object.type === 'RenderTarget') {\n      return this.renderPassEntries.renderTarget.find(\n        (entry) => entry.renderPass.uuid === (object as RenderTarget).renderPass.uuid\n      )\n    } else if (object.type === 'PingPongPlane') {\n      return this.renderPassEntries.pingPong.find((entry) => entry.element.uuid === object.uuid)\n    } else if (object.type === 'ShaderPass') {\n      return this.renderPassEntries.screen.find((entry) => entry.element?.uuid === object.uuid)\n    } else {\n      const entryType = (object as RenderedMesh).outputTarget ? 'renderTarget' : 'screen'\n\n      if ((object as RenderedMesh).renderBundle) {\n        return this.renderPassEntries[entryType].find((entry) => {\n          return [\n            ...entry.stack.unProjected.opaque,\n            ...entry.stack.unProjected.transparent,\n            ...entry.stack.projected.opaque,\n            ...entry.stack.projected.transparent,\n          ]\n            .filter((object) => object.type === 'RenderBundle')\n            .some((bundle: RenderBundle) => {\n              return bundle.meshes.get(object.uuid)\n            })\n        })\n      } else {\n        return this.renderPassEntries[entryType].find((entry) => {\n          return [\n            ...entry.stack.unProjected.opaque,\n            ...entry.stack.unProjected.transparent,\n            ...entry.stack.projected.opaque,\n            ...entry.stack.projected.transparent,\n          ].some((mesh) => mesh.uuid === object.uuid)\n        })\n      }\n    }\n  }\n\n  /**\n   * Sort transparent projected meshes by their render order or distance to the camera (farther meshes should be drawn first).\n   * @param meshes - transparent projected meshes array to sort\n   */\n  sortTransparentMeshes(meshes: Array<ProjectedMesh | RenderBundle>) {\n    meshes.sort((meshA, meshB) => {\n      if (meshA.renderOrder !== meshB.renderOrder) {\n        return meshA.renderOrder - meshB.renderOrder\n      }\n\n      if (this.isStackObjectRenderBundle(meshA) || this.isStackObjectRenderBundle(meshB)) {\n        return meshA.renderOrder - meshB.renderOrder\n      }\n\n      // apply world matrices to objects\n      meshA.geometry\n        ? posA.copy(meshA.geometry.boundingBox.center).applyMat4(meshA.worldMatrix)\n        : meshA.worldMatrix.getTranslation(posA)\n\n      meshB.geometry\n        ? posB.copy(meshB.geometry.boundingBox.center).applyMat4(meshB.worldMatrix)\n        : meshB.worldMatrix.getTranslation(posB)\n\n      // apply scale to bounding sphere radius\n      const radiusA = meshA.geometry ? meshA.geometry.boundingBox.radius * meshA.worldMatrix.getMaxScaleOnAxis() : 0\n      const radiusB = meshB.geometry ? meshB.geometry.boundingBox.radius * meshB.worldMatrix.getMaxScaleOnAxis() : 0\n\n      return (\n        meshB.camera.worldMatrix.getTranslation(camPosB).distance(posB) -\n        radiusB -\n        (meshA.camera.worldMatrix.getTranslation(camPosA).distance(posA) - radiusA)\n      )\n    })\n  }\n\n  /**\n   * Here we render a {@link RenderPassEntry}:\n   * - Set its {@link RenderPass#descriptor | renderPass descriptor} view or resolveTarget and get it at as swap chain texture\n   * - Execute {@link RenderPassEntry#onBeforeRenderPass | onBeforeRenderPass} callback if specified\n   * - Begin the {@link GPURenderPassEncoder | GPU render pass encoder} using our {@link RenderPass#descriptor | renderPass descriptor}\n   * - Render the single element if specified or the render pass entry {@link Stack}: draw unprojected opaque / transparent meshes first, then set the {@link core/renderers/GPUCameraRenderer.GPUCameraRenderer#cameraLightsBindGroup | camera and lights bind group} and draw projected opaque / transparent meshes\n   * - End the {@link GPURenderPassEncoder | GPU render pass encoder}\n   * - Execute {@link RenderPassEntry#onAfterRenderPass | onAfterRenderPass} callback if specified\n   * - Reset {@link core/pipelines/PipelineManager.PipelineManager#currentPipelineIndex | pipeline manager current pipeline}\n   * @param commandEncoder - current {@link GPUCommandEncoder}\n   * @param renderPassEntry - {@link RenderPassEntry} to render\n   */\n  renderSinglePassEntry(commandEncoder: GPUCommandEncoder, renderPassEntry: RenderPassEntry) {\n    // set the pass texture to render to\n    const swapChainTexture = renderPassEntry.renderPass.updateView(renderPassEntry.renderTexture?.texture)\n\n    renderPassEntry.onBeforeRenderPass && renderPassEntry.onBeforeRenderPass(commandEncoder, swapChainTexture)\n\n    // now begin our actual render pass\n    const pass = commandEncoder.beginRenderPass(renderPassEntry.renderPass.descriptor)\n\n    if (!this.renderer.production) {\n      pass.pushDebugGroup(\n        renderPassEntry.element\n          ? `${renderPassEntry.element.options.label} render pass using ${renderPassEntry.renderPass.options.label} descriptor`\n          : `Render stack pass using ${renderPassEntry.renderPass.options.label}${\n              renderPassEntry.renderTexture ? ' onto ' + renderPassEntry.renderTexture.options.label : ''\n            }`\n      )\n    }\n\n    // pass entries can have a single element or a stack\n    if (renderPassEntry.element) {\n      if (renderPassEntry.element.renderBundle) {\n        renderPassEntry.element.renderBundle.render(pass)\n      } else {\n        renderPassEntry.element.render(pass)\n      }\n    } else if (renderPassEntry.stack) {\n      // draw unProjected regular meshes\n      for (const mesh of renderPassEntry.stack.unProjected.opaque) {\n        mesh.render(pass)\n      }\n      for (const mesh of renderPassEntry.stack.unProjected.transparent) {\n        mesh.render(pass)\n      }\n\n      // then draw projected meshes\n      if (renderPassEntry.stack.projected.opaque.length || renderPassEntry.stack.projected.transparent.length) {\n        // opaque\n        for (const mesh of renderPassEntry.stack.projected.opaque) {\n          mesh.render(pass)\n        }\n\n        // transparent\n        this.sortTransparentMeshes(renderPassEntry.stack.projected.transparent as Array<ProjectedMesh | RenderBundle>)\n\n        for (const mesh of renderPassEntry.stack.projected.transparent) {\n          mesh.render(pass)\n        }\n      }\n    }\n\n    if (!this.renderer.production) pass.popDebugGroup()\n\n    pass.end()\n\n    renderPassEntry.onAfterRenderPass && renderPassEntry.onAfterRenderPass(commandEncoder, swapChainTexture)\n\n    this.renderer.pipelineManager.resetCurrentPipeline()\n  }\n\n  /**\n   * Before actually rendering the scene, update matrix stack and frustum culling checks. Batching these calls greatly improve performance. Called by the {@link renderer} before rendering.\n   */\n  onBeforeRender() {\n    // execute meshes onBeforeRender callback if needed\n    for (let i = 0, l = this.renderer.meshes.length; i < l; i++) {\n      this.renderer.meshes[i].onBeforeRenderScene()\n    }\n\n    // update matrices\n    this.updateMatrixStack()\n\n    // TODO store projected meshes only?\n    // frustum culling check if needed\n    for (const mesh of this.renderer.meshes) {\n      if ('checkFrustumCulling' in mesh && mesh.visible) {\n        mesh.checkFrustumCulling()\n      }\n    }\n  }\n\n  /**\n   * Render our {@link Scene}\n   * - Execute {@link onBeforeRender} first\n   * - Then render {@link computePassEntries}\n   * - And finally render our {@link renderPassEntries}\n   * @param commandEncoder - current {@link GPUCommandEncoder}\n   */\n  render(commandEncoder: GPUCommandEncoder) {\n    for (const computePass of this.computePassEntries) {\n      const pass = commandEncoder.beginComputePass()\n\n      if (!this.renderer.production) pass.pushDebugGroup(`${computePass.options.label}: begin compute pass`)\n\n      computePass.render(pass)\n\n      if (!this.renderer.production) pass.popDebugGroup()\n\n      pass.end()\n\n      computePass.copyBufferToResult(commandEncoder)\n\n      this.renderer.pipelineManager.resetCurrentPipeline()\n    }\n\n    for (const renderPassEntryType in this.renderPassEntries) {\n      let passDrawnCount = 0\n\n      this.renderPassEntries[renderPassEntryType].forEach((renderPassEntry) => {\n        // early bail if there's nothing to draw\n        if (!this.getRenderPassEntryLength(renderPassEntry)) return\n\n        // if we're drawing to screen and it's not our first pass, load result from previous passes\n        // post processing scene pass will clear content inside onBeforeRenderPass anyway\n        renderPassEntry.renderPass.setLoadOp(\n          renderPassEntryType === 'screen' && passDrawnCount !== 0 ? 'load' : 'clear'\n        )\n\n        passDrawnCount++\n\n        this.renderSinglePassEntry(commandEncoder, renderPassEntry)\n      })\n    }\n  }\n}\n","/** Defines a task queue item */\r\nexport interface TaskQueueItem {\r\n  /** Unique id of the task queue item */\r\n  id: number\r\n  /** Priority order in the {@link TasksQueueManager#queue | tasks queue array} */\r\n  order: number\r\n  /** Callback to execute */\r\n  callback: (args?: any) => void\r\n  /** Whether to execute the task only once and them automatically remove it from the {@link TasksQueueManager#queue | tasks queue array} */\r\n  once: boolean\r\n}\r\n\r\n/** Parameters used to add a task to the {@link TasksQueueManager#queue | tasks queue array} */\r\nexport type TaskQueueItemParams = Partial<Omit<TaskQueueItem, 'id' | 'callback'>>\r\n\r\n/**\r\n * Used to keep track of a bunch of callbacks and execute them in the right order when needed\r\n */\r\nexport class TasksQueueManager {\r\n  /** Array of {@link TaskQueueItem | task queue item} to execute */\r\n  queue: TaskQueueItem[]\r\n  /** Private number to assign a unique id to each {@link TaskQueueItem | task queue item} */\r\n  #taskCount = 0\r\n\r\n  /**\r\n   * TaskQueueManager constructor\r\n   */\r\n  constructor() {\r\n    this.queue = []\r\n  }\r\n\r\n  /**\r\n   * Add a {@link TaskQueueItem | task queue item} to the queue\r\n   * @param callback - callback to add to the {@link TaskQueueItem | task queue item}\r\n   * @param parameters - {@link TaskQueueItemParams | parameters} of the {@link TaskQueueItem | task queue item} to add\r\n   * @returns - {@link TaskQueueItem#id | id} of the new {@link TaskQueueItem | task queue item}, useful to later remove the task if needed\r\n   */\r\n  add(\r\n    callback: TaskQueueItem['callback'] = (args?: any) => {\r\n      /* allow empty callbacks */\r\n    },\r\n    { order = this.queue.length, once = false } = {} as TaskQueueItemParams\r\n  ): TaskQueueItem['id'] {\r\n    const task = {\r\n      callback,\r\n      order,\r\n      once,\r\n      id: this.#taskCount,\r\n    }\r\n\r\n    // increment id\r\n    this.#taskCount++\r\n\r\n    this.queue.push(task)\r\n    this.queue.sort((a, b) => {\r\n      return a.order - b.order\r\n    })\r\n\r\n    return task.id\r\n  }\r\n\r\n  /**\r\n   * Remove a {@link TaskQueueItem | task queue item} from the queue\r\n   * @param taskId - {@link TaskQueueItem#id | id} of the new {@link TaskQueueItem | task queue item} to remove\r\n   */\r\n  remove(taskId = 0) {\r\n    this.queue = this.queue.filter((task) => task.id !== taskId)\r\n  }\r\n\r\n  /**\r\n   * Execute the {@link TasksQueueManager#queue | tasks queue array}\r\n   */\r\n  execute(args?: any) {\r\n    this.queue.forEach((task) => {\r\n      task.callback(args)\r\n\r\n      // if it was a one time callback, remove it\r\n      if (task.once) {\r\n        this.remove(task.id)\r\n      }\r\n    })\r\n  }\r\n}\r\n","import { PipelineManager } from '../pipelines/PipelineManager'\nimport { DOMElement, DOMElementBoundingRect, RectBBox, RectSize } from '../DOM/DOMElement'\nimport { Scene } from '../scenes/Scene'\nimport { RenderPass, RenderPassParams } from '../renderPasses/RenderPass'\nimport { generateUUID, throwError, throwWarning } from '../../utils/utils'\n\nimport { ComputePass } from '../computePasses/ComputePass'\nimport { PingPongPlane } from '../../extras/meshes/PingPongPlane'\nimport { ShaderPass } from '../renderPasses/ShaderPass'\nimport { RenderTarget } from '../renderPasses/RenderTarget'\nimport { DOMTexture } from '../textures/DOMTexture'\nimport { Sampler } from '../samplers/Sampler'\n\nimport { DOMMesh } from '../../curtains/meshes/DOMMesh'\nimport { Plane } from '../../curtains/meshes/Plane'\nimport { Mesh } from '../meshes/Mesh'\nimport { TasksQueueManager } from '../../utils/TasksQueueManager'\nimport { AllowedBindGroups } from '../../types/BindGroups'\nimport { Texture } from '../textures/Texture'\nimport { GPUDeviceManager } from './GPUDeviceManager'\nimport { FullscreenPlane } from '../meshes/FullscreenPlane'\nimport { Buffer } from '../buffers/Buffer'\nimport { RenderBundle } from '../renderPasses/RenderBundle'\n\n/**\n * Parameters used to create a {@link GPURenderer}\n */\nexport interface GPURendererParams {\n  /** The {@link GPUDeviceManager} used to create this {@link GPURenderer} */\n  deviceManager: GPUDeviceManager\n\n  /** Optional label of this {@link GPURenderer} */\n  label?: string\n  /** {@link HTMLElement} or selector used as a container for our {@link GPURenderer#canvas | canvas}. Could also be directly a {@link HTMLCanvasElement | canvas element}. */\n  container: string | HTMLElement\n  /** Pixel ratio to use for rendering */\n  pixelRatio?: number\n\n  /** Whether to auto resize the renderer each time its {@link GPURenderer#domElement} size changes or not. It is advised to set this parameter to `false` if the provided {@link container} is a {@link HTMLCanvasElement | canvas element}, and handle {@link GPURenderer#resize | resizing} by yourself. */\n  autoResize?: boolean\n  /** Texture rendering {@link GPUTextureFormat | preferred format} */\n  preferredFormat?: GPUTextureFormat\n  /** Set the {@link GPUCanvasContext | context} alpha mode */\n  alphaMode?: GPUCanvasAlphaMode\n\n  /** The {@link GPURenderer#renderPass | renderer RenderPass} parameters */\n  renderPass?: {\n    /** Whether the {@link GPURenderer#renderPass | renderer RenderPass} should handle depth. Default to `true` */\n    useDepth: RenderPassParams['useDepth']\n    /** The {@link GPURenderer#renderPass | renderer RenderPass} sample count (i.e. whether it should use multisampled antialiasing). Default to `4` */\n    sampleCount: RenderPassParams['sampleCount']\n    /** The {@link GPUColor | color values} to clear to before drawing the {@link GPURenderer#renderPass | renderer RenderPass}. Default to `[0, 0, 0, 0]` */\n    clearValue: GPUColor\n  }\n}\n\n/** Any Mesh that is bound to a DOM Element */\nexport type DOMProjectedMesh = DOMMesh | Plane\n/** Any Mesh that is projected (i.e use a {@link core/camera/Camera.Camera | Camera} to compute a model view projection matrix) */\nexport type ProjectedMesh = Mesh | DOMProjectedMesh\n/** Any Mesh that can be drawn (including fullscreen quad meshes) and that will be put in the {@link Scene} meshes stacks */\nexport type SceneStackedMesh = ProjectedMesh | FullscreenPlane\n/** Anything that can be added to a {@link Scene} meshes stacks, including {@link RenderBundle} */\nexport type SceneStackedObject = SceneStackedMesh | RenderBundle\n/** Any Mesh that is drawn fullscren, i.e. fullscreen quad meshes used for post processing and {@link PingPongPlane} */\nexport type FullscreenPass = PingPongPlane | ShaderPass\n/** Any Mesh that can be drawn, including fullscreen quad meshes used for post processing and {@link PingPongPlane} */\nexport type RenderedMesh = SceneStackedMesh | FullscreenPass\n/** Any Mesh or Compute pass */\nexport type SceneObject = RenderedMesh | ComputePass\n\n/**\n * Base renderer class, that could technically be used to render compute passes and draw fullscreen quads, even tho it is strongly advised to use at least the {@link core/renderers/GPUCameraRenderer.GPUCameraRenderer | GPUCameraRenderer} class instead.\n * A renderer is responsible for:\n * - Setting a {@link GPUCanvasContext | context}\n * - Handling the {@link HTMLCanvasElement | canvas} onto everything is drawn\n * - Creating a {@link RenderPass} that will handle our render and depth textures and the render pass descriptor\n * - Keeping track of every specific class objects created relative to computing and rendering\n * - Creating a {@link Scene} class that will take care of the rendering process of all previously mentioned objects\n */\nexport class GPURenderer {\n  /** The type of the {@link GPURenderer} */\n  type: string\n  /** The universal unique id of this {@link GPURenderer} */\n  readonly uuid: string\n\n  /** The {@link GPUDeviceManager} used to create this {@link GPURenderer} */\n  deviceManager: GPUDeviceManager\n\n  /** {@link HTMLCanvasElement} onto everything is drawn */\n  canvas: HTMLCanvasElement\n  /** The WebGPU {@link GPUCanvasContext | context} used */\n  context: null | GPUCanvasContext\n  /** Set the {@link GPUCanvasContext | context} alpha mode */\n  alphaMode?: GPUCanvasAlphaMode\n\n  /** Options used to create this {@link GPURenderer} */\n  options: GPURendererParams\n\n  /** The {@link RenderPass | render pass} used to render our result to screen */\n  renderPass: RenderPass\n  /** Additional {@link RenderPass | render pass} used by {@link ShaderPass} for compositing / post processing. Does not handle depth */\n  postProcessingPass: RenderPass\n\n  /** The {@link Scene} used */\n  scene: Scene\n\n  /** Whether we should render our {@link GPURenderer} or not. If set to `false`, the render hooks {@link onBeforeCommandEncoderCreation}, {@link onBeforeRenderScene}, {@link onAfterRenderScene} and {@link onAfterCommandEncoderSubmission} won't be called, the scene graph will not be updated and the scene will not be rendered, completely pausing the renderer. Default to `true`. */\n  shouldRender: boolean\n\n  /** Whether we should explicitly update our {@link Scene} or not. If set to `false`, the scene graph will not be updated and the scene will not be rendered. Default to `true`. */\n  shouldRenderScene: boolean\n\n  /** An array containing all our created {@link ComputePass} */\n  computePasses: ComputePass[]\n  /** An array containing all our created {@link PingPongPlane} */\n  pingPongPlanes: PingPongPlane[]\n  /** An array containing all our created {@link ShaderPass} */\n  shaderPasses: ShaderPass[]\n  /** An array containing all our created {@link RenderTarget} */\n  renderTargets: RenderTarget[]\n  /** An array containing all our created {@link SceneStackedMesh | meshes} */\n  meshes: SceneStackedMesh[]\n  /** An array containing all our created {@link Texture} */\n  textures: Texture[]\n  /** An array containing all our created {@link RenderBundle} */\n  renderBundles: RenderBundle[]\n\n  /** Pixel ratio to use for rendering */\n  pixelRatio: number\n  /** An object defining the width, height, top and left position of the canvas. Mainly used internally. If you need to get the renderer dimensions, use {@link boundingRect} instead. */\n  rectBBox: RectBBox\n\n  /** {@link DOMElement} that will track our canvas container size */\n  domElement: DOMElement | undefined\n\n  /** Allow to add callbacks to be executed at each render before the {@link GPUCommandEncoder} is created */\n  onBeforeCommandEncoderCreation: TasksQueueManager\n  /** Allow to add callbacks to be executed at each render after the {@link GPUCommandEncoder} has been created but before the {@link Scene} is rendered */\n  onBeforeRenderScene: TasksQueueManager\n  /** Allow to add callbacks to be executed at each render after the {@link GPUCommandEncoder} has been created and after the {@link Scene} has been rendered */\n  onAfterRenderScene: TasksQueueManager\n  /** Allow to add callbacks to be executed at each render after the {@link Scene} has been rendered and the {@link GPUCommandEncoder} has been submitted */\n  onAfterCommandEncoderSubmission: TasksQueueManager\n\n  // callbacks / events\n  /** function assigned to the {@link onBeforeRender} callback */\n  _onBeforeRenderCallback = (commandEncoder: GPUCommandEncoder) => {\n    /* allow empty callback */\n  }\n  /** function assigned to the {@link onAfterRender} callback */\n  _onAfterRenderCallback = (commandEncoder: GPUCommandEncoder) => {\n    /* allow empty callback */\n  }\n  /** function assigned to the {@link resizeObjects} callback */\n  _onResizeCallback: () => void = () => {\n    /* allow empty callback */\n  }\n  /** function assigned to the {@link onAfterResize} callback */\n  _onAfterResizeCallback: () => void = () => {\n    /* allow empty callback */\n  }\n\n  /**\n   * GPURenderer constructor\n   * @param parameters - {@link GPURendererParams | parameters} used to create this {@link GPURenderer}\n   */\n  constructor({\n    deviceManager,\n    label,\n    container,\n    pixelRatio = 1,\n    autoResize = true,\n    preferredFormat,\n    alphaMode = 'premultiplied',\n    renderPass,\n  }: GPURendererParams) {\n    this.type = 'GPURenderer'\n    this.uuid = generateUUID()\n\n    if (!deviceManager || deviceManager.constructor.name !== 'GPUDeviceManager') {\n      throwError(\n        label\n          ? `${label} (${this.type}): no device manager or wrong device manager provided: ${deviceManager}`\n          : `${this.type}: no device manager or wrong device manager provided: ${deviceManager}`\n      )\n    }\n\n    if (!label) {\n      label = `${this.constructor.name}${deviceManager.renderers.length}`\n    }\n\n    this.deviceManager = deviceManager\n    this.deviceManager.addRenderer(this)\n\n    this.shouldRender = true\n    this.shouldRenderScene = true\n\n    // render pass default values\n    renderPass = { ...{ useDepth: true, sampleCount: 4, clearValue: [0, 0, 0, 0] }, ...renderPass }\n    preferredFormat = preferredFormat ?? this.deviceManager.gpu?.getPreferredCanvasFormat()\n\n    this.options = {\n      deviceManager,\n      label,\n      container,\n      pixelRatio,\n      autoResize,\n      preferredFormat,\n      alphaMode,\n      renderPass,\n    }\n\n    this.pixelRatio = pixelRatio ?? window.devicePixelRatio ?? 1\n    this.alphaMode = alphaMode\n\n    // create the canvas\n    const isOffscreenCanvas = container instanceof OffscreenCanvas\n    const isContainerCanvas = isOffscreenCanvas || container instanceof HTMLCanvasElement\n    this.canvas = isContainerCanvas ? (container as HTMLCanvasElement) : document.createElement('canvas')\n\n    // set default size\n    const { width, height } = this.canvas\n    this.rectBBox = {\n      width,\n      height,\n      top: 0,\n      left: 0,\n    }\n\n    this.setScene()\n    this.setTasksQueues()\n    this.setRendererObjects()\n\n    if (!isOffscreenCanvas) {\n      // needed to get container bounding box\n      this.domElement = new DOMElement({\n        element: container,\n        priority: 5, // renderer callback need to be called first\n        onSizeChanged: () => {\n          if (this.options.autoResize) this.resize()\n        },\n      })\n\n      // now that we have a domElement, resize right away\n      this.resize()\n\n      if (!isContainerCanvas) {\n        // append the canvas\n        this.domElement.element.appendChild(this.canvas)\n      }\n    }\n\n    // device is already available? create the context!\n    if (this.deviceManager.device) {\n      this.setContext()\n    }\n  }\n\n  /**\n   * Set the renderer {@link RectBBox} and canvas sizes\n   * @param rectBBox - the optional new {@link canvas} {@link RectBBox} to set\n   */\n  setSize(rectBBox: Partial<RectBBox> | null = null) {\n    // patch rect bbox with missing values from bounding rect if needed\n    rectBBox = {\n      ...{\n        width: Math.max(1, this.boundingRect.width),\n        height: Math.max(1, this.boundingRect.height),\n        top: this.boundingRect.top,\n        left: this.boundingRect.left,\n      },\n      ...rectBBox,\n    }\n\n    this.rectBBox = rectBBox as RectBBox\n\n    const renderingSize = {\n      width: this.rectBBox.width,\n      height: this.rectBBox.height,\n    }\n\n    renderingSize.width *= this.pixelRatio\n    renderingSize.height *= this.pixelRatio\n\n    this.clampToMaxDimension(renderingSize)\n\n    // canvas rendering size\n    this.canvas.width = Math.floor(renderingSize.width)\n    this.canvas.height = Math.floor(renderingSize.height)\n\n    // canvas display size\n    if (this.canvas.style) {\n      this.canvas.style.width = this.rectBBox.width + 'px'\n      this.canvas.style.height = this.rectBBox.height + 'px'\n    }\n  }\n\n  /**\n   * Set the renderer {@link pixelRatio | pixel ratio} and {@link resize} it\n   * @param pixelRatio - new pixel ratio to use\n   */\n  setPixelRatio(pixelRatio: number = 1) {\n    this.pixelRatio = pixelRatio\n    this.resize(this.rectBBox)\n  }\n\n  /**\n   * Resize our {@link GPURenderer}\n   * @param rectBBox - the optional new {@link canvas} {@link RectBBox} to set\n   */\n  resize(rectBBox: RectBBox | null = null) {\n    this.setSize(rectBBox)\n\n    this._onResizeCallback && this._onResizeCallback()\n\n    this.resizeObjects()\n\n    this._onAfterResizeCallback && this._onAfterResizeCallback()\n  }\n\n  /**\n   * Resize all tracked objects ({@link Texture | textures}, {@link RenderPass | render passes}, {@link RenderTarget | render targets}, {@link ComputePass | compute passes} and meshes).\n   */\n  resizeObjects() {\n    // resize textures first\n    this.textures.forEach((texture) => {\n      texture.resize()\n    })\n\n    // resize render & shader passes\n    this.renderPass?.resize()\n    this.postProcessingPass?.resize()\n\n    this.renderTargets.forEach((renderTarget) => renderTarget.resize())\n\n    // force compute passes onAfterResize callback\n    this.computePasses.forEach((computePass) => computePass.resize())\n\n    // now resize meshes that are bound to the renderer size\n    // especially useful to resize textures\n    this.pingPongPlanes.forEach((pingPongPlane) => pingPongPlane.resize(this.boundingRect))\n    this.shaderPasses.forEach((shaderPass) => shaderPass.resize(this.boundingRect))\n    this.resizeMeshes()\n  }\n\n  /**\n   * Resize the {@link meshes}.\n   */\n  resizeMeshes() {\n    this.meshes.forEach((mesh) => {\n      mesh.resize(this.boundingRect)\n    })\n  }\n\n  /**\n   * Get our {@link domElement | DOM Element} {@link DOMElement#boundingRect | bounding rectangle}. If there's no {@link domElement | DOM Element} (like when using an offscreen canvas for example), the {@link rectBBox} values are used.\n   */\n  get boundingRect(): DOMElementBoundingRect {\n    if (!!this.domElement && !!this.domElement.boundingRect) {\n      return this.domElement.boundingRect\n    } else if (!!this.domElement) {\n      const boundingRect = this.domElement.element?.getBoundingClientRect()\n      return {\n        top: boundingRect.top,\n        right: boundingRect.right,\n        bottom: boundingRect.bottom,\n        left: boundingRect.left,\n        width: boundingRect.width,\n        height: boundingRect.height,\n        x: boundingRect.x,\n        y: boundingRect.y,\n      }\n    } else {\n      return {\n        top: this.rectBBox.top,\n        right: this.rectBBox.left + this.rectBBox.width,\n        bottom: this.rectBBox.top + this.rectBBox.height,\n        left: this.rectBBox.left,\n        width: this.rectBBox.width,\n        height: this.rectBBox.height,\n        x: this.rectBBox.left,\n        y: this.rectBBox.top,\n      }\n    }\n  }\n\n  /**\n   * Clamp to max WebGPU texture dimensions\n   * @param dimension - width and height dimensions to clamp\n   */\n  clampToMaxDimension(dimension: RectSize | DOMElementBoundingRect) {\n    if (this.device) {\n      dimension.width = Math.min(this.device.limits.maxTextureDimension2D, dimension.width)\n      dimension.height = Math.min(this.device.limits.maxTextureDimension2D, dimension.height)\n    }\n  }\n\n  /* USEFUL DEVICE MANAGER OBJECTS */\n\n  /**\n   * Get our {@link GPUDeviceManager#device | device}\n   * @readonly\n   */\n  get device(): GPUDevice | undefined {\n    return this.deviceManager.device\n  }\n\n  /**\n   * Get whether our {@link GPUDeviceManager} is ready (i.e. its {@link GPUDeviceManager#adapter | adapter} and {@link GPUDeviceManager#device | device} are set) its {@link context} is set and its size is set\n   * @readonly\n   */\n  get ready(): boolean {\n    return this.deviceManager.ready && !!this.context && !!this.canvas.width && !!this.canvas.height\n  }\n\n  /**\n   * Get our {@link GPUDeviceManager#production | GPUDeviceManager production flag}\n   * @readonly\n   */\n  get production(): boolean {\n    return this.deviceManager.production\n  }\n\n  /**\n   * Get all the created {@link GPUDeviceManager#samplers | samplers}\n   * @readonly\n   */\n  get samplers(): Sampler[] {\n    return this.deviceManager.samplers\n  }\n\n  /**\n   * Get all the created {@link GPUDeviceManager#buffers | GPU buffers}\n   * @readonly\n   */\n  get buffers(): Map<string, Buffer> {\n    return this.deviceManager.buffers\n  }\n\n  /**\n   * Get the {@link GPUDeviceManager#pipelineManager | pipeline manager}\n   * @readonly\n   */\n  get pipelineManager(): PipelineManager {\n    return this.deviceManager.pipelineManager\n  }\n\n  /**\n   * Get all the rendered objects (i.e. compute passes, meshes, ping pong planes and shader passes) created by the {@link GPUDeviceManager}\n   * @readonly\n   */\n  get deviceRenderedObjects(): SceneObject[] {\n    return this.deviceManager.deviceRenderedObjects\n  }\n\n  /**\n   * Configure our {@link context} with the given options\n   */\n  configureContext() {\n    this.context.configure({\n      device: this.device,\n      format: this.options.preferredFormat,\n      alphaMode: this.alphaMode,\n      // needed so we can copy textures for post processing usage\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n      //viewFormats: []\n    })\n  }\n\n  /**\n   * Set our {@link context} if possible and set {@link renderPass | main render pass} and {@link scene}\n   */\n  setContext() {\n    this.context = this.canvas.getContext('webgpu')\n\n    if (this.device) {\n      this.configureContext()\n\n      this.setMainRenderPasses()\n    }\n  }\n\n  /**\n   * Called when the {@link GPUDeviceManager#device | device} is lost.\n   * Force all our scene objects to lose context.\n   */\n  loseContext() {\n    // force all our scene objects to lose context\n    this.renderBundles.forEach((bundle) => bundle.loseContext())\n    this.renderedObjects.forEach((sceneObject) => sceneObject.loseContext())\n  }\n\n  /**\n   * Called when the {@link GPUDeviceManager#device | device} should be restored.\n   * Configure the context again, resize the {@link RenderTarget | render targets} and {@link Texture | textures}, restore our {@link renderedObjects | rendered objects} context.\n   * @async\n   */\n  restoreContext() {\n    this.configureContext()\n\n    // recreate all textures first\n    this.textures.forEach((texture) => {\n      texture.createTexture()\n    })\n\n    // resize render passes/recreate their textures\n    this.renderPass?.resize()\n    this.postProcessingPass?.resize()\n\n    this.renderTargets.forEach((renderTarget) => renderTarget.resize())\n\n    // restore context of all our scene objects\n    this.renderedObjects.forEach((sceneObject) => sceneObject.restoreContext())\n  }\n\n  /* PIPELINES, SCENE & MAIN RENDER PASS */\n\n  /**\n   * Set our {@link renderPass | main render pass} that will be used to render the result of our draw commands back to the screen and our {@link postProcessingPass | postprocessing pass} that will be used for any additional postprocessing render passes.\n   */\n  setMainRenderPasses() {\n    this.renderPass = new RenderPass(this, {\n      label: this.options.label + ' render pass',\n      ...this.options.renderPass,\n    } as RenderPassParams)\n\n    // add to the scene stack\n    this.scene.setMainRenderPassEntry()\n\n    this.postProcessingPass = new RenderPass(this, {\n      label: this.options.label + ' post processing render pass',\n      // no need to handle depth or perform MSAA on a fullscreen quad\n      useDepth: false,\n      sampleCount: 1,\n    })\n  }\n\n  /**\n   * Set our {@link scene}\n   */\n  setScene() {\n    this.scene = new Scene({ renderer: this })\n  }\n\n  /* BUFFERS & BINDINGS */\n\n  /**\n   * Create a {@link GPUBuffer}\n   * @param buffer - {@link Buffer} to use for buffer creation\n   * @returns - newly created {@link GPUBuffer}\n   */\n  createBuffer(buffer: Buffer): GPUBuffer {\n    const GPUBuffer = this.deviceManager.device?.createBuffer(buffer.options)\n    this.deviceManager.addBuffer(buffer)\n    return GPUBuffer\n  }\n\n  /**\n   * Remove a {@link Buffer} from our {@link GPUDeviceManager#buffers | buffers Map}\n   * @param buffer - {@link Buffer} to remove\n   */\n  removeBuffer(buffer: Buffer) {\n    this.deviceManager.removeBuffer(buffer)\n  }\n\n  /**\n   * Write to a {@link GPUBuffer}\n   * @param buffer - {@link GPUBuffer} to write to\n   * @param bufferOffset - {@link GPUSize64 | buffer offset}\n   * @param data - {@link BufferSource | data} to write\n   */\n  queueWriteBuffer(buffer: GPUBuffer, bufferOffset: GPUSize64, data: BufferSource) {\n    this.deviceManager.device?.queue.writeBuffer(buffer, bufferOffset, data)\n  }\n\n  /**\n   * Copy a source {@link Buffer#GPUBuffer | Buffer GPUBuffer} into a destination {@link Buffer#GPUBuffer | Buffer GPUBuffer}\n   * @param parameters - parameters used to realize the copy\n   * @param parameters.srcBuffer - source {@link Buffer}\n   * @param [parameters.dstBuffer] - destination {@link Buffer}. Will create a new one if none provided.\n   * @param [parameters.commandEncoder] - {@link GPUCommandEncoder} to use for the copy. Will create a new one and submit the command buffer if none provided.\n   * @returns - destination {@link Buffer} after copy\n   */\n  copyBufferToBuffer({\n    srcBuffer,\n    dstBuffer,\n    commandEncoder,\n  }: {\n    srcBuffer: Buffer\n    dstBuffer?: Buffer\n    commandEncoder?: GPUCommandEncoder\n  }): Buffer | null {\n    if (!srcBuffer || !srcBuffer.GPUBuffer) {\n      throwWarning(\n        `${this.options.label} (${this.type}): cannot copy to buffer because the source buffer has not been provided`\n      )\n      return null\n    }\n\n    if (!dstBuffer) {\n      dstBuffer = new Buffer()\n    }\n\n    if (!dstBuffer.GPUBuffer) {\n      dstBuffer.createBuffer(this, {\n        label: `GPURenderer (${this.options.label}): destination copy buffer from: ${srcBuffer.options.label}`,\n        size: srcBuffer.GPUBuffer.size,\n        //usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n        usage: ['copyDst', 'mapRead'],\n      })\n    }\n\n    if (srcBuffer.GPUBuffer.mapState !== 'unmapped') {\n      throwWarning(\n        `${this.options.label} (${this.type}): Cannot copy from ${srcBuffer.GPUBuffer} because it is currently mapped`\n      )\n      return\n    }\n    if (dstBuffer.GPUBuffer.mapState !== 'unmapped') {\n      throwWarning(\n        `${this.options.label} (${this.type}): Cannot copy from ${dstBuffer.GPUBuffer} because it is currently mapped`\n      )\n      return\n    }\n\n    // if there's no command encoder provided, we'll have to create one and submit it after the copy process\n    const hasCommandEncoder = !!commandEncoder\n\n    if (!hasCommandEncoder) {\n      commandEncoder = this.deviceManager.device?.createCommandEncoder({\n        label: `${this.type} (${this.options.label}): Copy buffer command encoder`,\n      })\n      !this.production &&\n        commandEncoder.pushDebugGroup(`${this.type} (${this.options.label}): Copy buffer command encoder`)\n    }\n\n    commandEncoder.copyBufferToBuffer(srcBuffer.GPUBuffer, 0, dstBuffer.GPUBuffer, 0, dstBuffer.GPUBuffer.size)\n\n    if (!hasCommandEncoder) {\n      !this.production && commandEncoder.popDebugGroup()\n      const commandBuffer = commandEncoder.finish()\n      this.deviceManager.device?.queue.submit([commandBuffer])\n    }\n\n    return dstBuffer\n  }\n\n  /* BIND GROUPS & LAYOUTS */\n\n  /**\n   * Get all created {@link AllowedBindGroups | bind group} tracked by our {@link GPUDeviceManager}\n   * @readonly\n   */\n  get bindGroups(): Map<string, AllowedBindGroups> {\n    return this.deviceManager.bindGroups\n  }\n\n  /**\n   * Add a {@link AllowedBindGroups | bind group} to our {@link GPUDeviceManager#bindGroups | bind groups array}\n   * @param bindGroup - {@link AllowedBindGroups | bind group} to add\n   */\n  addBindGroup(bindGroup: AllowedBindGroups) {\n    this.deviceManager.addBindGroup(bindGroup)\n  }\n\n  /**\n   * Remove a {@link AllowedBindGroups | bind group} from our {@link GPUDeviceManager#bindGroups | bind groups array}\n   * @param bindGroup - {@link AllowedBindGroups | bind group} to remove\n   */\n  removeBindGroup(bindGroup: AllowedBindGroups) {\n    this.deviceManager.removeBindGroup(bindGroup)\n  }\n\n  /**\n   * Create a {@link GPUBindGroupLayout}\n   * @param bindGroupLayoutDescriptor - {@link GPUBindGroupLayoutDescriptor | GPU bind group layout descriptor}\n   * @returns - newly created {@link GPUBindGroupLayout}\n   */\n  createBindGroupLayout(bindGroupLayoutDescriptor: GPUBindGroupLayoutDescriptor): GPUBindGroupLayout {\n    return this.deviceManager.device?.createBindGroupLayout(bindGroupLayoutDescriptor)\n  }\n\n  /**\n   * Create a {@link GPUBindGroup}\n   * @param bindGroupDescriptor - {@link GPUBindGroupDescriptor | GPU bind group descriptor}\n   * @returns - newly created {@link GPUBindGroup}\n   */\n  createBindGroup(bindGroupDescriptor: GPUBindGroupDescriptor): GPUBindGroup {\n    return this.deviceManager.device?.createBindGroup(bindGroupDescriptor)\n  }\n\n  /* SHADERS & PIPELINES */\n\n  /**\n   * Create a {@link GPUShaderModule}\n   * @param shaderModuleDescriptor - {@link shaderModuleDescriptor | shader module descriptor}\n   * @returns - newly created {@link GPUShaderModule}\n   */\n  createShaderModule(shaderModuleDescriptor: GPUShaderModuleDescriptor): GPUShaderModule {\n    return this.device?.createShaderModule(shaderModuleDescriptor)\n  }\n\n  /**\n   * Create a {@link GPUPipelineLayout}\n   * @param pipelineLayoutDescriptor - {@link GPUPipelineLayoutDescriptor | GPU pipeline layout descriptor}\n   * @returns - newly created {@link GPUPipelineLayout}\n   */\n  createPipelineLayout(pipelineLayoutDescriptor: GPUPipelineLayoutDescriptor): GPUPipelineLayout {\n    return this.device?.createPipelineLayout(pipelineLayoutDescriptor)\n  }\n\n  /**\n   * Create a {@link GPURenderPipeline}\n   * @param pipelineDescriptor - {@link GPURenderPipelineDescriptor | GPU render pipeline descriptor}\n   * @returns - newly created {@link GPURenderPipeline}\n   */\n  createRenderPipeline(pipelineDescriptor: GPURenderPipelineDescriptor): GPURenderPipeline {\n    return this.device?.createRenderPipeline(pipelineDescriptor)\n  }\n\n  /**\n   * Asynchronously create a {@link GPURenderPipeline}\n   * @async\n   * @param pipelineDescriptor - {@link GPURenderPipelineDescriptor | GPU render pipeline descriptor}\n   * @returns - newly created {@link GPURenderPipeline}\n   */\n  async createRenderPipelineAsync(pipelineDescriptor: GPURenderPipelineDescriptor): Promise<GPURenderPipeline> {\n    return await this.device?.createRenderPipelineAsync(pipelineDescriptor)\n  }\n\n  /**\n   * Create a {@link GPUComputePipeline}\n   * @param pipelineDescriptor - {@link GPUComputePipelineDescriptor | GPU compute pipeline descriptor}\n   * @returns - newly created {@link GPUComputePipeline}\n   */\n  createComputePipeline(pipelineDescriptor: GPUComputePipelineDescriptor): GPUComputePipeline {\n    return this.device?.createComputePipeline(pipelineDescriptor)\n  }\n\n  /**\n   * Asynchronously create a {@link GPUComputePipeline}\n   * @async\n   * @param pipelineDescriptor - {@link GPUComputePipelineDescriptor | GPU compute pipeline descriptor}\n   * @returns - newly created {@link GPUComputePipeline}\n   */\n  async createComputePipelineAsync(pipelineDescriptor: GPUComputePipelineDescriptor): Promise<GPUComputePipeline> {\n    return await this.device?.createComputePipelineAsync(pipelineDescriptor)\n  }\n\n  /* TEXTURES */\n\n  /**\n   * Get all created {@link DOMTexture} tracked by our {@link GPUDeviceManager}\n   * @readonly\n   */\n  get domTextures(): DOMTexture[] {\n    return this.deviceManager.domTextures\n  }\n\n  /**\n   * Add a {@link DOMTexture} to our {@link GPUDeviceManager#domTextures | textures array}\n   * @param texture - {@link DOMTexture} to add\n   */\n  addDOMTexture(texture: DOMTexture) {\n    this.deviceManager.addDOMTexture(texture)\n  }\n\n  /**\n   * Remove a {@link DOMTexture} from our {@link GPUDeviceManager#domTextures | textures array}\n   * @param texture - {@link DOMTexture} to remove\n   */\n  removeDOMTexture(texture: DOMTexture) {\n    this.deviceManager.removeDOMTexture(texture)\n  }\n\n  /**\n   * Add a {@link Texture} to our {@link textures} array\n   * @param texture - {@link Texture} to add\n   */\n  addTexture(texture: Texture) {\n    this.textures.push(texture)\n  }\n\n  /**\n   * Remove a {@link Texture} from our {@link textures} array\n   * @param texture - {@link Texture} to remove\n   */\n  removeTexture(texture: Texture) {\n    this.textures = this.textures.filter((t) => t.uuid !== texture.uuid)\n  }\n\n  /**\n   * Create a {@link GPUTexture}\n   * @param textureDescriptor - {@link GPUTextureDescriptor | GPU texture descriptor}\n   * @returns - newly created {@link GPUTexture}\n   */\n  createTexture(textureDescriptor: GPUTextureDescriptor): GPUTexture {\n    return this.deviceManager.device?.createTexture(textureDescriptor)\n  }\n\n  /**\n   * Upload a {@linkDOMTexture#texture | texture} to the GPU\n   * @param texture - {@link DOMTexture} class object with the {@link DOMTexture#texture | texture} to upload\n   */\n  uploadTexture(texture: DOMTexture) {\n    this.deviceManager.uploadTexture(texture)\n  }\n\n  /**\n   * Import a {@link GPUExternalTexture}\n   * @param video - {@link HTMLVideoElement} source\n   * @returns - {@link GPUExternalTexture}\n   */\n  importExternalTexture(video: HTMLVideoElement): GPUExternalTexture {\n    // TODO WebCodecs may be the way to go when time comes!\n    // https://developer.chrome.com/blog/new-in-webgpu-113/#use-webcodecs-videoframe-source-in-importexternaltexture\n    // see onVideoFrameCallback method in DOMTexture class\n    // const videoFrame = new VideoFrame(video)\n    // return this.deviceManager.device?.importExternalTexture({ source: videoFrame })\n    return this.deviceManager.device?.importExternalTexture({ source: video })\n  }\n\n  /**\n   * Check if a {@link Sampler} has already been created with the same {@link Sampler#options | parameters}.\n   * Use it if found, else create a new one and add it to the {@link GPUDeviceManager#samplers | samplers array}.\n   * @param sampler - {@link Sampler} to create\n   * @returns - the {@link GPUSampler}\n   */\n  createSampler(sampler: Sampler): GPUSampler {\n    const existingSampler = this.samplers.find((existingSampler) => {\n      return JSON.stringify(existingSampler.options) === JSON.stringify(sampler.options) && existingSampler.sampler\n    })\n\n    if (existingSampler) {\n      return existingSampler.sampler\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { type, ...samplerOptions } = sampler.options\n      const gpuSampler: GPUSampler = this.deviceManager.device?.createSampler({\n        label: sampler.label,\n        ...samplerOptions,\n      })\n\n      this.deviceManager.addSampler(sampler)\n\n      return gpuSampler\n    }\n  }\n\n  /**\n   * Remove a {@link Sampler} from our {@link GPUDeviceManager#samplers | samplers array}\n   * @param sampler - {@link Sampler} to remove\n   */\n  removeSampler(sampler: Sampler) {\n    this.deviceManager.removeSampler(sampler)\n  }\n\n  /* OBJECTS & TASKS */\n\n  /**\n   * Set different tasks queue managers to execute callbacks at different phases of our render call:\n   * - {@link onBeforeCommandEncoderCreation}: callbacks executed before the creation of the command encoder\n   * - {@link onBeforeRenderScene}: callbacks executed after the creation of the command encoder and before rendering the {@link Scene}\n   * - {@link onAfterRenderScene}: callbacks executed after the creation of the command encoder and after rendering the {@link Scene}\n   * - {@link onAfterCommandEncoderSubmission}: callbacks executed after the submission of the command encoder\n   */\n  setTasksQueues() {\n    this.onBeforeCommandEncoderCreation = new TasksQueueManager()\n    this.onBeforeRenderScene = new TasksQueueManager()\n    this.onAfterRenderScene = new TasksQueueManager()\n    this.onAfterCommandEncoderSubmission = new TasksQueueManager()\n  }\n\n  /**\n   * Set all objects arrays that we'll keep track of\n   */\n  setRendererObjects() {\n    // keep track of compute passes, meshes, etc.\n    this.computePasses = []\n    this.pingPongPlanes = []\n    this.shaderPasses = []\n    this.renderTargets = []\n    this.meshes = []\n    this.textures = []\n    this.renderBundles = []\n  }\n\n  /**\n   * Get all this {@link GPURenderer} rendered objects (i.e. compute passes, meshes, ping pong planes and shader passes)\n   * @readonly\n   */\n  get renderedObjects(): SceneObject[] {\n    return [...this.computePasses, ...this.meshes, ...this.shaderPasses, ...this.pingPongPlanes]\n  }\n\n  /**\n   * Get all objects ({@link RenderedMesh | rendered meshes} or {@link ComputePass | compute passes}) using a given {@link AllowedBindGroups | bind group}.\n   * Useful (but slow) to know if a resource is used by multiple objects and if it is safe to destroy it or not.\n   * @param bindGroup - {@link AllowedBindGroups | bind group} to check\n   */\n  getObjectsByBindGroup(bindGroup: AllowedBindGroups): undefined | SceneObject[] {\n    return this.deviceRenderedObjects.filter((object) => {\n      return [\n        ...object.material.bindGroups,\n        ...object.material.inputsBindGroups,\n        ...object.material.clonedBindGroups,\n      ].some((bG) => bG.uuid === bindGroup.uuid)\n    })\n  }\n\n  /**\n   * Get all objects ({@link RenderedMesh | rendered meshes} or {@link ComputePass | compute passes}) using a given {@link DOMTexture} or {@link Texture}.\n   * Useful to know if a resource is used by multiple objects and if it is safe to destroy it or not.\n   * @param texture - {@link DOMTexture} or {@link Texture} to check\n   */\n  getObjectsByTexture(texture: DOMTexture | Texture): undefined | SceneObject[] {\n    return this.deviceRenderedObjects.filter((object) => {\n      return [...object.material.domTextures, ...object.material.textures].some((t) => t.uuid === texture.uuid)\n    })\n  }\n\n  /* EVENTS */\n\n  /**\n   * Assign a callback function to _onBeforeRenderCallback\n   * @param callback - callback to run just before the {@link render} method will be executed\n   * @returns - our {@link GPURenderer}\n   */\n  onBeforeRender(callback: (commandEncoder?: GPUCommandEncoder) => void) {\n    if (callback) {\n      this._onBeforeRenderCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Assign a callback function to _onAfterRenderCallback\n   * @param callback - callback to run just after the {@link render} method has been executed\n   * @returns - our {@link GPURenderer}\n   */\n  onAfterRender(callback: (commandEncoder?: GPUCommandEncoder) => void) {\n    if (callback) {\n      this._onAfterRenderCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Callback to run after the {@link GPURenderer} has been resized but before the {@link resizeObjects} method has been executed (before the {@link Texture | textures}, {@link RenderPass | render passes}, {@link RenderTarget | render targets}, {@link ComputePass | compute passes} and meshes are resized).\n   * @param callback - callback to execute.\n   * @returns - our {@link GPURenderer}\n   */\n  onResize(callback: (commandEncoder?: GPUCommandEncoder) => void) {\n    if (callback) {\n      this._onResizeCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Callback to run after the {@link GPURenderer} has been resized and after the {@link resizeObjects} method has been executed (after the {@link Texture | textures}, {@link RenderPass | render passes}, {@link RenderTarget | render targets}, {@link ComputePass | compute passes} and meshes have been resized).\n   * @param callback - callback to execute.\n   * @returns - our {@link GPURenderer}\n   */\n  onAfterResize(callback: (commandEncoder?: GPUCommandEncoder) => void) {\n    if (callback) {\n      this._onAfterResizeCallback = callback\n    }\n\n    return this\n  }\n\n  /* RENDER */\n\n  /**\n   * Render a single {@link ComputePass}\n   * @param commandEncoder - current {@link GPUCommandEncoder}\n   * @param computePass - {@link ComputePass}\n   */\n  renderSingleComputePass(commandEncoder: GPUCommandEncoder, computePass: ComputePass) {\n    const pass = commandEncoder.beginComputePass()\n    computePass.render(pass)\n    pass.end()\n\n    computePass.copyBufferToResult(commandEncoder)\n  }\n\n  /**\n   * Render a single {@link RenderedMesh | Mesh}\n   * @param commandEncoder - current {@link GPUCommandEncoder}\n   * @param mesh - {@link RenderedMesh | Mesh} to render\n   */\n  renderSingleMesh(commandEncoder: GPUCommandEncoder, mesh: RenderedMesh) {\n    const pass = commandEncoder.beginRenderPass(this.renderPass.descriptor)\n    mesh.render(pass)\n    pass.end()\n  }\n\n  /**\n   * Render an array of objects (either {@link RenderedMesh | Meshes} or {@link ComputePass}) once. This method won't call any of the renderer render hooks like {@link onBeforeRender}, {@link onAfterRender}\n   * @param objects - Array of {@link RenderedMesh | Meshes} or {@link ComputePass} to render\n   */\n  renderOnce(objects: SceneObject[]) {\n    const commandEncoder = this.device?.createCommandEncoder({\n      label: 'Render once command encoder',\n    })\n    !this.production && commandEncoder.pushDebugGroup('Render once command encoder')\n\n    this.pipelineManager.resetCurrentPipeline()\n\n    objects.forEach((object) => {\n      if (object.type === 'ComputePass') {\n        this.renderSingleComputePass(commandEncoder, object as ComputePass)\n      } else {\n        this.renderSingleMesh(commandEncoder, object as RenderedMesh)\n      }\n    })\n\n    !this.production && commandEncoder.popDebugGroup()\n    const commandBuffer = commandEncoder.finish()\n    this.device?.queue.submit([commandBuffer])\n\n    this.pipelineManager.resetCurrentPipeline()\n  }\n\n  /**\n   * Force to clear a {@link GPURenderer} content to its {@link RenderPass#options.clearValue | clear value} by rendering and empty pass.\n   * @param commandEncoder\n   */\n  forceClear(commandEncoder?: GPUCommandEncoder) {\n    // if there's no command encoder provided, we'll have to create one and submit it after the copy process\n    const hasCommandEncoder = !!commandEncoder\n\n    if (!hasCommandEncoder) {\n      commandEncoder = this.device?.createCommandEncoder({\n        label: `${this.type} (${this.options.label}): Force clear command encoder`,\n      })\n      !this.production &&\n        commandEncoder.pushDebugGroup(`${this.type} (${this.options.label}): Force clear command encoder`)\n    }\n\n    this.renderPass.updateView()\n    const pass = commandEncoder.beginRenderPass(this.renderPass.descriptor)\n    pass.end()\n\n    if (!hasCommandEncoder) {\n      !this.production && commandEncoder.popDebugGroup()\n      const commandBuffer = commandEncoder.finish()\n      this.device?.queue.submit([commandBuffer])\n    }\n  }\n\n  /**\n   * Called by the {@link GPUDeviceManager#render | GPUDeviceManager render method} before the {@link GPUCommandEncoder} has been created. Used to update the {@link Scene} matrix stack.\n   */\n  onBeforeCommandEncoder() {\n    if (!this.ready) return\n    if (this.shouldRenderScene) this.scene?.onBeforeRender()\n    this.onBeforeCommandEncoderCreation.execute()\n  }\n\n  /**\n   * Called by the {@link GPUDeviceManager#render | GPUDeviceManager render method} after the {@link GPUCommandEncoder} has been created.\n   */\n  onAfterCommandEncoder() {\n    if (!this.ready) return\n\n    this.onAfterCommandEncoderSubmission.execute()\n  }\n\n  /**\n   * Called at each draw call to render our scene and its content\n   * @param commandEncoder - current {@link GPUCommandEncoder}\n   */\n  render(commandEncoder: GPUCommandEncoder) {\n    if (!this.ready || !this.shouldRender) return\n\n    this._onBeforeRenderCallback && this._onBeforeRenderCallback(commandEncoder)\n    this.onBeforeRenderScene.execute(commandEncoder)\n\n    if (this.shouldRenderScene) this.scene?.render(commandEncoder)\n\n    this._onAfterRenderCallback && this._onAfterRenderCallback(commandEncoder)\n    this.onAfterRenderScene.execute(commandEncoder)\n  }\n\n  /**\n   * Destroy our {@link GPURenderer} and everything that needs to be destroyed as well\n   */\n  destroy() {\n    this.deviceManager.renderers = this.deviceManager.renderers.filter((renderer) => renderer.uuid !== this.uuid)\n\n    this.domElement?.destroy()\n\n    // remove/destroy render bundles\n    this.renderBundles.forEach((bundle) => bundle.destroy())\n\n    // destroy render passes\n    this.renderPass?.destroy()\n    this.postProcessingPass?.destroy()\n\n    this.renderTargets.forEach((renderTarget) => renderTarget.destroy())\n    this.renderedObjects.forEach((sceneObject) => sceneObject.remove())\n\n    this.textures.forEach((texture) => texture.destroy())\n\n    this.context?.unconfigure()\n  }\n}\n","import { GPURenderer, GPURendererParams, SceneObject } from './GPURenderer'\nimport { Camera, CameraBasePerspectiveOptions } from '../camera/Camera'\nimport { BufferBinding } from '../bindings/BufferBinding'\nimport { BindGroup } from '../bindGroups/BindGroup'\nimport { Vec3 } from '../../math/Vec3'\nimport { AllowedBindGroups, Input } from '../../types/BindGroups'\nimport { RectBBox } from '../DOM/DOMElement'\nimport type { Light, LightsType, ShadowCastingLights } from '../lights/Light'\nimport { TypedArrayConstructor, WGSLVariableType } from '../bindings/utils'\nimport { throwWarning } from '../../utils/utils'\nimport { directionalShadowStruct } from '../shadows/DirectionalShadow'\nimport { pointShadowStruct } from '../shadows/PointShadow'\nimport { ShadowsType } from '../shadows/Shadow'\n\n/** Defines the parameters used to build the {@link BufferBinding} of each type of lights. */\nexport interface LightParams {\n  /** Maximum number for a given type of light. */\n  max: number\n  /** Label for a given type of light. */\n  label: string\n  /** Parameters to use to build the {@link BufferBinding} for a given type of light. */\n  params: Record<\n    string,\n    {\n      /** WGSL type of the input. */\n      type: WGSLVariableType\n      /** Size of the input. */\n      size: number\n    }\n  >\n}\n\n/** Defines the {@link BufferBinding} parameters for all kinds of {@link LightsType | light types}. */\nexport type LightsBindingParams = Record<LightsType, LightParams>\n\n/** Defines all the possible {@link BufferBinding} to use in the {@link GPUCameraRenderer#cameraLightsBindGroup | renderer camera, lights and shadows bind group}. */\nexport type GPUCameraRendererBindings = Record<'camera' | LightsType | ShadowsType, BufferBinding>\n\n/**\n * Base parameters for the maximum number of lights to use when creating a {@link GPUCameraRenderer}.\n */\nexport interface GPUCameraRendererLightParams {\n  /** Maximum number of {@link core/lights/AmbientLight.AmbientLight | AmbientLight} to use. Default to `2`. */\n  maxAmbientLights?: LightsBindingParams['ambientLights']['max']\n  /** Maximum number of {@link core/lights/DirectionalLight.DirectionalLight | DirectionalLight} to use. Default to `5`. */\n  maxDirectionalLights?: LightsBindingParams['directionalLights']['max']\n  /** Maximum number of {@link core/lights/PointLight.PointLight | PointLight} to use. Default to `5`. */\n  maxPointLights?: LightsBindingParams['pointLights']['max']\n}\n\n/**\n * Parameters used to create a {@link GPUCameraRenderer}\n */\nexport interface GPUCameraRendererParams extends GPURendererParams {\n  /** An object defining {@link CameraBasePerspectiveOptions | camera perspective parameters} */\n  camera?: CameraBasePerspectiveOptions\n  /** An object defining {@link GPUCameraRendererLightParams | the maximum number of light} to use when creating the {@link GPUCameraRenderer}. */\n  lights?: GPUCameraRendererLightParams\n}\n\n/**\n * This renderer is meant to render meshes projected by a {@link Camera}. It therefore creates a {@link Camera} with its associated {@link bindings} as well as lights and shadows {@link bindings} used for lighting and their associated {@link cameraLightsBindGroup | bind group}.<br>\n * Can be safely used to render compute passes and meshes if they do not need to be tied to the DOM.\n *\n * @example\n * ```javascript\n * // first, we need a WebGPU device, that's what GPUDeviceManager is for\n * const gpuDeviceManager = new GPUDeviceManager({\n *   label: 'Custom device manager',\n * })\n *\n * // we need to wait for the WebGPU device to be created\n * await gpuDeviceManager.init()\n *\n * // then we can create a camera renderer\n * const gpuCameraRenderer = new GPUCameraRenderer({\n *   deviceManager: gpuDeviceManager, // we need the WebGPU device to create the renderer context\n *   container: document.querySelector('#canvas'),\n * })\n * ```\n */\nexport class GPUCameraRenderer extends GPURenderer {\n  /** {@link Camera} used by this {@link GPUCameraRenderer}. */\n  camera: Camera\n  /** {@link BindGroup | bind group} handling the camera, lights and shadows {@link BufferBinding}. */\n  cameraLightsBindGroup: BindGroup\n\n  /** Array of all the created {@link Light}. */\n  lights: Light[]\n  /** An object defining the current {@link LightsBindingParams | lights binding parameters}, including the maximum number of lights for each type and the structure used to create the associated {@link BufferBinding}. */\n  lightsBindingParams: LightsBindingParams\n  /** An object defining the structure used to create the shadows {@link BufferBinding}. */\n  shadowsBindingsStruct: Record<string, Record<string, Input>>\n  /** The bindings used by the {@link cameraLightsBindGroup | camera, lights and shadows bind group}. */\n  bindings: GPUCameraRendererBindings\n\n  /** Options used to create this {@link GPUCameraRenderer}. */\n  options: GPUCameraRendererParams\n\n  /** @ignore */\n  #shouldUpdateCameraLightsBindGroup: boolean\n\n  /**\n   * GPUCameraRenderer constructor\n   * @param parameters - {@link GPUCameraRendererParams | parameters} used to create this {@link GPUCameraRenderer}\n   */\n  constructor({\n    deviceManager,\n    label,\n    container,\n    pixelRatio = 1,\n    autoResize = true,\n    preferredFormat,\n    alphaMode = 'premultiplied',\n    renderPass,\n    camera = {},\n    lights = {},\n  }: GPUCameraRendererParams) {\n    super({\n      deviceManager,\n      label,\n      container,\n      pixelRatio,\n      autoResize,\n      preferredFormat,\n      alphaMode,\n      renderPass,\n    })\n\n    this.type = 'GPUCameraRenderer'\n\n    camera = { ...{ fov: 50, near: 0.1, far: 1000 }, ...camera }\n    lights = { ...{ maxAmbientLights: 2, maxDirectionalLights: 5, maxPointLights: 5 }, ...lights }\n\n    this.options = {\n      ...this.options,\n      camera,\n      lights,\n    }\n\n    this.bindings = {} as GPUCameraRendererBindings\n    this.#shouldUpdateCameraLightsBindGroup = true\n\n    this.lights = []\n\n    this.setCamera(camera)\n\n    this.setCameraBinding()\n    this.setLightsBinding()\n    this.setShadowsBinding()\n    this.setCameraLightsBindGroup()\n  }\n\n  /**\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} is lost.\n   * Reset all our samplers, force all our scene objects and camera bind group to lose context.\n   */\n  loseContext() {\n    super.loseContext()\n    // lose camera bind group context as well\n    this.cameraLightsBindGroup.loseContext()\n  }\n\n  /**\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been restored.\n   * Configure the context again, resize the {@link core/renderPasses/RenderTarget.RenderTarget | render targets} and {@link core/textures/Texture.Texture | textures}, restore our {@link renderedObjects | rendered objects} context, re-write our {@link cameraLightsBindGroup | camera, lights and shadows bind group} bindings.\n   * @async\n   */\n  restoreContext() {\n    super.restoreContext()\n    this.cameraLightsBindGroup?.restoreContext()\n    this.updateCameraBindings()\n  }\n\n  /* CAMERA */\n\n  /**\n   * Set the {@link camera}\n   * @param cameraParameters - {@link CameraBasePerspectiveOptions | parameters} used to create the {@link camera}\n   */\n  setCamera(cameraParameters: CameraBasePerspectiveOptions) {\n    const { width, height } = this.rectBBox\n\n    this.useCamera(\n      new Camera({\n        fov: cameraParameters.fov,\n        near: cameraParameters.near,\n        far: cameraParameters.far,\n        width,\n        height,\n        pixelRatio: this.pixelRatio,\n        onMatricesChanged: () => {\n          this.onCameraMatricesChanged()\n        },\n      })\n    )\n  }\n\n  /**\n   * Tell our {@link GPUCameraRenderer} to use this {@link Camera}. If a {@link camera} has already been set, reset the {@link GPUCameraRenderer#bindings.camera | camera binding} inputs view values and the {@link meshes} {@link Camera} object.\n   * @param camera - new {@link Camera} to use.\n   */\n  useCamera(camera: Camera) {\n    if (this.camera && camera && this.camera.uuid === camera.uuid) return\n\n    if (this.camera) {\n      this.camera.parent = null\n      this.camera.onMatricesChanged = () => {}\n    }\n\n    this.camera = camera\n    this.camera.parent = this.scene\n\n    if (this.bindings.camera) {\n      this.camera.onMatricesChanged = () => this.onCameraMatricesChanged()\n\n      // replace the 2 matrices inputs view values\n      // position will be computed before updating the binding anyway\n      this.bindings.camera.inputs.view.value = this.camera.viewMatrix\n      this.bindings.camera.inputs.projection.value = this.camera.projectionMatrix\n\n      for (const mesh of this.meshes) {\n        if ('modelViewMatrix' in mesh) {\n          mesh.camera = this.camera\n        }\n      }\n    }\n  }\n\n  /**\n   * Update the {@link core/renderers/GPURenderer.ProjectedMesh | projected meshes} sizes and positions when the {@link camera} {@link Camera#position | position} changes\n   */\n  onCameraMatricesChanged() {\n    this.updateCameraBindings()\n\n    for (const mesh of this.meshes) {\n      if ('modelViewMatrix' in mesh) {\n        mesh.shouldUpdateProjectionMatrixStack()\n      }\n    }\n  }\n\n  /**\n   * Set the {@link GPUCameraRenderer#bindings.camera | camera buffer binding} and {@link cameraLightsBindGroup | camera bind group}\n   */\n  setCameraBinding() {\n    // TODO add world matrix / inverseViewMatrix?\n    this.bindings.camera = new BufferBinding({\n      label: 'Camera',\n      name: 'camera',\n      visibility: ['vertex'],\n      struct: {\n        view: {\n          // camera view matrix\n          type: 'mat4x4f',\n          value: this.camera.viewMatrix,\n        },\n        projection: {\n          // camera projection matrix\n          type: 'mat4x4f',\n          value: this.camera.projectionMatrix,\n        },\n        position: {\n          // camera world position\n          type: 'vec3f',\n          value: this.camera.position.clone().setFromMatrixPosition(this.camera.worldMatrix),\n          onBeforeUpdate: () => {\n            ;(this.bindings.camera.inputs.position.value as Vec3)\n              .copy(this.camera.position)\n              .setFromMatrixPosition(this.camera.worldMatrix)\n          },\n        },\n      },\n    })\n  }\n\n  /* LIGHTS */\n\n  /**\n   * Add a {@link Light} to the {@link lights} array.\n   * @param light - {@link Light} to add.\n   */\n  addLight(light: Light) {\n    this.lights.push(light)\n    this.bindings[light.type].inputs.count.value++\n    this.bindings[light.type].inputs.count.shouldUpdate = true\n  }\n\n  /**\n   * Remove a {@link Light} from the {@link lights} array.\n   * @param light - {@link Light} to remove.\n   */\n  removeLight(light: Light) {\n    this.lights = this.lights.filter((l) => l.uuid !== light.uuid)\n    this.bindings[light.type].inputs.count.value--\n    this.bindings[light.type].inputs.count.shouldUpdate = true\n  }\n\n  /**\n   * Set the lights {@link BufferBinding} based on the {@link lightsBindingParams}.\n   */\n  setLightsBinding() {\n    this.lightsBindingParams = {\n      ambientLights: {\n        max: this.options.lights.maxAmbientLights,\n        label: 'Ambient lights',\n        params: {\n          color: {\n            type: 'array<vec3f>',\n            size: 3,\n          },\n        },\n      },\n      directionalLights: {\n        max: this.options.lights.maxDirectionalLights,\n        label: 'Directional lights',\n        params: {\n          color: {\n            type: 'array<vec3f>',\n            size: 3,\n          },\n          direction: {\n            type: 'array<vec3f>',\n            size: 3,\n          },\n        },\n      },\n      pointLights: {\n        max: this.options.lights.maxPointLights,\n        label: 'Point lights',\n        params: {\n          color: {\n            type: 'array<vec3f>',\n            size: 3,\n          },\n          position: {\n            type: 'array<vec3f>',\n            size: 3,\n          },\n          range: {\n            type: 'array<f32>',\n            size: 1,\n          },\n        },\n      },\n    }\n\n    const lightsBindings = {\n      ambientLights: null,\n      directionalLights: null,\n      pointLights: null,\n    }\n\n    Object.keys(lightsBindings).forEach((lightsType) => {\n      this.setLightsTypeBinding(lightsType as LightsType)\n    })\n  }\n\n  /**\n   * Set or reset the {@link BufferBinding} for a given {@link LightsType | type of light}.\n   * @param lightsType - {@link LightsType | Type of light} for which to create the {@link BufferBinding}.\n   */\n  setLightsTypeBinding(lightsType: LightsType) {\n    const structParams = Object.keys(this.lightsBindingParams[lightsType].params)\n      .map((paramKey) => {\n        return {\n          key: paramKey,\n          type: this.lightsBindingParams[lightsType].params[paramKey].type,\n          size: this.lightsBindingParams[lightsType].params[paramKey].size,\n        }\n      })\n      .reduce((acc, binding) => {\n        acc[binding.key] = {\n          type: binding.type,\n          value: new Float32Array(Math.max(this.lightsBindingParams[lightsType].max, 1) * binding.size),\n        }\n\n        return acc\n      }, {})\n\n    this.bindings[lightsType] = new BufferBinding({\n      label: this.lightsBindingParams[lightsType].label,\n      name: lightsType,\n      bindingType: 'storage',\n      visibility: ['vertex', 'fragment', 'compute'], // TODO needed in compute?\n      struct: {\n        count: {\n          type: 'i32',\n          value: 0,\n        },\n        ...structParams,\n      },\n    })\n  }\n\n  /**\n   * Called when a {@link LightsType | type of light} has overflown its maximum capacity. Destroys the associated {@link BufferBinding} (and eventually the associated shadow {@link BufferBinding}), recreates the {@link cameraLightsBindGroup | camera, lights and shadows bind group} and reset all lights for this {@link LightsType | type of light}.\n   * @param lightsType - {@link LightsType | Type of light} that has overflown its maximum capacity.\n   */\n  onMaxLightOverflow(lightsType: LightsType) {\n    if (!this.production) {\n      throwWarning(\n        `${this.options.label} (${this.type}): You are overflowing the current max lights count of '${\n          this.lightsBindingParams[lightsType].max\n        }' for this type of lights: ${lightsType}. This should be avoided by setting a larger ${\n          'max' + lightsType.charAt(0).toUpperCase() + lightsType.slice(1)\n        } when instancing your ${this.type}.`\n      )\n    }\n\n    this.lightsBindingParams[lightsType].max++\n\n    const oldLightBinding = this.cameraLightsBindGroup.getBindingByName(lightsType)\n    if (oldLightBinding) {\n      this.cameraLightsBindGroup.destroyBufferBinding(oldLightBinding as BufferBinding)\n    }\n\n    this.setLightsTypeBinding(lightsType)\n\n    const lightBindingIndex = this.cameraLightsBindGroup.bindings.findIndex((binding) => binding.name === lightsType)\n\n    this.cameraLightsBindGroup.bindings[lightBindingIndex] = this.bindings[lightsType]\n\n    // increase shadows binding size as well\n    // TODO if the meshes shaders are already compiled, should we flush their pipelines?\n    if (lightsType === 'directionalLights' || lightsType === 'pointLights') {\n      const shadowsType = (lightsType.replace('Lights', '') + 'Shadows') as ShadowsType\n      const oldShadowsBinding = this.cameraLightsBindGroup.getBindingByName(shadowsType)\n      this.cameraLightsBindGroup.destroyBufferBinding(oldShadowsBinding as BufferBinding)\n      this.setShadowsTypeBinding(lightsType)\n\n      const shadowsBindingIndex = this.cameraLightsBindGroup.bindings.findIndex(\n        (binding) => binding.name === shadowsType\n      )\n      this.cameraLightsBindGroup.bindings[shadowsBindingIndex] = this.bindings[shadowsType]\n    }\n\n    this.cameraLightsBindGroup.resetEntries()\n    this.cameraLightsBindGroup.createBindGroup()\n\n    this.lights.forEach((light) => {\n      if (light.type === lightsType) {\n        light.reset()\n      }\n    })\n  }\n\n  /* SHADOW MAPS */\n\n  /**\n   * Get all the current {@link ShadowCastingLights | lights that can cast shadows}.\n   * @returns - All {@link ShadowCastingLights | lights that can cast shadows}.\n   */\n  get shadowCastingLights(): ShadowCastingLights[] {\n    return this.lights.filter(\n      (light) => light.type === 'directionalLights' || light.type === 'pointLights'\n    ) as ShadowCastingLights[]\n  }\n\n  /**\n   * Set the shadows {@link BufferBinding} based on the {@link shadowsBindingsStruct}.\n   */\n  setShadowsBinding() {\n    this.shadowsBindingsStruct = {\n      directional: directionalShadowStruct,\n      point: pointShadowStruct,\n    }\n\n    this.setShadowsTypeBinding('directionalLights')\n    this.setShadowsTypeBinding('pointLights')\n  }\n\n  /**\n   * Set or reset the associated shadow {@link BufferBinding} for a given {@link LightsType | type of light}.\n   * @param lightsType - {@link LightsType | Type of light} for which to create the associated shadow {@link BufferBinding}.\n   */\n  setShadowsTypeBinding(lightsType: LightsType) {\n    const type = lightsType.replace('Lights', '')\n    const shadowsType = (type + 'Shadows') as ShadowsType\n    const struct = this.shadowsBindingsStruct[type]\n    const label = type.charAt(0).toUpperCase() + type.slice(1) + ' shadows'\n\n    const binding = new BufferBinding({\n      label: label + ' element',\n      name: shadowsType + 'Elements',\n      bindingType: 'uniform',\n      visibility: ['vertex', 'fragment'],\n      struct,\n    })\n\n    this.bindings[shadowsType] = new BufferBinding({\n      label: label,\n      name: shadowsType,\n      bindingType: 'storage',\n      visibility: ['vertex', 'fragment', 'compute'], // TODO needed in compute?\n      bindings: Array.from(Array(Math.max(1, this.lightsBindingParams[lightsType].max)).keys()).map((i) => {\n        return binding.clone({\n          ...binding.options,\n          // clone struct with new arrays\n          struct: Object.keys(struct).reduce((acc, bindingKey) => {\n            const binding = struct[bindingKey]\n            return {\n              ...acc,\n              [bindingKey]: {\n                type: binding.type,\n                value:\n                  Array.isArray(binding.value) || ArrayBuffer.isView(binding.value)\n                    ? new (binding.value.constructor as ArrayConstructor | TypedArrayConstructor)(binding.value.length)\n                    : binding.value,\n              },\n            }\n          }, {}),\n        })\n      }),\n    })\n  }\n\n  /* CAMERA, LIGHTS & SHADOWS BIND GROUP */\n\n  /**\n   * Set the {@link cameraLightsBindGroup | camera, lights and shadows bind group}.\n   */\n  setCameraLightsBindGroup() {\n    // now initialize bind group\n    this.cameraLightsBindGroup = new BindGroup(this, {\n      label: this.options.label + ': Camera and lights uniform bind group',\n      bindings: Object.keys(this.bindings)\n        .map((bindingName) => this.bindings[bindingName])\n        .flat(),\n    })\n\n    this.cameraLightsBindGroup.consumers.add(this.uuid)\n  }\n\n  /**\n   * Create the {@link cameraLightsBindGroup | camera, lights and shadows bind group} buffers\n   */\n  setCameraBindGroup() {\n    if (this.cameraLightsBindGroup && this.cameraLightsBindGroup.shouldCreateBindGroup) {\n      this.cameraLightsBindGroup.setIndex(0)\n      this.cameraLightsBindGroup.createBindGroup()\n    }\n  }\n\n  /**\n   * Tell our  {@link cameraLightsBindGroup | camera, lights and shadows bind group} to update.\n   */\n  shouldUpdateCameraLightsBindGroup() {\n    this.#shouldUpdateCameraLightsBindGroup = true\n  }\n\n  /**\n   * Tell our {@link GPUCameraRenderer#bindings.camera | camera buffer binding} that we should update its bindings and update the bind group. Called each time the camera matrices change.\n   */\n  updateCameraBindings() {\n    this.bindings.camera?.shouldUpdateBinding('view')\n    this.bindings.camera?.shouldUpdateBinding('projection')\n    this.bindings.camera?.shouldUpdateBinding('position')\n\n    // tell our bind group to update\n    this.shouldUpdateCameraLightsBindGroup()\n  }\n\n  /**\n   * Get all objects ({@link core/renderers/GPURenderer.RenderedMesh | rendered meshes} or {@link core/computePasses/ComputePass.ComputePass | compute passes}) using a given {@link AllowedBindGroups | bind group}, including {@link cameraLightsBindGroup | camera and lights bind group}.\n   * Useful to know if a resource is used by multiple objects and if it is safe to destroy it or not.\n   * @param bindGroup - {@link AllowedBindGroups | bind group} to check\n   */\n  getObjectsByBindGroup(bindGroup: AllowedBindGroups): undefined | SceneObject[] {\n    return this.deviceRenderedObjects.filter((object) => {\n      return [\n        ...object.material.bindGroups,\n        ...object.material.inputsBindGroups,\n        ...object.material.clonedBindGroups,\n        this.cameraLightsBindGroup,\n      ].some((bG) => bG.uuid === bindGroup.uuid)\n    })\n  }\n\n  /**\n   * Set our {@link camera} perspective matrix new parameters (fov, near plane and far plane)\n   * @param parameters - {@link CameraBasePerspectiveOptions | parameters} to use for the perspective\n   */\n  setPerspective({ fov, near, far }: CameraBasePerspectiveOptions = {}) {\n    this.camera?.setPerspective({\n      fov,\n      near,\n      far,\n      width: this.rectBBox.width,\n      height: this.rectBBox.height,\n      pixelRatio: this.pixelRatio,\n    })\n  }\n\n  /**\n   * Set our {@link camera} {@link Camera#position | position}\n   * @param position - new {@link Camera#position | position}\n   */\n  setCameraPosition(position: Vec3 = new Vec3(0, 0, 1)) {\n    this.camera.position.copy(position)\n  }\n\n  /**\n   * Resize our {@link GPUCameraRenderer} and resize our {@link camera} before anything else.\n   * @param rectBBox - the optional new {@link canvas} {@link RectBBox} to set\n   */\n  resize(rectBBox: RectBBox | null = null) {\n    this.setSize(rectBBox)\n\n    this.setPerspective()\n\n    this._onResizeCallback && this._onResizeCallback()\n\n    this.resizeObjects()\n\n    this._onAfterResizeCallback && this._onAfterResizeCallback()\n  }\n\n  /* RENDER */\n\n  /**\n   * {@link setCameraBindGroup | Set the camera bind group if needed} and then call our {@link GPURenderer#render | GPURenderer render method}\n   * @param commandEncoder - current {@link GPUCommandEncoder}\n   */\n  render(commandEncoder: GPUCommandEncoder) {\n    if (!this.ready) return\n\n    this.setCameraBindGroup()\n\n    if (this.cameraLightsBindGroup && this.#shouldUpdateCameraLightsBindGroup) {\n      this.cameraLightsBindGroup.update()\n      this.#shouldUpdateCameraLightsBindGroup = false\n    }\n\n    super.render(commandEncoder)\n  }\n\n  /**\n   * Destroy our {@link GPUCameraRenderer}\n   */\n  destroy() {\n    this.cameraLightsBindGroup?.destroy()\n    this.lights.forEach((light) => light.remove())\n    super.destroy()\n  }\n}\n","import { throwError, throwWarning } from '../../utils/utils'\nimport { generateMips, Renderer } from './utils'\nimport { Sampler } from '../samplers/Sampler'\nimport { PipelineManager } from '../pipelines/PipelineManager'\nimport { SceneObject } from './GPURenderer'\nimport { DOMTexture } from '../textures/DOMTexture'\nimport { AllowedBindGroups } from '../../types/BindGroups'\nimport { Buffer } from '../buffers/Buffer'\nimport { BufferBinding } from '../bindings/BufferBinding'\n\n/**\n * Base parameters used to create a {@link GPUDeviceManager}\n */\nexport interface GPUDeviceManagerBaseParams {\n  /** Flag indicating whether we're running the production mode or not. If not, useful warnings could be logged to the console */\n  production?: boolean\n  /** Additional options to use when requesting an {@link GPUAdapter | adapter} */\n  adapterOptions?: GPURequestAdapterOptions\n}\n\n/**\n * Parameters used to create a {@link GPUDeviceManager}\n */\nexport interface GPUDeviceManagerParams extends GPUDeviceManagerBaseParams {\n  /** The label of the {@link GPUDeviceManager}, used to create the {@link GPUDevice} for debugging purpose */\n  label?: string\n  /** Callback to run if there's any error while trying to set up the {@link GPUAdapter | adapter} or {@link GPUDevice | device} */\n  onError?: () => void\n  /** Callback to run whenever the {@link GPUDeviceManager#device | device} is lost */\n  onDeviceLost?: (info?: GPUDeviceLostInfo) => void\n}\n\n/** Optional parameters used to set up/init a {@link GPUAdapter} and {@link GPUDevice} */\nexport interface GPUDeviceManagerSetupParams {\n  /** {@link GPUAdapter} to use if set */\n  adapter?: GPUAdapter | null\n  /** {@link GPUDevice} to use if set */\n  device?: GPUDevice | null\n}\n\n/**\n * Responsible for the WebGPU {@link GPUAdapter | adapter} and {@link GPUDevice | device} creations, losing and restoration.\n *\n * It will create all the GPU objects that need a {@link GPUDevice | device} to do so, as well as a {@link PipelineManager}. It will also keep a track of all the {@link Renderer}, {@link AllowedBindGroups | bind groups}, {@link Sampler}, {@link DOMTexture} and {@link GPUBuffer | GPU buffers} created.\n *\n * The {@link GPUDeviceManager} is also responsible for creating the {@link GPUCommandBuffer}, rendering all the {@link Renderer} and then submitting the {@link GPUCommandBuffer} at each {@link GPUDeviceManager#render | render} calls.\n */\nexport class GPUDeviceManager {\n  /** Number of times a {@link GPUDevice} has been created */\n  index: number\n  /** The label of the {@link GPUDeviceManager}, used to create the {@link GPUDevice} for debugging purpose */\n  label: string\n\n  /** Flag indicating whether we're running the production mode or not. If not, useful warnings could be logged to the console */\n  production: boolean\n\n  /** The navigator {@link GPU} object */\n  gpu: GPU | undefined\n  /** The WebGPU {@link GPUAdapter | adapter} used */\n  adapter: GPUAdapter | void\n  /** Additional options to use when requesting an {@link GPUAdapter | adapter} */\n  adapterOptions: GPURequestAdapterOptions\n  /** The WebGPU {@link GPUDevice | device} used */\n  device: GPUDevice | undefined\n  /** Flag indicating whether the {@link GPUDeviceManager} is ready, i.e. its {@link adapter} and {@link device} have been successfully created */\n  ready: boolean\n\n  /** The {@link PipelineManager} used to cache {@link GPURenderPipeline} and {@link GPUComputePipeline} and set them only when appropriate */\n  pipelineManager: PipelineManager\n\n  /** Array of {@link Renderer | renderers} using that {@link GPUDeviceManager} */\n  renderers: Renderer[]\n  /** A Map containing all our created {@link AllowedBindGroups} */\n  bindGroups: Map<string, AllowedBindGroups>\n  /** An array containing all our created {@link GPUBuffer} */\n  buffers: Map<string, Buffer>\n\n  /** A Map containing all our created {@link GPUBindGroupLayout} indexed by cache keys */\n  bindGroupLayouts: Map<string, GPUBindGroupLayout>\n  /** A Map containing all our created {@link BufferBinding} indexed by cache keys */\n  bufferBindings: Map<string, BufferBinding>\n\n  /** An array containing all our created {@link Sampler} */\n  samplers: Sampler[]\n  /** An array containing all our created {@link DOMTexture} */\n  domTextures: DOMTexture[]\n  /** An array to keep track of the newly uploaded {@link DOMTexture} and set their {@link DOMTexture#sourceUploaded | sourceUploaded} property */\n  texturesQueue: DOMTexture[]\n\n  /** Callback to run if there's any error while trying to set up the {@link GPUAdapter | adapter} or {@link GPUDevice | device} */\n  onError: () => void\n  /** Callback to run whenever the {@link device} is lost */\n  onDeviceLost: (info?: GPUDeviceLostInfo) => void\n\n  /**\n   * GPUDeviceManager constructor\n   * @param parameters - {@link GPUDeviceManagerParams | parameters} used to create this {@link GPUDeviceManager}\n   */\n  constructor({\n    label,\n    production = false,\n    adapterOptions = {},\n    onError = () => {\n      /* allow empty callbacks */\n    },\n    onDeviceLost = (info?: GPUDeviceLostInfo) => {\n      /* allow empty callbacks */\n    },\n  }: GPUDeviceManagerParams = {}) {\n    this.index = 0\n    this.label = label ?? 'GPUDeviceManager instance'\n    this.production = production\n    this.ready = false\n\n    this.adapterOptions = adapterOptions\n\n    this.onError = onError\n    this.onDeviceLost = onDeviceLost\n\n    this.gpu = navigator.gpu\n\n    this.setPipelineManager()\n    this.setDeviceObjects()\n  }\n\n  /**\n   * Set our {@link adapter} and {@link device} if possible.\n   * @param parameters - {@link GPUAdapter} and/or {@link GPUDevice} to use if set.\n   */\n  async setAdapterAndDevice({ adapter = null, device = null }: GPUDeviceManagerSetupParams = {}) {\n    await this.setAdapter(adapter)\n    await this.setDevice(device)\n  }\n\n  /**\n   * Set up our {@link adapter} and {@link device} and all the already created {@link renderers} contexts\n   * @param parameters - {@link GPUAdapter} and/or {@link GPUDevice} to use if set.\n   */\n  async init({ adapter = null, device = null }: GPUDeviceManagerSetupParams = {}) {\n    await this.setAdapterAndDevice({ adapter, device })\n\n    // set context\n    if (this.device) {\n      for (const renderer of this.renderers) {\n        if (!renderer.context) {\n          renderer.setContext()\n        }\n      }\n    }\n  }\n\n  /**\n   * Set our {@link adapter} if possible.\n   * The adapter represents a specific GPU. Some devices have multiple GPUs.\n   * @async\n   * @param adapter - {@link GPUAdapter} to use if set.\n   */\n  async setAdapter(adapter: GPUAdapter | null = null) {\n    if (!this.gpu) {\n      this.onError()\n      throwError(\"GPUDeviceManager: WebGPU is not supported on your browser/OS. No 'gpu' object in 'navigator'.\")\n    }\n\n    if (adapter) {\n      this.adapter = adapter\n    } else {\n      try {\n        this.adapter = await this.gpu?.requestAdapter(this.adapterOptions)\n\n        if (!this.adapter) {\n          this.onError()\n          throwError(\"GPUDeviceManager: WebGPU is not supported on your browser/OS. 'requestAdapter' failed.\")\n        }\n      } catch (e) {\n        this.onError()\n        throwError('GPUDeviceManager: ' + e.message)\n      }\n    }\n  }\n\n  /**\n   * Set our {@link device}.\n   * @async\n   * @param device - {@link GPUDevice} to use if set.\n   */\n  async setDevice(device: GPUDevice | null = null) {\n    if (device) {\n      this.device = device\n      this.ready = true\n      this.index++\n    } else {\n      try {\n        const requiredFeatures = [] as GPUFeatureName[]\n\n        if ((this.adapter as GPUAdapter).features.has('float32-filterable')) {\n          requiredFeatures.push('float32-filterable')\n        }\n\n        this.device = await (this.adapter as GPUAdapter)?.requestDevice({\n          label: this.label + ' ' + this.index,\n          requiredFeatures,\n        })\n\n        if (this.device) {\n          this.ready = true\n          this.index++\n        }\n      } catch (error) {\n        this.onError()\n        throwError(`${this.label}: WebGPU is not supported on your browser/OS. 'requestDevice' failed: ${error}`)\n      }\n    }\n\n    this.device?.lost.then((info) => {\n      throwWarning(`${this.label}: WebGPU device was lost: ${info.message}`)\n\n      this.loseDevice()\n\n      // do not call onDeviceLost event if the device was intentionally destroyed\n      if (info.reason !== 'destroyed') {\n        this.onDeviceLost(info)\n      }\n    })\n  }\n\n  /**\n   * Set our {@link pipelineManager | pipeline manager}\n   */\n  setPipelineManager() {\n    this.pipelineManager = new PipelineManager()\n  }\n\n  /**\n   * Called when the {@link device} is lost.\n   * Reset all our renderers\n   */\n  loseDevice() {\n    this.ready = false\n\n    this.pipelineManager.resetCurrentPipeline()\n\n    // first clean all samplers\n    this.samplers.forEach((sampler) => (sampler.sampler = null))\n\n    this.renderers.forEach((renderer) => renderer.loseContext())\n\n    this.bindGroupLayouts.clear()\n\n    // reset the buffers array, it would eventually be repopulated while restoring the device\n    this.buffers.clear()\n  }\n\n  /**\n   * Called when the {@link device} should be restored.\n   * Restore all our renderers.\n   * @async\n   * @param parameters - {@link GPUAdapter} and/or {@link GPUDevice} to use if set.\n   */\n  async restoreDevice({ adapter = null, device = null }: GPUDeviceManagerSetupParams = {}) {\n    await this.setAdapterAndDevice({ adapter, device })\n\n    if (this.device) {\n      // now recreate all the samplers\n      this.samplers.forEach((sampler) => {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { type, ...samplerOptions } = sampler.options\n        sampler.sampler = this.device.createSampler({\n          label: sampler.label,\n          ...samplerOptions,\n        })\n      })\n\n      // then the renderers\n      this.renderers.forEach((renderer) => renderer.restoreContext())\n    }\n  }\n\n  /**\n   * Set all objects arrays that we'll keep track of\n   */\n  setDeviceObjects() {\n    // keep track of renderers, bind groups, buffers, samplers, textures\n    this.renderers = []\n    this.bindGroups = new Map()\n    this.buffers = new Map()\n    this.bindGroupLayouts = new Map()\n    this.bufferBindings = new Map()\n    this.samplers = []\n    this.domTextures = []\n\n    // keep track of all textures that are being uploaded\n    this.texturesQueue = []\n  }\n\n  /**\n   * Add a {@link Renderer} to our {@link renderers} array\n   * @param renderer - {@link Renderer} to add\n   */\n  addRenderer(renderer: Renderer) {\n    this.renderers.push(renderer)\n  }\n\n  /**\n   * Remove a {@link Renderer} from our {@link renderers} array\n   * @param renderer - {@link Renderer} to remove\n   */\n  removeRenderer(renderer: Renderer) {\n    this.renderers = this.renderers.filter((r) => r.uuid !== renderer.uuid)\n  }\n\n  /**\n   * Get all the rendered objects (i.e. compute passes, meshes, ping pong planes and shader passes) created by this {@link GPUDeviceManager}\n   * @readonly\n   */\n  get deviceRenderedObjects(): SceneObject[] {\n    return this.renderers.map((renderer) => renderer.renderedObjects).flat()\n  }\n\n  /**\n   * Add a {@link AllowedBindGroups | bind group} to our {@link bindGroups | bind groups array}\n   * @param bindGroup - {@link AllowedBindGroups | bind group} to add\n   */\n  addBindGroup(bindGroup: AllowedBindGroups) {\n    this.bindGroups.set(bindGroup.uuid, bindGroup)\n  }\n\n  /**\n   * Remove a {@link AllowedBindGroups | bind group} from our {@link bindGroups | bind groups array}\n   * @param bindGroup - {@link AllowedBindGroups | bind group} to remove\n   */\n  removeBindGroup(bindGroup: AllowedBindGroups) {\n    this.bindGroups.delete(bindGroup.uuid)\n  }\n\n  /**\n   * Add a {@link GPUBuffer} to our our {@link buffers} array\n   * @param buffer - {@link Buffer} to add\n   */\n  addBuffer(buffer: Buffer) {\n    this.buffers.set(buffer.uuid, buffer)\n  }\n\n  /**\n   * Remove a {@link Buffer} from our {@link buffers} Map\n   * @param buffer - {@link Buffer} to remove\n   */\n  removeBuffer(buffer: Buffer) {\n    this.buffers.delete(buffer?.uuid)\n  }\n\n  /**\n   * Add a {@link Sampler} to our {@link samplers} array\n   * @param sampler - {@link Sampler} to add\n   */\n  addSampler(sampler: Sampler) {\n    this.samplers.push(sampler)\n  }\n\n  /**\n   * Remove a {@link Sampler} from our {@link samplers} array\n   * @param sampler - {@link Sampler} to remove\n   */\n  removeSampler(sampler: Sampler) {\n    this.samplers = this.samplers.filter((s) => s.uuid !== sampler.uuid)\n  }\n\n  /**\n   * Add a {@link DOMTexture} to our {@link domTextures} array\n   * @param texture - {@link DOMTexture} to add\n   */\n  addDOMTexture(texture: DOMTexture) {\n    this.domTextures.push(texture)\n  }\n\n  /**\n   * Upload a {@link DOMTexture#texture | texture} to the GPU\n   * @param texture - {@link DOMTexture} class object with the {@link DOMTexture#texture | texture} to upload\n   */\n  uploadTexture(texture: DOMTexture) {\n    if (texture.source) {\n      try {\n        this.device?.queue.copyExternalImageToTexture(\n          {\n            source: texture.source as GPUImageCopyExternalImageSource,\n            flipY: texture.options.flipY,\n          } as GPUImageCopyExternalImage,\n          { texture: texture.texture as GPUTexture, premultipliedAlpha: texture.options.premultipliedAlpha },\n          { width: texture.size.width, height: texture.size.height }\n        )\n\n        if ((texture.texture as GPUTexture).mipLevelCount > 1) {\n          generateMips(this.device, texture.texture as GPUTexture)\n        }\n\n        // add to our textures queue array to track when it has been uploaded\n        this.texturesQueue.push(texture)\n      } catch ({ message }) {\n        throwError(`GPUDeviceManager: could not upload texture: ${texture.options.name} because: ${message}`)\n      }\n    } else {\n      this.device?.queue.writeTexture(\n        { texture: texture.texture as GPUTexture },\n        new Uint8Array(texture.options.placeholderColor),\n        { bytesPerRow: texture.size.width * 4 },\n        { width: texture.size.width, height: texture.size.height }\n      )\n    }\n  }\n\n  /**\n   * Remove a {@link DOMTexture} from our {@link domTextures} array\n   * @param texture - {@link DOMTexture} to remove\n   */\n  removeDOMTexture(texture: DOMTexture) {\n    this.domTextures = this.domTextures.filter((t) => t.uuid !== texture.uuid)\n  }\n\n  /**\n   * Render everything:\n   * - call all our {@link renderers} {@link core/renderers/GPURenderer.GPURenderer#onBeforeCommandEncoder | onBeforeCommandEncoder} callbacks\n   * - create a {@link GPUCommandEncoder}\n   * - render all our {@link renderers}\n   * - submit our {@link GPUCommandBuffer}\n   * - upload {@link DOMTexture#texture | DOMTexture textures} that do not have a parentMesh\n   * - empty our {@link texturesQueue} array\n   * - call all our {@link renderers} {@link core/renderers/GPURenderer.GPURenderer#onAfterCommandEncoder | onAfterCommandEncoder} callbacks\n   */\n  render() {\n    if (!this.ready) return\n\n    for (const renderer of this.renderers) {\n      if (renderer.shouldRender) renderer.onBeforeCommandEncoder()\n    }\n\n    const commandEncoder = this.device?.createCommandEncoder({ label: this.label + ' command encoder' })\n    !this.production && commandEncoder.pushDebugGroup(this.label + ' command encoder: main render loop')\n\n    this.renderers.forEach((renderer) => renderer.render(commandEncoder))\n\n    !this.production && commandEncoder.popDebugGroup()\n    const commandBuffer = commandEncoder.finish()\n    this.device?.queue.submit([commandBuffer])\n\n    // handle textures\n    // first check if media textures without parentMesh need to be uploaded\n    this.domTextures\n      .filter((texture) => !texture.parentMesh && texture.sourceLoaded && !texture.sourceUploaded)\n      .forEach((texture) => this.uploadTexture(texture))\n\n    // no need to use device.queue.onSubmittedWorkDone\n    // as [Kai Ninomiya](https://github.com/kainino0x) stated:\n    // \"Anything you submit() after the copyExternalImageToTexture() is guaranteed to see the result of that call.\"\n    for (const texture of this.texturesQueue) {\n      texture.sourceUploaded = true\n    }\n\n    // clear texture queue\n    this.texturesQueue = []\n\n    for (const renderer of this.renderers) {\n      if (renderer.shouldRender) renderer.onAfterCommandEncoder()\n    }\n  }\n\n  /**\n   * Destroy the {@link GPUDeviceManager} and its {@link renderers}\n   */\n  destroy() {\n    this.device?.destroy()\n    this.device = null\n\n    this.renderers.forEach((renderer) => renderer.destroy())\n\n    // now clear everything that could have been left behind\n    this.bindGroups.forEach((bindGroup) => bindGroup.destroy())\n    this.buffers.forEach((buffer) => buffer?.destroy())\n\n    this.domTextures.forEach((texture) => texture.destroy())\n\n    this.setDeviceObjects()\n  }\n}\n","import { isRenderer, Renderer } from '../renderers/utils'\nimport { ProjectedMesh, RenderedMesh, SceneStackedMesh } from '../renderers/GPURenderer'\nimport { generateUUID, throwWarning } from '../../utils/utils'\nimport { BufferBinding } from '../bindings/BufferBinding'\nimport { BufferUsageKeys } from '../buffers/utils'\nimport { RenderPass } from './RenderPass'\nimport { ShaderPass } from './ShaderPass'\nimport { PingPongPlane } from '../../extras/meshes/PingPongPlane'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\n\nlet bundleIndex = 0\n\n/** Options used to create a {@link RenderBundle}. */\nexport interface RenderBundleOptions {\n  /** The label of the {@link RenderBundle}, sent to various GPU objects for debugging purpose. */\n  label: string\n  /** The {@link RenderPass} used to describe the {@link RenderBundle#descriptor | RenderBundle encoder descriptor}. Default to the first added mesh output target if not set (usually the {@link Renderer#renderPass | renderer main render pass} or {@link Renderer#postProcessingPass | renderer post processing pass}). */\n  renderPass: RenderPass\n  /** Whether the {@link RenderBundle} should handle all its child {@link core/renderers/GPURenderer.ProjectedMesh | meshes} transformation matrices with a single {@link GPUBuffer}. Can greatly improve performance when dealing with a lot of moving objects, but the {@link size} parameter has to be set upon creation and should not change afterwards. */\n  useBuffer: boolean\n  /** Fixed size (number of meshes) of the {@link RenderBundle}. Mostly useful when using the {@link useBuffer} parameter. */\n  size: number\n}\n\n/** Parameters used to created a {@link RenderBundle}. */\nexport interface RenderBundleParams extends Partial<RenderBundleOptions> {\n  /** Controls the order in which this {@link RenderBundle} should be rendered by our {@link core/scenes/Scene.Scene | Scene}. */\n  renderOrder?: number\n  /** Whether this {@link RenderBundle} should be added to our {@link core/scenes/Scene.Scene | Scene} transparent stack (drawn after the opaque stack). */\n  transparent?: boolean\n  /** Whether this {@link RenderBundle} content should be drawn. */\n  visible?: boolean\n}\n\n/**\n * Used to create a {@link GPURenderBundle} and its associated {@link GPURenderBundleEncoder}.\n *\n * Render bundle are a powerful tool that can significantly reduce the amount of CPU time spent issuing repeated rendered commands. In other words, it can be used to draw given set of meshes that share the same {@link RenderPass | output target} faster (up to 1.5x in some cases) and with less CPU overhead.\n *\n * The main drawback is that {@link RenderBundle} works best when the number of meshes drawn is known in advance and is not subject to change.\n */\nexport class RenderBundle {\n  /** The type of the {@link RenderBundle}. */\n  type: string\n  /** The universal unique id of the {@link RenderBundle}. */\n  readonly uuid: string\n  /** Index of this {@link RenderBundle}, i.e. creation order. */\n  readonly index: number\n\n  /** The {@link Renderer} used to create this {@link RenderBundle}. */\n  renderer: Renderer\n\n  /** Options used to create this {@link RenderBundle}. */\n  options: RenderBundleOptions\n\n  /** Controls the order in which this {@link RenderBundle} should be rendered by our {@link core/scenes/Scene.Scene | Scene}. */\n  renderOrder: number\n  /** Whether this {@link RenderBundle} should be added to our {@link core/scenes/Scene.Scene | Scene} transparent stack (drawn after the opaque stack). */\n  transparent: boolean | null\n  /** Whether this {@link RenderBundle} content should be drawn. */\n  visible: boolean\n\n  /** @ignore */\n  // whether this render bundle should be added to the 'projected' or 'unProjected' Scene stacks.\n  #useProjection: boolean | null\n\n  /** Optional {@link BufferBinding} created if the {@link RenderBundleParams#useBuffer | useBuffer} parameter has been set to `true` and if the {@link meshes} drawn actually have transformation matrices. This {@link BufferBinding} will act as a parent buffer, and the {@link meshes} `matrices` binding will use {core/bindings/BufferBindingOffsetChild.BufferBindingOffsetChild | BufferBindingOffsetChild} binding with the correct `offset`. */\n  binding: BufferBinding | null\n\n  /** The {@link GPURenderBundleEncoderDescriptor} created by this {@link RenderBundle}, based on the {@link RenderPass} passed as parameters. */\n  descriptor: GPURenderBundleEncoderDescriptor\n  /** The {@link GPURenderBundleEncoder} created by this {@link RenderBundle}. */\n  encoder: GPURenderBundleEncoder | null\n  /** The {@link GPURenderBundle} created by this {@link RenderBundle}. */\n  bundle: GPURenderBundle | null\n\n  /** A {@link Map} of {@link RenderedMesh | mesh} drawn by this {@link RenderBundle}. */\n  meshes: Map<RenderedMesh['uuid'], RenderedMesh>\n\n  /** @ignore */\n  #ready: boolean\n\n  /**\n   * RenderBundle constructor\n   * @param renderer - {@link Renderer} or {@link GPUCurtains} class object used to create this {@link RenderBundle}.\n   * @param parameters - {@link RenderBundleParams | parameters} use to create this {@link RenderBundle}.\n   */\n  constructor(\n    renderer: Renderer | GPUCurtains,\n    {\n      label = '',\n      renderPass = null,\n      renderOrder = 0,\n      transparent = null,\n      visible = true,\n      size = 0,\n      useBuffer = false,\n    } = {} as RenderBundleParams\n  ) {\n    this.type = 'RenderBundle'\n\n    renderer = isRenderer(renderer, this.type)\n\n    this.renderer = renderer\n\n    this.uuid = generateUUID()\n\n    Object.defineProperty(this as RenderBundle, 'index', { value: bundleIndex++ })\n    this.renderOrder = renderOrder\n\n    this.renderer.renderBundles.push(this)\n\n    this.transparent = transparent\n    this.visible = visible\n\n    this.options = {\n      label,\n      renderPass,\n      useBuffer,\n      size,\n    }\n\n    this.meshes = new Map()\n\n    this.encoder = null\n    this.bundle = null\n    this.#ready = false\n\n    this.binding = null\n\n    if (this.options.useBuffer) {\n      this.#useProjection = true\n\n      if (this.options.size !== 0) {\n        this.#setBinding()\n      } else {\n        this.options.useBuffer = false\n\n        if (!this.renderer.production) {\n          throwWarning(\n            `${this.options.label} (${this.type}): Cannot use a single transformation buffer if the size parameter has not been set upon creation.`\n          )\n        }\n      }\n    }\n  }\n\n  /**\n   * Get whether our {@link RenderBundle} handles {@link core/renderers/GPURenderer.ProjectedMesh | projected meshes} or not (useful to know in which {@link core/scenes/Scene.Scene | Scene} stack it has been added.\n   * @readonly\n   * @returns - Whether our {@link RenderBundle} handles {@link core/renderers/GPURenderer.ProjectedMesh | projected meshes} or not.\n   */\n  get useProjection(): boolean | null {\n    return this.#useProjection\n  }\n\n  /**\n   * Set whether our {@link RenderBundle} handles {@link core/renderers/GPURenderer.ProjectedMesh | projected meshes} or not.\n   * @param value - New projection value.\n   */\n  set useProjection(value: boolean) {\n    this.#useProjection = value\n  }\n\n  /**\n   * Set the {@link binding} and patches its array and buffer size if needed.\n   * @private\n   */\n  #setBinding() {\n    this.binding = new BufferBinding({\n      label: this.options.label + ' matrices',\n      name: 'matrices',\n      struct: {\n        model: {\n          type: 'array<mat4x4f>',\n          value: new Float32Array(16 * this.options.size),\n        },\n        modelView: {\n          type: 'array<mat4x4f>',\n          value: new Float32Array(16 * this.options.size),\n        },\n        normal: {\n          type: 'array<mat3x3f>',\n          value: new Float32Array(12 * this.options.size),\n        },\n      },\n    })\n\n    this.#patchBindingOffset(this.options.size)\n  }\n\n  /**\n   * Path the {@link binding} array and buffer size with the minimum {@link Renderer#device | device} buffer offset alignment.\n   * @param size - new {@link binding} size to use.\n   * @private\n   */\n  #patchBindingOffset(size: number) {\n    const minOffset = this.renderer.device.limits.minUniformBufferOffsetAlignment\n\n    // patch minimum uniform buffer offset\n    if (this.binding.arrayBufferSize < size * minOffset) {\n      this.binding.arrayBufferSize = size * minOffset\n      this.binding.arrayBuffer = new ArrayBuffer(this.binding.arrayBufferSize)\n      this.binding.buffer.size = this.binding.arrayBuffer.byteLength\n    }\n  }\n\n  /**\n   * Called each time the {@link RenderBundle} size has actually changed.\n   * @param newSize - new {@link RenderBundle} size to set.\n   * @private\n   */\n  #onSizeChanged(newSize: number) {\n    if (newSize > this.options.size && this.binding) {\n      this.#patchBindingOffset(newSize)\n\n      if (this.binding.buffer.GPUBuffer) {\n        this.binding.buffer.GPUBuffer.destroy()\n\n        this.binding.buffer.createBuffer(this.renderer, {\n          label: this.binding.options.label,\n          usage: [\n            ...(['copySrc', 'copyDst', this.binding.bindingType] as BufferUsageKeys[]),\n            ...this.binding.options.usage,\n          ],\n        })\n\n        let offset = 0\n        this.meshes.forEach((mesh: ProjectedMesh) => {\n          mesh.patchRenderBundleBinding(offset)\n          offset++\n        })\n\n        this.binding.shouldUpdate = true\n      }\n    }\n  }\n\n  /**\n   * Set the new {@link RenderBundle} size. Should be used before adding or removing {@link meshes} to the {@link RenderBundle} if the {@link bundle} has already been created (especially if it's using a {@link binding}).\n   * @param value - New size to set.\n   */\n  set size(value: number) {\n    if (value !== this.options.size) {\n      if (this.ready && !this.renderer.production) {\n        throwWarning(\n          `${this.options.label} (${this.type}): The content of a render bundle is meant to be static. You should not change its size after it has been created.`\n        )\n      }\n\n      this.ready = false\n\n      this.#onSizeChanged(value)\n\n      this.options.size = value\n    }\n  }\n\n  /**\n   * Get whether our {@link RenderBundle} is ready.\n   * @readonly\n   * @returns - Whether our {@link RenderBundle} is ready.\n   */\n  get ready(): boolean {\n    return this.#ready\n  }\n\n  /**\n   * Set whether our {@link RenderBundle} is ready and encode it if needed.\n   * @param value - New ready state.\n   */\n  set ready(value: boolean) {\n    if (value && !this.ready) {\n      // set the new size\n      // can eventually resize the buffer\n      this.size = this.meshes.size\n\n      // finally ready\n      this.#encodeRenderCommands()\n    } else if (!value && this.ready) {\n      // invalidate\n      this.bundle = null\n    }\n\n    this.#ready = value\n  }\n\n  /**\n   * Called by the {@link core/scenes/Scene.Scene | Scene} to eventually add a {@link RenderedMesh | mesh} to this {@link RenderBundle}. Can set the {@link RenderBundleOptions#renderPass | render pass} if needed. If the {@link RenderBundleOptions#renderPass | render pass} is already set and the {@link mesh} output {@link RenderPass} does not match, it won't be added.\n   * @param mesh - {@link RenderedMesh | Mesh} to eventually add.\n   * @param outputPass - The mesh output {@link RenderPass}.\n   */\n  addMesh(mesh: RenderedMesh, outputPass: RenderPass) {\n    // check for correct render pass first?\n    if (!this.options.renderPass) {\n      this.options.renderPass = outputPass\n    } else if (outputPass.uuid !== this.options.renderPass.uuid) {\n      throwWarning(\n        `${this.options.label} (${this.type}): Cannot add Mesh ${mesh.options.label} to this render bundle because the output render passes do not match.`\n      )\n\n      mesh.renderBundle = null\n\n      return\n    }\n\n    if (this.ready && !this.renderer.production) {\n      throwWarning(\n        `${this.options.label} (${this.type}): The content of a render bundle is meant to be static. You should not add meshes to it after it has been created (mesh added: ${mesh.options.label}).`\n      )\n    }\n\n    this.ready = false\n    this.meshes.set(mesh.uuid, mesh)\n  }\n\n  /**\n   * Remove any {@link RenderedMesh | rendered mesh} from this {@link RenderBundle}.\n   * @param mesh - {@link RenderedMesh | Mesh} to remove.\n   */\n  removeSceneObject(mesh: RenderedMesh) {\n    if (this.ready && !this.renderer.production) {\n      throwWarning(\n        `${this.options.label} (${this.type}): The content of a render bundle is meant to be static. You should not remove meshes from it after it has been created (mesh removed: ${mesh.options.label}).`\n      )\n    }\n\n    this.ready = false\n    this.meshes.delete(mesh.uuid)\n\n    mesh.setRenderBundle(null, false)\n  }\n\n  /**\n   * Remove a {@link SceneStackedMesh | scene stacked mesh} from this {@link RenderBundle}.\n   * @param mesh - {@link SceneStackedMesh | Scene stacked mesh} to remove.\n   * @param keepMesh - Whether to preserve the {@link mesh} in order to render it normally again. Default to `true`.\n   */\n  removeMesh(mesh: SceneStackedMesh, keepMesh = true) {\n    this.removeSceneObject(mesh)\n\n    if (keepMesh && mesh.type !== 'ShaderPass' && mesh.type !== 'PingPongPlane') {\n      this.renderer.scene.addMesh(mesh)\n    }\n\n    if (this.meshes.size === 0) {\n      this.renderer.scene.removeRenderBundle(this)\n    }\n  }\n\n  /**\n   * Set the {@link descriptor} based on the {@link RenderBundleOptions#renderPass | render pass}.\n   * @private\n   */\n  #setDescriptor() {\n    this.descriptor = {\n      ...(this.options.renderPass.options.colorAttachments && {\n        colorFormats: this.options.renderPass.options.colorAttachments.map(\n          (colorAttachment) => colorAttachment.targetFormat\n        ),\n      }),\n      ...(this.options.renderPass.options.useDepth && {\n        depthStencilFormat: this.options.renderPass.options.depthFormat,\n      }),\n      sampleCount: this.options.renderPass.options.sampleCount,\n    }\n  }\n\n  /**\n   * Create the {@link descriptor}, {@link encoder} and {@link bundle} used by this {@link RenderBundle}.\n   * @private\n   */\n  #encodeRenderCommands() {\n    this.#setDescriptor()\n\n    this.renderer.pipelineManager.resetCurrentPipeline()\n\n    this.encoder = this.renderer.device.createRenderBundleEncoder({\n      ...this.descriptor,\n      label: this.options.label + ' (encoder)',\n    })\n\n    if (!this.renderer.production) {\n      this.encoder.pushDebugGroup(`${this.options.label}: create encoder`)\n    }\n\n    // render commands\n    this.meshes.forEach((mesh) => {\n      mesh.material.render(this.encoder)\n      mesh.geometry.render(this.encoder)\n    })\n\n    if (!this.renderer.production) {\n      this.encoder.popDebugGroup()\n    }\n\n    this.bundle = this.encoder.finish({ label: this.options.label + ' (bundle)' })\n\n    this.renderer.pipelineManager.resetCurrentPipeline()\n  }\n\n  /**\n   * Update the {@link binding} buffer if needed.\n   */\n  updateBinding() {\n    if (this.binding && this.binding.shouldUpdate && this.binding.buffer.GPUBuffer) {\n      this.renderer.queueWriteBuffer(this.binding.buffer.GPUBuffer, 0, this.binding.arrayBuffer)\n      this.binding.shouldUpdate = false\n    }\n  }\n\n  /**\n   * Render the {@link RenderBundle}.\n   *\n   * If it is ready, execute each {@link RenderedMesh#onBeforeRenderPass | mesh onBeforeRenderPass method}, {@link updateBinding | update the binding} if needed, execute the {@link bundle} and finally execute each {@link RenderedMesh#onAfterRenderPass | mesh onAfterRenderPass method}.\n   *\n   * If not, just render its {@link meshes} as usual and check whether they are all ready and if we can therefore encode our {@link RenderBundle}.\n   * @param pass - {@link GPURenderPassEncoder} to use.\n   */\n  render(pass: GPURenderPassEncoder) {\n    // render bundle ready, render meshes\n    if (this.ready && this.bundle && this.visible) {\n      this.meshes.forEach((mesh) => {\n        mesh.onBeforeRenderPass()\n      })\n\n      // update transformations binding if needed\n      this.updateBinding()\n\n      // force pipeline resets before and after executing the bundle\n      this.renderer.pipelineManager.resetCurrentPipeline()\n\n      if (!this.renderer.production) {\n        pass.pushDebugGroup(`${this.options.label}: execute bundle`)\n      }\n\n      pass.executeBundles([this.bundle])\n\n      if (!this.renderer.production) {\n        pass.popDebugGroup()\n      }\n\n      this.renderer.pipelineManager.resetCurrentPipeline()\n\n      this.meshes.forEach((mesh) => {\n        mesh.onAfterRenderPass()\n      })\n    }\n\n    // bundle not ready?\n    // render meshes as usual\n    if (!this.ready) {\n      let isReady = true\n\n      for (const [_key, mesh] of this.meshes) {\n        mesh.render(pass)\n\n        if (!mesh.ready) {\n          isReady = false\n        }\n\n        // dom textures should be ready\n        // in order to validate the render bundle\n        if ('sourcesReady' in mesh && !mesh.sourcesReady) {\n          isReady = false\n        }\n      }\n\n      this.ready = isReady\n    }\n  }\n\n  /**\n   * Called when the {@link Renderer#device | WebGPU device} has been lost.\n   * Just set the {@link ready} flag to `false` to eventually invalidate the {@link bundle}.\n   */\n  loseContext() {\n    this.ready = false\n  }\n\n  /**\n   * Empty the {@link RenderBundle}. Can eventually re-add the {@link SceneStackedMesh | scene stacked meshes} to the {@link core/scenes/Scene.Scene | Scene} in order to render them normally again.\n   * @param keepMeshes - Whether to preserve the {@link meshes} in order to render them normally again. Default to `true`.\n   */\n  empty(keepMeshes = true) {\n    this.ready = false\n\n    this.meshes.forEach((mesh) => {\n      this.removeMesh(mesh, keepMeshes)\n    })\n\n    this.size = 0\n  }\n\n  /**\n   * Destroy the {@link binding} buffer if needed and remove the {@link RenderBundle} from the {@link Renderer}.\n   * @private\n   */\n  #cleanUp() {\n    // destroy binding\n    if (this.binding) {\n      this.binding.buffer.destroy()\n    }\n\n    // remove from renderer\n    this.renderer.renderBundles = this.renderer.renderBundles.filter((bundle) => bundle.uuid !== this.uuid)\n  }\n\n  /**\n   * Remove the {@link RenderBundle}, i.e. destroy it while preserving the {@link SceneStackedMesh | scene stacked meshes} by re-adding them to the {@link core/scenes/Scene.Scene | Scene}.\n   */\n  remove() {\n    this.empty(true)\n    this.#cleanUp()\n  }\n\n  /**\n   * Remove the {@link RenderBundle} from our {@link core/scenes/Scene.Scene | Scene}, {@link RenderedMesh#remove | remove the meshes}, eventually destroy the {@link binding} and remove the {@link RenderBundle} from the {@link Renderer}.\n   */\n  destroy() {\n    this.ready = false\n\n    this.meshes.forEach((mesh) => {\n      mesh.remove()\n    })\n\n    this.size = 0\n\n    this.#cleanUp()\n  }\n}\n","export default /* wgsl */ `\r\nstruct VSOutput {\r\n  @builtin(position) position: vec4f,\r\n  @location(0) uv: vec2f,\r\n};\r\n\r\n@fragment fn main(fsInput: VSOutput) -> @location(0) vec4f {\r\n  return textureSample(renderTexture, defaultSampler, fsInput.uv);\r\n}`\r\n","import { FullscreenPlane } from '../meshes/FullscreenPlane'\nimport { isRenderer, Renderer } from '../renderers/utils'\nimport { RenderTarget } from './RenderTarget'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\nimport { MeshBaseOptions, MeshBaseRenderParams } from '../meshes/mixins/MeshBaseMixin'\nimport { Texture } from '../textures/Texture'\nimport default_pass_fsWGSl from '../shaders/chunks/default/default_pass_fs.wgsl'\nimport { throwWarning } from '../../utils/utils'\n\n/**\n * Parameters used to create a {@link ShaderPass}\n */\nexport interface ShaderPassParams extends MeshBaseRenderParams {\n  /** Optional input {@link RenderTarget} to assign to the {@link ShaderPass}. Used to automatically copy the content of the given {@link RenderTarget} texture into the {@link ShaderPass#renderTexture | ShaderPass renderTexture}. */\n  inputTarget?: RenderTarget\n\n  /** Whether the result of this {@link ShaderPass} should be copied to the {@link ShaderPass#renderTexture | renderTexture} after each render. Default to false. */\n  copyOutputToRenderTexture?: boolean\n}\n\nexport interface ShaderPassOptions extends MeshBaseOptions {\n  /** Whether the result of this {@link ShaderPass} should be copied to the {@link ShaderPass#renderTexture | renderTexture} after each render. Default to false. */\n  copyOutputToRenderTexture?: boolean\n}\n\n/**\n * Used to apply postprocessing, i.e. draw meshes to a {@link Texture} and then draw a {@link FullscreenPlane} using that texture as an input.\n *\n * A ShaderPass could either post process the whole scene or just a bunch of meshes using a specific {@link RenderTarget}.\n *\n * @example\n * ```javascript\n * // set our main GPUCurtains instance\n * const gpuCurtains = new GPUCurtains({\n *   container: '#canvas' // selector of our WebGPU canvas container\n * })\n *\n * // set the GPU device\n * // note this is asynchronous\n * await gpuCurtains.setDevice()\n *\n * // create a ShaderPass\n * const shaderPass = new ShaderPass(gpuCurtain, {\n *   label: 'My shader pass',\n *   shaders: {\n *     fragment: {\n *       code: shaderPassCode, // assume it is a valid WGSL fragment shader\n *     },\n *   },\n * })\n * ```\n */\nexport class ShaderPass extends FullscreenPlane {\n  /** Optional input {@link RenderTarget} to assign to the {@link ShaderPass}. Used to automatically copy the content of the given {@link RenderTarget} texture into the {@link ShaderPass#renderTexture | ShaderPass renderTexture}. */\n  inputTarget: RenderTarget | undefined\n\n  /** Options used to create this {@link ShaderPass} */\n  options: ShaderPassOptions\n\n  /**\n   * ShaderPass constructor\n   * @param renderer - {@link Renderer} object or {@link GPUCurtains} class object used to create this {@link ShaderPass}\n   * @param parameters - {@link ShaderPassParams | parameters} use to create this {@link ShaderPass}\n   */\n  constructor(renderer: Renderer | GPUCurtains, parameters: ShaderPassParams = {}) {\n    renderer = isRenderer(renderer, parameters.label ? parameters.label + ' ShaderPass' : 'ShaderPass')\n\n    // disable depth for postprocessing passes\n    parameters.depth = false\n\n    // blend equation specific to shader passes\n    const defaultBlend: GPUBlendState = {\n      color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n      },\n      alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n      },\n    }\n\n    if (!parameters.targets) {\n      parameters.targets = [\n        {\n          blend: defaultBlend,\n        },\n      ]\n    } else if (parameters.targets && parameters.targets.length && !parameters.targets[0].blend) {\n      parameters.targets[0].blend = defaultBlend\n    }\n\n    parameters.label = parameters.label ?? 'ShaderPass ' + renderer.shaderPasses?.length\n\n    // set default sample count to post processing render pass\n    parameters.sampleCount = !!parameters.sampleCount\n      ? parameters.sampleCount\n      : renderer && renderer.postProcessingPass\n      ? renderer && renderer.postProcessingPass.options.sampleCount\n      : 1\n\n    if (!parameters.shaders) {\n      parameters.shaders = {}\n    }\n\n    if (!parameters.shaders.fragment) {\n      parameters.shaders.fragment = {\n        code: default_pass_fsWGSl,\n        entryPoint: 'main',\n      }\n    }\n\n    // force the postprocessing passes to not use depth\n    parameters.depth = false\n\n    super(renderer, parameters)\n\n    if (parameters.inputTarget) {\n      this.setInputTarget(parameters.inputTarget)\n    }\n\n    if (this.outputTarget) {\n      // patch to match outputTarget if needed\n      this.setRenderingOptionsForRenderPass(this.outputTarget.renderPass)\n    }\n\n    this.type = 'ShaderPass'\n\n    this.createTexture({\n      label: parameters.label ? `${parameters.label} render texture` : 'Shader pass render texture',\n      name: 'renderTexture',\n      fromTexture: this.inputTarget ? this.inputTarget.renderTexture : null,\n      usage: ['copySrc', 'copyDst', 'textureBinding'],\n      ...(this.outputTarget &&\n        this.outputTarget.options.qualityRatio && { qualityRatio: this.outputTarget.options.qualityRatio }),\n    })\n  }\n\n  /**\n   * Hook used to clean up parameters before sending them to the material.\n   * @param parameters - parameters to clean before sending them to the {@link core/materials/RenderMaterial.RenderMaterial | RenderMaterial}\n   * @returns - cleaned parameters\n   */\n  cleanupRenderMaterialParameters(parameters: ShaderPassParams): MeshBaseRenderParams {\n    // patch mesh parameters\n    delete parameters.copyOutputToRenderTexture\n    delete parameters.inputTarget\n\n    super.cleanupRenderMaterialParameters(parameters)\n\n    return parameters\n  }\n\n  /**\n   * Get our main {@link Texture} that contains the input content to be used by the {@link ShaderPass}. Can also contain the ouputted content if {@link ShaderPassOptions#copyOutputToRenderTexture | copyOutputToRenderTexture} is set to true.\n   * @readonly\n   */\n  get renderTexture(): Texture | undefined {\n    return this.textures.find((texture) => texture.options.name === 'renderTexture')\n  }\n\n  /**\n   * Assign or remove an input {@link RenderTarget} to this {@link ShaderPass}, which can be different from what has just been drawn to the {@link core/renderers/GPURenderer.GPURenderer#context | context} current texture.\n   *\n   * Since this manipulates the {@link core/scenes/Scene.Scene | Scene} stacks, it can be used to remove a RenderTarget as well.\n   * Also copy or remove the {@link RenderTarget#renderTexture | render target render texture} into the {@link ShaderPass} {@link renderTexture}\n   * @param inputTarget - the {@link RenderTarget} to assign or null if we want to remove the current {@link RenderTarget}\n   */\n  setInputTarget(inputTarget: RenderTarget | null) {\n    if (inputTarget && inputTarget.type !== 'RenderTarget') {\n      throwWarning(`${this.options.label ?? this.type}: inputTarget is not a RenderTarget: ${inputTarget}`)\n      return\n    }\n\n    // ensure the mesh is in the correct scene stack\n    this.removeFromScene()\n    this.inputTarget = inputTarget\n    this.addToScene()\n\n    // it might not have been created yet\n    if (this.renderTexture) {\n      if (inputTarget) {\n        this.renderTexture.copy(this.inputTarget.renderTexture)\n      } else {\n        this.renderTexture.options.fromTexture = null\n        this.renderTexture.createTexture()\n      }\n    }\n  }\n\n  /**\n   * Add the {@link ShaderPass} to the {@link core/scenes/Scene.Scene | Scene} and optionally to the renderer as well.\n   * @param addToRenderer - whether to add this {@link ShaderPass} to the {@link Renderer#shaderPasses | Renderer shaderPasses array}\n   */\n  addToScene(addToRenderer = false) {\n    if (addToRenderer) {\n      this.renderer.shaderPasses.push(this)\n    }\n\n    this.setRenderingOptionsForRenderPass(\n      this.outputTarget ? this.outputTarget.renderPass : this.renderer.postProcessingPass\n    )\n\n    if (this.autoRender) {\n      this.renderer.scene.addShaderPass(this)\n    }\n  }\n\n  /**\n   * Remove the {@link ShaderPass} from the {@link core/scenes/Scene.Scene | Scene} and optionally from the renderer as well.\n   * @param removeFromRenderer - whether to remove this {@link ShaderPass} from the {@link Renderer#shaderPasses | Renderer shaderPasses array}\n   */\n  removeFromScene(removeFromRenderer = false) {\n    if (this.outputTarget) {\n      this.outputTarget.destroy()\n    }\n\n    if (this.autoRender) {\n      this.renderer.scene.removeShaderPass(this)\n    }\n\n    if (removeFromRenderer) {\n      this.renderer.shaderPasses = this.renderer.shaderPasses.filter((sP) => sP.uuid !== this.uuid)\n    }\n  }\n}\n","export default /* wgsl */ `\r\nfn lessThan3(a: vec3f, b: vec3f) -> vec3f {\r\n  return vec3f(vec3<bool>(a.x < b.x, a.y < b.y, a.z < b.z));\r\n}\r\n\r\nfn pow2( x: f32 ) -> f32 {\r\n    return x * x;\r\n}\r\n\r\nfn pow3( x: f32 ) -> f32 {\r\n    return x * x * x;\r\n}\r\n\r\nfn pow4( x: f32 ) -> f32 {\r\n    return pow2(x) * pow2(x);\r\n}\r\n`\r\n","import common from '../common.wgsl.js'\r\n\r\nexport default /* wgsl */ `\r\n${common}\r\n\r\nstruct ReflectedLight {\r\n  directDiffuse: vec3f,\r\n  directSpecular: vec3f,\r\n  indirectDiffuse: vec3f,\r\n  indirectSpecular: vec3f,\r\n}\r\n\r\nstruct DirectLight {\r\n  color: vec3f,\r\n  direction: vec3f,\r\n  visible: bool,\r\n}\r\n\r\nfn rangeAttenuation(range: f32, distance: f32) -> f32 {\r\n  var distanceFalloff: f32 = 1.0 / max( pow( distance, 2.0 ), 0.01 );\r\n  if ( range > 0.0 ) {\r\n      distanceFalloff *= pow2( clamp( 1.0 - pow4( distance / range ), 0.0, 1.0 ) );\r\n  }\r\n  \r\n  return distanceFalloff;\r\n}\r\n\r\nfn BRDF_Lambert(diffuseColor: vec3f) -> vec3f {\r\n  return RECIPROCAL_PI * diffuseColor;\r\n}\r\n\r\nfn F_Schlick(VdotH: f32, f0: vec3f) -> vec3f {\r\n  let fresnel: f32 = pow( 1.0 - VdotH, 5.0 );\r\n  \r\n  // TODO if specular intensity is defined\r\n  // it could be: mix( specularIntensity, 1.0, metallic );\r\n  let f90: f32 = 1.0;\r\n  return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\r\n}\r\n\r\nfn getDirectionalLightInfo(directionalLight: DirectionalLightsElement, worldPosition: vec3f, ptr_light: ptr<function, DirectLight>) {\r\n  (*ptr_light).color = directionalLight.color;\r\n  (*ptr_light).direction = worldPosition - directionalLight.direction;\r\n  (*ptr_light).visible = true;\r\n}\r\n\r\nfn getPointLightInfo(pointLight: PointLightsElement, worldPosition: vec3f, ptr_light: ptr<function, DirectLight>) {\r\n  let lightDirection: vec3f = pointLight.position - worldPosition;\r\n  (*ptr_light).direction = normalize(lightDirection);\r\n  let lightDistance: f32 = length(lightDirection);\r\n  (*ptr_light).color = pointLight.color;\r\n  (*ptr_light).color *= rangeAttenuation(pointLight.range, lightDistance);\r\n  (*ptr_light).visible = length((*ptr_light).color) > 0.0001;\r\n}\r\n`\r\n","// TODO add more tone mapping options?\r\n// see https://github.com/dmnsgn/glsl-tone-map\r\n\r\n/** Defines all available tone mapping types */\r\nexport type ToneMappingTypes = 'linear' | 'khronos'\r\n\r\n/** Tone mapping utils chunks. */\r\nexport const toneMappingUtils = /* wgsl */ `\r\nfn linearToOutput3(value: vec3f) -> vec3f {\r\n  return vec3( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThan3( value.rgb, vec3( 0.0031308 ) ) ) ) );\r\n}\r\n\r\nfn linearToOutput4(value: vec4f) -> vec4f {\r\n  return vec4( linearToOutput3(value.rgb), value.a );\r\n}\r\n\r\n// linear <-> sRGB conversions\r\nfn linearTosRGB(linear: vec3f) -> vec3f {\r\n  if (all(linear <= vec3(0.0031308))) {\r\n    return linear * 12.92;\r\n  }\r\n  return (pow(abs(linear), vec3(1.0/2.4)) * 1.055) - vec3(0.055);\r\n}\r\n\r\nfn sRGBToLinear(srgb: vec3f) -> vec3f {\r\n  if (all(srgb <= vec3(0.04045))) {\r\n    return srgb / vec3(12.92);\r\n  }\r\n  return pow((srgb + vec3(0.055)) / vec3(1.055), vec3(2.4));\r\n}\r\n\r\nfn toneMapKhronosPbrNeutral( color: vec3f ) -> vec3f {\r\n  var toneMapColor = color; \r\n  const startCompression: f32 = 0.8 - 0.04;\r\n  const desaturation: f32 = 0.15;\r\n  var x: f32 = min(toneMapColor.r, min(toneMapColor.g, toneMapColor.b));\r\n  var offset: f32 = select(0.04, x - 6.25 * x * x, x < 0.08);\r\n  toneMapColor = toneMapColor - offset;\r\n  var peak: f32 = max(toneMapColor.r, max(toneMapColor.g, toneMapColor.b));\r\n  if (peak < startCompression) {\r\n    return toneMapColor;\r\n  }\r\n  const d: f32 = 1. - startCompression;\r\n  let newPeak: f32 = 1. - d * d / (peak + d - startCompression);\r\n  toneMapColor *= newPeak / peak;\r\n  let g: f32 = 1. - 1. / (desaturation * (peak - newPeak) + 1.);\r\n  return mix(toneMapColor, newPeak * vec3(1, 1, 1), g);\r\n}\r\n`\r\n","export default /* wgsl */ `\r\nfn getIndirectDiffuse(irradiance: vec3f, diffuseColor: vec3f, ptr_reflectedLight: ptr<function, ReflectedLight>) {\r\n  (*ptr_reflectedLight).indirectDiffuse += irradiance * BRDF_Lambert( diffuseColor );\r\n}\r\n\r\n// Indirect Diffuse RenderEquations\r\nfn RE_IndirectDiffuse(irradiance: vec3f, diffuseColor: vec3f, ptr_reflectedLight: ptr<function, ReflectedLight>) {\r\n  var totalAmbientIrradiance: vec3f = irradiance;\r\n  \r\n  for(var i: i32 = 0; i < ambientLights.count; i++) {\r\n    totalAmbientIrradiance += ambientLights.color[i];\r\n  }\r\n  \r\n  getIndirectDiffuse(totalAmbientIrradiance, diffuseColor, ptr_reflectedLight);\r\n}\r\n`\r\n","export default /* wgsl */ `\r\nconst PI = ${Math.PI};\r\nconst RECIPROCAL_PI = ${1 / Math.PI};\r\nconst RECIPROCAL_PI2 = ${0.5 / Math.PI};\r\nconst EPSILON = 1e-6;`\r\n","import light_utils from '../helpers/lights/light_utils.wgsl'\r\nimport { ToneMappingTypes, toneMappingUtils } from './tone-mapping-utils'\r\nimport RE_indirect_diffuse from '../helpers/lights/RE_indirect_diffuse.wgsl'\r\nimport { applyDirectionalShadows, applyPointShadows, getPCFShadows } from './shadows'\r\nimport constants from '../helpers/constants.wgsl'\r\n\r\n// TODO add emissive?\r\n/** Defines the basic parameters available for the various shading getter functions. */\r\nexport interface GetShadingParams {\r\n  /** Whether to add the utils functions such as constants or helper functions. Default to `true`. */\r\n  addUtils?: boolean\r\n  /** Whether the shading function should account for current shadows. Default to `false`. */\r\n  receiveShadows?: boolean\r\n  /** Whether the shading function should apply tone mapping to the resulting color and if so, which one. Default to `'linear'`. */\r\n  toneMapping?: ToneMappingTypes | boolean\r\n  /** Whether ambient occlusion should be accounted when calculating the shading. Default to `false`. If set to `true`, a float `f32` ambient occlusion value should be passed as the last shading function parameter. */\r\n  useOcclusion?: boolean\r\n}\r\n\r\n/** Basic minimum utils needed to compute Lambert shading. */\r\nexport const lambertUtils = /* wgsl */ `\r\n${constants}\r\n${light_utils}\r\n${RE_indirect_diffuse}\r\n`\r\n\r\n/** Helper function chunk appended internally and used to compute Lambert direct light contributions. */\r\nexport const getLambertDirect = /* wgsl */ `\r\nfn getLambertDirect(\r\n  normal: vec3f,\r\n  diffuseColor: vec3f,\r\n  directLight: DirectLight,\r\n  ptr_reflectedLight: ptr<function, ReflectedLight>\r\n) {\r\n  let L = normalize(directLight.direction);\r\n  let NdotL = max(dot(normal, L), 0.0);\r\n  \r\n  let irradiance: vec3f = NdotL * directLight.color;\r\n  (*ptr_reflectedLight).directDiffuse += irradiance * BRDF_Lambert( diffuseColor );\r\n}\r\n`\r\n\r\n/**\r\n * Shader chunk to add to the head of a fragment shader to be able to use Lambert shading.\r\n * @param parameters - {@link GetShadingParams | parameters} used to append the right chunks and calculate the Lambert shading.\r\n *\r\n * @example\r\n * ```wgsl\r\n * var color: vec3f = vec3(1.0);\r\n * color = getLambert(normal, worldPosition, color);\r\n * ```\r\n */\r\nexport const getLambert = (\r\n  { addUtils = true, receiveShadows = false, toneMapping = 'linear', useOcclusion = false } = {} as GetShadingParams\r\n) => /* wgsl */ `\r\n${addUtils ? lambertUtils : ''}\r\n${getLambertDirect}\r\n${toneMapping ? toneMappingUtils : ''}\r\n\r\nfn getLambert(\r\n  normal: vec3f,\r\n  worldPosition: vec3f,\r\n  diffuseColor: vec3f,\r\n  ${useOcclusion ? 'occlusion: f32,' : ''}\r\n) -> vec3f {\r\n  var directLight: DirectLight;\r\n  var reflectedLight: ReflectedLight;\r\n  \r\n  ${receiveShadows ? getPCFShadows : ''}\r\n\r\n  // point lights\r\n  for(var i = 0; i < pointLights.count; i++) {\r\n    getPointLightInfo(pointLights.elements[i], worldPosition, &directLight);\r\n    ${receiveShadows ? applyPointShadows : ''}\r\n    getLambertDirect(normal, diffuseColor, directLight, &reflectedLight);\r\n  }\r\n  \r\n  // directional lights\r\n  for(var i = 0; i < directionalLights.count; i++) {\r\n    getDirectionalLightInfo(directionalLights.elements[i], worldPosition, &directLight);\r\n    ${receiveShadows ? applyDirectionalShadows : ''}\r\n    getLambertDirect(normal, diffuseColor, directLight, &reflectedLight);\r\n  }\r\n  \r\n  // ambient lights\r\n  var irradiance: vec3f = vec3(0.0);\r\n  RE_IndirectDiffuse(irradiance, diffuseColor, &reflectedLight);\r\n  \r\n  let totalDirect: vec3f = reflectedLight.directDiffuse + reflectedLight.directSpecular;\r\n  var totalIndirect: vec3f = reflectedLight.indirectDiffuse + reflectedLight.indirectSpecular;\r\n  \r\n  ${useOcclusion ? 'totalIndirect *= occlusion;' : ''}\r\n  \r\n  var outgoingLight: vec3f = totalDirect + totalIndirect;\r\n  \r\n  ${\r\n    toneMapping === 'linear'\r\n      ? 'outgoingLight = linearToOutput3(outgoingLight);'\r\n      : toneMapping === 'khronos'\r\n      ? 'outgoingLight = linearTosRGB(toneMapKhronosPbrNeutral(outgoingLight));'\r\n      : ''\r\n  }\r\n  \r\n  return outgoingLight;\r\n}\r\n`\r\n","import { toneMappingUtils } from './tone-mapping-utils'\r\nimport { GetShadingParams, lambertUtils } from './lambert-shading'\r\nimport { applyDirectionalShadows, applyPointShadows, getPCFShadows } from './shadows'\r\n\r\n/** Helper function chunk appended internally and used to compute Phong direct light contributions. */\r\nexport const getPhongDirect = /* wgsl */ `\r\nfn D_BlinnPhong( shininess: f32, NdotH: f32 ) -> f32 {\r\n  return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( NdotH, shininess );\r\n}\r\n\r\nfn BRDF_BlinnPhong(\r\n  normal: vec3f,\r\n  viewDirection: vec3f,\r\n  specularColor: vec3f,\r\n  shininess: f32,\r\n  directLight: DirectLight\r\n) -> vec3f {\r\n  let L = normalize(directLight.direction);\r\n  let NdotL = max(dot(normal, L), 0.0);\r\n  let H: vec3f = normalize(viewDirection + L);\r\n  \r\n  let NdotH: f32 = clamp(dot(normal, H), 0.0, 1.0);\r\n  let VdotH: f32 = clamp(dot(viewDirection, H), 0.0, 1.0);\r\n  let NdotV: f32 = clamp( dot(normal, viewDirection), 0.0, 1.0 );\r\n  \r\n  let F: vec3f = F_Schlick(VdotH, specularColor);\r\n  \r\n  let G: f32 = 0.25; // blinn phong implicit\r\n  \r\n  let D = D_BlinnPhong(shininess, NdotH);\r\n  \r\n  let specular: vec3f = F * G * D;\r\n        \r\n  return specular;\r\n}\r\n\r\nfn getPhongDirect(\r\n  normal: vec3f,\r\n  diffuseColor: vec3f,\r\n  viewDirection: vec3f,\r\n  specularColor: vec3f,\r\n  specularStrength: f32,\r\n  shininess: f32,\r\n  directLight: DirectLight,\r\n  ptr_reflectedLight: ptr<function, ReflectedLight>\r\n) {\r\n  let L = normalize(directLight.direction);\r\n  let NdotL = max(dot(normal, L), 0.0);\r\n  \r\n  let irradiance: vec3f = NdotL * directLight.color;\r\n  (*ptr_reflectedLight).directDiffuse += irradiance * BRDF_Lambert( diffuseColor );\r\n  (*ptr_reflectedLight).directSpecular += irradiance * BRDF_BlinnPhong( normal, viewDirection, specularColor, shininess, directLight ) * specularStrength;\r\n}\r\n`\r\n\r\n/**\r\n * Shader chunk to add to the head of a fragment shader to be able to use Phong shading.\r\n * @param parameters - {@link GetShadingParams | parameters} used to append the right chunks and calculate the Phong shading.\r\n *\r\n * @example\r\n * ```wgsl\r\n * var color: vec3f = vec3(1.0);\r\n * let specularColor: vec3f = vec3(1.0);\r\n * let specularStrength: f32 = 1.0;\r\n * let shininess: f32 = 32.0;\r\n * color = getPhong(normal, worldPosition, color, viewDirection, specularColor, specularStrength, shininess);\r\n * ```\r\n */\r\nexport const getPhong = (\r\n  { addUtils = true, receiveShadows = false, toneMapping = 'linear', useOcclusion = false } = {} as GetShadingParams\r\n) => /* wgsl */ `\r\n${addUtils ? lambertUtils : ''}\r\n${getPhongDirect}\r\n${toneMapping ? toneMappingUtils : ''}\r\n\r\nfn getPhong(\r\n  normal: vec3f,\r\n  worldPosition: vec3f,\r\n  diffuseColor: vec3f,\r\n  viewDirection: vec3f,\r\n  specularColor: vec3f,\r\n  specularStrength: f32,\r\n  shininess: f32,\r\n  ${useOcclusion ? 'occlusion: f32,' : ''}\r\n) -> vec3f {\r\n  var directLight: DirectLight;\r\n  var reflectedLight: ReflectedLight;\r\n  \r\n  ${receiveShadows ? getPCFShadows : ''}\r\n\r\n  // point lights\r\n  for(var i = 0; i < pointLights.count; i++) {  \r\n    getPointLightInfo(pointLights.elements[i], worldPosition, &directLight);\r\n    ${receiveShadows ? applyPointShadows : ''}\r\n    getPhongDirect(normal, diffuseColor, viewDirection, specularColor, specularStrength, shininess, directLight, &reflectedLight);\r\n  }\r\n  \r\n  // directional lights\r\n  for(var i = 0; i < directionalLights.count; i++) {\r\n    getDirectionalLightInfo(directionalLights.elements[i], worldPosition, &directLight);\r\n    ${receiveShadows ? applyDirectionalShadows : ''}\r\n    getPhongDirect(normal, diffuseColor, viewDirection, specularColor, specularStrength, shininess, directLight, &reflectedLight);\r\n  }\r\n  \r\n  // ambient lights\r\n  var irradiance: vec3f = vec3(0.0);\r\n  RE_IndirectDiffuse(irradiance, diffuseColor, &reflectedLight);\r\n  \r\n  let totalDirect: vec3f = reflectedLight.directDiffuse + reflectedLight.directSpecular;\r\n  var totalIndirect: vec3f = reflectedLight.indirectDiffuse + reflectedLight.indirectSpecular;\r\n  \r\n  ${useOcclusion ? 'totalIndirect *= occlusion;' : ''}\r\n  \r\n  var outgoingLight: vec3f = totalDirect + totalIndirect;\r\n  \r\n  ${\r\n    toneMapping === 'linear'\r\n      ? 'outgoingLight = linearToOutput3(outgoingLight);'\r\n      : toneMapping === 'khronos'\r\n      ? 'outgoingLight = linearTosRGB(toneMapKhronosPbrNeutral(outgoingLight));'\r\n      : ''\r\n  }\r\n  \r\n  return outgoingLight;\r\n}\r\n`\r\n","export default /* wgsl */ `\r\nfn DFGApprox(\r\n  normal: vec3f,\r\n  viewDirection: vec3f,\r\n  roughness: f32,\r\n) -> vec2f {\r\n  let dotNV: f32 = clamp( dot( normal, viewDirection ), 0.0, 1.0 );\r\n\r\n\tlet c0: vec4f = vec4( - 1, - 0.0275, - 0.572, 0.022 );\r\n\tlet c1: vec4f = vec4( 1, 0.0425, 1.04, - 0.04 );\r\n\r\n\tlet r: vec4f = roughness * c0 + c1;\r\n\tlet a004: f32 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\r\n\t\r\n\tlet fab: vec2f = vec2( - 1.04, 1.04 ) * a004 + r.zw;\r\n\r\n\treturn fab;\r\n}\r\n\r\nstruct TotalScattering {\r\n  single: vec3f,\r\n  multi: vec3f,\r\n}\r\n\r\nfn computeMultiscattering(\r\n  normal: vec3f,\r\n  viewDirection: vec3f,\r\n  specularColor: vec3f,\r\n  f90: f32,\r\n  roughness: f32,\r\n  ptr_totalScattering: ptr<function, TotalScattering>\r\n) {\r\n  let fab: vec2f = DFGApprox( normal, viewDirection, roughness );\r\n\r\n\tlet Fr: vec3f = specularColor;\r\n\r\n\tlet FssEss: vec3f = Fr * fab.x + f90 * fab.y;\r\n\r\n\tlet Ess: f32 = fab.x + fab.y;\r\n\tlet Ems: f32 = 1.0 - Ess;\r\n\r\n\tlet Favg: vec3f = Fr + ( 1.0 - Fr ) * 0.047619; // 1/21\r\n\tlet Fms: vec3f = FssEss * Favg / ( 1.0 - Ems * Favg );\r\n\r\n\t(*ptr_totalScattering).single += FssEss;\r\n\t(*ptr_totalScattering).multi += Fms * Ems;\r\n}\r\n\r\n// Indirect Specular RenderEquations\r\nfn RE_IndirectSpecular(\r\n  radiance: vec3f,\r\n  irradiance: vec3f,\r\n  normal: vec3f,\r\n  diffuseColor: vec3f,\r\n  viewDirection: vec3f,\r\n  metallic: f32,\r\n  roughness: f32,\r\n  ptr_reflectedLight: ptr<function, ReflectedLight>\r\n) {\r\n  var totalScattering: TotalScattering;\r\n  let cosineWeightedIrradiance: vec3f = irradiance * RECIPROCAL_PI;\r\n  \r\n  let specularColor: vec3f = mix( vec3( 0.04 ), diffuseColor, metallic );\r\n  \r\n  let f90: f32 = 1.0;\r\n  \r\n  computeMultiscattering( normal, viewDirection, specularColor, f90, roughness, &totalScattering );\r\n  \r\n  let totalScatter: vec3f = totalScattering.single + totalScattering.multi;\r\n  let diffuse: vec3f = diffuseColor * ( 1.0 - max( max( totalScatter.r, totalScatter.g ), totalScatter.b ) );\r\n\r\n  (*ptr_reflectedLight).indirectSpecular += radiance * totalScattering.single;\r\n  (*ptr_reflectedLight).indirectSpecular += totalScattering.multi * cosineWeightedIrradiance;\r\n\r\n  (*ptr_reflectedLight).indirectDiffuse += diffuse * cosineWeightedIrradiance;\r\n}\r\n`\r\n","import { toneMappingUtils } from './tone-mapping-utils'\r\nimport RE_indirect_specular from '../helpers/lights/RE_indirect_specular.wgsl'\r\nimport { GetShadingParams, lambertUtils } from './lambert-shading'\r\nimport { applyDirectionalShadows, applyPointShadows, getPCFShadows } from './shadows'\r\n\r\n/** Basic minimum utils needed to compute PBR shading. Extends {@link lambertUtils | utils needed for lambert shading}. */\r\nexport const pbrUtils = `\r\n${lambertUtils}\r\n${RE_indirect_specular}\r\n`\r\n\r\n/** Helper function chunk appended internally and used to compute PBR direct light contributions. */\r\nexport const getPBRDirect = /* wgsl */ `\r\nfn DistributionGGX(NdotH: f32, roughness: f32) -> f32 {\r\n  let a: f32 = pow2( roughness );\r\n  let a2: f32 = pow2( a );\r\n\r\n  let denom: f32 = (pow2( NdotH ) * (a2 - 1.0) + 1.0);\r\n\r\n  return RECIPROCAL_PI * a2 / ( pow2( denom ) );\r\n}\r\n\r\nfn GeometrySmith(NdotL: f32, NdotV: f32, roughness: f32) -> f32 {\r\n  let a: f32 = pow2( roughness );\r\n  let a2: f32 = pow2( a );\r\n  \r\n  let gv: f32 = NdotL * sqrt( a2 + ( 1.0 - a2 ) * pow2( NdotV ) );\r\n  let gl: f32 = NdotV * sqrt( a2 + ( 1.0 - a2 ) * pow2( NdotL ) );\r\n\r\n  return 0.5 / max( gv + gl, EPSILON );\r\n}\r\n\r\nfn BRDF_GGX(\r\n  NdotV: f32,\r\n  NdotL: f32,\r\n  NdotH: f32,\r\n  VdotH: f32,\r\n  roughness: f32,\r\n  f0: vec3f\r\n) -> vec3f {\r\n  // cook-torrance brdf\r\n  let G: f32 = GeometrySmith(NdotL, NdotV, roughness);\r\n  let D: f32 = DistributionGGX(NdotH, roughness);\r\n  let F: vec3f = F_Schlick(VdotH, f0);\r\n  \r\n  return G * D * F;\r\n}\r\n\r\nfn getPBRDirect(\r\n  normal: vec3f,\r\n  diffuseColor: vec3f,\r\n  viewDirection: vec3f,\r\n  f0: vec3f,\r\n  metallic: f32,\r\n  roughness: f32,\r\n  directLight: DirectLight,\r\n  ptr_reflectedLight: ptr<function, ReflectedLight>\r\n) {\r\n  let N: vec3f = normalize(normal);\r\n  let L: vec3f = normalize(directLight.direction);\r\n  let V: vec3f = normalize(viewDirection);\r\n  let H: vec3f = normalize(V + L);\r\n  let NdotV: f32 = clamp(dot(N, V), 0.0, 1.0);\r\n  let NdotL: f32 = clamp(dot(N, L), 0.0, 1.0);\r\n  let NdotH: f32 = clamp(dot(N, H), 0.0, 1.0);\r\n  let VdotH: f32 = clamp(dot(V, H), 0.0, 1.0);\r\n\r\n  let irradiance: vec3f = NdotL * directLight.color;\r\n  let ggx: vec3f = BRDF_GGX(NdotV, NdotL, NdotH, VdotH, roughness, f0);\r\n  \r\n  (*ptr_reflectedLight).directDiffuse += irradiance * BRDF_Lambert( diffuseColor );\r\n  (*ptr_reflectedLight).directSpecular += ggx * irradiance;\r\n}\r\n`\r\n\r\n/**\r\n * Shader chunk to add to the head of a fragment shader to be able to use PBR shading.\r\n * @param parameters - {@link GetShadingParams | parameters} used to append the right chunks and calculate the PBR shading.\r\n *\r\n * @example\r\n * ```wgsl\r\n * var color: vec3f = vec3(1.0);\r\n * color = getPBR(normal, worldPosition, color, viewDirection, f0, metallic, roughness);\r\n * ```\r\n */\r\nexport const getPBR = (\r\n  { addUtils = true, receiveShadows = false, toneMapping = 'linear', useOcclusion = false } = {} as GetShadingParams\r\n) => /* wgsl */ `\r\n${addUtils ? pbrUtils : ''}\r\n${getPBRDirect}\r\n${toneMapping ? toneMappingUtils : ''}\r\n\r\nfn getPBR(\r\n  normal: vec3f,\r\n  worldPosition: vec3f,\r\n  diffuseColor: vec3f,\r\n  viewDirection: vec3f,\r\n  f0: vec3f,\r\n  metallic: f32,\r\n  roughness: f32,\r\n  ${useOcclusion ? 'occlusion: f32,' : ''}\r\n) -> vec3f {\r\n  var directLight: DirectLight;\r\n  var reflectedLight: ReflectedLight;\r\n  \r\n  ${receiveShadows ? getPCFShadows : ''}\r\n\r\n  // point lights\r\n  for(var i = 0; i < pointLights.count; i++) {\r\n    getPointLightInfo(pointLights.elements[i], worldPosition, &directLight);\r\n    ${receiveShadows ? applyPointShadows : ''}\r\n    getPBRDirect(normal, diffuseColor, viewDirection, f0, metallic, roughness, directLight, &reflectedLight);\r\n  }\r\n  \r\n  // directional lights\r\n  for(var i = 0; i < directionalLights.count; i++) {\r\n    getDirectionalLightInfo(directionalLights.elements[i], worldPosition, &directLight);\r\n    ${receiveShadows ? applyDirectionalShadows : ''}\r\n    getPBRDirect(normal, diffuseColor, viewDirection, f0, metallic, roughness, directLight, &reflectedLight);\r\n  }\r\n  \r\n  // ambient lights\r\n  var irradiance: vec3f = vec3(0.0);\r\n  RE_IndirectDiffuse(irradiance, diffuseColor, &reflectedLight);\r\n  \r\n  // ambient lights specular\r\n  // var radiance: vec3f = vec3(0.0);\r\n  // RE_IndirectSpecular(radiance, irradiance, normal, diffuseColor, viewDirection, metallic, roughness, &reflectedLight);\r\n  \r\n  let totalDirect: vec3f = reflectedLight.directDiffuse + reflectedLight.directSpecular;\r\n  var totalIndirect: vec3f = reflectedLight.indirectDiffuse + reflectedLight.indirectSpecular;\r\n  \r\n  ${useOcclusion ? 'totalIndirect *= occlusion;' : ''}\r\n  \r\n  var outgoingLight: vec3f = totalDirect + totalIndirect;\r\n  \r\n  ${\r\n    toneMapping === 'linear'\r\n      ? 'outgoingLight = linearToOutput3(outgoingLight);'\r\n      : toneMapping === 'khronos'\r\n      ? 'outgoingLight = linearTosRGB(toneMapKhronosPbrNeutral(outgoingLight));'\r\n      : ''\r\n  }\r\n  \r\n  return outgoingLight;\r\n}\r\n`\r\n","import { getPBRDirect, pbrUtils } from './pbr-shading'\r\nimport { toneMappingUtils } from './tone-mapping-utils'\r\nimport { applyDirectionalShadows, applyPointShadows, getPCFShadows } from './shadows'\r\nimport { GetShadingParams } from './lambert-shading'\r\n\r\n/** Helper function chunk appended internally and used to compute IBL indirect light contributions, based on environment diffuse and specular maps. Image Based Lightning also use {@link getPBRDirect | PBR direct light contributions}. */\r\n// we could either compute the indirect contribution directly inside getIBLIndirect()\r\n// or compute IBL radiance (specular) and irradiance (diffuse) factors\r\n// and use them inside RE_IndirectSpecular() later to apply scattering\r\n// first solution seems to be more realistic for now\r\nexport const getIBLIndirect = /* wgsl */ `\r\n// struct IBLIndirect {\r\n//   diffuse: vec3f,\r\n//   specular: vec3f\r\n// }\r\n\r\nfn getIBLIndirect(\r\n  normal: vec3f,\r\n  viewDirection: vec3f,\r\n  roughness: f32,\r\n  metallic: f32,\r\n  diffuseColor: vec3f,\r\n  f0: vec3f,\r\n  lutTexture: texture_2d<f32>,\r\n  lutSampler: sampler,\r\n  envSpecularTexture: texture_cube<f32>,\r\n  envSpecularSampler: sampler,\r\n  envDiffuseTexture: texture_cube<f32>,\r\n  envDiffuseSampler: sampler,\r\n  ptr_reflectedLight: ptr<function, ReflectedLight>,\r\n  // ptr_iblIndirect: ptr<function, IBLIndirect>\r\n) {\r\n  let N: vec3f = normalize(normal);\r\n  let V: vec3f = normalize(viewDirection);\r\n  let NdotV: f32 = clamp(dot(N, V), 0.0, 1.0);\r\n  \r\n  let reflection: vec3f = normalize(reflect(-V, N));\r\n  \r\n  let iblDiffuseColor: vec3f = mix(diffuseColor, vec3(0.0), vec3(metallic));\r\n\r\n  let brdfSamplePoint: vec2f = clamp(vec2(NdotV, roughness), vec2(0.0), vec2(1.0));\r\n  \r\n  let brdf: vec3f = textureSample(\r\n    lutTexture,\r\n    lutSampler,\r\n    brdfSamplePoint\r\n  ).rgb;\r\n\r\n  let Fr: vec3f = max(vec3(1.0 - roughness), f0) - f0;\r\n  let k_S: vec3f = f0 + Fr * pow(1.0 - NdotV, 5.0);\r\n  var FssEss: vec3f = k_S * brdf.x + brdf.y;\r\n  \r\n  // IBL specular (radiance)\r\n  let lod: f32 = roughness * f32(textureNumLevels(envSpecularTexture) - 1);\r\n  \r\n  let specularLight: vec4f = textureSampleLevel(\r\n    envSpecularTexture,\r\n    envSpecularSampler,\r\n    reflection,\r\n    lod\r\n  );\r\n  \r\n  // IBL diffuse (irradiance)\r\n  let diffuseLight: vec4f = textureSample(\r\n    envDiffuseTexture,\r\n    envDiffuseSampler,\r\n    normal\r\n  );\r\n  \r\n  // product of specularFactor and specularTexture.a\r\n  let specularWeight: f32 = 1.0;\r\n        \r\n  FssEss = specularWeight * k_S * brdf.x + brdf.y;\r\n  \r\n  let Ems: f32 = (1.0 - (brdf.x + brdf.y));\r\n  let F_avg: vec3f = specularWeight * (f0 + (1.0 - f0) / 21.0);\r\n  let FmsEms: vec3f = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\r\n  let k_D: vec3f = iblDiffuseColor * (1.0 - FssEss + FmsEms);\r\n  \r\n  (*ptr_reflectedLight).indirectSpecular += specularLight.rgb * FssEss * ibl.specularStrength;\r\n  (*ptr_reflectedLight).indirectDiffuse += (FmsEms + k_D) * diffuseLight.rgb * ibl.diffuseStrength;\r\n  \r\n  // (*ptr_iblIndirect).diffuse = PI * diffuseLight.rgb * ibl.diffuseStrength;\r\n  // (*ptr_iblIndirect).specular = specularLight.rgb * ibl.specularStrength;\r\n}\r\n`\r\n\r\n/**\r\n * Shader chunk to add to the head of a fragment shader to be able to use IBL shading.\r\n * @param parameters - {@link GetShadingParams | parameters} used to append the right chunks and calculate the IBL shading.\r\n *\r\n * @example\r\n * ```wgsl\r\n * var color: vec3f = vec3(1.0);\r\n * color = getIBL(normal, worldPosition, color, viewDirection, f0, metallic, roughness, lutTeture, lutSampler, envSpecularTexture, envSpecularSampler, envDiffuseTexture, envDiffuseSampler);\r\n * ```\r\n */\r\nexport const getIBL = (\r\n  { addUtils = true, receiveShadows = false, toneMapping = 'linear', useOcclusion = false } = {} as GetShadingParams\r\n) => /* wgsl */ `\r\n${addUtils ? pbrUtils : ''}\r\n${getPBRDirect}\r\n${getIBLIndirect}\r\n${toneMapping ? toneMappingUtils : ''}\r\n\r\nfn getIBL(\r\n  normal: vec3f,\r\n  worldPosition: vec3f,\r\n  diffuseColor: vec3f,\r\n  viewDirection: vec3f,\r\n  f0: vec3f,\r\n  metallic: f32,\r\n  roughness: f32,\r\n  lutTexture: texture_2d<f32>,\r\n  lutSampler: sampler,\r\n  envSpecularTexture: texture_cube<f32>,\r\n  envSpecularSampler: sampler,\r\n  envDiffuseTexture: texture_cube<f32>,\r\n  envDiffuseSampler: sampler,\r\n  ${useOcclusion ? 'occlusion: f32,' : ''}\r\n) -> vec3f {\r\n  var directLight: DirectLight;\r\n  var reflectedLight: ReflectedLight;\r\n  \r\n  ${receiveShadows ? getPCFShadows : ''}\r\n\r\n  // point lights\r\n  for(var i = 0; i < pointLights.count; i++) {\r\n    getPointLightInfo(pointLights.elements[i], worldPosition, &directLight);\r\n    ${receiveShadows ? applyPointShadows : ''}\r\n    getPBRDirect(normal, diffuseColor, viewDirection, f0, metallic, roughness, directLight, &reflectedLight);\r\n  }\r\n  \r\n  // directional lights\r\n  for(var i = 0; i < directionalLights.count; i++) {\r\n    getDirectionalLightInfo(directionalLights.elements[i], worldPosition, &directLight);\r\n    ${receiveShadows ? applyDirectionalShadows : ''}\r\n    getPBRDirect(normal, diffuseColor, viewDirection, f0, metallic, roughness, directLight, &reflectedLight);\r\n  }\r\n  \r\n  var irradiance: vec3f = vec3(0.0);\r\n  var radiance: vec3f = vec3(0.0);\r\n  \r\n  // var iblIndirect: IBLIndirect;\r\n  \r\n  // IBL\r\n  getIBLIndirect(\r\n    normal,\r\n    viewDirection,\r\n    roughness,\r\n    metallic,\r\n    diffuseColor,\r\n    f0,\r\n    lutTexture,\r\n    lutSampler,\r\n    envSpecularTexture,\r\n    envSpecularSampler,\r\n    envDiffuseTexture,\r\n    envDiffuseSampler,\r\n    &reflectedLight,\r\n    // &iblIndirect\r\n  );\r\n  \r\n  // irradiance += iblIndirect.diffuse;\r\n  // radiance += iblIndirect.specular;\r\n  \r\n  // ambient lights\r\n  RE_IndirectDiffuse(irradiance, diffuseColor, &reflectedLight);\r\n  \r\n  // ambient lights specular\r\n  // RE_IndirectSpecular(radiance, irradiance, normal, diffuseColor, viewDirection, metallic, roughness, &reflectedLight);  \r\n  \r\n  let totalDirect: vec3f = reflectedLight.directDiffuse + reflectedLight.directSpecular;\r\n  var totalIndirect: vec3f = reflectedLight.indirectDiffuse + reflectedLight.indirectSpecular;\r\n  \r\n  ${useOcclusion ? 'totalIndirect *= occlusion;' : ''}\r\n  \r\n  var outgoingLight: vec3f = totalDirect + totalIndirect;\r\n  \r\n  ${\r\n    toneMapping === 'linear'\r\n      ? 'outgoingLight = linearToOutput3(outgoingLight);'\r\n      : toneMapping === 'khronos'\r\n      ? 'outgoingLight = linearTosRGB(toneMapKhronosPbrNeutral(outgoingLight));'\r\n      : ''\r\n  }\r\n  \r\n  return outgoingLight;\r\n}\r\n`\r\n","import { ProjectedObject3D } from '../../core/objects3D/ProjectedObject3D'\r\nimport { GPUCurtainsRenderer } from '../renderers/GPUCurtainsRenderer'\r\nimport { GPUCurtains } from '../GPUCurtains'\r\nimport { isCurtainsRenderer } from '../../core/renderers/utils'\r\nimport { DOMElement, DOMElementBoundingRect, DOMElementParams, DOMPosition, RectBBox } from '../../core/DOM/DOMElement'\r\nimport { Vec2 } from '../../math/Vec2'\r\nimport { Vec3 } from '../../math/Vec3'\r\nimport { Object3DTransforms } from '../../core/objects3D/Object3D'\r\nimport { Box3 } from '../../math/Box3'\r\n\r\n/** Defines the {@link DOMObject3D} bounding boxes in both document and world spaces */\r\nexport interface DOMObject3DSize {\r\n  /** Whether we should update the computed sizes before updating the matrices. */\r\n  shouldUpdate: boolean\r\n  /** Normalized world size represent the size ratio of the DOM element compared to its container (the renderer DOM element). */\r\n  normalizedWorld: {\r\n    /** 2D size of the {@link DOMObject3D} relative to the document, in the [0, 1] range. */\r\n    size: Vec2\r\n    /** 2D position of the {@link DOMObject3D} relative to the document, in the [-1, 1] range, [0, 0] being at the container center. */\r\n    position: Vec2\r\n  }\r\n  /** Camera world size and position are the {@link normalizedWorld} size and positions accounting for camera screen ratio (visible height / width in world unit) */\r\n  cameraWorld: {\r\n    /** 2D size of the {@link DOMObject3D} relative to the camera field of view and size. */\r\n    size: Vec2\r\n  }\r\n  /** Scaled world size and position are the {@link cameraWorld} size and position scaled by the geometry bounding box, because the geometry vertices are not always in the [-1, 1] range. */\r\n  scaledWorld: {\r\n    /** 3D size of the {@link DOMObject3D} relative to the camera field of view and size and the geometry bounding box. */\r\n    size: Vec3\r\n    /** 3D position of the {@link DOMObject3D} relative to the camera field of view and size and the normalized coordinates. */\r\n    position: Vec3\r\n  }\r\n}\r\n\r\n/**\r\n * Defines all necessary {@link Vec3 | vectors}/{@link math/Quat.Quat | quaternions} to compute a 3D {@link math/Mat4.Mat4 | model matrix} based on a DOM {@link HTMLElement}\r\n */\r\nexport interface DOMObject3DTransforms extends Omit<Object3DTransforms, 'origin' | 'position'> {\r\n  /** Transformation origin object */\r\n  origin: {\r\n    /** Transformation origin {@link Vec3 | vector} relative to the {@link DOMObject3D} */\r\n    model: Vec3\r\n    /** Transformation origin {@link Vec3 | vector} relative to the 3D world */\r\n    world: Vec3\r\n  }\r\n  /** Position object */\r\n  position: {\r\n    /** Position {@link Vec3 | vector} relative to the 3D world */\r\n    world: Vec3\r\n    /** Additional translation {@link Vec3 | vector} relative to the DOM document */\r\n    document: Vec3\r\n  }\r\n}\r\n\r\n/**\r\n * Parameters used to create a {@link DOMObject3D}\r\n */\r\nexport interface DOMObject3DParams {\r\n  /** Whether to automatically update the {@link DOMObject3D} document and world positions on scroll */\r\n  watchScroll?: boolean\r\n}\r\n\r\n/**\r\n * This special kind of {@link ProjectedObject3D} uses an {@link HTMLElement} to convert the corresponding X and Y {@link DOMObject3D#scale | scale} and {@link DOMObject3D#position | position} relative to the 3D world space.\r\n *\r\n * Internally used by the {@link curtains/meshes/DOMMesh.DOMMesh | DOMMesh} and {@link curtains/meshes/Plane.Plane | Plane}, but can also be used as any {@link core/meshes/Mesh.Mesh | Mesh} {@link parent} to map it with an {@link HTMLElement} size and position values.\r\n */\r\nexport class DOMObject3D extends ProjectedObject3D {\r\n  /** {@link GPUCurtainsRenderer} used to create this {@link DOMObject3D} */\r\n  renderer: GPUCurtainsRenderer\r\n\r\n  /** Defines the {@link DOMObject3D} bounding boxes in both document and world spaces */\r\n  size: DOMObject3DSize\r\n  /** {@link DOMElement} used to track the given {@link HTMLElement} size change */\r\n  domElement: DOMElement\r\n\r\n  /** Whether to automatically update the {@link DOMObject3D} document and world positions on scroll */\r\n  watchScroll: boolean\r\n\r\n  /** {@link DOMObject3DTransforms | Transformation object} of the {@link DOMObject3D} */\r\n  transforms: DOMObject3DTransforms\r\n\r\n  /** Private {@link Vec3 | vector} used to keep track of the actual {@link DOMObject3DTransforms#position.world | world position} accounting the {@link DOMObject3DTransforms#position.document | additional document translation} converted into world space */\r\n  #DOMObjectWorldPosition: Vec3 = new Vec3()\r\n  /** Private {@link Vec3 | vector} used to keep track of the actual {@link DOMObject3D} world scale accounting the {@link DOMObject3D#size.world | DOMObject3D world size} */\r\n  #DOMObjectWorldScale: Vec3 = new Vec3(1)\r\n  /** Private number representing the scale ratio of the {@link DOMObject3D} along Z axis to apply. Since it can be difficult to guess the most accurate scale along the Z axis of an object mapped to 2D coordinates, this helps with adjusting the scale along the Z axis. */\r\n  #DOMObjectDepthScaleRatio: number = 1\r\n\r\n  /** Helper {@link Box3 | bounding box} used to map the 3D object onto the 2D DOM element. */\r\n  boundingBox: Box3 = new Box3(new Vec3(-1), new Vec3(1))\r\n\r\n  /** function assigned to the {@link onAfterDOMElementResize} callback */\r\n  _onAfterDOMElementResizeCallback: () => void = () => {\r\n    /* allow empty callback */\r\n  }\r\n\r\n  /**\r\n   * DOMObject3D constructor\r\n   * @param renderer - {@link GPUCurtainsRenderer} object or {@link GPUCurtains} class object used to create this {@link DOMObject3D}\r\n   * @param element - {@link HTMLElement} or string representing an {@link HTMLElement} selector used to scale and position the {@link DOMObject3D}\r\n   * @param parameters - {@link DOMObject3DParams | parameters} used to create this {@link DOMObject3D}\r\n   */\r\n  constructor(\r\n    renderer: GPUCurtainsRenderer | GPUCurtains,\r\n    element: DOMElementParams['element'],\r\n    parameters: DOMObject3DParams = {}\r\n  ) {\r\n    super(renderer)\r\n\r\n    renderer = isCurtainsRenderer(renderer, 'DOM3DObject')\r\n\r\n    this.renderer = renderer\r\n\r\n    this.size = {\r\n      shouldUpdate: true,\r\n      normalizedWorld: {\r\n        size: new Vec2(1),\r\n        position: new Vec2(),\r\n      },\r\n      cameraWorld: {\r\n        size: new Vec2(1),\r\n      },\r\n      scaledWorld: {\r\n        size: new Vec3(1),\r\n        position: new Vec3(),\r\n      },\r\n    }\r\n\r\n    this.watchScroll = parameters.watchScroll\r\n\r\n    this.camera = this.renderer.camera\r\n\r\n    this.boundingBox.min.onChange(() => this.shouldUpdateComputedSizes())\r\n    this.boundingBox.max.onChange(() => this.shouldUpdateComputedSizes())\r\n\r\n    this.setDOMElement(element)\r\n    ;(this.renderer as GPUCurtainsRenderer).domObjects.push(this)\r\n  }\r\n\r\n  /**\r\n   * Set the {@link domElement | DOM Element}\r\n   * @param element - {@link HTMLElement} or string representing an {@link HTMLElement} selector to use\r\n   */\r\n  setDOMElement(element: DOMElementParams['element']) {\r\n    this.domElement = new DOMElement({\r\n      element,\r\n      onSizeChanged: (boundingRect) => this.resize(boundingRect),\r\n      onPositionChanged: () => this.onPositionChanged(),\r\n    })\r\n\r\n    // eagerly set size and position\r\n    this.updateSizeAndPosition()\r\n  }\r\n\r\n  /**\r\n   * Update size and position when the {@link domElement | DOM Element} position changed\r\n   */\r\n  onPositionChanged() {\r\n    if (this.watchScroll) {\r\n      this.shouldUpdateComputedSizes()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset the {@link domElement | DOMElement}\r\n   * @param element - the new {@link HTMLElement} or string representing an {@link HTMLElement} selector to use\r\n   */\r\n  resetDOMElement(element: string | HTMLElement) {\r\n    if (this.domElement) {\r\n      this.domElement.destroy()\r\n    }\r\n\r\n    this.setDOMElement(element)\r\n  }\r\n\r\n  /**\r\n   * Resize the {@link DOMObject3D}\r\n   * @param boundingRect - new {@link domElement | DOM Element} {@link DOMElement#boundingRect | bounding rectangle}\r\n   */\r\n  resize(boundingRect: DOMElementBoundingRect | null = null) {\r\n    if (!boundingRect && (!this.domElement || this.domElement?.isResizing)) return\r\n\r\n    // update size and position eagerly on resize\r\n    // so we have new values in the callbacks\r\n    this.updateSizeAndPosition()\r\n\r\n    this._onAfterDOMElementResizeCallback && this._onAfterDOMElementResizeCallback()\r\n  }\r\n\r\n  /* BOUNDING BOXES GETTERS */\r\n\r\n  /**\r\n   * Get the {@link domElement | DOM Element} {@link DOMElement#boundingRect | bounding rectangle}\r\n   * @readonly\r\n   */\r\n  get boundingRect(): DOMElementBoundingRect {\r\n    return (\r\n      this.domElement?.boundingRect ?? {\r\n        width: 1,\r\n        height: 1,\r\n        top: 0,\r\n        right: 0,\r\n        bottom: 0,\r\n        left: 0,\r\n        x: 0,\r\n        y: 0,\r\n      }\r\n    )\r\n  }\r\n\r\n  /* TRANSFOMS */\r\n\r\n  /**\r\n   * Set our transforms properties and {@link Vec3#onChange | onChange vector} callbacks\r\n   */\r\n  setTransforms() {\r\n    super.setTransforms()\r\n\r\n    // reset our model transform origin to reflect CSS transform origins\r\n    this.transforms.origin.model.set(0.5, 0.5, 0)\r\n\r\n    this.transforms.origin.world = new Vec3()\r\n    this.transforms.position.document = new Vec3()\r\n\r\n    this.documentPosition.onChange(() => this.applyPosition())\r\n    this.transformOrigin.onChange(() => this.setWorldTransformOrigin())\r\n  }\r\n\r\n  /**\r\n   * Get the {@link DOMObject3DTransforms#position.document | additional translation relative to the document}\r\n   */\r\n  get documentPosition(): Vec3 {\r\n    return this.transforms.position.document\r\n  }\r\n\r\n  /**\r\n   * Set the {@link DOMObject3DTransforms#position.document | additional translation relative to the document}\r\n   * @param value - additional translation relative to the document to apply\r\n   */\r\n  set documentPosition(value: Vec3) {\r\n    this.transforms.position.document = value\r\n    this.applyPosition()\r\n  }\r\n\r\n  /**\r\n   * Get the {@link domElement | DOM element} scale in world space\r\n   * @readonly\r\n   */\r\n  get DOMObjectWorldScale(): Vec3 {\r\n    return this.#DOMObjectWorldScale.clone()\r\n  }\r\n\r\n  /**\r\n   * Get the {@link DOMObject3D} scale in world space (accounting for {@link scale})\r\n   * @readonly\r\n   */\r\n  get worldScale(): Vec3 {\r\n    return this.DOMObjectWorldScale.multiply(this.scale)\r\n  }\r\n\r\n  /**\r\n   * Get the {@link DOMObject3D} position in world space\r\n   * @readonly\r\n   */\r\n  get worldPosition(): Vec3 {\r\n    return this.#DOMObjectWorldPosition.clone()\r\n  }\r\n\r\n  /**\r\n   * Get the {@link DOMObject3D} transform origin relative to the {@link DOMObject3D}\r\n   */\r\n  get transformOrigin(): Vec3 {\r\n    return this.transforms.origin.model\r\n  }\r\n\r\n  /**\r\n   * Set the {@link DOMObject3D} transform origin relative to the {@link DOMObject3D}\r\n   * @param value - new transform origin\r\n   */\r\n  set transformOrigin(value: Vec3) {\r\n    this.transforms.origin.model = value\r\n    this.setWorldTransformOrigin()\r\n  }\r\n\r\n  /**\r\n   * Get the {@link DOMObject3D} transform origin in world space\r\n   */\r\n  get worldTransformOrigin(): Vec3 {\r\n    return this.transforms.origin.world\r\n  }\r\n\r\n  /**\r\n   * Set the {@link DOMObject3D} transform origin in world space\r\n   * @param value - new world space transform origin\r\n   */\r\n  set worldTransformOrigin(value: Vec3) {\r\n    this.transforms.origin.world = value\r\n  }\r\n\r\n  /**\r\n   * Check whether at least one of the matrix should be updated\r\n   */\r\n  shouldUpdateMatrices() {\r\n    super.shouldUpdateMatrices()\r\n\r\n    if (this.matricesNeedUpdate || this.size.shouldUpdate) {\r\n      this.updateSizeAndPosition()\r\n      this.matricesNeedUpdate = true\r\n    }\r\n\r\n    this.size.shouldUpdate = false\r\n  }\r\n\r\n  /**\r\n   * Set the {@link DOMObject3D#size.shouldUpdate | size shouldUpdate} flag to true to compute the new sizes before next matrices calculations.\r\n   */\r\n  shouldUpdateComputedSizes() {\r\n    this.size.shouldUpdate = true\r\n  }\r\n\r\n  /**\r\n   * Update the {@link DOMObject3D} sizes and position\r\n   */\r\n  updateSizeAndPosition() {\r\n    this.setWorldSizes()\r\n    this.applyDocumentPosition()\r\n    this.shouldUpdateModelMatrix()\r\n  }\r\n\r\n  /**\r\n   * Compute the {@link DOMObject3D} world position using its world position and document translation converted to world space\r\n   */\r\n  applyDocumentPosition() {\r\n    // avoid unnecessary calculations if we don't have a users set relative position\r\n    let worldPosition = new Vec3(0, 0, 0)\r\n    if (!this.documentPosition.equals(worldPosition)) {\r\n      worldPosition = this.documentToWorldSpace(this.documentPosition)\r\n    }\r\n\r\n    this.#DOMObjectWorldPosition.set(\r\n      this.position.x + this.size.scaledWorld.position.x + worldPosition.x,\r\n      this.position.y + this.size.scaledWorld.position.y + worldPosition.y,\r\n      this.position.z + this.size.scaledWorld.position.z + this.documentPosition.z / this.camera.CSSPerspective\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Apply the transform origin and set the {@link DOMObject3D} world transform origin\r\n   */\r\n  applyTransformOrigin() {\r\n    if (!this.size) return\r\n\r\n    this.setWorldTransformOrigin()\r\n\r\n    super.applyTransformOrigin()\r\n  }\r\n\r\n  /* MATRICES */\r\n\r\n  /**\r\n   * Update the {@link modelMatrix | model matrix} accounting the {@link DOMObject3D} world position and {@link DOMObject3D} world scale\r\n   */\r\n  updateModelMatrix() {\r\n    // override for this special case\r\n    // compose our model transformation matrix from custom origin\r\n    this.modelMatrix.composeFromOrigin(\r\n      this.#DOMObjectWorldPosition,\r\n      this.quaternion,\r\n      this.scale,\r\n      this.worldTransformOrigin\r\n    )\r\n\r\n    // we need to scale our meshes at least on X and Y axis, from a square to a right sized rectangle\r\n    // we're doing this after our transformation matrix because this scale transformation always have the same origin\r\n    this.modelMatrix.scale(this.DOMObjectWorldScale)\r\n\r\n    this.shouldUpdateWorldMatrix()\r\n  }\r\n\r\n  /**\r\n   * Convert a document position {@link Vec3 | vector} to a world position {@link Vec3 | vector}\r\n   * @param vector - document position {@link Vec3 | vector} converted to world space\r\n   */\r\n  documentToWorldSpace(vector: Vec3 = new Vec3()): Vec3 {\r\n    return new Vec3(\r\n      ((vector.x * this.renderer.pixelRatio) / this.renderer.boundingRect.width) * this.camera.visibleSize.width,\r\n      -((vector.y * this.renderer.pixelRatio) / this.renderer.boundingRect.height) * this.camera.visibleSize.height,\r\n      vector.z\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Compute the {@link DOMObject3D#size | world sizes}\r\n   */\r\n  computeWorldSizes() {\r\n    const containerBoundingRect = this.renderer.boundingRect\r\n\r\n    // dimensions and positions of our plane in the document and clip spaces\r\n    // don't forget positions in webgl space are referring to the center of our plane and canvas\r\n    const planeCenter = {\r\n      x: this.boundingRect.width / 2 + this.boundingRect.left,\r\n      y: this.boundingRect.height / 2 + this.boundingRect.top,\r\n    }\r\n\r\n    const containerCenter = {\r\n      x: containerBoundingRect.width / 2 + containerBoundingRect.left,\r\n      y: containerBoundingRect.height / 2 + containerBoundingRect.top,\r\n    }\r\n\r\n    // not always ranging from -1 to 1!\r\n    const { size, center } = this.boundingBox\r\n    if (size.x !== 0 && size.y !== 0 && size.z !== 0) {\r\n      center.divide(size)\r\n    }\r\n\r\n    // normalized world size represent the size ratio of the DOM element compared to its container (the renderer DOM element)\r\n    // in the [0, 1] range\r\n    this.size.normalizedWorld.size.set(\r\n      this.boundingRect.width / containerBoundingRect.width,\r\n      this.boundingRect.height / containerBoundingRect.height\r\n    )\r\n\r\n    // normalized world position represent the position of the DOM element compared to its container (the renderer DOM element)\r\n    // in the [-1, 1] range, [0, 0] being the center of the container\r\n    this.size.normalizedWorld.position.set(\r\n      (planeCenter.x - containerCenter.x) / containerBoundingRect.width,\r\n      (containerCenter.y - planeCenter.y) / containerBoundingRect.height\r\n    )\r\n\r\n    // camera world size and position are the normalized world size and positions accounting for camera screen ratio (visible height / width in world unit).\r\n    this.size.cameraWorld.size.set(\r\n      this.size.normalizedWorld.size.x * this.camera.visibleSize.width,\r\n      this.size.normalizedWorld.size.y * this.camera.visibleSize.height\r\n    )\r\n\r\n    // scaled world size and position are the camera world size and position scaled by the geometry bounding box\r\n    // because the geometry vertices do not always have a [-1, 1] range\r\n    this.size.scaledWorld.size.set(this.size.cameraWorld.size.x / size.x, this.size.cameraWorld.size.y / size.y, 1)\r\n\r\n    // Z size is based on Y component, because with a perspective camera, the width is based upon the height\r\n    // we could still adjust with #DOMObjectDepthScaleRatio\r\n    this.size.scaledWorld.size.z =\r\n      this.size.scaledWorld.size.y * (size.x / size.y / (this.boundingRect.width / this.boundingRect.height))\r\n\r\n    // our scaled world position is the normalized position multiplied by the camera screen ratio\r\n    this.size.scaledWorld.position.set(\r\n      this.size.normalizedWorld.position.x * this.camera.visibleSize.width,\r\n      this.size.normalizedWorld.position.y * this.camera.visibleSize.height,\r\n      0\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Compute and set the {@link DOMObject3D#size.world | world size} and set the {@link DOMObject3D} world transform origin\r\n   */\r\n  setWorldSizes() {\r\n    this.computeWorldSizes()\r\n    this.setWorldScale()\r\n    this.setWorldTransformOrigin()\r\n  }\r\n\r\n  /**\r\n   * Set the {@link worldScale} accounting for scaled world size and {@link DOMObjectDepthScaleRatio}\r\n   */\r\n  setWorldScale() {\r\n    this.#DOMObjectWorldScale.set(\r\n      this.size.scaledWorld.size.x,\r\n      this.size.scaledWorld.size.y,\r\n      this.size.scaledWorld.size.z * this.#DOMObjectDepthScaleRatio\r\n    )\r\n\r\n    this.shouldUpdateMatrixStack()\r\n  }\r\n\r\n  /**\r\n   * Set {@link DOMObjectDepthScaleRatio}. Since it can be difficult to guess the most accurate scale along the Z axis of an object mapped to 2D coordinates, this helps with adjusting the scale along the Z axis.\r\n   * @param value - depth scale ratio value to use\r\n   */\r\n  set DOMObjectDepthScaleRatio(value: number) {\r\n    this.#DOMObjectDepthScaleRatio = value\r\n\r\n    this.setWorldScale()\r\n  }\r\n\r\n  /**\r\n   * Set the {@link DOMObject3D} world transform origin and tell the matrices to update\r\n   */\r\n  setWorldTransformOrigin() {\r\n    // set transformation origin relative to world space as well\r\n    this.transforms.origin.world = new Vec3(\r\n      (this.transformOrigin.x * 2 - 1) * // between -1 and 1\r\n        this.#DOMObjectWorldScale.x,\r\n      -(this.transformOrigin.y * 2 - 1) * // between -1 and 1\r\n        this.#DOMObjectWorldScale.y,\r\n      this.transformOrigin.z * this.#DOMObjectWorldScale.z\r\n    )\r\n\r\n    this.shouldUpdateMatrixStack()\r\n  }\r\n\r\n  /**\r\n   * Update the {@link domElement | DOM Element} scroll position\r\n   * @param delta - last {@link utils/ScrollManager.ScrollManager.delta | scroll delta values}\r\n   */\r\n  updateScrollPosition(delta: DOMPosition = { x: 0, y: 0 }) {\r\n    // actually update the plane position only if last X delta or last Y delta is not equal to 0\r\n    if (delta.x || delta.y) {\r\n      // set new positions based on our delta without triggering reflow\r\n      this.domElement.updateScrollPosition(delta)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback to execute just after the {@link domElement} has been resized.\r\n   * @param callback - callback to run just after {@link domElement} has been resized\r\n   * @returns - our {@link DOMObject3D}\r\n   */\r\n  onAfterDOMElementResize(callback: () => void): DOMObject3D {\r\n    if (callback) {\r\n      this._onAfterDOMElementResizeCallback = callback\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Destroy our {@link DOMObject3D}\r\n   */\r\n  destroy() {\r\n    super.destroy()\r\n    this.domElement?.destroy()\r\n  }\r\n}\r\n","import { DOMObject3D } from '../objects3D/DOMObject3D'\r\nimport { isCurtainsRenderer } from '../../core/renderers/utils'\r\nimport { ProjectedMeshBaseMixin } from '../../core/meshes/mixins/ProjectedMeshBaseMixin'\r\nimport { MeshBaseRenderParams } from '../../core/meshes/mixins/MeshBaseMixin'\r\nimport { throwWarning } from '../../utils/utils'\r\nimport { GPUCurtainsRenderer } from '../renderers/GPUCurtainsRenderer'\r\nimport { GPUCurtains } from '../GPUCurtains'\r\nimport { DOMTexture } from '../../core/textures/DOMTexture'\r\nimport { AllowedGeometries } from '../../types/Materials'\r\nimport { DOMElementBoundingRect, DOMElementParams } from '../../core/DOM/DOMElement'\r\n\r\n/**\r\n * Base parameters to create a {@link DOMMesh}\r\n */\r\nexport interface DOMMeshBaseParams extends MeshBaseRenderParams {\r\n  /** Whether to automatically create a {@link DOMTexture} for all {@link HTMLImageElement}, {@link HTMLVideoElement} and {@link HTMLCanvasElement} child of the specified {@link DOMMesh} {@link HTMLElement} */\r\n  autoloadSources?: boolean\r\n  /** Whether to automatically update the {@link DOMMesh} position on scroll */\r\n  watchScroll?: boolean\r\n}\r\n\r\n/**\r\n * Parameters to create a {@link DOMMesh}\r\n */\r\nexport interface DOMMeshParams extends DOMMeshBaseParams {\r\n  /** {@link core/geometries/Geometry.Geometry | Geometry} to use with the {@link DOMMesh} */\r\n  geometry: AllowedGeometries\r\n}\r\n\r\n/** @const - default {@link DOMMesh} parameters */\r\nconst defaultDOMMeshParams = {\r\n  autoloadSources: true,\r\n  watchScroll: true,\r\n} as DOMMeshBaseParams\r\n\r\n/**\r\n * Create a {@link core/meshes/Mesh.Mesh | Mesh} based on a {@link DOMObject3D}, which allow the {@link core/meshes/Mesh.Mesh | Mesh} to be scaled and positioned based on a {@link HTMLElement} {@link DOMElementBoundingRect | bounding rectangle}.\r\n *\r\n * @example\r\n * ```javascript\r\n * // set our main GPUCurtains instance\r\n * const gpuCurtains = new GPUCurtains({\r\n *   container: '#canvas' // selector of our WebGPU canvas container\r\n * })\r\n *\r\n * // set the GPU device\r\n * // note this is asynchronous\r\n * await gpuCurtains.setDevice()\r\n *\r\n * // create a DOMMesh with a box geometry,\r\n * // assuming there's a HTML element with the \"mesh\" ID in the DOM\r\n * // will use the normals colors as default shading\r\n * const domMesh = new DOMMesh(gpuCurtains, '#mesh', {\r\n *   label: 'My DOM Mesh',\r\n *   geometry: new BoxGeometry(),\r\n * })\r\n * ```\r\n */\r\nexport class DOMMesh extends ProjectedMeshBaseMixin(DOMObject3D) {\r\n  /** {@link GPUCurtainsRenderer} used to create this {@link DOMObject3D} */\r\n  renderer: GPUCurtainsRenderer\r\n  /** Whether to automatically create a {@link DOMTexture} for all {@link HTMLImageElement}, {@link HTMLVideoElement} and {@link HTMLCanvasElement} child of the specified {@link DOMMesh} {@link HTMLElement} */\r\n  autoloadSources: boolean\r\n  /** Whether all the sources have been successfully loaded */\r\n  _sourcesReady: boolean\r\n\r\n  // callbacks / events\r\n  /** function assigned to the {@link onLoading} callback */\r\n  _onLoadingCallback = (texture: DOMTexture): void => {\r\n    /* allow empty callback */\r\n  }\r\n\r\n  /**\r\n   * DOMMesh constructor\r\n   * @param renderer - {@link GPUCurtainsRenderer} object or {@link GPUCurtains} class object used to create this {@link DOMMesh}\r\n   * @param element - {@link HTMLElement} or string representing an {@link HTMLElement} selector used to scale and position the {@link DOMMesh}\r\n   * @param parameters - {@link DOMMeshParams | parameters} used to create this {@link DOMMesh}\r\n   */\r\n  constructor(\r\n    renderer: GPUCurtainsRenderer | GPUCurtains,\r\n    element: DOMElementParams['element'],\r\n    parameters: DOMMeshParams\r\n  ) {\r\n    super(renderer, element, { ...defaultDOMMeshParams, ...parameters })\r\n\r\n    parameters = { ...defaultDOMMeshParams, ...parameters }\r\n\r\n    isCurtainsRenderer(renderer, parameters.label ? parameters.label + ' DOMMesh' : 'DOMMesh')\r\n\r\n    this.type = 'DOMMesh'\r\n\r\n    const { autoloadSources } = parameters\r\n\r\n    this.autoloadSources = autoloadSources\r\n\r\n    this.sourcesReady = false\r\n    this.setInitSources()\r\n  }\r\n\r\n  /**\r\n   * Get/set whether our {@link material} and {@link geometry} are ready\r\n   * @readonly\r\n   */\r\n  get ready(): boolean {\r\n    return this._ready\r\n  }\r\n\r\n  set ready(value: boolean) {\r\n    if (value && !this._ready && this.sourcesReady) {\r\n      this._onReadyCallback && this._onReadyCallback()\r\n    }\r\n\r\n    this._ready = value\r\n  }\r\n\r\n  /**\r\n   * Get/set whether all the initial {@link DOMMesh} sources have been successfully loaded\r\n   * @readonly\r\n   */\r\n  get sourcesReady(): boolean {\r\n    return this._sourcesReady\r\n  }\r\n\r\n  set sourcesReady(value: boolean) {\r\n    if (value && !this._sourcesReady && this.ready) {\r\n      this._onReadyCallback && this._onReadyCallback()\r\n    }\r\n\r\n    this._sourcesReady = value\r\n  }\r\n\r\n  /**\r\n   * Add a {@link DOMMesh} to the {@link core/scenes/Scene.Scene | Scene} and optionally to the renderer.\r\n   * @param addToRenderer - whether to add this {@link DOMMesh} to the {@link GPUCurtainsRenderer#meshes | renderer meshes array} and {@link GPUCurtainsRenderer#domMeshes | renderer domMeshes array}\r\n   */\r\n  addToScene(addToRenderer = false) {\r\n    super.addToScene(addToRenderer)\r\n\r\n    if (addToRenderer) {\r\n      ;(this.renderer as GPUCurtainsRenderer).domMeshes.push(this)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a {@link DOMMesh} from the {@link core/scenes/Scene.Scene | Scene} and optionally from the renderer as well.\r\n   * @param removeFromRenderer - whether to remove this {@link DOMMesh} from the {@link GPUCurtainsRenderer#meshes | renderer meshes array} and {@link GPUCurtainsRenderer#domMeshes | renderer domMeshes array}\r\n   */\r\n  removeFromScene(removeFromRenderer = false) {\r\n    super.removeFromScene(removeFromRenderer)\r\n\r\n    if (removeFromRenderer) {\r\n      ;(this.renderer as GPUCurtainsRenderer).domMeshes = (this.renderer as GPUCurtainsRenderer).domMeshes.filter(\r\n        (m) => m.uuid !== this.uuid\r\n      )\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load initial {@link DOMMesh} sources if needed and create associated {@link DOMTexture}\r\n   */\r\n  setInitSources() {\r\n    let loaderSize = 0\r\n    let sourcesLoaded = 0\r\n\r\n    if (this.autoloadSources) {\r\n      const images = this.domElement.element.querySelectorAll('img')\r\n      const videos = this.domElement.element.querySelectorAll('video')\r\n      const canvases = this.domElement.element.querySelectorAll('canvas')\r\n\r\n      loaderSize = images.length + videos.length + canvases.length\r\n\r\n      const onSourceUploaded = (texture) => {\r\n        sourcesLoaded++\r\n\r\n        this._onLoadingCallback && this._onLoadingCallback(texture)\r\n\r\n        if (sourcesLoaded === loaderSize) {\r\n          this.sourcesReady = true\r\n        }\r\n      }\r\n\r\n      if (!loaderSize) {\r\n        this.sourcesReady = true\r\n      }\r\n\r\n      // load images\r\n      if (images.length) {\r\n        images.forEach((image) => {\r\n          const texture = this.createDOMTexture({\r\n            name: image.getAttribute('data-texture-name') ?? 'texture' + this.domTextures.length,\r\n          })\r\n\r\n          texture.onSourceUploaded(() => onSourceUploaded(texture)).loadImage(image.src)\r\n        })\r\n      }\r\n\r\n      // load videos\r\n      if (videos.length) {\r\n        videos.forEach((video) => {\r\n          const texture = this.createDOMTexture({\r\n            name: video.getAttribute('data-texture-name') ?? 'texture' + this.domTextures.length,\r\n          })\r\n\r\n          texture.onSourceUploaded(() => onSourceUploaded(texture)).loadVideo(video)\r\n        })\r\n      }\r\n\r\n      // load canvases\r\n      if (canvases.length) {\r\n        canvases.forEach((canvas) => {\r\n          const texture = this.createDOMTexture({\r\n            name: canvas.getAttribute('data-texture-name') ?? 'texture' + this.domTextures.length,\r\n          })\r\n\r\n          texture.onSourceUploaded(() => onSourceUploaded(texture)).loadCanvas(canvas)\r\n        })\r\n      }\r\n    } else {\r\n      this.sourcesReady = true\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset/change the {@link domElement | DOM Element}\r\n   * @param element - new {@link HTMLElement} or string representing an {@link HTMLElement} selector to use\r\n   */\r\n  resetDOMElement(element: string | HTMLElement) {\r\n    if (!!element) {\r\n      super.resetDOMElement(element)\r\n    } else if (!element && !this.renderer.production) {\r\n      throwWarning(\r\n        `${this.options.label}: You are trying to reset a ${this.type} with a HTML element that does not exist. The old HTML element will be kept instead.`\r\n      )\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get our {@link DOMMesh#domElement | DOM Element} {@link core/DOM/DOMElement.DOMElement#boundingRect | bounding rectangle} accounting for current {@link core/renderers/GPURenderer.GPURenderer#pixelRatio | renderer pixel ratio}\r\n   */\r\n  get pixelRatioBoundingRect(): DOMElementBoundingRect {\r\n    const devicePixelRatio = window.devicePixelRatio ?? 1\r\n    const scaleBoundingRect = this.renderer.pixelRatio / devicePixelRatio\r\n\r\n    return Object.keys(this.domElement.boundingRect).reduce(\r\n      (a, key) => ({ ...a, [key]: this.domElement.boundingRect[key] * scaleBoundingRect }),\r\n      {\r\n        x: 0,\r\n        y: 0,\r\n        width: 0,\r\n        height: 0,\r\n        top: 0,\r\n        right: 0,\r\n        bottom: 0,\r\n        left: 0,\r\n      }\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Compute the Mesh geometry if needed\r\n   */\r\n  computeGeometry() {\r\n    super.computeGeometry()\r\n    this.boundingBox.copy(this.geometry.boundingBox)\r\n  }\r\n\r\n  /* EVENTS */\r\n\r\n  /**\r\n   * Called each time one of the initial sources associated {@link DOMTexture#texture | GPU texture} has been uploaded to the GPU\r\n   * @param callback - callback to call each time a {@link DOMTexture#texture | GPU texture} has been uploaded to the GPU\r\n   * @returns - our {@link DOMMesh}\r\n   */\r\n  onLoading(callback: (texture: DOMTexture) => void): DOMMesh {\r\n    if (callback) {\r\n      this._onLoadingCallback = callback\r\n    }\r\n\r\n    return this\r\n  }\r\n}\r\n","import { isCurtainsRenderer } from '../../core/renderers/utils'\r\nimport { PlaneGeometry, PlaneGeometryParams } from '../../core/geometries/PlaneGeometry'\r\nimport { DOMMesh, DOMMeshBaseParams, DOMMeshParams } from './DOMMesh'\r\nimport { Vec3 } from '../../math/Vec3'\r\nimport { Vec2 } from '../../math/Vec2'\r\nimport { cacheManager } from '../../utils/CacheManager'\r\nimport { GPUCurtainsRenderer } from '../renderers/GPUCurtainsRenderer'\r\nimport { GPUCurtains } from '../GPUCurtains'\r\nimport { DOMElementParams } from '../../core/DOM/DOMElement'\r\n\r\n/**\r\n * Parameters used to create a {@link Plane}\r\n */\r\nexport interface PlaneParams extends DOMMeshBaseParams, PlaneGeometryParams {\r\n  /** Optional {@link PlaneGeometry} to use */\r\n  geometry?: PlaneGeometry\r\n}\r\n\r\n/** @const - default {@link Plane} parameters */\r\nconst defaultPlaneParams = {\r\n  label: 'Plane',\r\n\r\n  // geometry\r\n  instancesCount: 1,\r\n  vertexBuffers: [],\r\n} as PlaneParams\r\n\r\n/**\r\n * Used to create a special {@link DOMMesh} class object using a {@link PlaneGeometry}.\r\n * This means a quad that looks like an ordinary {@link HTMLElement} but with WebGPU rendering capabilities.\r\n *\r\n * @example\r\n * ```javascript\r\n * // set our main GPUCurtains instance\r\n * const gpuCurtains = new GPUCurtains({\r\n *   container: '#canvas' // selector of our WebGPU canvas container\r\n * })\r\n *\r\n * // set the GPU device\r\n * // note this is asynchronous\r\n * await gpuCurtains.setDevice()\r\n *\r\n * // create a Plane,\r\n * // assuming there's a HTML element with the \"plane\" ID in the DOM\r\n * // will use the normals colors as default shading\r\n * const plane = new Plane(gpuCurtains, '#plane', {\r\n *   label: 'My plane',\r\n * })\r\n * ```\r\n */\r\nexport class Plane extends DOMMesh {\r\n  /**\r\n   * Plane constructor\r\n   * @param renderer - {@link GPUCurtainsRenderer} object or {@link GPUCurtains} class object used to create this {@link Plane}\r\n   * @param element - {@link HTMLElement} or string representing an {@link HTMLElement} selector used to scale and position the {@link Plane}\r\n   * @param parameters - {@link PlaneParams | parameters} used to create this {@link Plane}\r\n   */\r\n  constructor(\r\n    renderer: GPUCurtainsRenderer | GPUCurtains,\r\n    element: DOMElementParams['element'],\r\n    parameters = {} as PlaneParams\r\n  ) {\r\n    renderer = isCurtainsRenderer(renderer, parameters.label ? parameters.label + ' Plane' : 'Plane')\r\n\r\n    // assign default params if needed\r\n    const params = { ...defaultPlaneParams, ...parameters }\r\n\r\n    let { geometry, widthSegments, heightSegments, ...DOMMeshParams } = params\r\n    const { instancesCount, vertexBuffers, ...materialParams } = DOMMeshParams\r\n\r\n    // can we get a cached geometry?\r\n    if (!geometry || geometry.type !== 'PlaneGeometry') {\r\n      widthSegments = widthSegments ?? 1\r\n      heightSegments = heightSegments ?? 1\r\n\r\n      const geometryID = widthSegments * heightSegments + widthSegments\r\n\r\n      // if there's no additional vertex buffers, try to get a geometry from cache\r\n      if (!vertexBuffers.length) {\r\n        geometry = cacheManager.getPlaneGeometryByID(geometryID)\r\n      }\r\n\r\n      if (!geometry) {\r\n        // no cached plane geometry, we need to create a new one\r\n        geometry = new PlaneGeometry({ widthSegments, heightSegments, instancesCount, vertexBuffers })\r\n        cacheManager.addPlaneGeometry(geometry as PlaneGeometry)\r\n      } else {\r\n        // if geometry comes from cache, force instances count\r\n        geometry.instancesCount = instancesCount\r\n      }\r\n    }\r\n\r\n    // get DOMMesh params\r\n    super(renderer, element, { geometry, ...materialParams } as DOMMeshParams)\r\n\r\n    this.type = 'Plane'\r\n  }\r\n}\r\n","import { GPUCameraRenderer, GPUCameraRendererParams } from '../../core/renderers/GPUCameraRenderer'\r\nimport { DOMProjectedMesh } from '../../core/renderers/GPURenderer'\r\nimport { DOMObject3D } from '../objects3D/DOMObject3D'\r\n\r\n/**\r\n * This renderer just extends the {@link GPUCameraRenderer} by keeping track of all the created {@link curtains/meshes/DOMMesh.DOMMesh | DOM Meshes}\r\n *\r\n * @example\r\n * ```javascript\r\n * // first, we need a WebGPU device, that's what GPUDeviceManager is for\r\n * const gpuDeviceManager = new GPUDeviceManager({\r\n *   label: 'Custom device manager',\r\n * })\r\n *\r\n * // we need to wait for the WebGPU device to be created\r\n * await gpuDeviceManager.init()\r\n *\r\n * // then we can create a curtains renderer\r\n * const gpuCurtainsRenderer = new GPUCurtainsRenderer({\r\n *   deviceManager: gpuDeviceManager, // we need the WebGPU device to create the renderer context\r\n *   container: document.querySelector('#canvas'),\r\n * })\r\n * ```\r\n */\r\nexport class GPUCurtainsRenderer extends GPUCameraRenderer {\r\n  /** All created {@link curtains/meshes/DOMMesh.DOMMesh | DOM Meshes} and {@link curtains/meshes/Plane.Plane | planes} */\r\n  domMeshes: DOMProjectedMesh[]\r\n  /** All created {@link curtains/objects3D/DOMObject3D.DOMObject3D | DOMObject3D} which position should be updated on scroll. */\r\n  domObjects: DOMObject3D[]\r\n\r\n  /**\r\n   * GPUCurtainsRenderer constructor\r\n   * @param parameters - {@link GPUCameraRendererParams | parameters} used to create this {@link GPUCurtainsRenderer}\r\n   */\r\n  constructor({\r\n    deviceManager,\r\n    label,\r\n    container,\r\n    pixelRatio = 1,\r\n    autoResize = true,\r\n    preferredFormat,\r\n    alphaMode = 'premultiplied',\r\n    renderPass,\r\n    camera,\r\n    lights,\r\n  }: GPUCameraRendererParams) {\r\n    super({\r\n      deviceManager,\r\n      label,\r\n      container,\r\n      pixelRatio,\r\n      autoResize,\r\n      preferredFormat,\r\n      alphaMode,\r\n      renderPass,\r\n      camera,\r\n      lights,\r\n    } as GPUCameraRendererParams)\r\n\r\n    this.type = 'GPUCurtainsRenderer'\r\n  }\r\n\r\n  /**\r\n   * Add the {@link GPUCurtainsRenderer#domMeshes | domMeshes} to our tracked elements\r\n   */\r\n  setRendererObjects() {\r\n    super.setRendererObjects()\r\n\r\n    this.domMeshes = []\r\n    this.domObjects = []\r\n  }\r\n\r\n  /**\r\n   * Update the {@link domObjects} sizes and positions when the {@link camera} {@link core/camera/Camera.Camera#position | position} or {@link core/camera/Camera.Camera#size | size} change.\r\n   */\r\n  onCameraMatricesChanged() {\r\n    super.onCameraMatricesChanged()\r\n\r\n    this.domObjects.forEach((domObject) => {\r\n      domObject.updateSizeAndPosition()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Resize the {@link meshes}.\r\n   */\r\n  resizeMeshes() {\r\n    this.meshes.forEach((mesh) => {\r\n      if (!('domElement' in mesh)) {\r\n        // resize meshes that do not have a bound DOM element\r\n        mesh.resize(this.boundingRect)\r\n      }\r\n    })\r\n\r\n    // resize dom objects as well\r\n    this.domObjects.forEach((domObject) => {\r\n      // update position for DOM objects only if they're not currently being resized\r\n      if (!domObject.domElement.isResizing) {\r\n        domObject.domElement.setSize()\r\n      }\r\n    })\r\n  }\r\n}\r\n","import { DOMPosition } from '../core/DOM/DOMElement'\r\n\r\n/**\r\n * Parameters used to create a {@link ScrollManager}\r\n */\r\nexport interface ScrollManagerParams {\r\n  /** Current scroll position */\r\n  scroll?: DOMPosition\r\n  /** Last scroll deltas */\r\n  delta?: DOMPosition\r\n  /** Whether the {@link ScrollManager} should listen to the window scroll event or not */\r\n  shouldWatch?: boolean\r\n  /** Callback to execute each time the {@link ScrollManager#scroll | scroll} values change */\r\n  onScroll?: (delta?: DOMPosition) => void\r\n}\r\n\r\n/**\r\n * Used to keep track of our scroll position, scroll deltas and trigger an onScroll callback.<br>\r\n * Could either listen to the native scroll event or be hooked to any scroll (natural or virtual) scroll event\r\n */\r\nexport class ScrollManager {\r\n  /** Current scroll position */\r\n  scroll: DOMPosition\r\n  /** Last scroll deltas */\r\n  delta: DOMPosition\r\n  /** Whether the {@link ScrollManager} should listen to the window scroll event or not */\r\n  shouldWatch: boolean\r\n  /** Callback to execute each time the {@link scroll} values change */\r\n  onScroll: (delta?: DOMPosition) => void\r\n\r\n  /**\r\n   * ScrollManager constructor\r\n   * @param parameters - {@link ScrollManagerParams | parameters} used to create this {@link ScrollManager}\r\n   */\r\n  constructor({\r\n    scroll = { x: 0, y: 0 },\r\n    delta = { x: 0, y: 0 },\r\n    shouldWatch = true,\r\n    onScroll = (delta: DOMPosition = { x: 0, y: 0 }) => {\r\n      /* allow empty callback */\r\n    },\r\n  }: ScrollManagerParams = {}) {\r\n    this.scroll = scroll\r\n    this.delta = delta\r\n\r\n    this.shouldWatch = shouldWatch\r\n\r\n    this.onScroll = onScroll\r\n\r\n    if (this.shouldWatch) {\r\n      window.addEventListener('scroll', this.setScroll.bind(this), { passive: true })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called by the scroll event listener\r\n   */\r\n  setScroll() {\r\n    this.updateScrollValues({ x: window.pageXOffset, y: window.pageYOffset })\r\n  }\r\n\r\n  /**\r\n   * Updates the scroll manager X and Y scroll values as well as last X and Y deltas\r\n   * Internally called by the scroll event listener\r\n   * Could be called externally as well if the user wants to handle the scroll by himself\r\n   * @param parameters - {@link core/DOM/DOMElement.DOMPosition | scroll values}\r\n   */\r\n  updateScrollValues({ x, y }: DOMPosition) {\r\n    // get our scroll delta values\r\n    const lastScroll = this.scroll\r\n    this.scroll = { x, y }\r\n    this.delta = {\r\n      x: lastScroll.x - this.scroll.x,\r\n      y: lastScroll.y - this.scroll.y,\r\n    }\r\n\r\n    if (this.onScroll) {\r\n      this.onScroll(this.delta)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroy our scroll manager (just remove our event listner if it had been added previously)\r\n   */\r\n  destroy() {\r\n    if (this.shouldWatch) {\r\n      // passive triggers a typescript error\r\n      // https://github.com/microsoft/TypeScript/issues/32912#issuecomment-522142969\r\n      window.removeEventListener('scroll', this.setScroll.bind(this), { passive: true } as AddEventListenerOptions &\r\n        EventListenerOptions)\r\n    }\r\n  }\r\n}\r\n","import { GPUCurtainsRenderer } from './renderers/GPUCurtainsRenderer'\nimport { ScrollManager } from '../utils/ScrollManager'\nimport { resizeManager } from '../utils/ResizeManager'\nimport { PingPongPlane } from '../extras/meshes/PingPongPlane'\nimport { ShaderPass } from '../core/renderPasses/ShaderPass'\nimport { GPURenderer, GPURendererParams, SceneStackedMesh } from '../core/renderers/GPURenderer'\nimport { DOMMesh } from './meshes/DOMMesh'\nimport { Plane } from './meshes/Plane'\nimport { ComputePass } from '../core/computePasses/ComputePass'\nimport { DOMElementBoundingRect, DOMElementParams, DOMPosition } from '../core/DOM/DOMElement'\nimport { GPUCameraRenderer, GPUCameraRendererParams } from '../core/renderers/GPUCameraRenderer'\nimport {\n  GPUDeviceManager,\n  GPUDeviceManagerBaseParams,\n  GPUDeviceManagerSetupParams,\n} from '../core/renderers/GPUDeviceManager'\nimport { Renderer } from '../core/renderers/utils'\nimport { DOMObject3D } from './objects3D/DOMObject3D'\n\n/**\n * Options used to create a {@link GPUCurtains}\n */\nexport interface GPUCurtainsOptions extends Omit<GPUCameraRendererParams, 'deviceManager'>, GPUDeviceManagerBaseParams {\n  /** Whether {@link GPUCurtains} should create its own requestAnimationFrame loop to render or not */\n  autoRender?: boolean\n  /** Whether {@link GPUCurtains} should handle all resizing by itself or not */\n  autoResize?: boolean\n  /** Whether {@link GPUCurtains} should listen to scroll event or not */\n  watchScroll?: boolean\n}\n\n/**\n * Parameters used to create a {@link GPUCurtains}\n */\nexport interface GPUCurtainsParams extends Partial<Omit<GPUCurtainsOptions, 'container'>> {\n  /** {@link HTMLElement} or string representing an {@link HTMLElement} selector that will hold the WebGPU {@link HTMLCanvasElement}. Could be set later if not specified. */\n  container?: string | HTMLElement | null\n}\n\n/**\n * Used as a global class to create a {@link GPUCurtainsRenderer}, create all objects that need a reference to a renderer, listen to various events such as scroll and resize and render.\n *\n * @example\n * ```javascript\n * // set our main GPUCurtains instance\n * const gpuCurtains = new GPUCurtains({\n *   container: '#canvas' // selector of our WebGPU canvas container\n * })\n *\n * // set the GPU device\n * // note this is asynchronous\n * await gpuCurtains.setDevice()\n * ```\n */\nexport class GPUCurtains {\n  /** The type of this {@link GPUCurtains} */\n  type: string\n  /** Options used to create this {@link GPUCurtains} */\n  options: GPUCurtainsOptions\n  /** {@link HTMLElement} that will hold the WebGPU {@link HTMLCanvasElement} */\n  container: HTMLElement\n\n  /** {@link GPUDeviceManager} used to handle the {@link GPUAdapter} and {@link GPUDevice} */\n  deviceManager: GPUDeviceManager\n\n  /** Tiny scroll event listener wrapper */\n  scrollManager: ScrollManager\n\n  /** Request animation frame callback returned id if used */\n  animationFrameID: null | number\n\n  // callbacks / events\n  /** function assigned to the {@link onRender} callback */\n  _onRenderCallback: () => void = () => {\n    /* allow empty callback */\n  }\n  /** function assigned to the {@link onScroll} callback */\n  _onScrollCallback: () => void = () => {\n    /* allow empty callback */\n  }\n  /** function assigned to the {@link onError} callback */\n  _onErrorCallback: () => void = () => {\n    /* allow empty callback */\n  }\n  /** function assigned to the {@link onContextLost} callback */\n  _onContextLostCallback: (info?: GPUDeviceLostInfo) => void = () => {\n    /* allow empty callback */\n  }\n\n  /**\n   * GPUCurtains constructor\n   * @param parameters - {@link GPUCurtainsParams | parameters} used to create this {@link GPUCurtains}\n   */\n  constructor({\n    container,\n    label,\n    pixelRatio = window.devicePixelRatio ?? 1,\n    preferredFormat,\n    alphaMode = 'premultiplied',\n    production = false,\n    adapterOptions = {},\n    renderPass,\n    camera,\n    lights,\n    autoRender = true,\n    autoResize = true,\n    watchScroll = true,\n  }: GPUCurtainsParams = {}) {\n    this.type = 'CurtainsGPU'\n\n    this.options = {\n      container,\n      label,\n      pixelRatio,\n      camera,\n      lights,\n      production,\n      adapterOptions,\n      preferredFormat,\n      alphaMode,\n      renderPass,\n      autoRender,\n      autoResize,\n      watchScroll,\n    }\n\n    this.setDeviceManager()\n\n    if (container) {\n      this.setContainer(container)\n    }\n\n    this.initEvents()\n\n    // only if auto render\n    if (this.options.autoRender) {\n      this.animate()\n    }\n  }\n\n  /**\n   * Set the {@link container}\n   * @param container - {@link HTMLElement} or string representing an {@link HTMLElement} selector to use\n   */\n  setContainer(container: DOMElementParams['element']) {\n    if (!container) {\n      const container = document.createElement('div')\n      container.setAttribute('id', 'curtains-gpu-canvas')\n      document.body.appendChild(container)\n      this.options.container = container\n    } else {\n      if (typeof container === 'string') {\n        container = document.querySelector(container)\n\n        if (!container) {\n          const container = document.createElement('div')\n          container.setAttribute('id', 'curtains-gpu-canvas')\n          document.body.appendChild(container)\n          this.options.container = container\n        } else {\n          this.options.container = container as HTMLElement\n        }\n      } else if (container instanceof Element) {\n        this.options.container = container as HTMLElement\n      }\n    }\n\n    this.container = this.options.container as HTMLElement\n\n    this.setMainRenderer()\n  }\n\n  /**\n   * Set the default {@link GPUCurtainsRenderer | renderer}\n   */\n  setMainRenderer() {\n    this.createCurtainsRenderer({\n      deviceManager: this.deviceManager,\n      // TODO ...this.options?\n      label: this.options.label || 'GPUCurtains main GPUCurtainsRenderer',\n      container: this.options.container,\n      pixelRatio: this.options.pixelRatio,\n      autoResize: this.options.autoResize,\n      preferredFormat: this.options.preferredFormat,\n      alphaMode: this.options.alphaMode,\n      renderPass: this.options.renderPass,\n      camera: this.options.camera,\n      lights: this.options.lights,\n    })\n  }\n\n  /**\n   * Patch the options with default values before creating a {@link Renderer}\n   * @param parameters - parameters to patch\n   */\n  patchRendererOptions<T extends GPURendererParams | GPUCameraRendererParams>(parameters: T): T {\n    if (parameters.pixelRatio === undefined) parameters.pixelRatio = this.options.pixelRatio\n    if (parameters.autoResize === undefined) parameters.autoResize = this.options.autoResize\n\n    return parameters\n  }\n\n  /**\n   * Create a new {@link GPURenderer} instance\n   * @param parameters - {@link GPURendererParams | parameters} to use\n   */\n  createRenderer(parameters: GPURendererParams): GPURenderer {\n    parameters = this.patchRendererOptions(parameters)\n\n    return new GPURenderer({ ...parameters, deviceManager: this.deviceManager })\n  }\n\n  /**\n   * Create a new {@link GPUCameraRenderer} instance\n   * @param parameters - {@link GPUCameraRendererParams | parameters} to use\n   */\n  createCameraRenderer(parameters: GPUCameraRendererParams): GPUCameraRenderer {\n    parameters = this.patchRendererOptions(parameters)\n\n    return new GPUCameraRenderer({ ...parameters, deviceManager: this.deviceManager })\n  }\n\n  /**\n   * Create a new {@link GPUCurtainsRenderer} instance\n   * @param parameters - {@link GPUCameraRendererParams | parameters} to use\n   */\n  createCurtainsRenderer(parameters: GPUCameraRendererParams): GPUCurtainsRenderer {\n    parameters = this.patchRendererOptions(parameters)\n\n    return new GPUCurtainsRenderer({ ...parameters, deviceManager: this.deviceManager })\n  }\n\n  /**\n   * Set our {@link GPUDeviceManager}\n   */\n  setDeviceManager() {\n    this.deviceManager = new GPUDeviceManager({\n      label: 'GPUCurtains default device',\n      production: this.options.production,\n      adapterOptions: this.options.adapterOptions,\n      onError: () =>\n        setTimeout(() => {\n          this._onErrorCallback && this._onErrorCallback()\n        }, 0),\n      onDeviceLost: (info) => this._onContextLostCallback && this._onContextLostCallback(info),\n    })\n  }\n\n  /**\n   * Get all created {@link Renderer}\n   * @readonly\n   */\n  get renderers(): Renderer[] {\n    return this.deviceManager.renderers\n  }\n\n  /**\n   * Get the first created {@link Renderer} if any\n   * @readonly\n   */\n  get renderer(): Renderer | undefined {\n    return this.renderers[0]\n  }\n\n  /**\n   * Set the {@link GPUDeviceManager} {@link GPUDeviceManager#adapter | adapter} and {@link GPUDeviceManager#device | device} if possible, then set all created {@link Renderer} contexts.\n   * @async\n   * @param parameters - {@link GPUAdapter} and/or {@link GPUDevice} to use if set.\n   */\n  async setDevice({ adapter = null, device = null }: GPUDeviceManagerSetupParams = {}) {\n    await this.deviceManager.init({ adapter, device })\n  }\n\n  /**\n   * Restore the {@link GPUDeviceManager#adapter | adapter} and {@link GPUDeviceManager#device | device}\n   * @async\n   */\n  async restoreContext() {\n    await this.deviceManager.restoreDevice()\n  }\n\n  /* RENDERER TRACKED OBJECTS */\n\n  /**\n   * Get all the created {@link PingPongPlane}\n   * @readonly\n   */\n  get pingPongPlanes(): PingPongPlane[] {\n    return this.renderers?.map((renderer) => renderer.pingPongPlanes).flat()\n  }\n\n  /**\n   * Get all the created {@link ShaderPass}\n   * @readonly\n   */\n  get shaderPasses(): ShaderPass[] {\n    return this.renderers?.map((renderer) => renderer.shaderPasses).flat()\n  }\n\n  /**\n   * Get all the created {@link SceneStackedMesh | meshes}\n   * @readonly\n   */\n  get meshes(): SceneStackedMesh[] {\n    return this.renderers?.map((renderer) => renderer.meshes).flat()\n  }\n\n  /**\n   * Get all the created {@link DOMMesh | DOM Meshes} (including {@link Plane | planes})\n   * @readonly\n   */\n  get domMeshes(): DOMMesh[] {\n    return this.renderers\n      ?.filter((renderer) => renderer instanceof GPUCurtainsRenderer)\n      .map((renderer: GPUCurtainsRenderer) => renderer.domMeshes)\n      .flat()\n  }\n\n  /**\n   * Get all created {@link curtains/objects3D/DOMObject3D.DOMObject3D | DOMObject3D} which position should be updated on scroll.\n   * @readonly\n   */\n  get domObjects(): DOMObject3D[] {\n    return this.renderers\n      ?.filter((renderer) => renderer instanceof GPUCurtainsRenderer)\n      .map((renderer: GPUCurtainsRenderer) => renderer.domObjects)\n      .flat()\n  }\n\n  /**\n   * Get all the created {@link Plane | planes}\n   * @readonly\n   */\n  get planes(): Plane[] {\n    return this.domMeshes.filter((domMesh) => domMesh instanceof Plane) as Plane[]\n  }\n\n  /**\n   * Get all the created {@link ComputePass | compute passes}\n   * @readonly\n   */\n  get computePasses(): ComputePass[] {\n    return this.renderers?.map((renderer) => renderer.computePasses).flat()\n  }\n\n  /**\n   * Get our {@link GPUCurtainsRenderer#setPerspective | default GPUCurtainsRenderer bounding rectangle}\n   */\n  get boundingRect(): DOMElementBoundingRect {\n    return this.renderer?.boundingRect\n  }\n\n  /* SCROLL */\n\n  /**\n   * Set the {@link scrollManager}\n   */\n  initScroll() {\n    this.scrollManager = new ScrollManager({\n      // init values\n      scroll: {\n        x: window.pageXOffset,\n        y: window.pageYOffset,\n      },\n      delta: {\n        x: 0,\n        y: 0,\n      },\n      shouldWatch: this.options.watchScroll,\n      onScroll: (delta) => this.updateScroll(delta),\n    })\n  }\n\n  /**\n   * Update all {@link DOMMesh#updateScrollPosition | DOMMesh scroll positions}\n   * @param delta - last {@link ScrollManager#delta | scroll delta values}\n   */\n  updateScroll(delta: DOMPosition = { x: 0, y: 0 }) {\n    this.domObjects.forEach((domObject) => {\n      if (domObject.domElement && domObject.watchScroll) {\n        domObject.updateScrollPosition(delta)\n      }\n    })\n\n    this._onScrollCallback && this._onScrollCallback()\n  }\n\n  /**\n   * Update our {@link ScrollManager#scroll | scrollManager scroll values}. Called each time the scroll has changed if {@link GPUCurtains#options.watchScroll | watchScroll option} is set to true. Could be called externally as well.\n   * @param scroll - new {@link DOMPosition | scroll values}\n   */\n  updateScrollValues(scroll: DOMPosition = { x: 0, y: 0 }) {\n    this.scrollManager.updateScrollValues(scroll)\n  }\n\n  /**\n   * Get our {@link ScrollManager#delta | scrollManager delta values}\n   * @readonly\n   */\n  get scrollDelta(): DOMPosition {\n    return this.scrollManager.delta\n  }\n\n  /**\n   * Get our {@link ScrollManager#scroll | scrollManager scroll values}\n   * @readonly\n   */\n  get scrollValues(): DOMPosition {\n    return this.scrollManager.scroll\n  }\n\n  /* EVENT LISTENERS */\n\n  /**\n   * Set the resize and scroll event listeners\n   */\n  initEvents() {\n    resizeManager.useObserver(this.options.autoResize)\n\n    this.initScroll()\n  }\n\n  /* EVENTS */\n\n  /**\n   * Called at each render frame\n   * @param callback - callback to run at each render\n   * @returns - our {@link GPUCurtains}\n   */\n  onRender(callback: () => void): GPUCurtains {\n    if (callback) {\n      this._onRenderCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Called each time the {@link ScrollManager#scroll | scrollManager scroll values} changed\n   * @param callback - callback to run each time the {@link ScrollManager#scroll | scrollManager scroll values} changed\n   * @returns - our {@link GPUCurtains}\n   */\n  onScroll(callback: () => void): GPUCurtains {\n    if (callback) {\n      this._onScrollCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Called if there's been an error while trying to create the {@link GPUDeviceManager#device | device}\n   * @param callback - callback to run if there's been an error while trying to create the {@link GPUDeviceManager#device | device}\n   * @returns - our {@link GPUCurtains}\n   */\n  onError(callback: () => void): GPUCurtains {\n    if (callback) {\n      this._onErrorCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Called whenever the {@link GPUDeviceManager#device | device} is lost\n   * @param callback - callback to run whenever the {@link GPUDeviceManager#device | device} is lost\n   * @returns - our {@link GPUCurtains}\n   */\n  onContextLost(callback: (info?: GPUDeviceLostInfo) => void): GPUCurtains {\n    if (callback) {\n      this._onContextLostCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Create a requestAnimationFrame loop and run it\n   */\n  animate() {\n    this.render()\n    this.animationFrameID = window.requestAnimationFrame(this.animate.bind(this))\n  }\n\n  /**\n   * Render our {@link GPUDeviceManager}\n   */\n  render() {\n    this._onRenderCallback && this._onRenderCallback()\n\n    this.deviceManager.render()\n  }\n\n  /**\n   * Destroy our {@link GPUCurtains} and {@link GPUDeviceManager}\n   */\n  destroy() {\n    if (this.animationFrameID) {\n      window.cancelAnimationFrame(this.animationFrameID)\n    }\n\n    this.deviceManager.destroy()\n    this.scrollManager?.destroy()\n    resizeManager.destroy()\n  }\n}\n","import { Camera } from '../../core/camera/Camera'\nimport { Vec2 } from '../../math/Vec2'\nimport { Vec3 } from '../../math/Vec3'\nimport { throwWarning } from '../../utils/utils'\n\n// largely based on https://github.com/oframe/ogl/blob/master/src/extras/Orbit.js\n\nconst tempVec2a = new Vec2()\nconst tempVec2b = new Vec2()\nconst tempVec3 = new Vec3()\n\n/** Defines the base parameters used to set / reset an {@link OrbitControls}. */\nexport interface OrbitControlsBaseParams {\n  /** The {@link Vec3 | focus point} or the {@link OrbitControls}. */\n  target?: Vec3\n  // zoom\n  /** Whether to allow zooming or not. */\n  enableZoom?: boolean\n  /** Minimum zoom value to use. */\n  minZoom?: number\n  /** Maximum zoom value to use. */\n  maxZoom?: number\n  /** Zoom speed value to use. */\n  zoomSpeed?: number\n  // rotate\n  /** Whether to allow rotating or not. */\n  enableRotate?: boolean\n  /** Minimum angle to use for vertical rotation. */\n  minPolarAngle?: number\n  /** Maximum angle to use for vertical rotation. */\n  maxPolarAngle?: number\n  /** Minimum angle to use for horizontal rotation. */\n  minAzimuthAngle?: number\n  /** Maximum angle to use for horizontal rotation. */\n  maxAzimuthAngle?: number\n  /** Rotate speed value to use. */\n  rotateSpeed?: number\n  // pan\n  /** Whether to allow paning or not. */\n  enablePan?: boolean\n  /** Pan speed value to use. */\n  panSpeed?: number\n}\n\n/** Defines base parameters used to create an {@link OrbitControls}. */\nexport interface OrbitControlsParams extends OrbitControlsBaseParams {\n  /** Optional {@link Camera} to use. */\n  camera?: Camera\n  /** Optional {@link HTMLElement} (or {@link Window} element) to use for event listeners. */\n  element?: HTMLElement | Window\n}\n\n/**\n * Helper to create orbit camera controls (sometimes called arc ball camera).\n *\n * @example\n * ```javascript\n * // assuming renderer is a valid CameraRenderer\n * const { camera } = renderer\n * const orbitControls = new OrbitControls({ camera })\n * ```\n */\nexport class OrbitControls {\n  /** {@link Camera} to use with this {@link OrbitControls}. */\n  camera: Camera\n\n  /**\n   * {@link HTMLElement} (or {@link Window} element) to use for event listeners.\n   * @private\n   */\n  #element = null\n\n  /** The {@link Vec3 | focus point} or the {@link OrbitControls}. Default to `Vec3(0)`. */\n  target: Vec3\n\n  /** @ignore */\n  #offset = new Vec3()\n\n  /** Whether to allow zooming or not. Default to `true`. */\n  enableZoom: boolean\n  /** Minimum zoom value to use. Default to `0`. */\n  minZoom: number\n  /** Maximum zoom value to use. Default to `Infinity`. */\n  maxZoom: number\n  /** Zoom speed value to use. Default to `1`. */\n  zoomSpeed: number\n\n  /** Whether to allow rotating or not. Default to `true`. */\n  enableRotate: boolean\n  /** Minimum angle to use for vertical rotation. Default to `0`. */\n  minPolarAngle: number\n  /** Maximum angle to use for vertical rotation. Default to `Math.PI`. */\n  maxPolarAngle: number\n  /** Minimum angle to use for horizontal rotation. Default to `-Infinity`. */\n  minAzimuthAngle: number\n  /** Maximum angle to use for horizontal rotation. Default to `Infinity`. */\n  maxAzimuthAngle: number\n  /** Rotate speed value to use. Default to `1`. */\n  rotateSpeed: number\n  /** @ignore */\n  #isOrbiting = false\n  /** @ignore */\n  #spherical = { radius: 1, phi: 0, theta: 0 }\n  /** @ignore */\n  #rotateStart = new Vec2()\n\n  /** Whether to allow paning or not. Default to `true`. */\n  enablePan: boolean\n  /** Pan speed value to use. Default to `1`. */\n  panSpeed: number\n  /** @ignore */\n  #isPaning = false\n  /** @ignore */\n  #panStart = new Vec2()\n  /** @ignore */\n  #panDelta = new Vec3()\n\n  /**\n   * OrbitControls constructor\n=   * @param parameters - parameters to use.\n   */\n  constructor({\n    camera,\n    element = null,\n    target = new Vec3(),\n    // zoom\n    enableZoom = true,\n    minZoom = 0,\n    maxZoom = Infinity,\n    zoomSpeed = 1,\n    // rotate\n    enableRotate = true,\n    minPolarAngle = 0,\n    maxPolarAngle = Math.PI,\n    minAzimuthAngle = -Infinity,\n    maxAzimuthAngle = Infinity,\n    rotateSpeed = 1,\n    // pan\n    enablePan = true,\n    panSpeed = 1,\n  }: OrbitControlsParams) {\n    if (!camera) {\n      throwWarning('OrbitControls: cannot initialize without a camera.')\n      return\n    }\n\n    // options\n    this.#setBaseParams({\n      target,\n      enableZoom,\n      minZoom,\n      maxZoom,\n      zoomSpeed,\n      enableRotate,\n      minPolarAngle,\n      maxPolarAngle,\n      minAzimuthAngle,\n      maxAzimuthAngle,\n      rotateSpeed,\n      enablePan,\n      panSpeed,\n    })\n\n    this.element = element ?? (typeof window !== 'undefined' ? window : null)\n\n    this.useCamera(camera)\n  }\n\n  /**\n   * Allow to set or reset this {@link OrbitControls#camera | OrbitControls camera}.\n   * @param camera - New {@link camera} to use.\n   */\n  useCamera(camera: Camera) {\n    this.camera = camera\n\n    this.camera.position.onChange(() => {\n      this.camera.lookAt(this.target)\n    })\n\n    // Grab initial position values\n    this.#offset.copy(this.camera.position).sub(this.target)\n    this.#spherical.radius = this.#offset.length()\n    this.#spherical.theta = Math.atan2(this.#offset.x, this.#offset.z)\n    this.#spherical.phi = Math.acos(Math.min(Math.max(this.#offset.y / this.#spherical.radius, -1), 1))\n\n    this.#update()\n  }\n\n  /**\n   * Set / reset base params\n   * @ignore\n   */\n  #setBaseParams({\n    target,\n    // zoom\n    enableZoom = this.enableZoom,\n    minZoom = this.minZoom,\n    maxZoom = this.maxZoom,\n    zoomSpeed = this.zoomSpeed,\n    // rotate\n    enableRotate = this.enableRotate,\n    minPolarAngle = this.minPolarAngle,\n    maxPolarAngle = this.maxPolarAngle,\n    minAzimuthAngle = this.minAzimuthAngle,\n    maxAzimuthAngle = this.maxAzimuthAngle,\n    rotateSpeed = this.rotateSpeed,\n    // pan\n    enablePan = this.enablePan,\n    panSpeed = this.panSpeed,\n  }: OrbitControlsBaseParams = {}) {\n    if (target) {\n      this.target = target\n    }\n\n    this.enableZoom = enableZoom\n    this.minZoom = minZoom\n    this.maxZoom = maxZoom\n    this.zoomSpeed = zoomSpeed\n\n    this.enableRotate = enableRotate\n    this.minPolarAngle = minPolarAngle\n    this.maxPolarAngle = maxPolarAngle\n    this.minAzimuthAngle = minAzimuthAngle\n    this.maxAzimuthAngle = maxAzimuthAngle\n    this.rotateSpeed = rotateSpeed\n\n    this.enablePan = enablePan\n    this.panSpeed = panSpeed\n  }\n\n  /**\n   * Reset the {@link OrbitControls} values.\n   * @param parameters - Parameters used to reset the values. Those are the same as {@link OrbitControlsBaseParams} with an additional position parameter to allow to override the {@link OrbitControls} position.\n   */\n  reset({\n    position,\n    target,\n    // zoom\n    enableZoom = this.enableZoom,\n    minZoom = this.minZoom,\n    maxZoom = this.maxZoom,\n    zoomSpeed = this.zoomSpeed,\n    // rotate\n    enableRotate = this.enableRotate,\n    minPolarAngle = this.minPolarAngle,\n    maxPolarAngle = this.maxPolarAngle,\n    minAzimuthAngle = this.minAzimuthAngle,\n    maxAzimuthAngle = this.maxAzimuthAngle,\n    rotateSpeed = this.rotateSpeed,\n    // pan\n    enablePan = this.enablePan,\n    panSpeed = this.panSpeed,\n  }: { position?: Vec3 } & OrbitControlsBaseParams = {}) {\n    this.#setBaseParams({\n      target,\n      enableZoom,\n      minZoom,\n      maxZoom,\n      zoomSpeed,\n      enableRotate,\n      minPolarAngle,\n      maxPolarAngle,\n      minAzimuthAngle,\n      maxAzimuthAngle,\n      rotateSpeed,\n      enablePan,\n      panSpeed,\n    })\n\n    if (position) {\n      this.updatePosition(position)\n    }\n  }\n\n  /**\n   * Allow to override the {@link camera} position.\n   * @param position - new {@link camera} position to set.\n   */\n  updatePosition(position = new Vec3()) {\n    position.sub(this.target)\n    this.#spherical.radius = position.length()\n    this.#spherical.theta = Math.atan2(position.x, position.z)\n    this.#spherical.phi = Math.acos(Math.min(Math.max(position.y / this.#spherical.radius, -1), 1))\n\n    this.#update()\n  }\n\n  /**\n   * Set the element to use for event listeners. Can remove previous event listeners first if needed.\n   * @param value - {@link HTMLElement} (or {@link Window} element) to use.\n   */\n  set element(value: HTMLElement | Window | null) {\n    if (this.#element && (!value || this.#element !== value)) {\n      this.#removeEvents()\n    }\n\n    this.#element = value\n\n    if (value) {\n      this.#addEvents()\n    }\n  }\n\n  /**\n   * Get our element to use for event listeners.\n   * @returns - {@link HTMLElement} (or {@link Window} element) used.\n   */\n  get element() {\n    return this.#element\n  }\n\n  /**\n   * Add the event listeners.\n   * @private\n   */\n  #addEvents() {\n    this.#element.addEventListener('contextmenu', this.#onContextMenu.bind(this), false)\n    this.#element.addEventListener('mousedown', this.#onMouseDown.bind(this), false)\n    this.#element.addEventListener('mousemove', this.#onMouseMove.bind(this), false)\n    this.#element.addEventListener('mouseup', this.#onMouseUp.bind(this), false)\n    this.#element.addEventListener('touchstart', this.#onTouchStart.bind(this), { passive: false })\n    this.#element.addEventListener('touchmove', this.#onTouchMove.bind(this), { passive: false })\n    this.#element.addEventListener('touchend', this.#onTouchEnd.bind(this), false)\n    this.#element.addEventListener('wheel', this.#onMouseWheel.bind(this), { passive: false })\n  }\n\n  /**\n   * Remove the event listeners.\n   * @private\n   */\n  #removeEvents() {\n    this.#element.removeEventListener('contextmenu', this.#onContextMenu.bind(this), false)\n    this.#element.removeEventListener('mousedown', this.#onMouseDown.bind(this), false)\n    this.#element.removeEventListener('mousemove', this.#onMouseMove.bind(this), false)\n    this.#element.removeEventListener('mouseup', this.#onMouseUp.bind(this), false)\n    this.#element.removeEventListener('touchstart', this.#onTouchStart.bind(this), { passive: false })\n    this.#element.removeEventListener('touchmove', this.#onTouchMove.bind(this), { passive: false })\n    this.#element.removeEventListener('touchend', this.#onTouchEnd.bind(this), false)\n    this.#element.removeEventListener('wheel', this.#onMouseWheel.bind(this), { passive: false })\n  }\n\n  /**\n   * Callback executed on mouse down event.\n   * @param e - {@link MouseEvent}.\n   * @private\n   */\n  #onMouseDown(e: MouseEvent) {\n    if (e.button === 0 && this.enableRotate) {\n      this.#isOrbiting = true\n      this.#rotateStart.set(e.clientX, e.clientY)\n    } else if (e.button === 2 && this.enablePan) {\n      this.#isPaning = true\n      this.#panStart.set(e.clientX, e.clientY)\n    }\n\n    e.stopPropagation()\n    e.preventDefault()\n  }\n\n  /**\n   * Callback executed on touch start event.\n   * @param e - {@link TouchEvent}.\n   * @private\n   */\n  #onTouchStart(e: TouchEvent) {\n    // TODO zoom / pan with 2 fingers\n    if (e.touches.length === 1 && this.enableRotate) {\n      this.#isOrbiting = true\n      this.#rotateStart.set(e.touches[0].pageX, e.touches[0].pageY)\n    }\n  }\n\n  /**\n   * Callback executed on mouse move event.\n   * @param e - {@link MouseEvent}.\n   */\n  #onMouseMove(e: MouseEvent) {\n    if (this.#isOrbiting && this.enableRotate) {\n      this.#rotate(e.clientX, e.clientY)\n    } else if (this.#isPaning && this.enablePan) {\n      this.#pan(e.clientX, e.clientY)\n    }\n  }\n\n  /**\n   * Callback executed on touch move event.\n   * @param e - {@link TouchEvent}.\n   * @private\n   */\n  #onTouchMove(e: TouchEvent) {\n    if (this.#isOrbiting && this.enableRotate) {\n      this.#rotate(e.touches[0].pageX, e.touches[0].pageY)\n    }\n  }\n\n  /**\n   * Callback executed on mouse up event.\n   * @param e - {@link MouseEvent}.\n   * @private\n   */\n  #onMouseUp(e: MouseEvent) {\n    this.#isOrbiting = false\n    this.#isPaning = false\n  }\n\n  /**\n   * Callback executed on touch end event.\n   * @param e - {@link MouseEvent}.\n   * @private\n   */\n  #onTouchEnd(e: TouchEvent) {\n    this.#isOrbiting = false\n    this.#isPaning = false\n  }\n\n  /**\n   * Callback executed on wheel event.\n   * @param e - {@link WheelEvent}.\n   * @private\n   */\n  #onMouseWheel(e: WheelEvent) {\n    if (this.enableZoom) {\n      this.#zoom(e.deltaY)\n\n      e.preventDefault()\n    }\n  }\n\n  /**\n   * Prevent context menu apparition on right click\n   * @param e - {@link MouseEvent}.\n   * @private\n   */\n  #onContextMenu(e: MouseEvent) {\n    e.preventDefault()\n  }\n\n  /**\n   * Update the {@link camera} position based on the {@link target} and internal values.\n   * @private\n   */\n  #update() {\n    // apply rotation to offset\n    const sinPhiRadius = this.#spherical.radius * Math.sin(Math.max(0.000001, this.#spherical.phi))\n    this.#offset.x = sinPhiRadius * Math.sin(this.#spherical.theta)\n    this.#offset.y = this.#spherical.radius * Math.cos(this.#spherical.phi)\n    this.#offset.z = sinPhiRadius * Math.cos(this.#spherical.theta)\n\n    // Apply updated values to object\n    this.camera.position.copy(this.target).add(this.#offset)\n  }\n\n  /**\n   * Update the {@link camera} position based on input coordinates so it rotates around the {@link target}.\n   * @param x - input coordinate along the X axis.\n   * @param y - input coordinate along the Y axis.\n   * @private\n   */\n  #rotate(x: number, y: number) {\n    tempVec2a.set(x, y)\n    tempVec2b.copy(tempVec2a).sub(this.#rotateStart).multiplyScalar(this.rotateSpeed)\n    this.#spherical.theta -= (2 * Math.PI * tempVec2b.x) / this.camera.size.height\n    this.#spherical.phi -= (2 * Math.PI * tempVec2b.y) / this.camera.size.height\n\n    this.#spherical.theta = Math.min(this.maxAzimuthAngle, Math.max(this.minAzimuthAngle, this.#spherical.theta))\n    this.#spherical.phi = Math.min(this.maxPolarAngle, Math.max(this.minPolarAngle, this.#spherical.phi))\n\n    this.#rotateStart.copy(tempVec2a)\n\n    this.#update()\n  }\n\n  /**\n   * Pan the {@link camera} position based on input coordinates by updating {@link target}.\n   * @param x - input coordinate along the X axis.\n   * @param y - input coordinate along the Y axis.\n   * @private\n   */\n  #pan(x: number, y: number) {\n    tempVec2a.set(x, y)\n    tempVec2b.copy(tempVec2a).sub(this.#panStart).multiplyScalar(this.panSpeed)\n\n    this.#panDelta.set(0)\n\n    tempVec3.copy(this.camera.position).sub(this.target)\n    let targetDistance = tempVec3.length()\n    targetDistance *= Math.tan(((this.camera.fov / 2) * Math.PI) / 180.0)\n\n    // pan left\n    // get right direction axis accounting for camera transform\n    tempVec3.set(\n      this.camera.modelMatrix.elements[0],\n      this.camera.modelMatrix.elements[1],\n      this.camera.modelMatrix.elements[2]\n    )\n\n    tempVec3.multiplyScalar(-(2 * tempVec2b.x * targetDistance) / this.camera.size.height)\n    this.#panDelta.add(tempVec3)\n\n    // pan up\n    // get up direction axis accounting for camera transform\n    tempVec3.set(\n      this.camera.modelMatrix.elements[4],\n      this.camera.modelMatrix.elements[5],\n      this.camera.modelMatrix.elements[6]\n    )\n    tempVec3.multiplyScalar((2 * tempVec2b.y * targetDistance) / this.camera.size.height)\n    this.#panDelta.add(tempVec3)\n\n    this.#panStart.copy(tempVec2a)\n\n    this.target.add(this.#panDelta)\n    this.#offset.copy(this.camera.position).sub(this.target)\n    this.#spherical.radius = this.#offset.length()\n\n    this.#update()\n  }\n\n  /**\n   * Move the {@link camera} forward or backward.\n   * @param value - new value to use for zoom.\n   * @private\n   */\n  #zoom(value: number) {\n    this.#spherical.radius = Math.min(\n      this.maxZoom,\n      Math.max(this.minZoom + 0.000001, this.#spherical.radius + (value * this.zoomSpeed) / 100)\n    )\n\n    this.#update()\n  }\n\n  /**\n   * Destroy the {@link OrbitControls}.\n   */\n  destroy() {\n    // will automatically remove listeners\n    this.element = null\n  }\n}\n","import { IndexedGeometry } from '../../core/geometries/IndexedGeometry'\r\nimport { Vec3 } from '../../math/Vec3'\r\nimport { GeometryBaseParams } from '../../types/Geometries'\r\n\r\n/**\r\n * Parameters used to create a {@link BoxGeometry}\r\n */\r\nexport interface BoxGeometryParams extends GeometryBaseParams {\r\n  /** Number of segments along the X axis */\r\n  widthSegments?: number\r\n  /** Number of segments along the Y axis */\r\n  heightSegments?: number\r\n  /** Number of segments along the Z axis */\r\n  depthSegments?: number\r\n}\r\n\r\n/**\r\n * Helper to easily create 3D box indexed geometries.\r\n *\r\n * @example\r\n * ```javascript\r\n * const boxGeometry = new BoxGeometry()\r\n * ```\r\n */\r\nexport class BoxGeometry extends IndexedGeometry {\r\n  constructor(\r\n    {\r\n      instancesCount = 1,\r\n      vertexBuffers = [],\r\n      topology,\r\n      mapBuffersAtCreation = true,\r\n      widthSegments = 1,\r\n      heightSegments = 1,\r\n      depthSegments = 1,\r\n    } = {} as BoxGeometryParams\r\n  ) {\r\n    super({ verticesOrder: 'ccw', topology, instancesCount, vertexBuffers, mapBuffersAtCreation })\r\n\r\n    this.type = 'BoxGeometry'\r\n\r\n    // taken from threejs\r\n    // https://github.com/mrdoob/three.js/blob/dev/src/geometries/BoxGeometry.js\r\n    widthSegments = Math.floor(widthSegments)\r\n    heightSegments = Math.floor(heightSegments)\r\n    depthSegments = Math.floor(depthSegments)\r\n\r\n    const vertices = []\r\n    const uvs = []\r\n    const normals = []\r\n    const indices = []\r\n\r\n    let numberOfVertices = 0\r\n\r\n    const buildPlane = (u, v, w, udir, vdir, width, height, depth, gridX, gridY) => {\r\n      const segmentWidth = width / gridX\r\n      const segmentHeight = height / gridY\r\n\r\n      const widthHalf = width / 2\r\n      const heightHalf = height / 2\r\n      const depthHalf = depth / 2\r\n\r\n      const gridX1 = gridX + 1\r\n      const gridY1 = gridY + 1\r\n\r\n      let vertexCounter = 0\r\n\r\n      const vector = new Vec3()\r\n\r\n      // generate vertices, normals and uvs\r\n\r\n      for (let iy = 0; iy < gridY1; iy++) {\r\n        const y = iy * segmentHeight - heightHalf\r\n\r\n        for (let ix = 0; ix < gridX1; ix++) {\r\n          const x = ix * segmentWidth - widthHalf\r\n\r\n          // set values to correct vector component\r\n\r\n          vector[u] = x * udir\r\n          vector[v] = y * vdir\r\n          vector[w] = depthHalf\r\n\r\n          // now apply vector to vertex buffer\r\n\r\n          vertices.push(vector.x, vector.y, vector.z)\r\n\r\n          // set values to correct vector component\r\n\r\n          vector[u] = 0\r\n          vector[v] = 0\r\n          vector[w] = depth > 0 ? 1 : -1\r\n\r\n          // now apply vector to normal buffer\r\n\r\n          normals.push(vector.x, vector.y, vector.z)\r\n\r\n          // uvs\r\n\r\n          uvs.push(ix / gridX)\r\n          uvs.push(iy / gridY)\r\n\r\n          // counters\r\n\r\n          vertexCounter += 1\r\n        }\r\n      }\r\n\r\n      // indices\r\n\r\n      // 1. you need three indices to draw a single face\r\n      // 2. a single segment consists of two faces\r\n      // 3. so we need to generate six (2*3) indices per segment\r\n\r\n      for (let iy = 0; iy < gridY; iy++) {\r\n        for (let ix = 0; ix < gridX; ix++) {\r\n          const a = numberOfVertices + ix + gridX1 * iy\r\n          const b = numberOfVertices + ix + gridX1 * (iy + 1)\r\n          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1)\r\n          const d = numberOfVertices + (ix + 1) + gridX1 * iy\r\n\r\n          // faces\r\n\r\n          indices.push(a, b, d)\r\n          indices.push(b, c, d)\r\n\r\n          // update total number of vertices\r\n\r\n          numberOfVertices += vertexCounter\r\n        }\r\n      }\r\n    }\r\n\r\n    buildPlane('z', 'y', 'x', -1, -1, 2, 2, 2, depthSegments, heightSegments) // px\r\n    buildPlane('z', 'y', 'x', 1, -1, 2, 2, -2, depthSegments, heightSegments) // nx\r\n    buildPlane('x', 'z', 'y', 1, 1, 2, 2, 2, widthSegments, depthSegments) // py\r\n    buildPlane('x', 'z', 'y', 1, -1, 2, 2, -2, widthSegments, depthSegments) // ny\r\n    buildPlane('x', 'y', 'z', 1, -1, 2, 2, 2, widthSegments, heightSegments) // pz\r\n    buildPlane('x', 'y', 'z', -1, -1, 2, 2, -2, widthSegments, heightSegments) // nz\r\n\r\n    this.setAttribute({\r\n      name: 'position',\r\n      type: 'vec3f',\r\n      bufferFormat: 'float32x3',\r\n      size: 3,\r\n      array: new Float32Array(vertices),\r\n    })\r\n\r\n    this.setAttribute({\r\n      name: 'uv',\r\n      type: 'vec2f',\r\n      bufferFormat: 'float32x2',\r\n      size: 2,\r\n      array: new Float32Array(uvs),\r\n    })\r\n\r\n    this.setAttribute({\r\n      name: 'normal',\r\n      type: 'vec3f',\r\n      bufferFormat: 'float32x3',\r\n      size: 3,\r\n      array: new Float32Array(normals),\r\n    })\r\n\r\n    this.setIndexBuffer({\r\n      array: this.useUint16IndexArray ? new Uint16Array(indices) : new Uint32Array(indices),\r\n      bufferFormat: this.useUint16IndexArray ? 'uint16' : 'uint32',\r\n    })\r\n  }\r\n}\r\n","import { IndexedGeometry } from '../../core/geometries/IndexedGeometry'\r\nimport { Vec3 } from '../../math/Vec3'\r\nimport { GeometryBaseParams } from '../../types/Geometries'\r\n\r\n/**\r\n * Parameters used to create a {@link SphereGeometry}\r\n */\r\nexport interface SphereGeometryParams extends GeometryBaseParams {\r\n  /** Number of horizontal segments */\r\n  widthSegments?: number\r\n  /** Number of vertical segments */\r\n  heightSegments?: number\r\n  /** Horizontal starting angle */\r\n  phiStart?: number\r\n  /** Horizontal sweep angle size */\r\n  phiLength?: number\r\n  /** Vertical starting angle */\r\n  thetaStart?: number\r\n  /** Vertical sweep angle size */\r\n  thetaLength?: number\r\n}\r\n\r\n/**\r\n * Helper to easily create 3D sphere indexed geometries.\r\n *\r\n * @example\r\n * ```javascript\r\n * const sphereGeometry = new SphereGeometry()\r\n * ```\r\n */\r\nexport class SphereGeometry extends IndexedGeometry {\r\n  constructor(\r\n    {\r\n      topology,\r\n      instancesCount = 1,\r\n      vertexBuffers = [],\r\n      mapBuffersAtCreation = true,\r\n      widthSegments = 32,\r\n      heightSegments = 16,\r\n      phiStart = 0,\r\n      phiLength = Math.PI * 2,\r\n      thetaStart = 0,\r\n      thetaLength = Math.PI,\r\n    } = {} as SphereGeometryParams\r\n  ) {\r\n    super({ verticesOrder: 'ccw', topology, instancesCount, vertexBuffers, mapBuffersAtCreation })\r\n\r\n    this.type = 'SphereGeometry'\r\n\r\n    // taken from threejs\r\n    // https://github.com/mrdoob/three.js/blob/dev/src/geometries/SphereGeometry.js\r\n    widthSegments = Math.max(3, Math.floor(widthSegments))\r\n    heightSegments = Math.max(2, Math.floor(heightSegments))\r\n\r\n    const radius = 1\r\n    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI)\r\n\r\n    let index = 0\r\n    const grid = []\r\n\r\n    const vertex = new Vec3()\r\n    const normal = new Vec3()\r\n\r\n    // buffers\r\n\r\n    const indices = []\r\n    const vertices = []\r\n    const normals = []\r\n    const uvs = []\r\n\r\n    // generate vertices, normals and uvs\r\n\r\n    for (let iy = 0; iy <= heightSegments; iy++) {\r\n      const verticesRow = []\r\n\r\n      const v = iy / heightSegments\r\n\r\n      // special case for the poles\r\n\r\n      let uOffset = 0\r\n\r\n      if (iy === 0 && thetaStart === 0) {\r\n        uOffset = 0.5 / widthSegments\r\n      } else if (iy === heightSegments && thetaEnd === Math.PI) {\r\n        uOffset = -0.5 / widthSegments\r\n      }\r\n\r\n      for (let ix = 0; ix <= widthSegments; ix++) {\r\n        const u = ix / widthSegments\r\n\r\n        // vertex\r\n\r\n        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength)\r\n        vertex.y = radius * Math.cos(thetaStart + v * thetaLength)\r\n        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength)\r\n\r\n        vertices.push(vertex.x, vertex.y, vertex.z)\r\n\r\n        // normal\r\n\r\n        normal.copy(vertex).normalize()\r\n        normals.push(normal.x, normal.y, normal.z)\r\n\r\n        // uv\r\n\r\n        uvs.push(u + uOffset, v)\r\n\r\n        verticesRow.push(index++)\r\n      }\r\n\r\n      grid.push(verticesRow)\r\n    }\r\n\r\n    // indices\r\n\r\n    for (let iy = 0; iy < heightSegments; iy++) {\r\n      for (let ix = 0; ix < widthSegments; ix++) {\r\n        const a = grid[iy][ix + 1]\r\n        const b = grid[iy][ix]\r\n        const c = grid[iy + 1][ix]\r\n        const d = grid[iy + 1][ix + 1]\r\n\r\n        if (iy !== 0 || thetaStart > 0) indices.push(a, b, d)\r\n        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d)\r\n      }\r\n    }\r\n\r\n    this.setAttribute({\r\n      name: 'position',\r\n      type: 'vec3f',\r\n      bufferFormat: 'float32x3',\r\n      size: 3,\r\n      array: new Float32Array(vertices),\r\n    })\r\n\r\n    this.setAttribute({\r\n      name: 'uv',\r\n      type: 'vec2f',\r\n      bufferFormat: 'float32x2',\r\n      size: 2,\r\n      array: new Float32Array(uvs),\r\n    })\r\n\r\n    this.setAttribute({\r\n      name: 'normal',\r\n      type: 'vec3f',\r\n      bufferFormat: 'float32x3',\r\n      size: 3,\r\n      array: new Float32Array(normals),\r\n    })\r\n\r\n    this.setIndexBuffer({\r\n      array: this.useUint16IndexArray ? new Uint16Array(indices) : new Uint32Array(indices),\r\n      bufferFormat: this.useUint16IndexArray ? 'uint16' : 'uint32',\r\n    })\r\n  }\r\n}\r\n","import { isRenderer, Renderer } from '../../core/renderers/utils'\r\nimport { RenderTarget } from '../../core/renderPasses/RenderTarget'\r\nimport { FullscreenPlane } from '../../core/meshes/FullscreenPlane'\r\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\r\nimport { Texture, TextureParams } from '../../core/textures/Texture'\r\nimport { MeshBaseRenderParams } from '../../core/meshes/mixins/MeshBaseMixin'\r\n\r\n/**\r\n * Used to create a special type of {@link FullscreenPlane} that allows to use the previous frame fragment shader output as an input texture.\r\n *\r\n * @example\r\n * ```javascript\r\n * // set our main GPUCurtains instance\r\n * const gpuCurtains = new GPUCurtains({\r\n *   container: '#canvas' // selector of our WebGPU canvas container\r\n * })\r\n *\r\n * // set the GPU device\r\n * // note this is asynchronous\r\n * await gpuCurtains.setDevice()\r\n *\r\n * // create a PingPongPlane\r\n * const shaderPass = new PingPongPlane(gpuCurtain, {\r\n *   label: 'My ping pong plane',\r\n *   shaders: {\r\n *     fragment: {\r\n *       code: pingPongCode, // assume it is a valid WGSL fragment shader\r\n *     },\r\n *   },\r\n * })\r\n * ```\r\n */\r\nexport class PingPongPlane extends FullscreenPlane {\r\n  /** {@link RenderTarget} content to use as an input */\r\n  outputTarget: RenderTarget\r\n\r\n  /**\r\n   * PingPongPlane constructor\r\n   * @param renderer - {@link Renderer} object or {@link GPUCurtains} class object used to create this {@link PingPongPlane}\r\n   * @param parameters - {@link MeshBaseRenderParams | parameters} use to create this {@link PingPongPlane}\r\n   */\r\n  constructor(renderer: Renderer | GPUCurtains, parameters = {} as MeshBaseRenderParams) {\r\n    renderer = isRenderer(renderer, parameters.label ? parameters.label + ' PingPongPlane' : 'PingPongPlane')\r\n\r\n    const colorAttachments =\r\n      parameters.targets &&\r\n      parameters.targets.length &&\r\n      parameters.targets.map((target) => {\r\n        return {\r\n          targetFormat: target.format,\r\n        }\r\n      })\r\n\r\n    // we will render into a separate texture\r\n    parameters.outputTarget = new RenderTarget(renderer, {\r\n      label: parameters.label ? parameters.label + ' render target' : 'Ping Pong render target',\r\n      useDepth: false,\r\n      ...(colorAttachments && { colorAttachments }),\r\n    })\r\n\r\n    // no blending and depth for ping pong planes\r\n    parameters.transparent = false\r\n    parameters.depth = false\r\n\r\n    parameters.label = parameters.label ?? 'PingPongPlane ' + renderer.pingPongPlanes?.length\r\n\r\n    super(renderer, parameters)\r\n\r\n    this.type = 'PingPongPlane'\r\n\r\n    this.createTexture({\r\n      label: parameters.label ? `${parameters.label} render texture` : 'PingPongPlane render texture',\r\n      name: 'renderTexture',\r\n      ...(parameters.targets && parameters.targets.length && { format: parameters.targets[0].format }),\r\n      usage: ['copyDst', 'textureBinding'],\r\n    } as TextureParams)\r\n  }\r\n\r\n  /**\r\n   * Get our main {@link Texture}, the one that contains our ping pong content\r\n   * @readonly\r\n   */\r\n  get renderTexture(): Texture | undefined {\r\n    return this.textures.find((texture) => texture.options.name === 'renderTexture')\r\n  }\r\n\r\n  /**\r\n   * Add the {@link PingPongPlane} to the {@link core/scenes/Scene.Scene | Scene} and optionally to the renderer.\r\n   * @param addToRenderer - whether to add this {@link PingPongPlane} to the {@link Renderer#pingPongPlanes | Renderer pingPongPlanes array}\r\n   */\r\n  addToScene(addToRenderer = false) {\r\n    if (addToRenderer) {\r\n      this.renderer.pingPongPlanes.push(this)\r\n    }\r\n\r\n    if (this.autoRender) {\r\n      this.renderer.scene.addPingPongPlane(this)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove the {@link PingPongPlane} from the {@link core/scenes/Scene.Scene | Scene} and optionally from the renderer as well.\r\n   * @param removeFromRenderer - whether to remove this {@link PingPongPlane} from the {@link Renderer#pingPongPlanes | Renderer pingPongPlanes array}\r\n   */\r\n  removeFromScene(removeFromRenderer = false) {\r\n    if (this.outputTarget) {\r\n      this.outputTarget.destroy()\r\n    }\r\n\r\n    if (this.autoRender) {\r\n      this.renderer.scene.removePingPongPlane(this)\r\n    }\r\n\r\n    if (removeFromRenderer) {\r\n      this.renderer.pingPongPlanes = this.renderer.pingPongPlanes.filter((pPP) => pPP.uuid !== this.uuid)\r\n    }\r\n  }\r\n}\r\n","import { Vec2 } from '../../math/Vec2'\r\nimport { Vec3 } from '../../math/Vec3'\r\nimport { CameraRenderer, isCameraRenderer, isProjectedMesh } from '../../core/renderers/utils'\r\nimport { Camera } from '../../core/camera/Camera'\r\nimport { throwWarning } from '../../utils/utils'\r\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\r\nimport { ProjectedMesh } from '../../core/renderers/GPURenderer'\r\nimport { IndexBuffer, IndexedGeometry } from '../../core/geometries/IndexedGeometry'\r\nimport { VertexBufferAttribute } from '../../types/Geometries'\r\nimport { Object3D } from '../../core/objects3D/Object3D'\r\n\r\n/**\r\n * Defines the returned values when an intersection between the {@link Raycaster#ray | ray} and a {@link ProjectedMesh | projected mesh} has been found.\r\n */\r\nexport interface Intersection {\r\n  /** Intersected {@link ProjectedMesh | projected mesh}. */\r\n  object: ProjectedMesh\r\n  /** Distance from the {@link Raycaster#ray | ray} origin to the intersection point. */\r\n  distance: number\r\n  /** {@link Vec3 | Coordinate} of the intersection point in {@link object} local space. */\r\n  localPoint: Vec3\r\n  /** {@link Vec3 | Coordinate} of the intersection point in world space. */\r\n  point: Vec3\r\n  /** The triangle (as an array of {@link Vec3} vertices) inside which lies the intersection point. */\r\n  triangle: Vec3[]\r\n  /** Index of the triangle in the {@link ProjectedMesh | projected mesh} geometry position or index array. */\r\n  triangleIndex: number\r\n  /** Interpolated {@link Vec2 | uv coordinates} of the intersection point. */\r\n  uv?: Vec2\r\n  /** Interpolated {@link Vec3 | normal} of the intersection point, in {@link object} local space. */\r\n  normal?: Vec3\r\n}\r\n\r\n/**\r\n * Utility to help with raycasting (determining what objects in the 3d space the mouse is over).\r\n *\r\n * @example\r\n * ```javascript\r\n * // set our main GPUCurtains instance\r\n * const gpuCurtains = new GPUCurtains({\r\n *   container: '#canvas' // selector of our WebGPU canvas container\r\n * })\r\n *\r\n * // set the GPU device\r\n * // note this is asynchronous\r\n * await gpuCurtains.setDevice()\r\n *\r\n * // create a mesh with a box geometry\r\n * // will use the normals colors as default shading\r\n * const mesh = new Mesh(gpuCurtains, {\r\n *   label: 'My mesh',\r\n *   geometry: new BoxGeometry(),\r\n * })\r\n *\r\n * const raycaster = new Raycaster(gpuCurtains)\r\n *\r\n * window.addEventListener('mousemove', (e) => {\r\n *   raycaster.setFromMouse(e)\r\n *\r\n *   const intersections = raycaster.intersectObject(mesh)\r\n *\r\n *   if(intersections.length) {\r\n *     // the mouse is hovering the mesh\r\n *     mesh.scale.set(1.25)\r\n *   } else {\r\n *     // the mouse is not hovering the mesh\r\n *     mesh.scale.set(1)\r\n *   }\r\n * })\r\n * ```\r\n */\r\nexport class Raycaster {\r\n  /** The type of the {@link Raycaster}. */\r\n  type: string\r\n  /** The {@link CameraRenderer} used. */\r\n  renderer: CameraRenderer\r\n  /** The {@link Camera} used. */\r\n  camera: Camera | null\r\n\r\n  /** Pointer position in normalized device coordinates (in the [-1, 1] range). */\r\n  pointer: Vec2\r\n\r\n  /** Ray used to test for intersections. */\r\n  ray: {\r\n    /** Origin of the ray in world space ({@link Camera} position). */\r\n    origin: Vec3\r\n    /** Normalized direction of the ray in world space. */\r\n    direction: Vec3\r\n  }\r\n\r\n  /** @ignore */\r\n  #localRay: {\r\n    origin: Vec3\r\n    direction: Vec3\r\n  }\r\n\r\n  /** @ignore */\r\n  #v0: Vec3\r\n  /** @ignore */\r\n  #v1: Vec3\r\n  /** @ignore */\r\n  #v2: Vec3\r\n\r\n  /** @ignore */\r\n  #edge1: Vec3\r\n  /** @ignore */\r\n  #edge2: Vec3\r\n\r\n  /** @ignore */\r\n  #uv0: Vec2\r\n  /** @ignore */\r\n  #uv1: Vec2\r\n  /** @ignore */\r\n  #uv2: Vec2\r\n\r\n  /** @ignore */\r\n  #n0: Vec3\r\n  /** @ignore */\r\n  #n1: Vec3\r\n  /** @ignore */\r\n  #n2: Vec3\r\n\r\n  /**\r\n   * Raycaster constructor\r\n   * @param renderer - {@link CameraRenderer} object or {@link GPUCurtains} class object used to create this {@link Raycaster}\r\n   */\r\n  constructor(renderer: CameraRenderer | GPUCurtains) {\r\n    this.type = 'Raycaster'\r\n\r\n    renderer = isCameraRenderer(renderer, this.type)\r\n\r\n    this.renderer = renderer\r\n    this.camera = this.renderer.camera\r\n\r\n    this.pointer = new Vec2(Infinity)\r\n\r\n    this.ray = {\r\n      origin: new Vec3(),\r\n      direction: new Vec3(),\r\n    }\r\n\r\n    // ray in local object space\r\n    this.#localRay = {\r\n      origin: this.ray.origin.clone(),\r\n      direction: this.ray.direction.clone(),\r\n    }\r\n\r\n    // helper vectors to speed up calcs\r\n    // positions\r\n    this.#v0 = new Vec3()\r\n    this.#v1 = new Vec3()\r\n    this.#v2 = new Vec3()\r\n    // edges\r\n    this.#edge1 = new Vec3()\r\n    this.#edge2 = new Vec3()\r\n    // uvs\r\n    this.#uv0 = new Vec2()\r\n    this.#uv1 = new Vec2()\r\n    this.#uv2 = new Vec2()\r\n    // normals\r\n    this.#n0 = new Vec3()\r\n    this.#n1 = new Vec3()\r\n    this.#n2 = new Vec3()\r\n  }\r\n\r\n  /**\r\n   * Set the {@link pointer} normalized device coordinates values (in the [-1, 1] range) based on a mouse/pointer/touch event and the {@link CameraRenderer#boundingRect | renderer bounding rectangle}. Useful if the canvas has a fixed position for example, but you might need to directly use {@link setFromNDCCoords} if not.\r\n   * @param e - Mouse, pointer or touch event.\r\n   */\r\n  setFromMouse(e: MouseEvent | PointerEvent | TouchEvent) {\r\n    const { clientX, clientY } =\r\n      (e as TouchEvent).targetTouches && (e as TouchEvent).targetTouches.length\r\n        ? (e as TouchEvent).targetTouches[0]\r\n        : (e as MouseEvent | PointerEvent)\r\n\r\n    this.setFromNDCCoords(\r\n      ((clientX - this.renderer.boundingRect.left) / this.renderer.boundingRect.width) * 2 - 1,\r\n      -((clientY - this.renderer.boundingRect.top) / this.renderer.boundingRect.height) * 2 + 1\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Set the {@link pointer} normalized device coordinates (in the [-1, 1] range).\r\n   * @param x - input position along the X axis in the [-1, 1] range where `-1` represents the left edge and `1` the right edge.\r\n   * @param y - input position along the Y axis in the [-1, 1] range where `-1` represents the bottom edge and `1` the top edge.\r\n   */\r\n  setFromNDCCoords(x = 0, y = 0) {\r\n    this.pointer.set(x, y)\r\n    this.setRay()\r\n  }\r\n\r\n  /**\r\n   * Sets the {@link ray} origin and direction based on the {@link camera} and the normalized device coordinates of the {@link pointer}.\r\n   */\r\n  setRay() {\r\n    this.camera.worldMatrix.getTranslation(this.ray.origin)\r\n    this.ray.direction.set(this.pointer.x, this.pointer.y, -1).unproject(this.camera).sub(this.ray.origin).normalize()\r\n  }\r\n\r\n  // INTERSECTIONS\r\n\r\n  /**\r\n   * Ray-Triangle Intersection with MllerTrumbore Algorithm.\r\n   * @param intersectionPoint - {@link Vec3} to store the intersection point if any.\r\n   * @returns - Whether an intersection point has been found or not.\r\n   */\r\n  rayIntersectsTriangle(intersectionPoint: Vec3): boolean {\r\n    const EPSILON = 1e-6\r\n    const h = new Vec3()\r\n    const q = new Vec3()\r\n\r\n    // Calculate the determinant\r\n    h.crossVectors(this.#localRay.direction, this.#edge2)\r\n    const a = this.#edge1.dot(h)\r\n\r\n    // If the determinant is near zero, the ray lies in the plane of the triangle\r\n    if (Math.abs(a) < EPSILON) return false\r\n\r\n    const f = 1.0 / a\r\n    const s = this.#localRay.origin.clone().sub(this.#v0)\r\n    const u = f * s.dot(h)\r\n\r\n    // Check if intersection lies outside the triangle\r\n    if (u < 0.0 || u > 1.0) return false\r\n\r\n    q.crossVectors(s, this.#edge1)\r\n    const v = f * this.#localRay.direction.dot(q)\r\n\r\n    if (v < 0.0 || u + v > 1.0) return false\r\n\r\n    // Compute the intersection distance along the ray\r\n    const t = f * this.#edge2.dot(q)\r\n\r\n    // If t is positive, we have an intersection\r\n    if (t > EPSILON) {\r\n      // Calculate the intersection point if needed\r\n      intersectionPoint.copy(this.#localRay.origin).add(this.#localRay.direction.clone().multiplyScalar(t))\r\n      return true\r\n    }\r\n\r\n    // No intersection\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Find the barycentric contributions of a given intersection point lying inside our current triangle.\r\n   * @param intersectionPoint - Given {@link Vec3 | intersection point}.\r\n   * @returns - {@link Vec3} barycentric contributions.\r\n   */\r\n  getBarycentricCoordinates(intersectionPoint: Vec3) {\r\n    const v0p = intersectionPoint.clone().sub(this.#v0) // Vector v0->intersectionPoint\r\n\r\n    // Calculate areas with cross products for u and v, w is 1 - u - v\r\n    const d00 = this.#edge1.dot(this.#edge1)\r\n    const d01 = this.#edge1.dot(this.#edge2)\r\n    const d11 = this.#edge2.dot(this.#edge2)\r\n    const d20 = v0p.dot(this.#edge1)\r\n    const d21 = v0p.dot(this.#edge2)\r\n    const denom = d00 * d11 - d01 * d01\r\n\r\n    const barycentric = new Vec3(0, (d11 * d20 - d01 * d21) / denom, (d00 * d21 - d01 * d20) / denom)\r\n\r\n    barycentric.x = 1.0 - barycentric.y - barycentric.z\r\n\r\n    return barycentric\r\n  }\r\n\r\n  /**\r\n   * Get a rough estimation of the current normal of our current triangle, in local space.\r\n   * @returns - {@link Vec3} normal.\r\n   */\r\n  getTriangleNormal(): Vec3 {\r\n    return new Vec3().crossVectors(this.#edge1, this.#edge2).normalize()\r\n  }\r\n\r\n  /**\r\n   * Set our input vector with the desired attribute value at the given offset defined by our triangleIndex, offset and whether we're using and indexed geometry or not.\r\n   * @param triangleIndex - Index of the triangle for which to look our attribute value.\r\n   * @param offset - Index of the point inside our triangle (`0`, `1` or `2`).\r\n   * @param indices - Indexed geometry array if defined or `null`.\r\n   * @param attribute - {@link VertexBufferAttribute | Vertex buffer attribute} to get the value from.\r\n   * @param vector - Input vector to set (can either be a {@link Vec2} or {@link Vec3}).\r\n   */\r\n  setAttributeVectorAtIndex(\r\n    triangleIndex: number,\r\n    offset: number,\r\n    indices: IndexBuffer['array'] | null,\r\n    attribute: VertexBufferAttribute,\r\n    vector: Vec2 | Vec3\r\n  ) {\r\n    const index = indices ? indices[triangleIndex * 3 + offset] : triangleIndex * 3 + offset\r\n\r\n    vector.x = attribute.array[index * attribute.size]\r\n    vector.y = attribute.array[index * attribute.size + 1]\r\n\r\n    if ('z' in vector) {\r\n      vector.z = attribute.array[index * attribute.size + 2]\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Test whether the {@link ray} is intersecting a given {@link ProjectedMesh | projected mesh} and if so, returns the given {@link Intersection | intersection} information.\r\n   * Uses various early exits to optimize the process:\r\n   * - if the mesh is frustum culled\r\n   * - if the pointer is currently outside the mesh clip space bounding rectangle.\r\n   * - based on the face culling.\r\n   * @param mesh - {@link ProjectedMesh | Projected mesh} to test against.\r\n   * @param intersections - Already existing {@link Intersection | intersections} if any.\r\n   * @returns - Updated {@link Intersection | intersections}.\r\n   * @private\r\n   */\r\n  #intersectMesh(mesh: ProjectedMesh, intersections: Intersection[] = []): Intersection[] {\r\n    if (!mesh.geometry) return intersections\r\n\r\n    const position = mesh.geometry.getAttributeByName('position')\r\n\r\n    if (!position) {\r\n      if (!this.renderer.production) {\r\n        throwWarning(`Raycaster: can't raycast on a mesh that has no position attribute: ${mesh.options.label}`)\r\n      }\r\n      return intersections\r\n    }\r\n\r\n    if (!position.array) {\r\n      if (!this.renderer.production) {\r\n        throwWarning(`Raycaster: can't raycast on a mesh that has no position attribute array: ${mesh.options.label}`)\r\n      }\r\n      return intersections\r\n    }\r\n\r\n    // early bounding rect check\r\n    if (mesh.frustumCulling && mesh.domFrustum) {\r\n      const { clipSpaceBoundingRect } = mesh.domFrustum\r\n\r\n      if (!mesh.domFrustum.isIntersecting) {\r\n        // frustum culled? bail\r\n        return intersections\r\n      } else if (\r\n        this.pointer.x > clipSpaceBoundingRect.left + clipSpaceBoundingRect.width ||\r\n        this.pointer.x < clipSpaceBoundingRect.left ||\r\n        this.pointer.y > clipSpaceBoundingRect.top ||\r\n        this.pointer.y < clipSpaceBoundingRect.top - clipSpaceBoundingRect.height\r\n      ) {\r\n        // outside of clip space bounding rectangle? bail\r\n        return intersections\r\n      }\r\n    }\r\n\r\n    // Invert the object's model matrix to go from world to object space\r\n    const inverseModelMatrix = mesh.worldMatrix.getInverse()\r\n\r\n    // Transform ray origin and direction into the object's local space\r\n    this.#localRay.origin.copy(this.ray.origin).applyMat4(inverseModelMatrix)\r\n    this.#localRay.direction.copy(this.ray.direction).transformDirection(inverseModelMatrix)\r\n\r\n    const uv = mesh.geometry.getAttributeByName('uv')\r\n    const normal = mesh.geometry.getAttributeByName('normal')\r\n\r\n    const indices = (mesh.geometry as IndexedGeometry).indexBuffer?.array\r\n\r\n    const triangleCount = indices ? indices.length / 3 : position.array.length / 9\r\n\r\n    // Iterate over each triangle\r\n    for (let i = 0; i < triangleCount; i++) {\r\n      this.setAttributeVectorAtIndex(i, 0, indices, position, this.#v0)\r\n      this.setAttributeVectorAtIndex(i, 1, indices, position, this.#v1)\r\n      this.setAttributeVectorAtIndex(i, 2, indices, position, this.#v2)\r\n\r\n      // Compute the two edges of the triangle\r\n      this.#edge1.copy(this.#v1).sub(this.#v0)\r\n      this.#edge2.copy(this.#v2).sub(this.#v0)\r\n\r\n      // face culling\r\n      if (mesh.material.options.rendering.cullMode !== 'none') {\r\n        const computedNormal = this.getTriangleNormal()\r\n        const faceDirection = computedNormal.dot(this.#localRay.direction)\r\n        if (faceDirection > 0 && mesh.material.options.rendering.cullMode === 'back') {\r\n          continue\r\n        } else if (faceDirection < 0 && mesh.material.options.rendering.cullMode === 'front') {\r\n          continue\r\n        }\r\n      }\r\n\r\n      // Check if the ray intersects this triangle\r\n      const intersectionPoint = new Vec3()\r\n      const isIntersected = this.rayIntersectsTriangle(intersectionPoint)\r\n\r\n      if (isIntersected) {\r\n        const barycentric = this.getBarycentricCoordinates(intersectionPoint)\r\n        const point = intersectionPoint.clone().applyMat4(mesh.worldMatrix)\r\n        const distance = this.ray.origin.distance(point)\r\n\r\n        // Store this intersection with its distance and face index\r\n        const intersection: Intersection = {\r\n          object: mesh,\r\n          distance,\r\n          localPoint: intersectionPoint,\r\n          point,\r\n          triangle: [this.#v0.clone(), this.#v1.clone(), this.#v2.clone()],\r\n          triangleIndex: i,\r\n        }\r\n\r\n        // get uvs\r\n        if (uv && uv.array && uv.array.length) {\r\n          this.setAttributeVectorAtIndex(i, 0, indices, uv, this.#uv0)\r\n          this.setAttributeVectorAtIndex(i, 1, indices, uv, this.#uv1)\r\n          this.setAttributeVectorAtIndex(i, 2, indices, uv, this.#uv2)\r\n\r\n          intersection.uv = this.#uv0\r\n            .clone() // useless?\r\n            .multiplyScalar(barycentric.x)\r\n            .add(this.#uv1.clone().multiplyScalar(barycentric.y))\r\n            .add(this.#uv2.clone().multiplyScalar(barycentric.z))\r\n        }\r\n\r\n        if (normal && normal.array && normal.array.length) {\r\n          this.setAttributeVectorAtIndex(i, 0, indices, normal, this.#n0)\r\n          this.setAttributeVectorAtIndex(i, 1, indices, normal, this.#n1)\r\n          this.setAttributeVectorAtIndex(i, 2, indices, normal, this.#n2)\r\n\r\n          intersection.normal = this.#n0\r\n            .clone() // useless?\r\n            .multiplyScalar(barycentric.x)\r\n            .add(this.#n1.clone().multiplyScalar(barycentric.y))\r\n            .add(this.#n2.clone().multiplyScalar(barycentric.z))\r\n        }\r\n\r\n        intersections.push(intersection)\r\n      }\r\n    }\r\n\r\n    return intersections\r\n  }\r\n\r\n  /**\r\n   * Test whether the {@link ray} is intersecting a given object, if the is object is actually a {@link ProjectedMesh | projected mesh}.\r\n   * Then, if the recursive flag is set to `true`, test if the {@link Object3D#children | object's children} are intersecting as well.\r\n   * @param object - {@link Object3D | object} to test against.\r\n   * @param recursive - Whether we should also test against the {@link Object3D#children | object's children}. Default to `true`.\r\n   * @param intersections - Already existing {@link Intersection | intersections} if any.\r\n   * @returns - Updated {@link Intersection | intersections}.\r\n   */\r\n  intersectObject(object: Object3D, recursive = true, intersections: Intersection[] = []): Intersection[] {\r\n    if (!(object instanceof Object3D)) {\r\n      if (!this.renderer.production) {\r\n        throwWarning(`${this.type}: object to test intersection again is not of type Object3D`)\r\n      }\r\n      return intersections\r\n    }\r\n\r\n    const mesh = isProjectedMesh(object)\r\n\r\n    if (mesh) {\r\n      this.#intersectMesh(mesh, intersections)\r\n    }\r\n\r\n    if (recursive) {\r\n      object.children.forEach((child) => {\r\n        this.intersectObject(child, recursive, intersections)\r\n      })\r\n    }\r\n\r\n    if (intersections.length) {\r\n      intersections.sort((a, b) => {\r\n        return this.ray.origin.distance(a.point) - this.ray.origin.distance(b.point)\r\n      })\r\n    }\r\n\r\n    return intersections\r\n  }\r\n\r\n  /**\r\n   * Test whether the {@link ray} is intersecting a given array of objects.\r\n   * If the recursive flag is set to `true`, test if each {@link Object3D#children | object's children} are intersecting as well.\r\n   * @param objects - Array of {@link Object3D | objects} to test against.\r\n   * @param recursive - Whether we should also test against each {@link Object3D#children | object's children}. Default to `true`.\r\n   * @param intersections - Already existing {@link Intersection | intersections} if any.\r\n   * @returns - Updated {@link Intersection | intersections}.\r\n   */\r\n  intersectObjects(objects: Object3D[], recursive = true, intersections: Intersection[] = []): Intersection[] {\r\n    objects.forEach((object) => {\r\n      this.intersectObject(object, recursive, intersections)\r\n    })\r\n\r\n    if (intersections.length) {\r\n      intersections.sort((a, b) => {\r\n        return this.ray.origin.distance(a.point) - this.ray.origin.distance(b.point)\r\n      })\r\n    }\r\n\r\n    return intersections\r\n  }\r\n}\r\n","import { CameraRenderer, isCameraRenderer } from '../../core/renderers/utils'\nimport { GLTF } from '../../types/gltf/GLTF'\nimport { GLTFLoader } from '../loaders/GLTFLoader'\nimport { Sampler, SamplerParams } from '../../core/samplers/Sampler'\nimport { Texture } from '../../core/textures/Texture'\nimport { Object3D } from '../../core/objects3D/Object3D'\nimport { Box3 } from '../../math/Box3'\nimport { Vec3 } from '../../math/Vec3'\nimport { Mat4 } from '../../math/Mat4'\nimport { Geometry } from '../../core/geometries/Geometry'\nimport { IndexedGeometry } from '../../core/geometries/IndexedGeometry'\nimport { Mesh } from '../../core/meshes/Mesh'\nimport { TypedArray, TypedArrayConstructor } from '../../core/bindings/utils'\nimport { GeometryParams, VertexBufferAttribute } from '../../types/Geometries'\nimport { ChildDescriptor, MeshDescriptor, PrimitiveInstances, ScenesManager } from '../../types/gltf/GLTFScenesManager'\n\n// TODO limitations, example...\n// use a list like: https://github.com/warrenm/GLTFKit2?tab=readme-ov-file#status-and-conformance\n\n// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants\n// To make it easier to reference the WebGL enums that glTF uses.\nconst GL = WebGLRenderingContext\n\n// one normal matrix to handle them all\nconst _normalMatrix = new Mat4()\n\n/**\n * Used to create a {@link GLTFScenesManager} from a given {@link GLTFLoader.gltf | gltf} object.\n *\n * Parse the {@link GLTFLoader.gltf | gltf} object, create all the {@link Sampler} and {@link Texture}, create all the {@link Object3D} nodes to compute the correct transformations and parent -> child relationships, create all the needed {@link MeshDescriptor} containing the {@link Geometry}, {@link Mesh} parameters and so on.\n *\n * ## Loading Features\n *\n * - [x] Accessors\n *   - [ ] Sparse accessors\n * - [x] Buffers\n * - [x] BufferViews\n * - [x] Images\n * - [x] Meshes\n * - [x] Nodes\n * - [x] Primitives\n * - [x] Samplers\n * - [x] Textures\n * - [ ] Animations\n * - [ ] Cameras\n * - [x] Materials\n * - [ ] Skins\n *\n * @example\n * ```javascript\n * const gltfLoader = new GLTFLoader()\n * const gltf = await gltfLoader.loadFromUrl('path/to/model.gltf')\n *\n * // create a gltfScenesManager from the resulting 'gltf' object\n * // assuming 'renderer' is a valid camera or curtains renderer\n * const gltfScenesManager = new GLTFScenesManager({ renderer, gltf })\n * gltfScenesManager.addMeshes()\n * ```\n */\nexport class GLTFScenesManager {\n  /** The {@link CameraRenderer} used. */\n  renderer: CameraRenderer\n  /** The {@link GLTFLoader.gltf | gltf} object used. */\n  gltf: GLTFLoader['gltf']\n  /** The {@link ScenesManager} containing all the useful data. */\n  scenesManager: ScenesManager\n  /** The {@link PrimitiveInstances} Map, to group similar {@link Mesh} by instances. */\n  #primitiveInstances: PrimitiveInstances\n\n  /**\n   * {@link GLTFScenesManager} constructor.\n   * @param parameters - parameters used to create our {@link GLTFScenesManager}.\n   * @param parameters.renderer - our {@link CameraRenderer} class object.\n   * @param parameters.gltf - The {@link GLTFLoader.gltf | gltf} object used.\n   */\n  constructor({ renderer, gltf }) {\n    renderer = isCameraRenderer(renderer, 'GLTFScenesManager')\n\n    this.renderer = renderer\n    this.gltf = gltf\n\n    this.#primitiveInstances = new Map()\n\n    const traverseChildren = (child) => {\n      return [\n        child.node,\n        ...child.children\n          ?.map((c) => {\n            return [...traverseChildren(c)]\n          })\n          .flat(),\n      ].flat()\n    }\n\n    this.scenesManager = {\n      node: new Object3D(),\n      boundingBox: new Box3(),\n      samplers: [],\n      materialsTextures: [],\n      scenes: [],\n      meshes: [],\n      meshesDescriptors: [],\n      getScenesNodes: () => {\n        return this.scenesManager.scenes\n          .map((scene) => {\n            return traverseChildren(scene)\n          })\n          .flat()\n      },\n    }\n\n    this.createSamplers()\n    this.createMaterialTextures()\n    this.createScenes()\n  }\n\n  /**\n   * Get an attribute type, bufferFormat and size from its {@link GLTF.AccessorType | accessor type}.\n   * @param type - {@link GLTF.AccessorType | accessor type} to use.\n   * @returns - corresponding type, bufferFormat and size.\n   */\n  static getVertexAttributeParamsFromType(type: GLTF.AccessorType): {\n    /** Corresponding attribute type */\n    type: VertexBufferAttribute['type']\n    /** Corresponding attribute bufferFormat */\n    bufferFormat: VertexBufferAttribute['bufferFormat']\n    /** Corresponding attribute size */\n    size: VertexBufferAttribute['size']\n  } {\n    switch (type) {\n      case 'VEC2':\n        return {\n          type: 'vec2f',\n          bufferFormat: 'float32x2',\n          size: 2,\n        }\n      case 'VEC3':\n        return {\n          type: 'vec3f',\n          bufferFormat: 'float32x3',\n          size: 3,\n        }\n      case 'VEC4':\n        return {\n          type: 'vec4f',\n          bufferFormat: 'float32x4',\n          size: 4,\n        }\n      case 'SCALAR':\n      default: // treat default as f32\n        return {\n          type: 'f32',\n          bufferFormat: 'float32',\n          size: 1,\n        }\n    }\n  }\n\n  /**\n   * Get the corresponding typed array constructor based on the {@link GLTF.AccessorComponentType | accessor component type}.\n   * @param componentType - {@link GLTF.AccessorComponentType | accessor component type} to use.\n   * @returns - corresponding typed array constructor.\n   */\n  static getTypedArrayConstructorFromComponentType(componentType: GLTF.AccessorComponentType): TypedArrayConstructor {\n    switch (componentType) {\n      case GL.BYTE: // GL.BYTE\n        return Int8Array\n      case GL.UNSIGNED_BYTE: // GL.UNSIGNED_BYTE\n        return Uint8Array\n      case GL.SHORT: // GL.SHORT\n        return Int16Array\n      case GL.UNSIGNED_SHORT: // GL.UNSIGNED_SHORT\n        return Uint16Array\n      case GL.UNSIGNED_INT: // GL.UNSIGNED_INT\n        return Uint32Array\n      case GL.FLOAT: // GL.FLOAT\n      default:\n        return Float32Array\n    }\n  }\n\n  /**\n   * Get the {@link GPUPrimitiveTopology} based on the {@link GLTF.MeshPrimitiveMode | WebGL primitive mode}.\n   * @param mode - {@link GLTF.MeshPrimitiveMode | WebGL primitive mode} to use.\n   * @returns - corresponding {@link GPUPrimitiveTopology}.\n   */\n  static gpuPrimitiveTopologyForMode(mode: GLTF.MeshPrimitiveMode): GPUPrimitiveTopology {\n    switch (mode) {\n      case GL.TRIANGLES: // GL.TRIANGLES\n        return 'triangle-list'\n      case GL.TRIANGLE_STRIP: // GL.TRIANGLE_STRIP\n        return 'triangle-strip'\n      case GL.LINES: // GL.LINES\n        return 'line-list'\n      case GL.LINE_STRIP: // GL.LINE_STRIP\n        return 'line-strip'\n      case GL.POINTS: // GL.POINTS\n        return 'point-list'\n    }\n  }\n\n  /**\n   * Get the {@link GPUAddressMode} based on the {@link GLTF.TextureWrapMode | WebGL texture wrap mode}.\n   * @param wrap - {@link GLTF.TextureWrapMode | WebGL texture wrap mode} to use.\n   * @returns - corresponding {@link GPUAddressMode}.\n   */\n  static gpuAddressModeForWrap(wrap: GLTF.TextureWrapMode): GPUAddressMode {\n    switch (wrap) {\n      case GL.CLAMP_TO_EDGE:\n        return 'clamp-to-edge'\n      case GL.MIRRORED_REPEAT:\n        return 'mirror-repeat'\n      default:\n        return 'repeat'\n    }\n  }\n\n  /**\n   * Create the {@link Sampler} and add them to the {@link ScenesManager.samplers | scenesManager samplers array}.\n   */\n  createSamplers() {\n    if (this.gltf.samplers) {\n      for (const [index, sampler] of Object.entries(this.gltf.samplers)) {\n        const descriptor = {\n          label: 'glTF sampler ' + index,\n          name: 'gltfSampler' + index, // TODO better name?\n          addressModeU: GLTFScenesManager.gpuAddressModeForWrap(sampler.wrapS),\n          addressModeV: GLTFScenesManager.gpuAddressModeForWrap(sampler.wrapT),\n        } as SamplerParams\n\n        // WebGPU's default min/mag/mipmap filtering is nearest, se we only have to override it if we\n        // want linear filtering for some aspect.\n        if (!sampler.magFilter || sampler.magFilter === GL.LINEAR) {\n          descriptor.magFilter = 'linear'\n        }\n\n        switch (sampler.minFilter) {\n          case GL.NEAREST:\n            break\n          case GL.LINEAR:\n          case GL.LINEAR_MIPMAP_NEAREST:\n            descriptor.minFilter = 'linear'\n            break\n          case GL.NEAREST_MIPMAP_LINEAR:\n            descriptor.mipmapFilter = 'linear'\n            break\n          case GL.LINEAR_MIPMAP_LINEAR:\n          default:\n            descriptor.minFilter = 'linear'\n            descriptor.mipmapFilter = 'linear'\n            break\n        }\n\n        this.scenesManager.samplers.push(new Sampler(this.renderer, descriptor))\n      }\n    } else {\n      // create a default sampler\n      this.scenesManager.samplers.push(\n        new Sampler(this.renderer, {\n          label: 'Default sampler',\n          name: 'defaultSampler',\n          magFilter: 'linear',\n          minFilter: 'linear',\n          mipmapFilter: 'linear',\n        })\n      )\n    }\n  }\n\n  /**\n   * Create a {@link Texture} based on the options.\n   * @param material - material using that texture.\n   * @param image - image source of the texture.\n   * @param name - name of the texture.\n   * @returns - newly created {@link Texture}.\n   */\n  createTexture(material: GLTF.IMaterial, image: ImageBitmap, name: string): Texture {\n    const format = (() => {\n      switch (name) {\n        case 'baseColorTexture':\n        case 'emissiveTexture':\n          return 'bgra8unorm-srgb'\n        case 'occlusionTexture':\n          return 'r8unorm'\n        default:\n          return 'bgra8unorm'\n      }\n    })()\n\n    const texture = new Texture(this.renderer, {\n      label: material.name ? material.name + ': ' + name : name,\n      name,\n      format,\n      visibility: ['fragment'],\n      generateMips: true, // generate mips by default\n      fixedSize: {\n        width: image.width,\n        height: image.height,\n      },\n    })\n\n    texture.uploadSource({\n      source: image,\n    })\n\n    return texture\n  }\n\n  /**\n   * Create the {ScenesManager.materialsTextures | scenesManager materialsTextures array} and each associated {@link types/gltf/GLTFScenesManager.MaterialTexture | MaterialTexture} and their respective {@link Texture}.\n   */\n  createMaterialTextures() {\n    this.scenesManager.materialsTextures = []\n\n    if (this.gltf.materials) {\n      for (const [materialIndex, material] of Object.entries(this.gltf.materials)) {\n        // TODO handle custom/additional UV attributes\n        const materialTextures = {\n          material: materialIndex,\n          texturesDescriptors: [],\n        }\n\n        const getUVAttributeName = (texture) => {\n          if (!texture.texCoord) return 'uv'\n\n          return texture.texCoord !== 0 ? 'uv' + texture.texCoord : 'uv'\n        }\n\n        this.scenesManager.materialsTextures[materialIndex] = materialTextures\n\n        if (material.pbrMetallicRoughness) {\n          if (\n            material.pbrMetallicRoughness.baseColorTexture &&\n            material.pbrMetallicRoughness.baseColorTexture.index !== undefined\n          ) {\n            const index = material.pbrMetallicRoughness.baseColorTexture.index\n            const image = this.gltf.imagesBitmaps[this.gltf.textures[index].source]\n\n            const texture = this.createTexture(material, image, 'baseColorTexture')\n            const samplerIndex = this.gltf.textures.find((t) => t.source === index)?.sampler\n\n            materialTextures.texturesDescriptors.push({\n              texture,\n              sampler: this.scenesManager.samplers[samplerIndex ?? 0],\n              texCoordAttributeName: getUVAttributeName(material.pbrMetallicRoughness.baseColorTexture),\n            })\n          }\n\n          if (\n            material.pbrMetallicRoughness.metallicRoughnessTexture &&\n            material.pbrMetallicRoughness.metallicRoughnessTexture.index !== undefined\n          ) {\n            const index = material.pbrMetallicRoughness.metallicRoughnessTexture.index\n            const image = this.gltf.imagesBitmaps[this.gltf.textures[index].source]\n\n            const texture = this.createTexture(material, image, 'metallicRoughnessTexture')\n            const samplerIndex = this.gltf.textures.find((t) => t.source === index)?.sampler\n\n            materialTextures.texturesDescriptors.push({\n              texture,\n              sampler: this.scenesManager.samplers[samplerIndex ?? 0],\n              texCoordAttributeName: getUVAttributeName(material.pbrMetallicRoughness.metallicRoughnessTexture),\n            })\n          }\n        }\n\n        if (material.normalTexture && material.normalTexture.index !== undefined) {\n          const index = material.normalTexture.index\n          const image = this.gltf.imagesBitmaps[this.gltf.textures[index].source]\n\n          const texture = this.createTexture(material, image, 'normalTexture')\n          const samplerIndex = this.gltf.textures.find((t) => t.source === index)?.sampler\n\n          materialTextures.texturesDescriptors.push({\n            texture,\n            sampler: this.scenesManager.samplers[samplerIndex ?? 0],\n            texCoordAttributeName: getUVAttributeName(material.normalTexture),\n          })\n        }\n\n        if (material.occlusionTexture && material.occlusionTexture.index !== undefined) {\n          const index = material.occlusionTexture.index\n          const image = this.gltf.imagesBitmaps[this.gltf.textures[index].source]\n\n          const texture = this.createTexture(material, image, 'occlusionTexture')\n          const samplerIndex = this.gltf.textures.find((t) => t.source === index)?.sampler\n\n          materialTextures.texturesDescriptors.push({\n            texture,\n            sampler: this.scenesManager.samplers[samplerIndex ?? 0],\n            texCoordAttributeName: getUVAttributeName(material.occlusionTexture),\n          })\n        }\n\n        if (material.emissiveTexture && material.emissiveTexture.index !== undefined) {\n          const index = material.emissiveTexture.index\n          const image = this.gltf.imagesBitmaps[this.gltf.textures[index].source]\n\n          const texture = this.createTexture(material, image, 'emissiveTexture')\n          const samplerIndex = this.gltf.textures.find((t) => t.source === index)?.sampler\n\n          materialTextures.texturesDescriptors.push({\n            texture,\n            sampler: this.scenesManager.samplers[samplerIndex ?? 0],\n            texCoordAttributeName: getUVAttributeName(material.emissiveTexture),\n          })\n        }\n      }\n    }\n  }\n\n  /**\n   * Create a {@link ChildDescriptor} from a parent {@link ChildDescriptor} and a {@link GLTF.INode | GLTF Node}\n   * @param parent - parent {@link ChildDescriptor} to use.\n   * @param node - {@link GLTF.INode | GLTF Node} to use.\n   */\n  createNode(parent: ChildDescriptor, node: GLTF.INode) {\n    if (node.camera !== undefined) return\n\n    const child: ChildDescriptor = {\n      name: node.name,\n      node: new Object3D(),\n      children: [],\n    }\n\n    parent.children.push(child)\n\n    child.node.parent = parent.node\n\n    if (node.matrix) {\n      child.node.modelMatrix.setFromArray(new Float32Array(node.matrix))\n      // avoid overriding the matrix with empty position/scale/rotation\n      child.node.matrices.model.shouldUpdate = false\n    } else {\n      if (node.translation) child.node.position.set(node.translation[0], node.translation[1], node.translation[2])\n      if (node.scale) child.node.scale.set(node.scale[0], node.scale[1], node.scale[2])\n      if (node.rotation) child.node.quaternion.setFromArray(new Float32Array(node.rotation))\n    }\n\n    const mesh = this.gltf.meshes[node.mesh]\n\n    if (node.children) {\n      node.children.forEach((childNodeIndex) => {\n        const childNode = this.gltf.nodes[childNodeIndex]\n        this.createNode(child, childNode)\n      })\n    }\n\n    if (mesh) {\n      // each primitive is in fact a mesh\n      mesh.primitives.forEach((primitive, index) => {\n        const meshDescriptor: MeshDescriptor = {\n          parent: child.node,\n          attributes: [],\n          textures: [],\n          parameters: {\n            label: mesh.name ? mesh.name + ' ' + index : 'glTF mesh ' + index,\n          },\n          nodes: [],\n        }\n\n        let instancesDescriptor = this.#primitiveInstances.get(primitive)\n        if (!instancesDescriptor) {\n          instancesDescriptor = {\n            instances: [], // instances\n            nodes: [], // node transform\n            meshDescriptor,\n          }\n\n          this.#primitiveInstances.set(primitive, instancesDescriptor)\n        }\n\n        instancesDescriptor.instances.push(node)\n        instancesDescriptor.nodes.push(child.node)\n      })\n    }\n  }\n\n  /**\n   * Create the {@link ScenesManager#scenes | ScenesManager scenes} based on the {@link gltf} object.\n   */\n  createScenes() {\n    this.scenesManager.node.parent = this.renderer.scene\n\n    this.gltf.scenes.forEach((childScene) => {\n      const sceneDescriptor = {\n        name: childScene.name,\n        children: [],\n        node: new Object3D(),\n      }\n\n      sceneDescriptor.node.parent = this.scenesManager.node\n\n      this.scenesManager.scenes.push(sceneDescriptor)\n\n      childScene.nodes.forEach((nodeIndex) => {\n        const node = this.gltf.nodes[nodeIndex]\n        this.createNode(sceneDescriptor, node)\n      })\n    })\n\n    // now that we created all our nodes, update all the matrices eagerly\n    // needed to get the right bounding box\n    this.scenesManager.node.updateMatrixStack()\n\n    for (const [primitive, primitiveInstance] of this.#primitiveInstances) {\n      const { instances, nodes, meshDescriptor } = primitiveInstance\n\n      const instancesCount = instances.length\n\n      meshDescriptor.nodes = nodes\n\n      this.scenesManager.meshesDescriptors.push(meshDescriptor)\n\n      // ------------------------------------\n      // GEOMETRY\n      // ------------------------------------\n\n      const geometryBBox = new Box3()\n\n      // TODO should we pass an already created buffer to the geometry main vertex and index buffers if possible?\n      // and use bufferOffset and bufferSize parameters\n      // if the accessors byteOffset is large enough,\n      // it means we have an array that is not interleaved (with each vertexBuffer attributes bufferOffset = 0)\n      // but we can deal with the actual offset in the geometry setVertexBuffer call!\n      // see https://toji.dev/webgpu-gltf-case-study/#handling-large-attribute-offsets\n\n      const defaultAttributes = []\n\n      // check whether the buffer view is already interleaved\n      let interleavedArray = null\n      let interleavedBufferView = null\n      let maxByteOffset = 0\n\n      // prepare default attributes\n      for (const [attribName, accessorIndex] of Object.entries(primitive.attributes)) {\n        const accessor = this.gltf.accessors[accessorIndex as number]\n\n        const constructor = GLTFScenesManager.getTypedArrayConstructorFromComponentType(accessor.componentType)\n\n        const bufferView = this.gltf.bufferViews[accessor.bufferView]\n\n        // clean attributes names\n        const name =\n          attribName === 'TEXCOORD_0' ? 'uv' : attribName.replace('_', '').replace('TEXCOORD', 'uv').toLowerCase()\n\n        const byteStride = bufferView.byteStride || 0\n        const accessorByteOffset = accessor.byteOffset || 0\n        if (byteStride && accessorByteOffset && accessorByteOffset < byteStride) {\n          maxByteOffset = Math.max(accessorByteOffset, maxByteOffset)\n        } else {\n          maxByteOffset = 0\n        }\n\n        // custom bbox\n        // glTF specs says: \"vertex position attribute accessors MUST have accessor.min and accessor.max defined\"\n        if (name === 'position') {\n          geometryBBox.min.min(new Vec3(accessor.min[0], accessor.min[1], accessor.min[2]))\n          geometryBBox.max.max(new Vec3(accessor.max[0], accessor.max[1], accessor.max[2]))\n\n          interleavedBufferView = bufferView\n        }\n\n        const attributeParams = GLTFScenesManager.getVertexAttributeParamsFromType(accessor.type)\n\n        const attribute = {\n          name,\n          ...attributeParams,\n          array: new constructor(\n            this.gltf.arrayBuffers[bufferView.buffer],\n            accessor.byteOffset + bufferView.byteOffset,\n            accessor.count * attributeParams.size\n          ),\n        }\n\n        defaultAttributes.push(attribute)\n        meshDescriptor.attributes.push({\n          name: attribute.name,\n          type: attribute.type,\n        })\n      }\n\n      if (maxByteOffset > 0) {\n        // check they are all really interleaved\n        const accessorsBufferViews = Object.values(primitive.attributes).map(\n          (accessorIndex) => this.gltf.accessors[accessorIndex as number].bufferView\n        )\n\n        if (!accessorsBufferViews.every((val) => val === accessorsBufferViews[0])) {\n          // we're not that lucky since we have interleaved values coming from different positions of our main buffer\n          // we'll have to rebuild an interleaved array ourselves\n          let totalStride = 0\n          const mainBufferStrides = {}\n          const arrayLength = Object.values(primitive.attributes).reduce(\n            (acc: number, accessorIndex: number): number => {\n              const accessor = this.gltf.accessors[accessorIndex]\n\n              const attrSize = GLTFScenesManager.getVertexAttributeParamsFromType(accessor.type).size\n\n              if (!mainBufferStrides[accessor.bufferView]) {\n                mainBufferStrides[accessor.bufferView] = 0\n              }\n\n              mainBufferStrides[accessor.bufferView] = Math.max(\n                mainBufferStrides[accessor.bufferView],\n                accessor.byteOffset + attrSize * Float32Array.BYTES_PER_ELEMENT\n              )\n\n              totalStride += attrSize * Float32Array.BYTES_PER_ELEMENT\n\n              return acc + accessor.count * attrSize\n            },\n            0\n          ) as number\n\n          interleavedArray = new Float32Array(Math.ceil(arrayLength / 4) * 4)\n\n          Object.values(primitive.attributes).forEach((accessorIndex: number) => {\n            const accessor = this.gltf.accessors[accessorIndex]\n            const bufferView = this.gltf.bufferViews[accessor.bufferView]\n\n            const attrSize = GLTFScenesManager.getVertexAttributeParamsFromType(accessor.type).size\n\n            for (let i = 0; i < accessor.count; i++) {\n              const startOffset =\n                accessor.byteOffset / Float32Array.BYTES_PER_ELEMENT +\n                (i * totalStride) / Float32Array.BYTES_PER_ELEMENT\n\n              interleavedArray\n                .subarray(startOffset, startOffset + attrSize)\n                .set(\n                  new Float32Array(\n                    this.gltf.arrayBuffers[bufferView.buffer],\n                    bufferView.byteOffset + accessor.byteOffset + i * mainBufferStrides[accessor.bufferView],\n                    attrSize\n                  )\n                )\n            }\n          })\n        } else {\n          // we're lucky to have an interleaved array!\n          // we won't have to compute our geometry!\n          interleavedArray = new Float32Array(\n            this.gltf.arrayBuffers[interleavedBufferView.buffer],\n            interleavedBufferView.byteOffset,\n            (Math.ceil(interleavedBufferView.byteLength / 4) * 4) / Float32Array.BYTES_PER_ELEMENT\n          )\n        }\n      } else {\n        // not interleaved?\n        // let's try to reorder the attributes so we might benefit from pipeline cache\n        const attribOrder = ['position', 'uv', 'normal']\n\n        defaultAttributes.sort((a, b) => {\n          let aIndex = attribOrder.findIndex((attrName) => attrName === a.name)\n          aIndex = aIndex === -1 ? Infinity : aIndex\n\n          let bIndex = attribOrder.findIndex((attrName) => attrName === b.name)\n          bIndex = bIndex === -1 ? Infinity : bIndex\n\n          return aIndex - bIndex\n        })\n      }\n\n      const geometryAttributes: GeometryParams = {\n        instancesCount,\n        topology: GLTFScenesManager.gpuPrimitiveTopologyForMode(primitive.mode),\n        vertexBuffers: [\n          {\n            name: 'attributes',\n            stepMode: 'vertex', // explicitly set the stepMode even if not mandatory\n            attributes: defaultAttributes,\n            ...(interleavedArray && { array: interleavedArray }), // interleaved array!\n          },\n        ],\n      }\n\n      const isIndexedGeometry = 'indices' in primitive\n      const GeometryConstructor = isIndexedGeometry ? IndexedGeometry : Geometry\n\n      meshDescriptor.parameters.geometry = new GeometryConstructor(geometryAttributes)\n      //meshDescriptor.parameters.geometry.boundingBox.copy(geometryBBox)\n      meshDescriptor.parameters.geometry.boundingBox = geometryBBox\n\n      if (isIndexedGeometry) {\n        const accessor = this.gltf.accessors[primitive.indices]\n        const bufferView = this.gltf.bufferViews[accessor.bufferView]\n\n        const constructor = GLTFScenesManager.getTypedArrayConstructorFromComponentType(accessor.componentType) as\n          | Uint32ArrayConstructor\n          | Uint16ArrayConstructor\n\n        const arrayOffset = accessor.byteOffset + bufferView.byteOffset\n        const arrayBuffer = this.gltf.arrayBuffers[bufferView.buffer]\n        const arrayLength = Math.min(\n          (arrayBuffer.byteLength - arrayOffset) / constructor.BYTES_PER_ELEMENT,\n          Math.ceil(accessor.count / 4) * 4\n        )\n\n        // do not allow Uint8Array arrays\n        const array =\n          constructor.name === 'Uint8Array'\n            ? Uint16Array.from(new constructor(arrayBuffer, arrayOffset, arrayLength))\n            : new constructor(arrayBuffer, arrayOffset, arrayLength)\n\n        ;(meshDescriptor.parameters.geometry as IndexedGeometry).setIndexBuffer({\n          bufferFormat: constructor.name === 'Uint32Array' ? 'uint32' : 'uint16',\n          array,\n        })\n      }\n\n      // ------------------------------------\n      // MATERIAL\n      // ------------------------------------\n\n      const materialTextures = this.scenesManager.materialsTextures[primitive.material]\n\n      meshDescriptor.parameters.samplers = []\n      meshDescriptor.parameters.textures = []\n\n      materialTextures?.texturesDescriptors.forEach((t) => {\n        meshDescriptor.textures.push({\n          texture: t.texture.options.name,\n          sampler: t.sampler.name,\n          texCoordAttributeName: t.texCoordAttributeName,\n        })\n\n        const samplerExists = meshDescriptor.parameters.samplers.find((s) => s.uuid === t.sampler.uuid)\n\n        if (!samplerExists) {\n          meshDescriptor.parameters.samplers.push(t.sampler)\n        }\n\n        meshDescriptor.parameters.textures.push(t.texture)\n      })\n\n      const material = (this.gltf.materials && this.gltf.materials[primitive.material]) || {}\n\n      meshDescriptor.parameters.cullMode = material.doubleSided ? 'none' : 'back'\n\n      // transparency\n      if (material.alphaMode === 'BLEND' || (material.extensions && material.extensions.KHR_materials_transmission)) {\n        meshDescriptor.parameters.transparent = true\n        meshDescriptor.parameters.targets = [\n          {\n            blend: {\n              color: {\n                srcFactor: 'src-alpha',\n                dstFactor: 'one-minus-src-alpha',\n              },\n              alpha: {\n                // This just prevents the canvas from having alpha \"holes\" in it.\n                srcFactor: 'one',\n                dstFactor: 'one',\n              },\n            },\n          },\n        ]\n      }\n\n      // uniforms\n      const materialUniformStruct = {\n        baseColorFactor: {\n          type: 'vec4f',\n          value: material.pbrMetallicRoughness?.baseColorFactor || [1, 1, 1, 1],\n        },\n        alphaCutoff: {\n          type: 'f32',\n          value: material.alphaCutoff !== undefined ? material.alphaCutoff : material.alphaMode === 'MASK' ? 0.5 : 0,\n        },\n        metallicFactor: {\n          type: 'f32',\n          value:\n            material.pbrMetallicRoughness?.metallicFactor === undefined\n              ? 1\n              : material.pbrMetallicRoughness.metallicFactor,\n        },\n        roughnessFactor: {\n          type: 'f32',\n          value:\n            material.pbrMetallicRoughness?.roughnessFactor === undefined\n              ? 1\n              : material.pbrMetallicRoughness.roughnessFactor,\n        },\n        normalMapScale: {\n          type: 'f32',\n          value: material.normalTexture?.scale === undefined ? 1 : material.normalTexture.scale,\n        },\n        occlusionStrength: {\n          type: 'f32',\n          value: material.occlusionTexture?.strength === undefined ? 1 : material.occlusionTexture.strength,\n        },\n        emissiveFactor: {\n          type: 'vec3f',\n          value: material.emissiveFactor !== undefined ? material.emissiveFactor : [1, 1, 1],\n        },\n      }\n\n      if (Object.keys(materialUniformStruct).length) {\n        meshDescriptor.parameters.uniforms = {\n          material: {\n            visibility: ['vertex', 'fragment'],\n            struct: materialUniformStruct,\n          },\n        }\n      }\n\n      // instances matrices storage\n      if (instancesCount > 1) {\n        const worldMatrices = new Float32Array(instancesCount * 16)\n        const normalMatrices = new Float32Array(instancesCount * 16)\n\n        for (let i = 0; i < instancesCount; ++i) {\n          worldMatrices.set(nodes[i].worldMatrix.elements, i * 16)\n\n          _normalMatrix.copy(nodes[i].worldMatrix).invert().transpose()\n          normalMatrices.set(_normalMatrix.elements, i * 16)\n        }\n\n        meshDescriptor.parameters.storages = {\n          instances: {\n            visibility: ['vertex', 'fragment'],\n            struct: {\n              modelMatrix: {\n                type: 'array<mat4x4f>',\n                value: worldMatrices,\n              },\n              normalMatrix: {\n                type: 'array<mat4x4f>',\n                value: normalMatrices,\n              },\n            },\n          },\n        }\n      }\n\n      // computed transformed bbox\n      for (let i = 0; i < nodes.length; i++) {\n        const tempBbox = geometryBBox.clone()\n        const transformedBbox = tempBbox.applyMat4(meshDescriptor.nodes[i].worldMatrix)\n\n        this.scenesManager.boundingBox.min.min(transformedBbox.min)\n        this.scenesManager.boundingBox.max.max(transformedBbox.max)\n      }\n    }\n  }\n\n  /**\n   * Add all the needed {@link Mesh} based on the {@link ScenesManager#meshesDescriptors | ScenesManager meshesDescriptors} array.\n   * @param patchMeshesParameters - allow to optionally patch the {@link Mesh} parameters before creating it (can be used to add custom shaders, uniforms or storages, change rendering options, etc.)\n   * @returns - Array of created {@link Mesh}.\n   */\n  addMeshes(patchMeshesParameters = (meshDescriptor: MeshDescriptor) => {}): Mesh[] {\n    // once again, update all the matrix stack eagerly\n    // because the main node or children transformations might have changed\n    this.scenesManager.node.updateMatrixStack()\n\n    return this.scenesManager.meshesDescriptors.map((meshDescriptor) => {\n      if (meshDescriptor.parameters.geometry) {\n        // patch the parameters\n        patchMeshesParameters(meshDescriptor)\n\n        const hasInstancedShadows =\n          meshDescriptor.parameters.geometry.instancesCount > 1 && meshDescriptor.parameters.castShadows\n\n        if (hasInstancedShadows) {\n          meshDescriptor.parameters.castShadows = false\n        }\n\n        const mesh = new Mesh(this.renderer, {\n          ...meshDescriptor.parameters,\n        })\n\n        if (meshDescriptor.nodes.length > 1) {\n          // if we're dealing with instances\n          // we must patch the mesh updateWorldMatrix method\n          // in order to update the instanceMatrix binding each time the mesh world matrix change\n\n          const _updateWorldMatrix = mesh.updateWorldMatrix.bind(mesh)\n          mesh.updateWorldMatrix = () => {\n            _updateWorldMatrix()\n\n            meshDescriptor.nodes.forEach((node, i) => {\n              ;(mesh.storages.instances.modelMatrix.value as TypedArray).set(node.worldMatrix.elements, i * 16)\n\n              _normalMatrix.copy(node.worldMatrix).invert().transpose()\n              ;(mesh.storages.instances.normalMatrix.value as TypedArray).set(_normalMatrix.elements, i * 16)\n            })\n\n            mesh.storages.instances.modelMatrix.shouldUpdate = true\n            mesh.storages.instances.normalMatrix.shouldUpdate = true\n          }\n        }\n\n        // instanced shadows\n        if (hasInstancedShadows) {\n          const instancesBinding = mesh.material.inputsBindings.get('instances')\n\n          this.renderer.shadowCastingLights.forEach((light) => {\n            if (light.shadow.isActive) {\n              light.shadow.addShadowCastingMesh(mesh, {\n                bindings: [instancesBinding],\n              })\n            }\n          })\n        }\n\n        mesh.parent = meshDescriptor.parent\n\n        this.scenesManager.meshes.push(mesh)\n\n        return mesh\n      }\n    })\n  }\n\n  /**\n   * Destroy the current {@link ScenesManager} by removing all created {@link ScenesManager#meshes | meshes} and destroying all the {@link Object3D} nodes.\n   */\n  destroy() {\n    this.scenesManager.meshes.forEach((mesh) => mesh.remove())\n    this.scenesManager.meshes = []\n\n    const nodes = this.scenesManager.getScenesNodes()\n    nodes.forEach((node) => {\n      node.destroy()\n    })\n\n    this.scenesManager.node.destroy()\n  }\n}\n","import { MeshDescriptor } from '../../types/gltf/GLTFScenesManager'\r\nimport { ShaderOptions } from '../../types/Materials'\r\nimport { Texture } from '../../core/textures/Texture'\r\nimport { Sampler } from '../../core/samplers/Sampler'\r\nimport { ComputePass } from '../../core/computePasses/ComputePass'\r\nimport { Renderer } from '../../core/renderers/utils'\r\nimport { throwWarning } from '../../utils/utils'\r\nimport { getLambert, GetShadingParams } from '../../core/shaders/chunks/shading/lambert-shading'\r\nimport { getPhong } from '../../core/shaders/chunks/shading/phong-shading'\r\nimport { getPBR } from '../../core/shaders/chunks/shading/pbr-shading'\r\nimport { getIBL } from '../../core/shaders/chunks/shading/ibl-shading'\r\n\r\n/** Defines all kinds of shading models available. */\r\nexport type ShadingModels = 'Lambert' | 'Phong' | 'PBR' | 'IBL'\r\n\r\n/**\r\n * Parameters to use for IBL textures.\r\n */\r\nexport interface IBLShaderTextureParams {\r\n  /** {@link Texture} to use. */\r\n  texture: Texture\r\n  /** {@link Sampler#name | Sampler name} to use. */\r\n  samplerName?: Sampler['name']\r\n}\r\n\r\n/**\r\n * Parameters used to build the shaders\r\n */\r\nexport interface ShaderBuilderParameters {\r\n  /** Shading model to use. */\r\n  shadingModel?: ShadingModels\r\n  /** Additional WGSL chunks to add to the shaders. */\r\n  chunks?: {\r\n    /** Additional WGSL chunk to add to the fragment shader head. */\r\n    additionalFragmentHead?: string\r\n    /** Preliminary modification to apply to the fragment shader `color` `vec4f` variable before applying any lightning calculations. */\r\n    preliminaryColorContribution?: string\r\n    /** Additional modification to apply to the fragment shader `color` `vec4f` variable before returning it. */\r\n    additionalColorContribution?: string\r\n  }\r\n  /** Additional IBL parameters to pass as uniform and textures. */\r\n  iblParameters?: {\r\n    /** Environment diffuse strength. Default to `0.5`. */\r\n    diffuseStrength?: number\r\n    /** Environment specular strength. Default to `0.5`. */\r\n    specularStrength?: number\r\n    /** Look Up Table texture parameters to use for IBL. */\r\n    lutTexture?: IBLShaderTextureParams\r\n    /** Environment diffuse texture parameters to use for IBL. */\r\n    envDiffuseTexture?: IBLShaderTextureParams\r\n    /** Environment specular texture parameters to use for IBL. */\r\n    envSpecularTexture?: IBLShaderTextureParams\r\n  }\r\n}\r\n\r\n/** Shaders returned by the shaders builder function. */\r\nexport interface BuiltShaders {\r\n  /** Vertex shader returned by the PBR shader builder. */\r\n  vertex: ShaderOptions\r\n  /** Fragment shader returned by the PBR shader builder. */\r\n  fragment: ShaderOptions\r\n}\r\n\r\n/**\r\n * Build shaders made for glTF parsed objects, based on a {@link MeshDescriptor} and optional {@link ShaderBuilderParameters | shader parameters}.\r\n *\r\n * @param meshDescriptor - {@link MeshDescriptor} built by the {@link extras/gltf/GLTFScenesManager.GLTFScenesManager | GLTFScenesManager}\r\n * @param shaderParameters - {@link ShaderBuilderParameters | shader parameters} to use.\r\n * @returns - An object containing the shaders.\r\n */\r\nexport const buildShaders = (\r\n  meshDescriptor: MeshDescriptor,\r\n  shaderParameters = {} as ShaderBuilderParameters\r\n): BuiltShaders => {\r\n  // textures check\r\n  const baseColorTexture = meshDescriptor.textures.find((t) => t.texture === 'baseColorTexture')\r\n  const normalTexture = meshDescriptor.textures.find((t) => t.texture === 'normalTexture')\r\n  const emissiveTexture = meshDescriptor.textures.find((t) => t.texture === 'emissiveTexture')\r\n  const occlusionTexture = meshDescriptor.textures.find((t) => t.texture === 'occlusionTexture')\r\n  const metallicRoughnessTexture = meshDescriptor.textures.find((t) => t.texture === 'metallicRoughnessTexture')\r\n\r\n  const facultativeAttributes = meshDescriptor.attributes.filter((attribute) => attribute.name !== 'position')\r\n\r\n  const structAttributes = facultativeAttributes\r\n    .map((attribute, index) => {\r\n      return `@location(${index}) ${attribute.name}: ${attribute.type},`\r\n    })\r\n    .join('\\n\\t')\r\n\r\n  let outputPositions = /* wgsl */ `\r\n    let worldPos = matrices.model * vec4(attributes.position, 1.0);\r\n    vsOutput.position = camera.projection * camera.view * worldPos;\r\n    vsOutput.worldPosition = worldPos.xyz / worldPos.w;\r\n    vsOutput.viewDirection = camera.position - vsOutput.worldPosition.xyz;\r\n  `\r\n  let outputNormal = facultativeAttributes.find((attr) => attr.name === 'normal')\r\n    ? 'vsOutput.normal = getWorldNormal(attributes.normal);'\r\n    : ''\r\n\r\n  if (meshDescriptor.parameters.storages && meshDescriptor.parameters.storages.instances) {\r\n    outputPositions = /* wgsl */ `\r\n      let worldPos: vec4f = instances[attributes.instanceIndex].modelMatrix * vec4f(attributes.position, 1.0);\r\n      vsOutput.position = camera.projection * camera.view * worldPos;\r\n      vsOutput.worldPosition = worldPos.xyz;\r\n      vsOutput.viewDirection = camera.position - vsOutput.worldPosition;\r\n      `\r\n\r\n    outputNormal = `vsOutput.normal = normalize((instances[attributes.instanceIndex].normalMatrix * vec4(attributes.normal, 0.0)).xyz);`\r\n  }\r\n\r\n  const outputAttributes = facultativeAttributes\r\n    .filter((attr) => attr.name !== 'normal')\r\n    .map((attribute) => {\r\n      return `vsOutput.${attribute.name} = attributes.${attribute.name};`\r\n    })\r\n    .join('\\n\\t')\r\n\r\n  let vertexOutputContent = `\r\n      @builtin(position) position: vec4f,\r\n      @location(${facultativeAttributes.length}) viewDirection: vec3f,\r\n      @location(${facultativeAttributes.length + 1}) worldPosition: vec3f,\r\n      ${structAttributes}\r\n  `\r\n\r\n  let outputNormalMap = ''\r\n  const tangentAttribute = facultativeAttributes.find((attr) => attr.name === 'tangent')\r\n  const useNormalMap = !!(normalTexture && tangentAttribute)\r\n\r\n  if (useNormalMap) {\r\n    vertexOutputContent += `\r\n      @location(${facultativeAttributes.length + 2}) bitangent: vec3f,\r\n      `\r\n\r\n    outputNormalMap = `\r\n        vsOutput.tangent = normalize(matrices.model * attributes.tangent);\r\n        vsOutput.bitangent = cross(vsOutput.normal, vsOutput.tangent.xyz) * attributes.tangent.w;\r\n      `\r\n  }\r\n\r\n  const vertexOutput = /*wgsl */ `\r\n    struct VSOutput {\r\n      ${vertexOutputContent}\r\n    };`\r\n\r\n  const fragmentInput = /*wgsl */ `\r\n    struct VSOutput {\r\n      @builtin(front_facing) frontFacing: bool,\r\n      ${vertexOutputContent}\r\n    };`\r\n\r\n  const vs = /* wgsl */ `\r\n    ${vertexOutput}\r\n    \r\n    @vertex fn main(\r\n      attributes: Attributes,\r\n    ) -> VSOutput {\r\n      var vsOutput: VSOutput;\r\n    \r\n      ${outputPositions}\r\n      ${outputNormal}\r\n      ${outputAttributes}\r\n      \r\n      ${outputNormalMap}\r\n\r\n      return vsOutput;\r\n    }\r\n  `\r\n\r\n  // not a PBR material for now, as it does not use roughness/metalness\r\n  // we might want to implement it later\r\n  // see https://github.com/oframe/ogl/blob/master/examples/load-gltf.html#L133\r\n  const initColor = /* wgsl */ 'var color: vec4f = vec4();'\r\n  const returnColor = /* wgsl */ `\r\n      return color;\r\n  `\r\n\r\n  // start with the base color\r\n  // use vertex color 0 if defined\r\n  const vertexColor = meshDescriptor.attributes.find((attr) => attr.name === 'color0')\r\n  let baseColor = /* wgsl */ !!vertexColor\r\n    ? vertexColor.type === 'vec3f'\r\n      ? 'var baseColor: vec4f = vec4(fsInput.color0, 1.0) * material.baseColorFactor;'\r\n      : 'var baseColor: vec4f = fsInput.color0 * material.baseColorFactor;'\r\n    : 'var baseColor: vec4f = material.baseColorFactor;'\r\n\r\n  if (baseColorTexture) {\r\n    baseColor = /* wgsl */ `\r\n      var baseColor: vec4f = textureSample(baseColorTexture, ${baseColorTexture.sampler}, fsInput.${baseColorTexture.texCoordAttributeName}) * material.baseColorFactor;\r\n      \r\n      if (baseColor.a < material.alphaCutoff) {\r\n        discard;\r\n      }\r\n    `\r\n  }\r\n\r\n  baseColor += /* wgsl */ `\r\n      color = baseColor;\r\n  `\r\n\r\n  // normal map\r\n\r\n  let normalMap = meshDescriptor.attributes.find((attribute) => attribute.name === 'normal')\r\n    ? /* wgsl */ `\r\n      let faceDirection = select(-1.0, 1.0, fsInput.frontFacing);\r\n      let geometryNormal: vec3f = normalize(faceDirection * fsInput.normal);\r\n    `\r\n    : /* wgsl */ `let geometryNormal: vec3f = normalize(vec3(0.0, 0.0, 1.0));`\r\n\r\n  if (useNormalMap) {\r\n    normalMap += /* wgsl */ `\r\n      let tbn = mat3x3<f32>(normalize(fsInput.tangent.xyz), normalize(fsInput.bitangent), geometryNormal);\r\n      let normalMap = textureSample(normalTexture, ${normalTexture.sampler}, fsInput.${normalTexture.texCoordAttributeName}).rgb;\r\n      let normal = normalize(tbn * (2.0 * normalMap - vec3(material.normalMapScale, material.normalMapScale, 1.0)));\r\n    `\r\n  } else {\r\n    normalMap += /* wgsl */ `\r\n      let normal = geometryNormal;\r\n    `\r\n  }\r\n\r\n  // metallic roughness\r\n  let metallicRoughness = /*  wgsl */ `\r\n      var metallic = material.metallicFactor;\r\n      var roughness = material.roughnessFactor;\r\n  `\r\n\r\n  if (metallicRoughnessTexture) {\r\n    metallicRoughness += /* wgsl */ `\r\n      let metallicRoughness = textureSample(metallicRoughnessTexture, ${metallicRoughnessTexture.sampler}, fsInput.${metallicRoughnessTexture.texCoordAttributeName});\r\n      \r\n      metallic = clamp(metallic * metallicRoughness.b, 0.0, 1.0);\r\n      roughness = clamp(roughness * metallicRoughness.g, 0.0, 1.0);\r\n    `\r\n  }\r\n\r\n  const f0 = /* wgsl */ `\r\n      let f0: vec3f = mix(vec3(0.04), color.rgb, vec3(metallic));\r\n  `\r\n\r\n  // emissive and occlusion\r\n  let emissiveOcclusion = /* wgsl */ `\r\n      var emissive: vec3f = vec3(0.0);\r\n      var occlusion: f32 = 1.0;\r\n  `\r\n\r\n  if (emissiveTexture) {\r\n    emissiveOcclusion += /* wgsl */ `\r\n      emissive = textureSample(emissiveTexture, ${emissiveTexture.sampler}, fsInput.${emissiveTexture.texCoordAttributeName}).rgb;\r\n      \r\n      emissive *= material.emissiveFactor;\r\n      `\r\n    if (occlusionTexture) {\r\n      emissiveOcclusion += /* wgsl */ `\r\n      occlusion = textureSample(occlusionTexture, ${occlusionTexture.sampler}, fsInput.${occlusionTexture.texCoordAttributeName}).r;\r\n      `\r\n    }\r\n  }\r\n\r\n  emissiveOcclusion += /* wgsl */ `\r\n      occlusion = 1.0 + material.occlusionStrength * (occlusion - 1.0);\r\n  `\r\n\r\n  // Shader parameters\r\n  let { shadingModel } = shaderParameters\r\n  if (!shadingModel) {\r\n    shadingModel = 'PBR'\r\n  }\r\n\r\n  let { chunks } = shaderParameters || {}\r\n  const { iblParameters } = shaderParameters || {}\r\n  const { lutTexture, envDiffuseTexture, envSpecularTexture } = iblParameters || {}\r\n\r\n  const useIBLContribution =\r\n    envDiffuseTexture &&\r\n    envDiffuseTexture.texture &&\r\n    envSpecularTexture &&\r\n    envSpecularTexture.texture &&\r\n    lutTexture &&\r\n    lutTexture.texture\r\n\r\n  if (useIBLContribution && shadingModel === 'IBL') {\r\n    // add lights & ibl uniforms\r\n    meshDescriptor.parameters.uniforms = {\r\n      ...meshDescriptor.parameters.uniforms,\r\n      ...{\r\n        ibl: {\r\n          struct: {\r\n            diffuseStrength: {\r\n              type: 'f32',\r\n              value: iblParameters?.diffuseStrength ?? 0.5,\r\n            },\r\n            specularStrength: {\r\n              type: 'f32',\r\n              value: iblParameters?.specularStrength ?? 0.5,\r\n            },\r\n          },\r\n        },\r\n      },\r\n    }\r\n\r\n    meshDescriptor.parameters.textures = [\r\n      ...meshDescriptor.parameters.textures,\r\n      lutTexture.texture,\r\n      envDiffuseTexture.texture,\r\n      envSpecularTexture.texture,\r\n    ]\r\n\r\n    lutTexture.samplerName = lutTexture.samplerName || 'defaultSampler'\r\n    envDiffuseTexture.samplerName = envDiffuseTexture.samplerName || 'defaultSampler'\r\n    envSpecularTexture.samplerName = envSpecularTexture.samplerName || 'defaultSampler'\r\n  } else if (shadingModel === 'IBL') {\r\n    throwWarning(\r\n      'IBL shading requested but one of the LUT, environment specular or diffuse texture is missing. Defaulting to PBR shading.'\r\n    )\r\n    shadingModel = 'PBR'\r\n  }\r\n\r\n  const shadingOptions: GetShadingParams = {\r\n    toneMapping: 'khronos',\r\n    receiveShadows: !!meshDescriptor.parameters.receiveShadows,\r\n    useOcclusion: true,\r\n  }\r\n\r\n  // user defined chunks\r\n  const defaultAdditionalHead = (() => {\r\n    switch (shadingModel) {\r\n      case 'Lambert':\r\n      default:\r\n        return getLambert(shadingOptions)\r\n      case 'Phong':\r\n        return getPhong(shadingOptions)\r\n      case 'PBR':\r\n        return getPBR(shadingOptions)\r\n      case 'IBL':\r\n        return getIBL(shadingOptions)\r\n    }\r\n  })()\r\n\r\n  const defaultPreliminaryColor = ''\r\n  const defaultAdditionalColor = ''\r\n\r\n  if (!chunks) {\r\n    chunks = {\r\n      additionalFragmentHead: defaultAdditionalHead,\r\n      preliminaryColorContribution: defaultPreliminaryColor,\r\n      additionalColorContribution: defaultAdditionalColor,\r\n    }\r\n  } else {\r\n    if (!chunks.additionalFragmentHead) {\r\n      chunks.additionalFragmentHead = defaultAdditionalHead\r\n    } else {\r\n      chunks.additionalFragmentHead = defaultAdditionalHead + chunks.additionalFragmentHead\r\n    }\r\n\r\n    if (!chunks.preliminaryColorContribution) {\r\n      chunks.preliminaryColorContribution = defaultPreliminaryColor\r\n    } else {\r\n      chunks.preliminaryColorContribution = defaultPreliminaryColor + chunks.preliminaryColorContribution\r\n    }\r\n\r\n    if (!chunks.additionalColorContribution) {\r\n      chunks.additionalColorContribution = defaultAdditionalColor\r\n    } else {\r\n      chunks.additionalColorContribution = defaultAdditionalColor + chunks.additionalColorContribution\r\n    }\r\n  }\r\n\r\n  // TODO shininess, specularStrength, specularColor\r\n  const applyLightShading: string = (() => {\r\n    switch (shadingModel) {\r\n      case 'Lambert':\r\n      default:\r\n        return /* wgsl */ `\r\n      color = vec4(\r\n        getLambert(\r\n          normal,\r\n          worldPosition,\r\n          color.rgb,\r\n          occlusion\r\n        ),\r\n        color.a\r\n      );`\r\n      case 'Phong':\r\n        return /* wgsl */ `\r\n      color = vec4(\r\n        getPhong(\r\n          normal,\r\n          worldPosition,\r\n          color.rgb,\r\n          viewDirection,\r\n          f0, // specular color\r\n          metallic * (1.0 - roughness) + (1.0 - metallic) * 0.04, // specular strength\r\n          (1.0 - roughness) * 30.0, // TODO shininess\r\n          occlusion\r\n        ),\r\n        color.a\r\n      );`\r\n      case 'PBR':\r\n        return /* wgsl */ `\r\n      color = vec4(\r\n        getPBR(\r\n          normal,\r\n          worldPosition,\r\n          color.rgb,\r\n          viewDirection,\r\n          f0,\r\n          metallic,\r\n          roughness,\r\n          occlusion\r\n        ),\r\n        color.a\r\n      );`\r\n      case 'IBL':\r\n        return /* wgsl */ `\r\n      color = vec4(\r\n        getIBL(\r\n          normal,\r\n          worldPosition,\r\n          color.rgb,\r\n          viewDirection,\r\n          f0,\r\n          metallic,\r\n          roughness,\r\n          ${lutTexture.texture.options.name},\r\n          ${lutTexture.samplerName},\r\n          ${envSpecularTexture.texture.options.name},\r\n          ${envSpecularTexture.samplerName},\r\n          ${envDiffuseTexture.texture.options.name},\r\n          ${envDiffuseTexture.samplerName},\r\n          occlusion\r\n        ),\r\n        color.a\r\n      );`\r\n    }\r\n  })()\r\n\r\n  const applyEmissive = /* wgsl */ `\r\n    color = vec4(color.rgb + emissive, color.a);\r\n  `\r\n\r\n  const fs = /* wgsl */ `  \r\n    ${chunks.additionalFragmentHead}\r\n  \r\n    ${fragmentInput}\r\n  \r\n    @fragment fn main(fsInput: VSOutput) -> @location(0) vec4f {       \r\n      ${initColor}\r\n      ${baseColor}\r\n      \r\n      let worldPosition: vec3f = fsInput.worldPosition;\r\n      let viewDirection: vec3f = fsInput.viewDirection;\r\n\r\n      ${normalMap}\r\n      ${metallicRoughness}  \r\n      \r\n      // user defined preliminary color contribution\r\n      ${chunks.preliminaryColorContribution}\r\n        \r\n      ${f0}\r\n      ${emissiveOcclusion}\r\n      \r\n      ${applyLightShading}\r\n      ${applyEmissive}\r\n      \r\n      // user defined additional color contribution\r\n      ${chunks.additionalColorContribution}\r\n      \r\n      ${returnColor}\r\n    }\r\n  `\r\n\r\n  return {\r\n    vertex: {\r\n      code: vs,\r\n      entryPoint: 'main',\r\n    },\r\n    fragment: {\r\n      code: fs,\r\n      entryPoint: 'main',\r\n    },\r\n  }\r\n}\r\n\r\n/**\r\n * Compute a diffuse cube map from a specular cube map using a {@link ComputePass} and copy the result into the diffuse texture {@link GPUTexture}.\r\n * @param renderer - {@link Renderer} to use.\r\n * @param diffuseTexture - diffuse cube map texture onto which the result of the {@link ComputePass} should be copied.\r\n * @param specularTexture - specular cube map texture to use as a source.\r\n */\r\nexport const computeDiffuseFromSpecular = async (\r\n  renderer: Renderer,\r\n  diffuseTexture: Texture,\r\n  specularTexture: Texture\r\n) => {\r\n  if (specularTexture.options.viewDimension !== 'cube') {\r\n    throwWarning(\r\n      'Could not compute the diffuse texture because the specular texture is not a cube map:' +\r\n        specularTexture.options.viewDimension\r\n    )\r\n    return\r\n  }\r\n\r\n  // ported from https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/9940e4b4f4a2a296351bcd35035cc518deadc298/source/shaders/ibl_filtering.frag\r\n  const computeDiffuseShader = `    \r\n    fn radicalInverse_VdC(inputBits: u32) -> f32 {\r\n        var bits: u32 = inputBits;\r\n        bits = (bits << 16u) | (bits >> 16u);\r\n        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r\n        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r\n        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r\n        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r\n        return f32(bits) * 2.3283064365386963e-10; // / 0x100000000\r\n    }\r\n    \r\n    // hammersley2d describes a sequence of points in the 2d unit square [0,1)^2\r\n    // that can be used for quasi Monte Carlo integration\r\n    fn hammersley2d(i: u32, N: u32) -> vec2f {\r\n        return vec2(f32(i) / f32(N), radicalInverse_VdC(i));\r\n    }\r\n    \r\n    // TBN generates a tangent bitangent normal coordinate frame from the normal\r\n    // (the normal must be normalized)\r\n    fn generateTBN(normal: vec3f) -> mat3x3f {\r\n      var bitangent: vec3f = vec3(0.0, 1.0, 0.0);\r\n  \r\n      let NdotUp: f32 = dot(normal, vec3(0.0, 1.0, 0.0));\r\n      let epsilon: f32 = 0.0000001;\r\n      \r\n      if (1.0 - abs(NdotUp) <= epsilon) {\r\n        // Sampling +Y or -Y, so we need a more robust bitangent.\r\n        if (NdotUp > 0.0) {\r\n          bitangent = vec3(0.0, 0.0, 1.0);\r\n        }\r\n        else {\r\n          bitangent = vec3(0.0, 0.0, -1.0);\r\n        }\r\n      }\r\n  \r\n      let tangent: vec3f = normalize(cross(bitangent, normal));\r\n      bitangent = cross(normal, tangent);\r\n  \r\n      return mat3x3f(tangent, bitangent, normal);\r\n    }\r\n    \r\n    // Mipmap Filtered Samples (GPU Gems 3, 20.4)\r\n    // https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling\r\n    // https://cgg.mff.cuni.cz/~jaroslav/papers/2007-sketch-fis/Final_sap_0073.pdf\r\n    fn computeLod(pdf: f32) -> f32 {\r\n      // https://cgg.mff.cuni.cz/~jaroslav/papers/2007-sketch-fis/Final_sap_0073.pdf\r\n      return 0.5 * log2( 6.0 * f32(params.faceSize) * f32(params.faceSize) / (f32(params.sampleCount) * pdf));\r\n    }\r\n    \r\n    fn transformDirection(face: u32, uv: vec2f) -> vec3f {\r\n      // Transform the direction based on the cubemap face\r\n      switch (face) {\r\n        case 0u {\r\n          // +X\r\n          return vec3f( 1.0,  uv.y, -uv.x);\r\n        }\r\n        case 1u {\r\n          // -X\r\n          return vec3f(-1.0,  uv.y,  uv.x);\r\n        }\r\n        case 2u {\r\n          // +Y\r\n          return vec3f( uv.x,  -1.0, uv.y);\r\n        }\r\n        case 3u {\r\n          // -Y\r\n          return vec3f( uv.x, 1.0,  -uv.y);\r\n        }\r\n        case 4u {\r\n          // +Z\r\n          return vec3f( uv.x,  uv.y,  1.0);\r\n        }\r\n        case 5u {\r\n          // -Z\r\n          return vec3f(-uv.x,  uv.y, -1.0);\r\n        }\r\n        default {\r\n          return vec3f(0.0, 0.0, 0.0);\r\n        }\r\n      }\r\n    }\r\n    \r\n    const PI = ${Math.PI};\r\n\r\n    @compute @workgroup_size(8, 8, 1) fn main(\r\n      @builtin(global_invocation_id) GlobalInvocationID: vec3u,\r\n    ) {\r\n      let faceSize: u32 = params.faceSize;\r\n      let sampleCount: u32 = params.sampleCount;\r\n      \r\n      let face: u32 = GlobalInvocationID.z;\r\n      let x: u32 = GlobalInvocationID.x;\r\n      let y: u32 = GlobalInvocationID.y;\r\n  \r\n      if (x >= faceSize || y >= faceSize) {\r\n          return;\r\n      }\r\n  \r\n      let texelSize: f32 = 1.0 / f32(faceSize);\r\n      let halfTexel: f32 = texelSize * 0.5;\r\n      \r\n      var uv: vec2f = vec2(\r\n        (f32(x) + halfTexel) * texelSize,\r\n        (f32(y) + halfTexel) * texelSize\r\n      );\r\n      \r\n      uv = uv * 2.0 - 1.0;\r\n  \r\n      let normal: vec3<f32> = transformDirection(face, uv);\r\n      \r\n      var irradiance: vec3f = vec3f(0.0, 0.0, 0.0);\r\n  \r\n      for (var i: u32 = 0; i < sampleCount; i++) {\r\n        // generate a quasi monte carlo point in the unit square [0.1)^2\r\n        let xi: vec2f = hammersley2d(i, sampleCount);\r\n        \r\n        let cosTheta: f32 = sqrt(1.0 - xi.y);\r\n        let sinTheta: f32 = sqrt(1.0 - cosTheta * cosTheta);\r\n        let phi: f32 = 2.0 * PI * xi.x;\r\n        let pdf: f32 = cosTheta / PI; // evaluation for solid angle, therefore drop the sinTheta\r\n\r\n        let sampleVec: vec3f = vec3f(\r\n            sinTheta * cos(phi),\r\n            sinTheta * sin(phi),\r\n            cosTheta\r\n        );\r\n        \r\n        let TBN: mat3x3f = generateTBN(normalize(normal));\r\n        \r\n        var direction: vec3f = TBN * sampleVec;\r\n        \r\n        // invert along Y axis\r\n        direction.y *= -1.0;\r\n        \r\n        let lod: f32 = computeLod(pdf);\r\n\r\n        // Convert sampleVec to texture coordinates of the specular env map\r\n        irradiance += textureSampleLevel(\r\n          envSpecularTexture,\r\n          specularSampler,\r\n          direction,\r\n          min(lod, f32(params.maxMipLevel))\r\n        ).rgb;\r\n      }\r\n  \r\n      irradiance /= f32(sampleCount);\r\n\r\n      textureStore(diffuseEnvMap, vec2(x, y), face, vec4f(irradiance, 1.0));\r\n    }\r\n  `\r\n\r\n  let diffuseStorageTexture = new Texture(renderer, {\r\n    label: 'Diffuse storage cubemap',\r\n    name: 'diffuseEnvMap',\r\n    format: 'rgba32float',\r\n    visibility: ['compute'],\r\n    usage: ['copySrc', 'storageBinding'],\r\n    type: 'storage',\r\n    fixedSize: {\r\n      width: specularTexture.size.width,\r\n      height: specularTexture.size.height,\r\n      depth: 6,\r\n    },\r\n    viewDimension: '2d-array',\r\n  })\r\n\r\n  const sampler = new Sampler(renderer, {\r\n    label: 'Compute diffuse sampler',\r\n    name: 'specularSampler',\r\n    addressModeU: 'clamp-to-edge',\r\n    addressModeV: 'clamp-to-edge',\r\n    minFilter: 'linear',\r\n    magFilter: 'linear',\r\n  })\r\n\r\n  let computeDiffusePass = new ComputePass(renderer, {\r\n    autoRender: false, // we're going to render only on demand\r\n    dispatchSize: [Math.ceil(specularTexture.size.width / 8), Math.ceil(specularTexture.size.height / 8), 6],\r\n    shaders: {\r\n      compute: {\r\n        code: computeDiffuseShader,\r\n      },\r\n    },\r\n    uniforms: {\r\n      params: {\r\n        struct: {\r\n          faceSize: {\r\n            type: 'u32',\r\n            value: specularTexture.size.width,\r\n          },\r\n          maxMipLevel: {\r\n            type: 'u32',\r\n            value: specularTexture.texture.mipLevelCount,\r\n          },\r\n          sampleCount: {\r\n            type: 'u32',\r\n            value: 2048,\r\n          },\r\n        },\r\n      },\r\n    },\r\n    samplers: [sampler],\r\n    textures: [specularTexture, diffuseStorageTexture],\r\n  })\r\n\r\n  await computeDiffusePass.material.compileMaterial()\r\n\r\n  renderer.onBeforeRenderScene.add(\r\n    (commandEncoder) => {\r\n      // run the compute pass just once\r\n      renderer.renderSingleComputePass(commandEncoder, computeDiffusePass)\r\n\r\n      // copy the result to our diffuse texture\r\n      commandEncoder.copyTextureToTexture(\r\n        {\r\n          texture: diffuseStorageTexture.texture,\r\n        },\r\n        {\r\n          texture: diffuseTexture.texture,\r\n        },\r\n        [diffuseTexture.texture.width, diffuseTexture.texture.height, diffuseTexture.texture.depthOrArrayLayers]\r\n      )\r\n    },\r\n    { once: true }\r\n  )\r\n\r\n  renderer.onAfterCommandEncoderSubmission.add(\r\n    () => {\r\n      // once command encoder has been submitted, free the resources\r\n      computeDiffusePass.destroy()\r\n      diffuseStorageTexture.destroy()\r\n      diffuseStorageTexture = null\r\n      computeDiffusePass = null\r\n    },\r\n    { once: true }\r\n  )\r\n}\r\n","import { GLTF } from '../../types/gltf/GLTF'\r\n\r\n/**\r\n * Defined the structure of the parsed result from the glTF json object.\r\n */\r\nexport interface GPUCurtainsGLTF extends GLTF.IGLTF {\r\n  /** Array of {@link ArrayBuffer} used by the glTF. */\r\n  arrayBuffers: ArrayBuffer[]\r\n  /** Array of created {@link ImageBitmap}. */\r\n  imagesBitmaps: ImageBitmap[]\r\n}\r\n\r\n// largely based on\r\n// https://toji.dev/webgpu-gltf-case-study/\r\n// https://github.com/toji/webgpu-gltf-case-study/blob/main/samples/js/tiny-gltf.js\r\n\r\n// also see glTF specs\r\n// https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants\r\n// To make it easier to reference the WebGL enums that glTF uses.\r\nconst GL = WebGLRenderingContext\r\n\r\nconst GLB_MAGIC = 0x46546c67\r\nconst CHUNK_TYPE = {\r\n  JSON: 0x4e4f534a,\r\n  BIN: 0x004e4942,\r\n}\r\n\r\nconst DEFAULT_TRANSLATION = [0, 0, 0]\r\nconst DEFAULT_ROTATION = [0, 0, 0, 1]\r\nconst DEFAULT_SCALE = [1, 1, 1]\r\n\r\nconst absUriRegEx =\r\n  (typeof window !== 'undefined' && new RegExp(`^${window.location.protocol}`, 'i')) || RegExp(`^(http|https):`, 'i')\r\nconst dataUriRegEx = /^data:/\r\n\r\n/**\r\n * Basic glTF loader class.\r\n *\r\n * Allow to load a glTF from an URI and create the associated {@link ArrayBuffer} and {@link ImageBitmap}.\r\n *\r\n * @example\r\n * ```javascript\r\n * const gltfLoader = new GLTFLoader()\r\n * const gltf = await gltfLoader.loadFromUrl('path/to/model.gltf')\r\n *\r\n * // create a gltfScenesManager from the resulting 'gltf' object\r\n * // assuming 'renderer' is a valid camera or curtains renderer\r\n * const gltfScenesManager = new GLTFScenesManager({ renderer, gltf })\r\n * gltfScenesManager.addMeshes()\r\n * ```\r\n */\r\nexport class GLTFLoader {\r\n  /** The {@link GPUCurtainsGLTF} object result. */\r\n  gltf: GPUCurtainsGLTF | null\r\n\r\n  /**\r\n   * {@link GLTFLoader} constructor.\r\n   */\r\n  constructor() {\r\n    this.gltf = null\r\n  }\r\n\r\n  /**\r\n   * Build the absolute uri of the resource\r\n   * @param uri - uri of the resource\r\n   * @param baseUrl - base url from which to get all the other assets.\r\n   * @returns - absolute uri of the resource\r\n   */\r\n  static resolveUri(uri: string, baseUrl: string): string {\r\n    if (!!uri.match(absUriRegEx) || !!uri.match(dataUriRegEx)) {\r\n      return uri\r\n    }\r\n    return baseUrl + uri\r\n  }\r\n\r\n  /**\r\n   * Load a glTF from the given url.\r\n   * @param url - url of the glTF.\r\n   * @returns - the {@link GPUCurtainsGLTF} created.\r\n   * @async\r\n   */\r\n  async loadFromUrl(url: string): Promise<GPUCurtainsGLTF> {\r\n    const i = url.lastIndexOf('/')\r\n    const baseUrl = i !== 0 ? url.substring(0, i + 1) : ''\r\n    const response = await fetch(url)\r\n\r\n    if (url.endsWith('.gltf')) {\r\n      return this.loadFromJson(await response.json(), baseUrl)\r\n    } else if (url.endsWith('.glb')) {\r\n      return this.loadFromBinary(await response.arrayBuffer(), baseUrl)\r\n    } else {\r\n      throw new Error('Unrecognized file extension')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse a {@link GLTF.IGLTF | glTF json} and create our {@link gltf} base object.\r\n   * @param json - already parsed JSON content.\r\n   * @param baseUrl - base url from which to get all the other assets.\r\n   * @param binaryChunk - optional binary chunks.\r\n   * @returns - {@link gltf} base object.\r\n   * @async\r\n   */\r\n  async loadFromJsonBase(\r\n    json: GLTF.IGLTF,\r\n    baseUrl: string,\r\n    binaryChunk: Record<string, ArrayBuffer> = null\r\n  ): Promise<GPUCurtainsGLTF> {\r\n    if (!baseUrl) {\r\n      throw new Error('baseUrl must be specified.')\r\n    }\r\n\r\n    if (!json.asset) {\r\n      throw new Error('Missing asset description.')\r\n    }\r\n\r\n    if (json.asset.minVersion !== '2.0' && json.asset.version !== '2.0') {\r\n      throw new Error('Incompatible asset version.')\r\n    }\r\n\r\n    // Resolve defaults for as many properties as we can.\r\n    for (const accessor of json.accessors) {\r\n      accessor.byteOffset = accessor.byteOffset ?? 0\r\n      accessor.normalized = accessor.normalized ?? false\r\n    }\r\n\r\n    for (const bufferView of json.bufferViews) {\r\n      bufferView.byteOffset = bufferView.byteOffset ?? 0\r\n    }\r\n\r\n    for (const node of json.nodes) {\r\n      if (!node.matrix) {\r\n        node.rotation = node.rotation ?? DEFAULT_ROTATION\r\n        node.scale = node.scale ?? DEFAULT_SCALE\r\n        node.translation = node.translation ?? DEFAULT_TRANSLATION\r\n      }\r\n    }\r\n\r\n    if (json.samplers) {\r\n      for (const sampler of json.samplers) {\r\n        sampler.wrapS = sampler.wrapS ?? GL.REPEAT\r\n        sampler.wrapT = sampler.wrapT ?? GL.REPEAT\r\n      }\r\n    }\r\n\r\n    // Resolve buffers and images first, since these are the only external resources that the file\r\n    // might reference.\r\n    // Buffers will be exposed as ArrayBuffers.\r\n    // Images will be exposed as ImageBitmaps.\r\n\r\n    // Buffers\r\n    const pendingBuffers = []\r\n    if (binaryChunk) {\r\n      pendingBuffers.push(Promise.resolve(binaryChunk))\r\n    } else {\r\n      for (const index in json.buffers) {\r\n        const buffer = json.buffers[index]\r\n        const uri = GLTFLoader.resolveUri(buffer.uri, baseUrl)\r\n        pendingBuffers[index] = fetch(uri).then((response) => response.arrayBuffer())\r\n      }\r\n    }\r\n\r\n    // Images\r\n    const pendingImages = []\r\n    for (let index = 0; index < json.images?.length || 0; ++index) {\r\n      const image = json.images[index]\r\n      if (image.uri) {\r\n        pendingImages[index] = fetch(GLTFLoader.resolveUri(image.uri, baseUrl)).then(async (response) => {\r\n          return createImageBitmap(await response.blob())\r\n        })\r\n      } else {\r\n        const bufferView = json.bufferViews[image.bufferView]\r\n        pendingImages[index] = pendingBuffers[bufferView.buffer].then((buffer) => {\r\n          const blob = new Blob([new Uint8Array(buffer, bufferView.byteOffset, bufferView.byteLength)], {\r\n            type: image.mimeType,\r\n          })\r\n          return createImageBitmap(blob)\r\n        })\r\n      }\r\n    }\r\n\r\n    return {\r\n      ...json,\r\n      arrayBuffers: await Promise.all(pendingBuffers),\r\n      imagesBitmaps: await Promise.all(pendingImages),\r\n    } as GPUCurtainsGLTF\r\n  }\r\n\r\n  /**\r\n   * Load a glTF from a .glb file.\r\n   * @param arrayBuffer - {@link ArrayBuffer} containing the data.\r\n   * @param baseUrl - base url from which to get all the other assets.\r\n   * @returns - the {@link GPUCurtainsGLTF} created.\r\n   * @async\r\n   */\r\n  async loadFromBinary(arrayBuffer: ArrayBuffer, baseUrl: string): Promise<GPUCurtainsGLTF> {\r\n    const headerView = new DataView(arrayBuffer, 0, 12)\r\n    const magic = headerView.getUint32(0, true)\r\n    const version = headerView.getUint32(4, true)\r\n    const length = headerView.getUint32(8, true)\r\n\r\n    if (magic !== GLB_MAGIC) {\r\n      throw new Error('Invalid magic string in binary header.')\r\n    }\r\n\r\n    if (version !== 2) {\r\n      throw new Error('Incompatible version in binary header.')\r\n    }\r\n\r\n    const chunks = {}\r\n    let chunkOffset = 12\r\n    while (chunkOffset < length) {\r\n      const chunkHeaderView = new DataView(arrayBuffer, chunkOffset, 8)\r\n      const chunkLength = chunkHeaderView.getUint32(0, true)\r\n      const chunkType = chunkHeaderView.getUint32(4, true)\r\n      chunks[chunkType] = arrayBuffer.slice(chunkOffset + 8, chunkOffset + 8 + chunkLength)\r\n      chunkOffset += chunkLength + 8\r\n    }\r\n\r\n    if (!chunks[CHUNK_TYPE.JSON]) {\r\n      throw new Error('File contained no json chunk.')\r\n    }\r\n\r\n    const decoder = new TextDecoder('utf-8')\r\n    const jsonString = decoder.decode(chunks[CHUNK_TYPE.JSON])\r\n    return this.loadFromJson(JSON.parse(jsonString), baseUrl, chunks[CHUNK_TYPE.BIN])\r\n  }\r\n\r\n  /**\r\n   * Load the glTF json, parse the data and create our {@link GPUCurtainsGLTF} object.\r\n   * @param json - already parsed JSON content.\r\n   * @param baseUrl - base url from which to get all the other assets.\r\n   * @param binaryChunk - optional binary chunks.\r\n   * @returns - the {@link GPUCurtainsGLTF} created.\r\n   * @async\r\n   */\r\n  async loadFromJson(\r\n    json: GLTF.IGLTF,\r\n    baseUrl: string,\r\n    binaryChunk: Record<string, ArrayBuffer> = null\r\n  ): Promise<GPUCurtainsGLTF> {\r\n    // Load the glTF file\r\n    this.gltf = await this.loadFromJsonBase(json, baseUrl, binaryChunk)\r\n    return this.gltf\r\n  }\r\n}\r\n","// ported from https://github.com/DerSchmale/io-rgbe/tree/main\r\n\r\n/**\r\n * HDRImageData contains all decompressed image data.\r\n */\r\nexport interface HDRImageData {\r\n  /** Width of the HDR image */\r\n  width: number\r\n  /** Height of the HDR image */\r\n  height: number\r\n  /** Exposure of the HDR image */\r\n  exposure: number\r\n  /** Gamma of the HDR image */\r\n  gamma: number\r\n  /** {@link Float32Array} holding the HDR image data */\r\n  data: Float32Array\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\ntype Header = {\r\n  width: number\r\n  height: number\r\n  gamma: number\r\n  exposure: number\r\n  colorCorr: number[]\r\n  flipX: boolean\r\n  flipY: boolean\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\ntype DataStream = {\r\n  offset: number\r\n  data: DataView\r\n}\r\n\r\n/**\r\n * Basic glTF loader class.\r\n *\r\n * Allow to load an HDR file from an URI and returns a {@link HDRImageData} object containing the {@link Float32Array} data alongside width, height and other useful information.\r\n *\r\n * @example\r\n * ```javascript\r\n * const hdrLoader = new HDRLoader()\r\n * const hdr = await hdrLoader.loadFromUrl('path/to/environment.hdr')\r\n *\r\n * // assuming `renderer` is a valid Renderer\r\n * const envTexture = new Texture(renderer, {\r\n *   label: 'Environment texture',\r\n *   name: 'envTexture',\r\n *   visibility: ['fragment'],\r\n *   format: 'rgba16float',\r\n *   generateMips: true,\r\n *   fixedSize: {\r\n *     width: hdr.width,\r\n *     height: hdr.height,\r\n *   },\r\n * })\r\n *\r\n * envTexture.uploadData({\r\n *   data: hdr.data,\r\n * })\r\n * ```\r\n */\r\nexport class HDRLoader {\r\n  /**\r\n   * Load and decode RGBE-encoded data to a flat list of floating point pixel data (RGBA).\r\n   * @param url -  The url of the .hdr file to load\r\n   * @returns - The {@link HDRImageData}\r\n   */\r\n  async loadFromUrl(url: string): Promise<HDRImageData> {\r\n    const buffer = await (await fetch(url)).arrayBuffer()\r\n\r\n    return this.#decodeRGBE(new DataView(buffer))\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   */\r\n  #decodeRGBE(data: DataView): HDRImageData {\r\n    const stream = {\r\n      data,\r\n      offset: 0,\r\n    }\r\n\r\n    const header = this.#parseHeader(stream)\r\n\r\n    return {\r\n      width: header.width,\r\n      height: header.height,\r\n      exposure: header.exposure,\r\n      gamma: header.gamma,\r\n      data: this.#parseData(stream, header),\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   */\r\n  #parseHeader(stream: DataStream): Header {\r\n    let line = this.#readLine(stream)\r\n    const header = {\r\n      colorCorr: [1, 1, 1],\r\n      exposure: 1,\r\n      gamma: 1,\r\n      width: 0,\r\n      height: 0,\r\n      flipX: false,\r\n      flipY: false,\r\n    }\r\n\r\n    if (line !== '#?RADIANCE' && line !== '#?RGBE') throw new Error('Incorrect file format!')\r\n\r\n    while (line !== '') {\r\n      // empty line means there's only 1 line left, containing size info:\r\n      line = this.#readLine(stream)\r\n      const parts = line.split('=')\r\n      switch (parts[0]) {\r\n        case 'GAMMA':\r\n          header.gamma = parseFloat(parts[1])\r\n          break\r\n        case 'FORMAT':\r\n          if (parts[1] !== '32-bit_rle_rgbe' && parts[1] !== '32-bit_rle_xyze')\r\n            throw new Error('Incorrect encoding format!')\r\n          break\r\n        case 'EXPOSURE':\r\n          header.exposure = parseFloat(parts[1])\r\n          break\r\n        case 'COLORCORR':\r\n          header.colorCorr = parts[1]\r\n            .replace(/^\\s+|\\s+$/g, '')\r\n            .split(' ')\r\n            .map((m) => parseFloat(m))\r\n          break\r\n      }\r\n    }\r\n\r\n    line = this.#readLine(stream)\r\n\r\n    const parts = line.split(' ')\r\n    this.#parseSize(parts[0], parseInt(parts[1]), header)\r\n    this.#parseSize(parts[2], parseInt(parts[3]), header)\r\n\r\n    return header\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   */\r\n  #parseSize(label: string, value: number, header: Header) {\r\n    switch (label) {\r\n      case '+X':\r\n        header.width = value\r\n        break\r\n      case '-X':\r\n        header.width = value\r\n        header.flipX = true\r\n        console.warn('Flipping horizontal orientation not currently supported')\r\n        break\r\n      case '-Y':\r\n        header.height = value\r\n        header.flipY = true // WebGPU flipY default is false\r\n        break\r\n      case '+Y':\r\n        header.height = value\r\n        break\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   */\r\n  #readLine(stream: DataStream): string {\r\n    let ch,\r\n      str = ''\r\n\r\n    while ((ch = stream.data.getUint8(stream.offset++)) !== 0x0a) str += String.fromCharCode(ch)\r\n\r\n    return str\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   */\r\n  #parseData(stream: DataStream, header: Header): Float32Array {\r\n    const hash = stream.data.getUint16(stream.offset)\r\n    let data\r\n\r\n    if (hash === 0x0202) {\r\n      data = this.#parseNewRLE(stream, header)\r\n      if (header.flipX) this.#flipX(data, header)\r\n      if (header.flipY) this.#flipY(data, header)\r\n    } else {\r\n      throw new Error('Obsolete HDR file version!')\r\n    }\r\n\r\n    return data\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   */\r\n  #parseNewRLE(stream: DataStream, header: Header): Float32Array {\r\n    const { width, height, colorCorr } = header\r\n    const tgt = new Float32Array(width * height * 4)\r\n    let i = 0\r\n    let { offset, data } = stream\r\n\r\n    for (let y = 0; y < height; ++y) {\r\n      if (data.getUint16(offset) !== 0x0202) throw new Error('Incorrect scanline start hash')\r\n\r\n      if (data.getUint16(offset + 2) !== width) throw new Error(\"Scanline doesn't match picture dimension!\")\r\n\r\n      offset += 4\r\n      const numComps = width * 4\r\n\r\n      // read individual RLE components\r\n      const comps = []\r\n      let x = 0\r\n\r\n      while (x < numComps) {\r\n        let value = data.getUint8(offset++)\r\n        if (value > 128) {\r\n          // RLE:\r\n          const len = value - 128\r\n          value = data.getUint8(offset++)\r\n          for (let rle = 0; rle < len; ++rle) {\r\n            comps[x++] = value\r\n          }\r\n        } else {\r\n          for (let n = 0; n < value; ++n) {\r\n            comps[x++] = data.getUint8(offset++)\r\n          }\r\n        }\r\n      }\r\n\r\n      for (x = 0; x < width; ++x) {\r\n        const r = comps[x]\r\n        const g = comps[x + width]\r\n        const b = comps[x + width * 2]\r\n        let e = comps[x + width * 3]\r\n\r\n        // NOT -128 but -136!!! This allows encoding smaller values rather than higher ones (as you'd expect).\r\n        e = e ? Math.pow(2.0, e - 136) : 0\r\n\r\n        tgt[i++] = r * e * colorCorr[0]\r\n        tgt[i++] = g * e * colorCorr[1]\r\n        tgt[i++] = b * e * colorCorr[2]\r\n        tgt[i++] = e\r\n      }\r\n    }\r\n\r\n    return tgt\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   */\r\n  #swap(data: Float32Array, i1: number, i2: number) {\r\n    i1 *= 4\r\n    i2 *= 4\r\n\r\n    for (let i = 0; i < 4; ++i) {\r\n      const tmp = data[i1 + i]\r\n      data[i1 + i] = data[i2 + i]\r\n      data[i2 + i] = tmp\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   */\r\n  #flipX(data: Float32Array, header: Header) {\r\n    const { width, height } = header\r\n    const hw = width >> 1\r\n\r\n    for (let y = 0; y < height; ++y) {\r\n      // selects the current row\r\n      const b = y * width\r\n      for (let x = 0; x < hw; ++x) {\r\n        // add the mirrored columns\r\n        const i1 = b + x\r\n        const i2 = b + width - 1 - x\r\n        this.#swap(data, i1, i2)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   */\r\n  #flipY(data: Float32Array, header: Header) {\r\n    const { width, height } = header\r\n    const hh = height >> 1\r\n\r\n    for (let y = 0; y < hh; ++y) {\r\n      // selects the mirrored rows\r\n      const b1 = y * width\r\n      const b2 = (height - 1 - y) * width\r\n\r\n      for (let x = 0; x < width; ++x) {\r\n        // adds the column\r\n        this.#swap(data, b1 + x, b2 + x)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert an equirectangular {@link HDRImageData} to 6 {@link HDRImageData} cube map faces. Works but can display artifacts at the poles.\r\n   * @param parsedHdr - equirectangular {@link HDRImageData} to use.\r\n   * @returns - 6 {@link HDRImageData} cube map faces\r\n   */\r\n  equirectangularToCubeMap(parsedHdr: HDRImageData): HDRImageData[] {\r\n    const faceSize = Math.max(parsedHdr.width / 4, parsedHdr.height / 2)\r\n\r\n    const faces = {\r\n      posX: new Float32Array(faceSize * faceSize * 4),\r\n      negX: new Float32Array(faceSize * faceSize * 4),\r\n      posY: new Float32Array(faceSize * faceSize * 4),\r\n      negY: new Float32Array(faceSize * faceSize * 4),\r\n      posZ: new Float32Array(faceSize * faceSize * 4),\r\n      negZ: new Float32Array(faceSize * faceSize * 4),\r\n    }\r\n\r\n    function getPixel(u, v) {\r\n      const x = Math.floor(u * parsedHdr.width)\r\n      const y = Math.floor(v * parsedHdr.height)\r\n\r\n      const index = (y * parsedHdr.width + x) * 4\r\n      return [parsedHdr.data[index], parsedHdr.data[index + 1], parsedHdr.data[index + 2], parsedHdr.data[index + 3]]\r\n    }\r\n\r\n    function setPixel(face, x, y, pixel) {\r\n      const index = (y * faceSize + x) * 4\r\n      faces[face][index] = pixel[0]\r\n      faces[face][index + 1] = pixel[1]\r\n      faces[face][index + 2] = pixel[2]\r\n      faces[face][index + 3] = pixel[3]\r\n    }\r\n\r\n    function mapDirection(face, x, y) {\r\n      const a = (2 * (x + 0.5)) / faceSize - 1\r\n      const b = (2 * (y + 0.5)) / faceSize - 1\r\n      switch (face) {\r\n        case 'posX':\r\n          return [a, -1, -b]\r\n        case 'negX':\r\n          return [-a, 1, -b]\r\n        case 'posY':\r\n          return [-b, -a, 1]\r\n        case 'negY':\r\n          return [b, -a, -1]\r\n        case 'posZ':\r\n          return [-1, -a, -b]\r\n        case 'negZ':\r\n          return [1, a, -b]\r\n      }\r\n    }\r\n\r\n    function directionToUV(direction) {\r\n      const [x, y, z] = direction\r\n      const r = Math.sqrt(x * x + y * y)\r\n      //const theta = mod(Math.atan2(y, x), 2 * Math.PI)\r\n      const theta = Math.atan2(y, x)\r\n      const phi = Math.atan2(z, r)\r\n      const u = (theta + Math.PI) / (2 * Math.PI)\r\n      const v = (phi + Math.PI / 2) / Math.PI\r\n      return [u, v]\r\n    }\r\n\r\n    for (const face in faces) {\r\n      for (let y = 0; y < faceSize; y++) {\r\n        for (let x = 0; x < faceSize; x++) {\r\n          const direction = mapDirection(face, x, y)\r\n          const [u, v] = directionToUV(direction)\r\n          const pixel = getPixel(u, v)\r\n          setPixel(face, x, y, pixel)\r\n        }\r\n      }\r\n    }\r\n\r\n    const facesData = [faces.posX, faces.negX, faces.posY, faces.negY, faces.posZ, faces.negZ]\r\n\r\n    return facesData.map((faceData) => {\r\n      return {\r\n        data: faceData,\r\n        width: faceSize,\r\n        height: faceSize,\r\n        exposure: parsedHdr.exposure,\r\n        gamma: parsedHdr.gamma,\r\n      }\r\n    })\r\n  }\r\n}\r\n","import { WritableBufferBinding } from '../core/bindings/WritableBufferBinding'\r\nimport { Renderer } from '../core/renderers/utils'\r\n\r\n/**\r\n * Logs all the main commands executed during each {@link core/scenes/Scene.Scene#render | Scene render} calls.\r\n */\r\nexport const logSceneCommands = (renderer: Renderer) => {\r\n  const { scene } = renderer\r\n\r\n  if (!scene) return\r\n\r\n  const renderCommands = []\r\n\r\n  scene.computePassEntries.forEach((computePass) => {\r\n    renderCommands.push({\r\n      command: 'Render ComputePass',\r\n      content: computePass.options.label,\r\n    })\r\n\r\n    computePass.material.bindGroups.forEach((bindGroup) => {\r\n      bindGroup.bufferBindings.forEach((binding: WritableBufferBinding) => {\r\n        if (binding.shouldCopyResult) {\r\n          renderCommands.push({\r\n            command: `Copy buffer to buffer`,\r\n            source: `${binding.name} buffer`,\r\n            destination: `${binding.name} result buffer`,\r\n          })\r\n        }\r\n      })\r\n    })\r\n  })\r\n\r\n  for (const renderPassEntryType in scene.renderPassEntries) {\r\n    let passDrawnCount = 0\r\n\r\n    scene.renderPassEntries[renderPassEntryType].forEach((renderPassEntry) => {\r\n      // early bail if there's nothing to draw\r\n      if (!scene.getRenderPassEntryLength(renderPassEntry)) return\r\n\r\n      const destination = !renderPassEntry.renderPass.options.useColorAttachments\r\n        ? undefined\r\n        : renderPassEntry.renderPass.options.colorAttachments.length === 0 &&\r\n          renderPassEntry.renderPass.options.useDepth\r\n        ? `${renderPassEntry.renderTexture.options.label} depth pass`\r\n        : renderPassEntry.renderPass.options.colorAttachments.length > 1\r\n        ? `${renderPassEntry.renderTexture.options.label} multiple targets`\r\n        : renderPassEntry.renderTexture\r\n        ? `${renderPassEntry.renderTexture.options.label}`\r\n        : 'Context current texture'\r\n\r\n      let descriptor = renderPassEntry.renderPass.options.label\r\n\r\n      const operations = {\r\n        loadOp: renderPassEntry.renderPass.options.useColorAttachments\r\n          ? renderPassEntryType === 'screen' && passDrawnCount > 0\r\n            ? 'load'\r\n            : renderPassEntry.renderPass.options.loadOp\r\n          : undefined,\r\n        depthLoadOp: undefined,\r\n        sampleCount: renderPassEntry.renderPass.options.sampleCount,\r\n        ...(renderPassEntry.renderPass.options.qualityRatio !== 1 && {\r\n          qualityRatio: renderPassEntry.renderPass.options.qualityRatio,\r\n        }),\r\n      }\r\n\r\n      if (renderPassEntry.renderPass.options.useDepth) {\r\n        operations.depthLoadOp = renderPassEntry.renderPass.options.depthLoadOp\r\n      }\r\n\r\n      passDrawnCount++\r\n\r\n      if (renderPassEntry.element) {\r\n        if (\r\n          renderPassEntry.element.type === 'ShaderPass' &&\r\n          !(renderPassEntry.element.inputTarget || renderPassEntry.element.outputTarget)\r\n        ) {\r\n          renderCommands.push({\r\n            command: `Copy texture to texture`,\r\n            source: destination,\r\n            destination: `${renderPassEntry.element.options.label} renderTexture`,\r\n          })\r\n\r\n          operations.loadOp = 'clear'\r\n        }\r\n\r\n        descriptor += ' ' + JSON.stringify(operations)\r\n\r\n        renderCommands.push({\r\n          command: `Render ${renderPassEntry.element.type}`,\r\n          source: renderPassEntry.element.options.label,\r\n          destination,\r\n          descriptor,\r\n        })\r\n\r\n        if (\r\n          renderPassEntry.element.type === 'ShaderPass' &&\r\n          !renderPassEntry.element.outputTarget &&\r\n          renderPassEntry.element.options.copyOutputToRenderTexture\r\n        ) {\r\n          renderCommands.push({\r\n            command: `Copy texture to texture`,\r\n            source: destination,\r\n            destination: `${renderPassEntry.element.options.label} renderTexture`,\r\n          })\r\n        } else if (renderPassEntry.element.type === 'PingPongPlane') {\r\n          renderCommands.push({\r\n            command: `Copy texture to texture`,\r\n            source: destination,\r\n            destination: `${renderPassEntry.element.renderTexture.options.label}`,\r\n          })\r\n        }\r\n      } else if (renderPassEntry.stack) {\r\n        descriptor += ' ' + JSON.stringify(operations)\r\n\r\n        for (const stackType in renderPassEntry.stack) {\r\n          for (const objectType in renderPassEntry.stack[stackType]) {\r\n            if (renderPassEntry.stack[stackType][objectType].length) {\r\n              renderCommands.push({\r\n                command: `Render stack (${stackType} ${objectType} objects)`,\r\n                source: renderPassEntry.stack[stackType][objectType],\r\n                destination,\r\n                descriptor,\r\n              })\r\n            }\r\n          }\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  console.table(renderCommands)\r\n}\r\n"],"names":["generateUUID","c","r","toCamelCase","string","ltr","idx","toKebabCase","camelCase","warningThrown","throwWarning","warning","throwError","error","formatRendererError","renderer","rendererType","type","isRenderer","isCameraRenderer","isCurtainsRenderer","isProjectedMesh","object","generateMips","sampler","module","pipelineByFormat","device","texture","pipeline","encoder","width","height","baseMipLevel","layer","bindGroup","renderPassDescriptor","pass","commandBuffer","WebGPUShaderStageConstants","WebGPUBufferUsageConstants","WebGPUTextureUsageConstants","bindingVisibilities","getBindingVisibility","visibilities","acc","v","bufferLayouts","getBufferLayout","bufferType","getBindingWGSLVarType","binding","getTextureBindingWGSLVarType","getBindGroupLayoutBindingType","getBindGroupLayoutTextureBindingType","getBindGroupLayoutTextureBindingCacheKey","Binding","label","name","bindingType","visibility","Vec2","x","y","value","changed","callback","vector","min","max","len","alpha","Quat","elements","axisOrder","array","quaternion","ax","ay","az","cosx","cosy","cosz","sinx","siny","sinz","axis","angle","halfAngle","matrix","te","m11","m12","m13","m21","m22","m23","m31","m32","m33","trace","s","Vec3","z","a","b","bx","by","bz","mArray","w","e","qx","qy","qz","qw","ix","iy","iz","iw","camera","slotsPerRow","bytesPerSlot","bytesPerRow","BufferElement","key","offset","position","overflow","p1","p2","nextPositionAvailable","alignment","size","align","startOffset","arrayBuffer","arrayView","i","j","result","BufferArrayElement","arrayLength","nextAlignment","valueIndex","viewLength","stride","BufferInterleavedArrayElement","subarray","startByteOffset","index","interleavedResult","resultOffset","bufferUsages","getBufferUsages","usages","Buffer","usage","mappedAtCreation","options","staticOptions","GPUBuffer","buffer","destroyPreviousBuffer","BufferBinding","useStruct","access","struct","bindings","params","defaultParams","bufferBindingCopy","bufferElement","newBufferElement","bindingKey","_onChangeCallback","orderedBindings","arrayBindings","bindingKeyA","bindingKeyB","isBindingAArray","isBindingBArray","bufferElementOptions","isArray","bufferLayout","interleavedBufferElements","tempBufferElements","totalStride","bufferElementsArrayBufferSize","bufferElLastRow","bindingLastRow","uniqueBindings","bindingExists","kebabCaseLabel","structs","bufferElements","interleavedBufferName","varType","additionalBindings","bindingName","inputs","bufferEl","bufferElementName","WritableBufferBinding","shouldCopyResult","BindGroup","uniforms","storages","inputKey","bindingParams","cachedBinding","BufferBindingConstructor","bufferBinding","optionalLabel","isChildBuffer","bindGroupLayout","needBindGroupReset","needBindGroupLayoutReset","keepLayout","bindGroupCopy","bindingsRef","TextureBinding","format","viewDimension","multisampled","isNewFormat","isNewMultisampled","xAxis","yAxis","zAxis","Mat4","n11","n12","n13","n14","n21","n22","n23","n24","n31","n32","n33","n34","n41","n42","n43","n44","ae","be","a11","a12","a13","a14","a21","a22","a23","a24","a31","a32","a33","a34","a41","a42","a43","a44","b11","b12","b13","b14","b21","b22","b23","b24","b31","b32","b33","b34","b41","b42","b43","b44","t11","t12","t13","t14","det","detInv","t","x2","y2","z2","xx","xy","xz","yy","yz","zz","wx","wy","wz","scaleXSq","scaleYSq","scaleZSq","translation","scale","sx","sy","sz","origin","ox","oy","oz","out0","out1","out2","out4","out5","out6","out8","out9","out10","eye","target","up","left","right","bottom","top","near","far","fov","aspect","d","objectIndex","tempMatrix","Object3D","child","rotationMatrix","l","matrixName","textureUsages","getTextureUsages","getDefaultTextureUsage","textureType","getNumMipLevels","sizes","maxSize","_parentRatio","_sourceRatio","_coverScale","_rotationMatrix","defaultDOMTextureParams","DOMTexture","parameters","__privateAdd","defaultOptions","parentScale","parentWidth","parentHeight","parentRatio","sourceRatio","__privateGet","coverRatio","url","blob","source","cachedTexture","video","TextureBindGroup","textures","samplers","SamplerBinding","_fov","_near","_far","_pixelRatio","Camera","pixelRatio","onMatricesChanged","__privateSet","depth","cameraOffset","vFOV","Sampler","addressModeU","addressModeV","magFilter","minFilter","mipmapFilter","maxAnisotropy","compare","_autoResize","defaultTextureParams","Texture","colorSpace","data","Material","shaders","useAsyncPipeline","bindGroups","domTextures","texturesBindGroupLength","shaderType","inputsBindGroup","inputBinding","bG","clone","bufferBindingName","objectsUsingTexture","dstBuffer","ComputeMaterial","dispatchSize","commandEncoder","_autoRender","computePassIndex","ComputePass","renderOrder","autoRender","texturesOptions","addToRenderer","removeFromRenderer","computePass","computeParameters","material","domTexture","_autoRender$2","points","Box3","box","transformedBox","corners","cornersCount","defaultDOMFrustumMargins","DOMFrustum","boundingBox","modelViewProjectionMatrix","containerBoundingRect","DOMFrustumMargins","onReEnterView","onLeaveView","boundingRect","minX","maxX","minY","maxY","boundingSphere","centerX","centerY","Geometry","verticesOrder","topology","instancesCount","vertexBuffers","mapBuffersAtCreation","attributesBuffer","vertexBuffer","aIndex","bIndex","stepMode","attributes","bufferOffset","bufferSize","attribute","bufferFormat","verticesStride","attributesLength","attributeCount","accumulator","currentValue","hasPositionAttribute","currentIndex","attributeIndex","attributeValue","locationIndex","IndexedGeometry","PlaneGeometry","widthSegments","heightSegments","verticesCount","indexArray","uv","normal","positionOffset","normalOffset","uvOffset","_intensity","_intensityColor","Light","color","intensity","hasRenderer","light","propertyKey","lightsType","AmbientLight","RenderPass","sampleCount","qualityRatio","useColorAttachments","renderToSwapChain","colorAttachments","useDepth","depthTexture","depthLoadOp","depthStoreOp","depthClearValue","depthFormat","defaultColorAttachment","colorAttachment","depthTextureView","viewTexture","resolveTarget","loadOp","colorAttachmentIndex","clearValue","renderTexture","RenderTarget","renderPassParams","depthTextureToUse","renderTarget","mesh","shaderPass","_autoRender$1","pipelineId","PipelineEntry","useAsync","code","shaderModule","compilationInfo","message","formattedMessage","newBindGroups","get_output_position","get_normals","get_uv_cover","get_vertex_to_uv_coords","ShaderChunks","ProjectedShaderChunks","RenderPipelineEntry","pipelineParams","cacheKey","renderingOptions","chunk","groupsBindings","bindIndex","bindingIndex","groupFragment","groupFragmentIndex","groupBinding","isSameShader","vertexLocationIndex","compareRenderingOptions","newOptions","baseOptions","default_projected_vsWgsl","default_vsWgsl","default_fsWgsl","RenderMaterial","useProjection","transparent","depthWriteEnabled","depthCompare","cullMode","targets","newProperties","oldRenderingOptions","oldProps","optKey","newProps","geometry","startBindGroupIndex","getPositionAndNormal","hasInstances","getDefaultShadowDepthVs","lightIndex","getPCFShadowContribution","getPCFDirectionalShadows","directionalLights","minDirectionalLights","getDefaultPointShadowDepthVs","getDefaultPointShadowDepthFs","getPCFPointShadowContribution","getPCFPointShadows","pointLights","minPointLights","getPCFShadows","applyDirectionalShadows","applyPointShadows","_bias","_normalBias","_pcfSamples","_isActive","_materials","_depthMaterials","_depthPassTaskID","_setParameters","setParameters_fn","shadowStruct","Shadow","bias","normalBias","pcfSamples","depthTextureSize","depthTextureFormat","__privateMethod","depthMaterial","samplerExists","depthPassTaskID","once","renderBundles","bundle","depthPass","directionalShadowStruct","DirectionalShadow","_self","prop","_actualPosition","_direction","DirectionalLight","shadow","_tempCubeDirection","pointShadowStruct","PointShadow","_range","PointLight","range","meshIndex","defaultMeshBaseParams","MeshBaseMixin","Base","_a","visible","outputTarget","renderBundle","meshParameters","m","oldRenderer","updateScene","renderPass","switchTransparency","CacheManager","planeGeometry","element","planeGeometryID","cacheManager","FullscreenPlane","mouseCoords","Mat3","me","tmp","ProjectedObject3D","default_normal_fsWgsl","_parent","BufferBindingOffsetChild","parent","minOffset","defaultProjectedMeshParams","ProjectedMeshBaseMixin","frustumCulling","receiveShadows","castShadows","matrices","depthTextures","depthSamplers","matricesUniforms","transformationBinding","center","radius","maxWorldRadius","cMin","cMax","sMin","sMax","rMin","rMax","rectMin","rectMax","rect","sphereCenter","sphereRadius","Mesh","ComputePipelineEntry","PipelineManager","shaderA","shaderB","pipelineEntry","rendering","sameCacheKey","sameVertexShader","sameFragmentShader","differentParams","existingPipelineEntry","ResizeManager","observedEntries","observedEntry","entry","shouldWatch","priority","resizeManager","DOMElement","onSizeChanged","onPositionChanged","notFoundEl","rect1","rect2","k","isSameRect","delta","camPosA","camPosB","posA","posB","Scene","renderPassEntry","cP","passEntry","stack","projectionStack","isTransparent","similarMeshes","similarObjects","onBeforeRenderPass","swapChainTexture","onAfterRenderPass","outputPass","shaderPassEntry","isPostProA","renderOrderA","indexA","isPostProB","renderOrderB","indexB","pingPongPlane","entryType","meshes","meshA","meshB","radiusA","radiusB","renderPassEntryType","passDrawnCount","_taskCount","TasksQueueManager","args","order","task","__privateWrapper","taskId","GPURenderer","deviceManager","container","autoResize","preferredFormat","alphaMode","isOffscreenCanvas","isContainerCanvas","rectBBox","renderingSize","dimension","sceneObject","srcBuffer","hasCommandEncoder","bindGroupLayoutDescriptor","bindGroupDescriptor","shaderModuleDescriptor","pipelineLayoutDescriptor","pipelineDescriptor","textureDescriptor","existingSampler","samplerOptions","gpuSampler","objects","_shouldUpdateCameraLightsBindGroup","GPUCameraRenderer","lights","cameraParameters","structParams","paramKey","oldLightBinding","lightBindingIndex","shadowsType","oldShadowsBinding","shadowsBindingIndex","GPUDeviceManager","production","adapterOptions","onError","onDeviceLost","info","adapter","requiredFeatures","_useProjection","_ready","_setBinding","setBinding_fn","_patchBindingOffset","patchBindingOffset_fn","_onSizeChanged","onSizeChanged_fn","_setDescriptor","setDescriptor_fn","_encodeRenderCommands","encodeRenderCommands_fn","_cleanUp","cleanUp_fn","bundleIndex","RenderBundle","useBuffer","keepMesh","isReady","_key","keepMeshes","newSize","default_pass_fsWGSl","ShaderPass","defaultBlend","inputTarget","sP","common","light_utils","toneMappingUtils","RE_indirect_diffuse","constants","lambertUtils","getLambertDirect","getLambert","addUtils","toneMapping","useOcclusion","getPhongDirect","getPhong","RE_indirect_specular","pbrUtils","getPBRDirect","getPBR","getIBLIndirect","getIBL","_DOMObjectWorldPosition","_DOMObjectWorldScale","_DOMObjectDepthScaleRatio","DOMObject3D","worldPosition","planeCenter","containerCenter","defaultDOMMeshParams","DOMMesh","autoloadSources","loaderSize","sourcesLoaded","images","videos","canvases","onSourceUploaded","image","canvas","devicePixelRatio","scaleBoundingRect","defaultPlaneParams","Plane","DOMMeshParams","materialParams","geometryID","GPUCurtainsRenderer","domObject","ScrollManager","scroll","onScroll","lastScroll","GPUCurtains","watchScroll","domMesh","_element","_offset","_isOrbiting","_spherical","_rotateStart","_isPaning","_panStart","_panDelta","_setBaseParams","setBaseParams_fn","_addEvents","addEvents_fn","_removeEvents","removeEvents_fn","_onMouseDown","onMouseDown_fn","_onTouchStart","onTouchStart_fn","_onMouseMove","onMouseMove_fn","_onTouchMove","onTouchMove_fn","_onMouseUp","onMouseUp_fn","_onTouchEnd","onTouchEnd_fn","_onMouseWheel","onMouseWheel_fn","_onContextMenu","onContextMenu_fn","_update","update_fn","_rotate","rotate_fn","_pan","pan_fn","_zoom","zoom_fn","tempVec2a","tempVec2b","tempVec3","OrbitControls","enableZoom","minZoom","maxZoom","zoomSpeed","enableRotate","minPolarAngle","maxPolarAngle","minAzimuthAngle","maxAzimuthAngle","rotateSpeed","enablePan","panSpeed","sinPhiRadius","targetDistance","BoxGeometry","depthSegments","vertices","uvs","normals","indices","numberOfVertices","buildPlane","u","udir","vdir","gridX","gridY","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","SphereGeometry","phiStart","phiLength","thetaStart","thetaLength","thetaEnd","grid","vertex","verticesRow","uOffset","PingPongPlane","pPP","_localRay","_v0","_v1","_v2","_edge1","_edge2","_uv0","_uv1","_uv2","_n0","_n1","_n2","_intersectMesh","intersectMesh_fn","Raycaster","clientX","clientY","intersectionPoint","h","q","f","v0p","d00","d01","d11","d20","d21","denom","barycentric","triangleIndex","recursive","intersections","clipSpaceBoundingRect","inverseModelMatrix","triangleCount","faceDirection","point","distance","intersection","_primitiveInstances","GL","_normalMatrix","_GLTFScenesManager","gltf","traverseChildren","scene","componentType","mode","wrap","descriptor","materialIndex","materialTextures","getUVAttributeName","samplerIndex","node","childNodeIndex","childNode","primitive","meshDescriptor","instancesDescriptor","childScene","sceneDescriptor","nodeIndex","primitiveInstance","instances","nodes","geometryBBox","defaultAttributes","interleavedArray","interleavedBufferView","maxByteOffset","attribName","accessorIndex","accessor","constructor","bufferView","byteStride","accessorByteOffset","attributeParams","accessorsBufferViews","val","mainBufferStrides","attrSize","attribOrder","attrName","geometryAttributes","isIndexedGeometry","GeometryConstructor","arrayOffset","materialUniformStruct","worldMatrices","normalMatrices","transformedBbox","patchMeshesParameters","hasInstancedShadows","_updateWorldMatrix","instancesBinding","GLTFScenesManager","buildShaders","shaderParameters","baseColorTexture","normalTexture","emissiveTexture","occlusionTexture","metallicRoughnessTexture","facultativeAttributes","structAttributes","outputPositions","outputNormal","attr","outputAttributes","vertexOutputContent","outputNormalMap","tangentAttribute","useNormalMap","vertexOutput","fragmentInput","vs","initColor","returnColor","vertexColor","baseColor","normalMap","metallicRoughness","f0","emissiveOcclusion","shadingModel","chunks","iblParameters","lutTexture","envDiffuseTexture","envSpecularTexture","shadingOptions","defaultAdditionalHead","defaultPreliminaryColor","defaultAdditionalColor","applyLightShading","fs","computeDiffuseFromSpecular","diffuseTexture","specularTexture","computeDiffuseShader","diffuseStorageTexture","computeDiffusePass","GLB_MAGIC","CHUNK_TYPE","DEFAULT_TRANSLATION","DEFAULT_ROTATION","DEFAULT_SCALE","absUriRegEx","dataUriRegEx","GLTFLoader","uri","baseUrl","response","json","binaryChunk","pendingBuffers","pendingImages","headerView","magic","version","length","chunkOffset","chunkHeaderView","chunkLength","chunkType","jsonString","_decodeRGBE","decodeRGBE_fn","_parseHeader","parseHeader_fn","_parseSize","parseSize_fn","_readLine","readLine_fn","_parseData","parseData_fn","_parseNewRLE","parseNewRLE_fn","_swap","swap_fn","_flipX","flipX_fn","_flipY","flipY_fn","HDRLoader","parsedHdr","faceSize","faces","getPixel","setPixel","face","pixel","mapDirection","directionToUV","direction","theta","phi","faceData","stream","header","line","parts","ch","str","hash","colorCorr","tgt","numComps","comps","rle","n","i1","i2","hw","hh","b1","b2","logSceneCommands","renderCommands","destination","operations","stackType","objectType"],"mappings":"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"}