{"version":3,"file":"Texture.mjs","sources":["../../../../src/core/textures/Texture.ts"],"sourcesContent":["import { Vec3 } from '../../math/Vec3'\r\nimport { isRenderer, Renderer } from '../renderers/utils'\r\nimport { TextureBinding, TextureBindingParams } from '../bindings/TextureBinding'\r\nimport { BufferBinding } from '../bindings/BufferBinding'\r\nimport { Object3D } from '../objects3D/Object3D'\r\nimport { Mat4 } from '../../math/Mat4'\r\nimport { generateUUID, throwWarning } from '../../utils/utils'\r\nimport { BindGroupBindingElement } from '../../types/BindGroups'\r\nimport { TextureOptions, TextureParams, TextureParent, TextureSize, TextureSource } from '../../types/Textures'\r\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\r\nimport { DOMProjectedMesh } from '../renderers/GPURenderer'\r\nimport { RectSize } from '../DOM/DOMElement'\r\n\r\n/** @const - default {@link Texture} parameters */\r\nconst defaultTextureParams: TextureParams = {\r\n  name: 'texture',\r\n  generateMips: false,\r\n  flipY: false,\r\n  format: 'rgba8unorm',\r\n  premultipliedAlpha: true,\r\n  placeholderColor: [0, 0, 0, 255], // default to black\r\n  useExternalTextures: true,\r\n  fromTexture: null,\r\n  viewDimension: '2d',\r\n  cache: true,\r\n}\r\n\r\n/**\r\n * Used to create {@link GPUTexture} or {@link GPUExternalTexture} from different kinds of {@link TextureSource | sources}, like {@link HTMLImageElement}, {@link HTMLVideoElement} or {@link HTMLCanvasElement}.\r\n *\r\n * Handles the various sources loading and uploading, GPU textures creation,{@link BufferBinding | texture model matrix binding} and {@link TextureBinding | GPU texture binding}.\r\n *\r\n * @example\r\n * ```javascript\r\n * // set our main GPUCurtains instance\r\n * const gpuCurtains = new GPUCurtains({\r\n *   container: '#canvas' // selector of our WebGPU canvas container\r\n * })\r\n *\r\n * // set the GPU device\r\n * // note this is asynchronous\r\n * await gpuCurtains.setDevice()\r\n *\r\n * // create a render texture\r\n * const imageTexture = new Texture(gpuCurtains, {\r\n *   label: 'My image texture',\r\n *   name: 'imageTexture',\r\n * })\r\n *\r\n * // load an image\r\n * await imageTexture.loadImage(document.querySelector('img'))\r\n * ```\r\n */\r\nexport class Texture extends Object3D {\r\n  /** The type of the {@link Texture} */\r\n  type: string\r\n  /** The universal unique id of this {@link Texture} */\r\n  readonly uuid: string\r\n  /** {@link Renderer} used by this {@link Texture} */\r\n  renderer: Renderer\r\n\r\n  /** The {@link GPUTexture} used if any */\r\n  texture: null | GPUTexture\r\n  /** The {@link GPUExternalTexture} used if any */\r\n  externalTexture: null | GPUExternalTexture\r\n\r\n  /** The {@link Texture} {@link TextureSource | source} to use */\r\n  source: TextureSource\r\n  /** The {@link GPUTexture}, matching the {@link TextureSource | source} {@link RectSize | size} (with 1 for depth) */\r\n  size: TextureSize\r\n\r\n  /** Options used to create this {@link Texture} */\r\n  options: TextureOptions\r\n\r\n  /** A {@link BufferBinding | buffer binding} that will hold the texture model matrix */\r\n  textureMatrix: BufferBinding\r\n  /** The bindings used by this {@link Texture}, i.e. its {@link textureMatrix} and its {@link TextureBinding | GPU texture binding} */\r\n  bindings: BindGroupBindingElement[]\r\n\r\n  /** {@link Texture} parentMesh if any */\r\n  private _parentMesh: TextureParent\r\n\r\n  /** Whether the source has been loaded */\r\n  private _sourceLoaded: boolean\r\n  /** Whether the source has been uploaded to the GPU, handled by the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#texturesQueue | GPUDeviceManager texturesQueue array} */\r\n  private _sourceUploaded: boolean\r\n  /** Whether the texture should be uploaded to the GPU */\r\n  shouldUpdate: boolean\r\n\r\n  /** {@link HTMLVideoElement.requestVideoFrameCallback | requestVideoFrameCallback} returned id if used */\r\n  videoFrameCallbackId: null | number\r\n\r\n  /** Private {@link Vec3 | vector} used for {@link#modelMatrix} calculations, based on {@link parentMesh} {@link RectSize | size} */\r\n  #parentRatio: Vec3 = new Vec3(1)\r\n  /** Private {@link Vec3 | vector} used for {@link modelMatrix} calculations, based on {@link size | source size} */\r\n  #sourceRatio: Vec3 = new Vec3(1)\r\n  /** Private {@link Vec3 | vector} used for {@link modelMatrix} calculations, based on #parentRatio and #sourceRatio */\r\n  #coverScale: Vec3 = new Vec3(1)\r\n  /** Private rotation {@link Mat4 | matrix} based on texture {@link quaternion} */\r\n  #rotationMatrix: Mat4 = new Mat4()\r\n\r\n  // callbacks / events\r\n  /** function assigned to the {@link onSourceLoaded} callback */\r\n  _onSourceLoadedCallback = () => {\r\n    /* allow empty callback */\r\n  }\r\n  /** function assigned to the {@link onSourceUploaded} callback */\r\n  _onSourceUploadedCallback = () => {\r\n    /* allow empty callback */\r\n  }\r\n\r\n  /**\r\n   * Texture constructor\r\n   * @param renderer - {@link Renderer} object or {@link GPUCurtains} class object used to create this {@link Texture}\r\n   * @param parameters - {@link TextureParams | parameters} used to create this {@link Texture}\r\n   */\r\n  constructor(renderer: Renderer | GPUCurtains, parameters = defaultTextureParams) {\r\n    super()\r\n\r\n    this.type = 'Texture'\r\n\r\n    // we could pass our curtains object OR our curtains renderer object\r\n    renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as Renderer)\r\n\r\n    isRenderer(renderer, parameters.label ? parameters.label + ' ' + this.type : this.type)\r\n\r\n    this.renderer = renderer\r\n\r\n    this.uuid = generateUUID()\r\n\r\n    const defaultOptions = {\r\n      ...defaultTextureParams,\r\n      source: parameters.fromTexture ? parameters.fromTexture.options.source : null,\r\n      sourceType: parameters.fromTexture ? parameters.fromTexture.options.sourceType : null,\r\n    }\r\n\r\n    this.options = { ...defaultOptions, ...parameters }\r\n    // force merge of texture object\r\n    //this.options.texture = { ...defaultOptions.texture, ...parameters.texture }\r\n\r\n    this.options.label = this.options.label ?? this.options.name\r\n\r\n    this.texture = null\r\n    this.externalTexture = null\r\n    this.source = null\r\n\r\n    // sizes\r\n    this.size = {\r\n      width: 1,\r\n      height: 1,\r\n      depth: 1,\r\n    }\r\n\r\n    // we will always declare a texture matrix\r\n    this.textureMatrix = new BufferBinding({\r\n      label: this.options.label + ': model matrix',\r\n      name: this.options.name + 'Matrix',\r\n      useStruct: false,\r\n      struct: {\r\n        matrix: {\r\n          name: this.options.name + 'Matrix',\r\n          type: 'mat4x4f',\r\n          value: this.modelMatrix,\r\n        },\r\n      },\r\n    })\r\n\r\n    this.setBindings()\r\n\r\n    this._parentMesh = null\r\n\r\n    this.sourceLoaded = false\r\n    this.sourceUploaded = false\r\n    this.shouldUpdate = false\r\n\r\n    this.renderer.addTexture(this)\r\n    this.createTexture()\r\n  }\r\n\r\n  /**\r\n   * Set our {@link bindings}\r\n   */\r\n  setBindings() {\r\n    this.bindings = [\r\n      new TextureBinding({\r\n        label: this.options.label + ': texture',\r\n        name: this.options.name,\r\n        texture: this.options.sourceType === 'externalVideo' ? this.externalTexture : this.texture,\r\n        bindingType: this.options.sourceType === 'externalVideo' ? 'externalTexture' : 'texture',\r\n        viewDimension: this.options.viewDimension,\r\n      } as TextureBindingParams),\r\n      this.textureMatrix,\r\n    ]\r\n  }\r\n\r\n  /**\r\n   * Get our {@link TextureBinding | GPU texture binding}\r\n   * @readonly\r\n   */\r\n  get textureBinding(): TextureBinding {\r\n    return this.bindings[0] as TextureBinding\r\n  }\r\n\r\n  /**\r\n   * Get our texture {@link parentMesh}\r\n   */\r\n  get parentMesh(): TextureParent {\r\n    return this._parentMesh\r\n  }\r\n\r\n  /**\r\n   * Set our texture {@link parentMesh}\r\n   * @param value - texture {@link parentMesh} to set (i.e. any kind of {@link core/renderers/GPURenderer.RenderedMesh | Mesh}\r\n   */\r\n  set parentMesh(value: TextureParent) {\r\n    this._parentMesh = value\r\n    this.resize()\r\n  }\r\n\r\n  /**\r\n   * Get whether our {@link source} has been loaded\r\n   */\r\n  get sourceLoaded(): boolean {\r\n    return this._sourceLoaded\r\n  }\r\n\r\n  /**\r\n   * Set whether our {@link source} has been loaded\r\n   * @param value - boolean flag indicating if the {@link source} has been loaded\r\n   */\r\n  set sourceLoaded(value: boolean) {\r\n    if (value && !this.sourceLoaded) {\r\n      this._onSourceLoadedCallback && this._onSourceLoadedCallback()\r\n    }\r\n    this._sourceLoaded = value\r\n  }\r\n\r\n  /**\r\n   * Get whether our {@link source} has been uploaded\r\n   */\r\n  get sourceUploaded(): boolean {\r\n    return this._sourceUploaded\r\n  }\r\n\r\n  /**\r\n   * Set whether our {@link source} has been uploaded\r\n   * @param value - boolean flag indicating if the {@link source} has been uploaded\r\n   */\r\n  set sourceUploaded(value: boolean) {\r\n    if (value && !this.sourceUploaded) {\r\n      this._onSourceUploadedCallback && this._onSourceUploadedCallback()\r\n    }\r\n    this._sourceUploaded = value\r\n  }\r\n\r\n  /**\r\n   * Set our texture {@link transforms} object\r\n   */\r\n  setTransforms() {\r\n    super.setTransforms()\r\n\r\n    this.transforms.quaternion.setAxisOrder('ZXY')\r\n\r\n    // reset our model transform origin to reflect CSS transform origins\r\n    this.transforms.origin.model.set(0.5, 0.5, 0)\r\n  }\r\n\r\n  /* TEXTURE MATRIX */\r\n\r\n  /**\r\n   * Update the {@link modelMatrix}\r\n   */\r\n  updateModelMatrix() {\r\n    if (!this.parentMesh) return\r\n\r\n    const parentScale = (this.parentMesh as DOMProjectedMesh).scale\r\n      ? (this.parentMesh as DOMProjectedMesh).scale\r\n      : new Vec3(1, 1, 1)\r\n\r\n    const parentWidth = (this.parentMesh as DOMProjectedMesh).boundingRect\r\n      ? (this.parentMesh as DOMProjectedMesh).boundingRect.width * parentScale.x\r\n      : this.size.width\r\n    const parentHeight = (this.parentMesh as DOMProjectedMesh).boundingRect\r\n      ? (this.parentMesh as DOMProjectedMesh).boundingRect.height * parentScale.y\r\n      : this.size.height\r\n\r\n    const parentRatio = parentWidth / parentHeight\r\n    const sourceRatio = this.size.width / this.size.height\r\n\r\n    // handle the texture rotation\r\n    // huge props to [@grgrdvrt](https://github.com/grgrdvrt) for this solution!\r\n    if (parentWidth > parentHeight) {\r\n      this.#parentRatio.set(parentRatio, 1, 1)\r\n      this.#sourceRatio.set(1 / sourceRatio, 1, 1)\r\n    } else {\r\n      this.#parentRatio.set(1, 1 / parentRatio, 1)\r\n      this.#sourceRatio.set(1, sourceRatio, 1)\r\n    }\r\n\r\n    // cover ratio is a bit tricky!\r\n    const coverRatio =\r\n      parentRatio > sourceRatio !== parentWidth > parentHeight\r\n        ? 1\r\n        : parentWidth > parentHeight\r\n        ? this.#parentRatio.x * this.#sourceRatio.x\r\n        : this.#sourceRatio.y * this.#parentRatio.y\r\n\r\n    this.#coverScale.set(1 / (coverRatio * this.scale.x), 1 / (coverRatio * this.scale.y), 1)\r\n\r\n    this.#rotationMatrix.rotateFromQuaternion(this.quaternion)\r\n\r\n    // here we could create a matrix for each translations / scales and do:\r\n    // this.modelMatrix\r\n    //   .identity()\r\n    //   .premultiply(negativeOriginMatrix)\r\n    //   .premultiply(coverScaleMatrix)\r\n    //   .premultiply(parentRatioMatrix)\r\n    //   .premultiply(rotationMatrix)\r\n    //   .premultiply(textureRatioMatrix)\r\n    //   .premultiply(originMatrix)\r\n    //   .translate(this.position)\r\n\r\n    // but this is faster!\r\n    this.modelMatrix\r\n      .identity()\r\n      .premultiplyTranslate(this.transformOrigin.clone().multiplyScalar(-1))\r\n      .premultiplyScale(this.#coverScale)\r\n      .premultiplyScale(this.#parentRatio)\r\n      .premultiply(this.#rotationMatrix)\r\n      .premultiplyScale(this.#sourceRatio)\r\n      .premultiplyTranslate(this.transformOrigin)\r\n      .translate(this.position)\r\n  }\r\n\r\n  /**\r\n   * If our {@link modelMatrix} has been updated, tell the {@link textureMatrix | texture matrix binding} to update as well\r\n   */\r\n  onAfterMatrixStackUpdate() {\r\n    this.textureMatrix.shouldUpdateBinding(this.options.name + 'Matrix')\r\n  }\r\n\r\n  /**\r\n   * Resize our {@link Texture}\r\n   */\r\n  resize() {\r\n    // this should only happen with canvas textures\r\n    if (\r\n      this.source &&\r\n      this.source instanceof HTMLCanvasElement &&\r\n      (this.source.width !== this.size.width || this.source.height !== this.size.height)\r\n    ) {\r\n      // since the source size has changed, we have to recreate a new texture\r\n      this.setSourceSize()\r\n      this.createTexture()\r\n    }\r\n\r\n    // tell our model matrix to update\r\n    this.shouldUpdateModelMatrix()\r\n  }\r\n\r\n  /**\r\n   * Get the number of mip levels create based on {@link size}\r\n   * @param sizes - Array containing our texture width, height and depth\r\n   * @returns - number of mip levels\r\n   */\r\n  getNumMipLevels(...sizes: number[]): number {\r\n    const maxSize = Math.max(...sizes)\r\n    return (1 + Math.log2(maxSize)) | 0\r\n  }\r\n\r\n  /**\r\n   * Tell the {@link Renderer} to upload or texture\r\n   */\r\n  uploadTexture() {\r\n    this.renderer.uploadTexture(this)\r\n    this.shouldUpdate = false\r\n  }\r\n\r\n  /**\r\n   * Import a {@link GPUExternalTexture} from the {@link Renderer}, update the  {@link textureBinding} and its {@link core/bindGroups/TextureBindGroup.TextureBindGroup | bind group}\r\n   */\r\n  uploadVideoTexture() {\r\n    this.externalTexture = this.renderer.importExternalTexture(this.source as HTMLVideoElement)\r\n    this.textureBinding.resource = this.externalTexture\r\n    this.textureBinding.setBindingType('externalTexture')\r\n    this.shouldUpdate = false\r\n    this.sourceUploaded = true\r\n  }\r\n\r\n  /**\r\n   * Copy a {@link Texture}\r\n   * @param texture - {@link Texture} to copy\r\n   */\r\n  copy(texture: Texture) {\r\n    if (this.options.sourceType === 'externalVideo' && texture.options.sourceType !== 'externalVideo') {\r\n      throwWarning(`${this.options.label}: cannot copy a GPUTexture to a GPUExternalTexture`)\r\n      return\r\n    } else if (this.options.sourceType !== 'externalVideo' && texture.options.sourceType === 'externalVideo') {\r\n      throwWarning(`${this.options.label}: cannot copy a GPUExternalTexture to a GPUTexture`)\r\n      return\r\n    }\r\n\r\n    this.options.fromTexture = texture\r\n\r\n    // now copy all desired texture options except source\r\n    // const { source, ...optionsToCopy } = texture.options\r\n    // this.options = { ...this.options, ...optionsToCopy }\r\n\r\n    this.options.sourceType = texture.options.sourceType\r\n\r\n    // TODO better way to do that?\r\n    this.options.generateMips = texture.options.generateMips\r\n    this.options.flipY = texture.options.flipY\r\n    this.options.format = texture.options.format\r\n    this.options.premultipliedAlpha = texture.options.premultipliedAlpha\r\n    this.options.placeholderColor = texture.options.placeholderColor\r\n    this.options.useExternalTextures = texture.options.useExternalTextures\r\n\r\n    this.sourceLoaded = texture.sourceLoaded\r\n    this.sourceUploaded = texture.sourceUploaded\r\n\r\n    // TODO external texture?\r\n    if (texture.texture) {\r\n      if (texture.sourceLoaded) {\r\n        this.size = texture.size\r\n        this.source = texture.source\r\n\r\n        this.resize()\r\n      }\r\n\r\n      if (texture.sourceUploaded) {\r\n        // texture to copy is ready, update our texture and binding\r\n        this.texture = texture.texture\r\n        this.textureBinding.resource = this.texture\r\n      } else {\r\n        this.createTexture()\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the {@link texture | GPU texture}\r\n   */\r\n  createTexture() {\r\n    const options = {\r\n      label: this.options.label,\r\n      format: this.options.format,\r\n      size: [this.size.width, this.size.height, this.size.depth], // [1, 1] if no source\r\n      dimensions: this.options.viewDimension === '1d' ? '1d' : this.options.viewDimension === '3d' ? '3d' : '2d',\r\n      //sampleCount: this.source ? this.renderer.sampleCount : 1,\r\n      usage: !!this.source\r\n        ? GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT\r\n        : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\r\n    } as GPUTextureDescriptor\r\n\r\n    if (this.options.sourceType !== 'externalVideo') {\r\n      options.mipLevelCount = this.options.generateMips ? this.getNumMipLevels(this.size.width, this.size.height) : 1\r\n\r\n      this.texture?.destroy()\r\n\r\n      this.texture = this.renderer.createTexture(options)\r\n\r\n      // update texture binding\r\n      this.textureBinding.resource = this.texture\r\n    }\r\n\r\n    this.shouldUpdate = true\r\n  }\r\n\r\n  /* SOURCES */\r\n\r\n  /**\r\n   * Set the {@link size} based on the {@link source}\r\n   */\r\n  setSourceSize() {\r\n    this.size = {\r\n      width:\r\n        (this.source as HTMLImageElement).naturalWidth ||\r\n        (this.source as HTMLCanvasElement).width ||\r\n        (this.source as HTMLVideoElement).videoWidth,\r\n      height:\r\n        (this.source as HTMLImageElement).naturalHeight ||\r\n        (this.source as HTMLCanvasElement).height ||\r\n        (this.source as HTMLVideoElement).videoHeight,\r\n      depth: 1,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load an {@link HTMLImageElement} from a URL and create an {@link ImageBitmap} to use as a {@link source}\r\n   * @async\r\n   * @param url - URL of the image to load\r\n   * @returns - the newly created {@link ImageBitmap}\r\n   */\r\n  async loadImageBitmap(url: string): Promise<ImageBitmap> {\r\n    const res = await fetch(url)\r\n    const blob = await res.blob()\r\n    return await createImageBitmap(blob, { colorSpaceConversion: 'none' })\r\n  }\r\n\r\n  /**\r\n   * Load and create an {@link ImageBitmap} from a URL or {@link HTMLImageElement}, use it as a {@link source} and create the {@link GPUTexture}\r\n   * @async\r\n   * @param source - the image URL or {@link HTMLImageElement} to load\r\n   * @returns - the newly created {@link ImageBitmap}\r\n   */\r\n  async loadImage(source: string | HTMLImageElement): Promise<void> {\r\n    const url = typeof source === 'string' ? source : source.getAttribute('src')\r\n\r\n    this.options.source = url\r\n    this.options.sourceType = 'image'\r\n\r\n    const cachedTexture = this.renderer.textures.find((t) => t.options.source === url)\r\n    if (cachedTexture && cachedTexture.texture && cachedTexture.sourceUploaded) {\r\n      this.copy(cachedTexture)\r\n      return\r\n    }\r\n\r\n    this.sourceLoaded = false\r\n    this.sourceUploaded = false\r\n\r\n    this.source = await this.loadImageBitmap(this.options.source)\r\n\r\n    this.setSourceSize()\r\n    this.resize()\r\n\r\n    this.sourceLoaded = true\r\n    this.createTexture()\r\n  }\r\n\r\n  // weirldy enough, we don't have to do anything in that callback\r\n  // because the <video> is not visible in the viewport, the video playback is throttled\r\n  // and the rendering is janky\r\n  // using requestVideoFrameCallback helps preventing this but is unsupported in Firefox at the moment\r\n  // WebCodecs may be the way to go when time comes!\r\n  // https://developer.chrome.com/blog/new-in-webgpu-113/#use-webcodecs-videoframe-source-in-importexternaltexture\r\n  /**\r\n   * Set our {@link shouldUpdate} flag to true at each new video frame\r\n   */\r\n  onVideoFrameCallback() {\r\n    if (this.videoFrameCallbackId) {\r\n      this.shouldUpdate = true\r\n      ;(this.source as HTMLVideoElement).requestVideoFrameCallback(this.onVideoFrameCallback.bind(this))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Callback to run when a {@link HTMLVideoElement} has loaded (when it has enough data to play).\r\n   * Set the {@link HTMLVideoElement} as a {@link source} and create the {@link GPUTexture} or {@link GPUExternalTexture}\r\n   * @param video - the newly loaded {@link HTMLVideoElement}\r\n   */\r\n  onVideoLoaded(video: HTMLVideoElement) {\r\n    if (!this.sourceLoaded) {\r\n      this.source = video\r\n\r\n      this.setSourceSize()\r\n      this.resize()\r\n\r\n      if (this.options.useExternalTextures) {\r\n        this.options.sourceType = 'externalVideo'\r\n\r\n        // texture binding will be set when uploading external texture\r\n        // meanwhile, destroy previous texture\r\n        this.texture?.destroy()\r\n      } else {\r\n        this.options.sourceType = 'video'\r\n        this.createTexture()\r\n      }\r\n\r\n      if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {\r\n        this.videoFrameCallbackId = (this.source as HTMLVideoElement).requestVideoFrameCallback(\r\n          this.onVideoFrameCallback.bind(this)\r\n        )\r\n      }\r\n\r\n      this.sourceLoaded = true\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get whether the {@link source} is a video\r\n   * @readonly\r\n   */\r\n  get isVideoSource(): boolean {\r\n    return this.source && (this.options.sourceType === 'video' || this.options.sourceType === 'externalVideo')\r\n  }\r\n\r\n  /**\r\n   * Load a video from a URL or {@link HTMLVideoElement} and register {@link onVideoLoaded} callback\r\n   * @param source - the video URL or {@link HTMLVideoElement} to load\r\n   */\r\n  loadVideo(source: string | HTMLVideoElement) {\r\n    let video\r\n\r\n    if (typeof source === 'string') {\r\n      video = document.createElement('video')\r\n      video.src = source\r\n    } else {\r\n      video = source\r\n    }\r\n\r\n    video.preload = 'auto'\r\n    video.muted = true\r\n    video.loop = true\r\n    video.crossOrigin = 'anonymous'\r\n    video.setAttribute('playsinline', '')\r\n\r\n    this.options.source = video.src\r\n    this.sourceLoaded = false\r\n    this.sourceUploaded = false\r\n\r\n    // If the video is in the cache of the browser,\r\n    // the 'canplaythrough' event might have been triggered\r\n    // before we registered the event handler.\r\n    if (video.readyState >= video.HAVE_ENOUGH_DATA) {\r\n      this.onVideoLoaded(video)\r\n    } else {\r\n      video.addEventListener('canplaythrough', this.onVideoLoaded.bind(this, video), {\r\n        once: true,\r\n      })\r\n    }\r\n\r\n    // if duration is not available, should mean our video has not started loading\r\n    if (isNaN(video.duration)) {\r\n      video.load()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load a {@link HTMLCanvasElement}, use it as a {@link source} and create the {@link GPUTexture}\r\n   * @param source - the {@link HTMLCanvasElement} to use\r\n   */\r\n  loadCanvas(source: HTMLCanvasElement) {\r\n    this.options.source = source\r\n    this.options.sourceType = 'canvas'\r\n    this.sourceLoaded = false\r\n    this.sourceUploaded = false\r\n\r\n    this.source = source\r\n\r\n    this.setSourceSize()\r\n    this.resize()\r\n\r\n    this.sourceLoaded = true\r\n    this.createTexture()\r\n  }\r\n\r\n  /* EVENTS */\r\n\r\n  /**\r\n   * Callback to run when the {@link source} has been loaded\r\n   * @param callback - callback to run when the {@link source} has been loaded\r\n   * @returns - our {@link Texture}\r\n   */\r\n  onSourceLoaded(callback: () => void): Texture {\r\n    if (callback) {\r\n      this._onSourceLoadedCallback = callback\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Callback to run when the {@link source} has been uploaded\r\n   * @param callback - callback to run when the {@link source} been uploaded\r\n   * @returns - our {@link Texture}\r\n   */\r\n  onSourceUploaded(callback: () => void): Texture {\r\n    if (callback) {\r\n      this._onSourceUploadedCallback = callback\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  /* RENDER */\r\n\r\n  /**\r\n   * Render a {@link Texture}:\r\n   * - Update its {@link modelMatrix} and {@link bindings} if needed\r\n   * - Upload the texture if it needs to be done\r\n   */\r\n  render() {\r\n    // update our model matrix if needed\r\n    this.updateMatrixStack()\r\n\r\n    // update uniforms values\r\n    this.textureMatrix.update()\r\n\r\n    // since external texture are destroyed as soon as JavaScript returns to the browser\r\n    // we need to update it at every tick, even if it hasn't changed\r\n    // to ensure we're not sending a stale / destroyed texture\r\n    // anyway, external texture are cached so it is fined to call importExternalTexture at each tick\r\n    if (this.options.sourceType === 'externalVideo') {\r\n      this.shouldUpdate = true\r\n    }\r\n\r\n    // if no videoFrameCallback check if the video is actually really playing\r\n    if (\r\n      this.isVideoSource &&\r\n      !this.videoFrameCallbackId &&\r\n      (this.source as HTMLVideoElement).readyState >= (this.source as HTMLVideoElement).HAVE_CURRENT_DATA &&\r\n      !(this.source as HTMLVideoElement).paused\r\n    ) {\r\n      this.shouldUpdate = true\r\n    }\r\n\r\n    if (this.shouldUpdate && this.options.sourceType && this.options.sourceType !== 'externalVideo') {\r\n      this.uploadTexture()\r\n    }\r\n  }\r\n\r\n  /* DESTROY */\r\n\r\n  /**\r\n   * Destroy the {@link Texture}\r\n   */\r\n  destroy() {\r\n    if (this.videoFrameCallbackId) {\r\n      ;(this.source as HTMLVideoElement).cancelVideoFrameCallback(this.videoFrameCallbackId)\r\n    }\r\n\r\n    if (this.isVideoSource) {\r\n      ;(this.source as HTMLVideoElement).removeEventListener(\r\n        'canplaythrough',\r\n        this.onVideoLoaded.bind(this, this.source),\r\n        {\r\n          once: true,\r\n        } as AddEventListenerOptions & EventListenerOptions\r\n      )\r\n    }\r\n\r\n    this.renderer.removeTexture(this)\r\n\r\n    this.texture?.destroy()\r\n    this.texture = null\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}