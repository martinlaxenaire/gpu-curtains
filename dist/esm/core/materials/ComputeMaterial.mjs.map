{"version":3,"file":"ComputeMaterial.mjs","sources":["../../../../src/core/materials/ComputeMaterial.ts"],"sourcesContent":["import { Material } from './Material'\nimport { ComputeMaterialOptions, ComputeMaterialParams, FullShadersType } from '../../types/Materials'\nimport { isRenderer, Renderer } from '../renderers/utils'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\nimport { ComputePipelineEntry } from '../pipelines/ComputePipelineEntry'\nimport { WritableBufferBinding } from '../bindings/WritableBufferBinding'\n\n/**\n * Create a {@link Material} specifically built to run computations on the GPU. Internally used by {@link core/computePasses/ComputePass.ComputePass | ComputePass}.\n *\n * ## Compute pipeline\n *\n * A {@link ComputeMaterial} automatically creates a {@link ComputePipelineEntry}. Once all the {@link core/bindGroups/BindGroup.BindGroup | BindGroup} have been created, they are sent with the compute shader code to the {@link ComputePipelineEntry}, which is in turns responsible for creating the {@link GPUComputePipeline}.\n *\n * After the {@link GPUComputePipeline} has been successfully compiled, the {@link ComputeMaterial} is considered to be ready and it can start running the compute shader computations.\n *\n */\nexport class ComputeMaterial extends Material {\n  /** {@link ComputePipelineEntry | Compute pipeline entry} used by this {@link ComputeMaterial} */\n  pipelineEntry: ComputePipelineEntry\n  /** Options used to create this {@link ComputeMaterial} */\n  options: ComputeMaterialOptions\n\n  /** Default work group dispatch size to use with this {@link ComputeMaterial} */\n  dispatchSize?: number | number[]\n\n  /** function assigned to the {@link useCustomRender} callback */\n  _useCustomRenderCallback: (pass: GPUComputePassEncoder) => void\n\n  /**\n   * ComputeMaterial constructor\n   * @param renderer - our {@link Renderer} class object\n   * @param parameters - {@link ComputeMaterialParams | parameters} used to create our {@link ComputeMaterial}\n   */\n  constructor(renderer: Renderer | GPUCurtains, parameters: ComputeMaterialParams) {\n    // we could pass our curtains object OR our curtains renderer object\n    renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as Renderer)\n\n    const type = 'ComputeMaterial'\n\n    isRenderer(renderer, type)\n\n    super(renderer, parameters)\n\n    this.type = type\n    this.renderer = renderer\n\n    let { shaders, dispatchSize } = parameters\n\n    if (!shaders || !shaders.compute) {\n      shaders = {\n        compute: {\n          code: '',\n          entryPoint: 'main',\n        },\n      }\n    }\n\n    if (!shaders.compute.code) {\n      shaders.compute.code = '@compute @workgroup_size(1) fn main(){}'\n    }\n\n    if (!shaders.compute.entryPoint) {\n      shaders.compute.entryPoint = 'main'\n    }\n\n    this.options = {\n      ...this.options,\n      shaders,\n      ...(parameters.dispatchSize !== undefined && { dispatchSize: parameters.dispatchSize }),\n    }\n\n    // set default dispatch size\n    if (!dispatchSize) {\n      dispatchSize = 1\n    }\n\n    if (Array.isArray(dispatchSize)) {\n      dispatchSize[0] = Math.ceil(dispatchSize[0] ?? 1)\n      dispatchSize[1] = Math.ceil(dispatchSize[1] ?? 1)\n      dispatchSize[2] = Math.ceil(dispatchSize[2] ?? 1)\n    } else if (!isNaN(dispatchSize)) {\n      dispatchSize = [Math.ceil(dispatchSize), 1, 1]\n    }\n\n    this.dispatchSize = dispatchSize\n\n    this.pipelineEntry = this.renderer.pipelineManager.createComputePipeline({\n      renderer: this.renderer,\n      label: this.options.label + ' compute pipeline',\n      shaders: this.options.shaders,\n      useAsync: this.options.useAsyncPipeline,\n    })\n  }\n\n  /**\n   * When all bind groups are created, add them to the {@link ComputePipelineEntry}\n   */\n  setPipelineEntryProperties() {\n    this.pipelineEntry.setPipelineEntryProperties({\n      bindGroups: this.bindGroups,\n    })\n  }\n\n  /**\n   * Compile the {@link ComputePipelineEntry}\n   * @async\n   */\n  async compilePipelineEntry(): Promise<void> {\n    await this.pipelineEntry.compilePipelineEntry()\n  }\n\n  /**\n   * Check if all bind groups are ready, create them if needed, set {@link ComputePipelineEntry} bind group buffers and compile the pipeline\n   * @async\n   */\n  async compileMaterial() {\n    super.compileMaterial()\n\n    if (this.pipelineEntry && this.pipelineEntry.canCompile) {\n      this.setPipelineEntryProperties()\n      await this.compilePipelineEntry()\n    }\n  }\n\n  /**\n   * Get the complete code of a given shader including all the WGSL fragment code snippets added by the pipeline\n   * @param [shaderType=\"compute\"] - shader to get the code from\n   * @returns - The corresponding shader code\n   */\n  getShaderCode(shaderType: FullShadersType = 'compute'): string {\n    return super.getShaderCode(shaderType)\n  }\n\n  /**\n   * Get the added code of a given shader, i.e. all the WGSL fragment code snippets added by the pipeline\n   * @param [shaderType=\"compute\"] - shader to get the code from\n   * @returns - The corresponding shader code\n   */\n  getAddedShaderCode(shaderType: FullShadersType = 'compute'): string {\n    return super.getAddedShaderCode(shaderType)\n  }\n\n  /* RENDER */\n\n  /**\n   * If a custom render function has been defined instead of the default one, register the callback\n   * @param callback - callback to run instead of the default render behaviour, which is to set the {@link bindGroups | bind groups} and dispatch the work groups based on the {@link dispatchSize | default dispatch size}. This is where you will have to set all the {@link core/bindGroups/BindGroup.BindGroup | bind groups} and dispatch the workgroups by yourself.\n   */\n  useCustomRender(callback: (pass: GPUComputePassEncoder) => void) {\n    if (callback) {\n      this._useCustomRenderCallback = callback\n    }\n  }\n\n  /**\n   * Render the material if it is ready:\n   * Set the current pipeline, set the bind groups and dispatch the work groups\n   * @param pass - current compute pass encoder\n   */\n  render(pass: GPUComputePassEncoder) {\n    // renderer or pipeline are not ready yet\n    // not really needed since compute passes do already check it beforehand\n    // mostly here as a safeguard\n    if (!this.ready) return\n\n    // set current pipeline\n    this.setPipeline(pass)\n\n    // if we declared a custom render function, call it\n    if (this._useCustomRenderCallback !== undefined) {\n      this._useCustomRenderCallback(pass)\n    } else {\n      // else just set our bind groups and dispatch\n      this.bindGroups.forEach((bindGroup) => {\n        pass.setBindGroup(bindGroup.index, bindGroup.bindGroup)\n      })\n\n      pass.dispatchWorkgroups(this.dispatchSize[0], this.dispatchSize[1], this.dispatchSize[2])\n    }\n  }\n\n  /* RESULT BUFFER */\n\n  /**\n   * Copy all writable binding buffers that need it\n   * @param commandEncoder - current command encoder\n   */\n  copyBufferToResult(commandEncoder: GPUCommandEncoder) {\n    this.bindGroups.forEach((bindGroup) => {\n      bindGroup.bufferBindings.forEach((binding: WritableBufferBinding) => {\n        if (binding.shouldCopyResult && binding.resultBuffer.mapState === 'unmapped') {\n          commandEncoder.copyBufferToBuffer(binding.buffer, 0, binding.resultBuffer, 0, binding.resultBuffer.size)\n        }\n      })\n    })\n  }\n\n  /**\n   * Get the {@link core/bindings/WritableBufferBinding.WritableBufferBinding#resultBuffer | result GPU buffer} content by {@link core/bindings/WritableBufferBinding.WritableBufferBinding | binding} and {@link core/bindings/bufferElements/BufferElement.BufferElement | buffer element} names\n   * @param parameters - parameters used to get the result\n   * @param parameters.bindingName - {@link core/bindings/WritableBufferBinding.WritableBufferBinding#name | binding name} from which to get the result\n   * @param parameters.bufferElementName - optional {@link core/bindings/bufferElements/BufferElement.BufferElement | buffer element} (i.e. struct member) name if the result needs to be restrained to only one element\n   * @async\n   * @returns - the mapped content of the {@link GPUBuffer} as a {@link Float32Array}\n   */\n  async getComputeResult({\n    bindingName = '',\n    bufferElementName = '',\n  }: {\n    bindingName?: string\n    bufferElementName?: string\n  }): Promise<Float32Array> {\n    const binding = this.getBufferBindingByName(bindingName)\n\n    if (binding && 'resultBuffer' in binding && binding.resultBuffer.mapState === 'unmapped') {\n      const result = await this.getBufferResult(binding.resultBuffer)\n\n      if (bufferElementName) {\n        return binding.extractBufferElementDataFromBufferResult({ result, bufferElementName })\n      } else {\n        return result\n      }\n    } else {\n      return new Float32Array(0)\n    }\n  }\n}\n"],"names":[],"mappings":"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"}