{"version":3,"file":"Material.mjs","sources":["../../../../src/core/materials/Material.ts"],"sourcesContent":["import { isRenderer, Renderer } from '../renderers/utils'\nimport { BindGroup } from '../bindGroups/BindGroup'\nimport { TextureBindGroup } from '../bindGroups/TextureBindGroup'\nimport { Sampler } from '../samplers/Sampler'\nimport { AllowedPipelineEntries } from '../pipelines/PipelineManager'\nimport { BufferBinding, BufferBindingInput } from '../bindings/BufferBinding'\nimport { AllowedBindGroups, BindGroupBindingElement, BindGroupBufferBindingElement } from '../../types/BindGroups'\nimport { Texture } from '../textures/Texture'\nimport { FullShadersType, MaterialOptions, MaterialParams, ShaderOptions } from '../../types/Materials'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\nimport { RenderTexture } from '../textures/RenderTexture'\nimport { Binding } from '../bindings/Binding'\nimport { generateUUID } from '../../utils/utils'\nimport { BufferElement } from '../bindings/bufferElements/BufferElement'\n\n/**\n * Used as a base to create a {@link Material}.<br>\n * The purpose of {@link Material} is to create and update the {@link BindGroup | bind groups} and their bindings (GPU buffers, textures and samplers), create a {@link core/pipelines/PipelineEntry.PipelineEntry | PipelineEntry} and use them to {@link Material#render | render}.\n *\n * ## Bind groups\n *\n * A {@link Material} automatically creates a {@link TextureBindGroup}, but it is actually added to the active {@link Material#bindGroups | bind groups array} only if necessary, which means if your shaders use a {@link GPUSampler}, a {@link GPUTexture} or a {@link GPUExternalTexture}.\n *\n * Another {@link BindGroup} will be created if you pass any {@link MaterialParams#uniforms | uniforms} or {@link MaterialParams#storages | storages} parameters.\n *\n * Finally, you can also pass already created {@link BindGroup} to a {@link Material} via the {@link MaterialParams#bindGroups | bindGroups} parameter.\n *\n * ----\n *\n * Note that this class is not intended to be used as is, but as a base for {@link core/materials/ComputeMaterial.ComputeMaterial | ComputeMaterial} and {@link core/materials/RenderMaterial.RenderMaterial | RenderMaterial} classes.\n */\nexport class Material {\n  /** The type of the {@link Material} */\n  type: string\n  /** The universal unique id of the {@link Material} */\n  uuid: string\n  /** The {@link Renderer} used */\n  renderer: Renderer\n  /** Options used to create this {@link Material} */\n  options: MaterialOptions\n\n  /** Pipeline entry used by this {@link Material} */\n  pipelineEntry: AllowedPipelineEntries\n\n  /**\n   * Array of {@link BindGroup | bind groups} used by this {@link Material}\n   * This array respects a specific order:\n   * 1. The {@link texturesBindGroup | textures bind groups}\n   * 2. The {@link BindGroup | bind group} created using {@link types/BindGroups.BindGroupInputs#uniforms | uniforms} and {@link types/BindGroups.BindGroupInputs#storages | storages} parameters if any\n   * 3. Additional {@link MaterialParams#bindGroups | bind groups} parameters if any\n   */\n  bindGroups: AllowedBindGroups[]\n  /** Array of {@link TextureBindGroup | texture bind groups} used by this {@link Material} */\n  texturesBindGroups: TextureBindGroup[]\n  /** Array of {@link BindGroup | bind groups} created using the {@link types/BindGroups.BindGroupInputs#uniforms | uniforms} and {@link types/BindGroups.BindGroupInputs#storages | storages} parameters when instancing this {@link Material} */\n  inputsBindGroups: BindGroup[]\n  /** Array of {@link BindGroup | cloned bind groups} created by this {@link Material} */\n  clonedBindGroups: AllowedBindGroups[]\n\n  /** Object containing all uniforms inputs handled by this {@link Material} */\n  uniforms: Record<string, Record<string, BufferBindingInput>>\n  /** Object containing all read only or read/write storages inputs handled by this {@link Material} */\n  storages: Record<string, Record<string, BufferBindingInput>>\n\n  /** Array of {@link Binding | bindings} created using the {@link types/BindGroups.BindGroupInputs#uniforms | uniforms} and {@link types/BindGroups.BindGroupInputs#storages | storages} parameters when instancing this {@link Material} */\n  inputsBindings: BindGroupBindingElement[]\n\n  /** Array of {@link Texture} handled by this {@link Material} */\n  textures: Texture[]\n  /** Array of {@link RenderTexture} handled by this {@link Material} */\n  renderTextures: RenderTexture[]\n  /** Array of {@link Sampler} handled by this {@link Material} */\n  samplers: Sampler[]\n\n  /**\n   * Material constructor\n   * @param renderer - our renderer class object\n   * @param parameters - {@link types/Materials.MaterialParams | parameters} used to create our Material\n   */\n  constructor(renderer: Renderer | GPUCurtains, parameters: MaterialParams) {\n    this.type = 'Material'\n\n    // we could pass our curtains object OR our curtains renderer object\n    renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as Renderer)\n\n    isRenderer(renderer, this.type)\n\n    this.renderer = renderer\n\n    this.uuid = generateUUID()\n\n    const {\n      shaders,\n      label,\n      useAsyncPipeline,\n      uniforms,\n      storages,\n      bindings,\n      bindGroups,\n      samplers,\n      textures,\n      renderTextures,\n    } = parameters\n\n    this.options = {\n      shaders,\n      label,\n      useAsyncPipeline: useAsyncPipeline === undefined ? true : useAsyncPipeline,\n      ...(uniforms !== undefined && { uniforms }),\n      ...(storages !== undefined && { storages }),\n      ...(bindings !== undefined && { bindings }),\n      ...(bindGroups !== undefined && { bindGroups }),\n      ...(samplers !== undefined && { samplers }),\n      ...(textures !== undefined && { textures }),\n      ...(renderTextures !== undefined && { renderTextures }),\n    }\n\n    this.bindGroups = []\n    this.texturesBindGroups = []\n    this.clonedBindGroups = []\n\n    this.setBindGroups()\n\n    this.setTextures()\n    this.setSamplers()\n  }\n\n  /**\n   * Check if all bind groups are ready, and create them if needed\n   */\n  compileMaterial() {\n    const texturesBindGroupLength = this.texturesBindGroup.bindings.length ? 1 : 0\n    const bindGroupsReady = this.bindGroups.length >= this.inputsBindGroups.length + texturesBindGroupLength\n\n    if (!bindGroupsReady) {\n      this.createBindGroups()\n    }\n  }\n\n  /**\n   * Get whether the renderer is ready, our pipeline entry and pipeline have been created and successfully compiled\n   * @readonly\n   */\n  get ready(): boolean {\n    return !!(this.renderer.ready && this.pipelineEntry && this.pipelineEntry.pipeline && this.pipelineEntry.ready)\n  }\n\n  /**\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been lost to prepare everything for restoration.\n   * Basically set all the {@link GPUBuffer} to null so they will be reset next time we try to render\n   */\n  loseContext() {\n    // start with the textures\n    this.textures.forEach((texture) => {\n      texture.texture = null\n      texture.sourceUploaded = false\n    })\n\n    this.renderTextures.forEach((texture) => {\n      texture.texture = null\n    })\n\n    // then bind groups and struct\n    ;[...this.bindGroups, ...this.clonedBindGroups, ...this.inputsBindGroups].forEach((bindGroup) =>\n      bindGroup.loseContext()\n    )\n\n    // reset pipeline as well\n    this.pipelineEntry.pipeline = null\n  }\n\n  /**\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been restored to recreate our bind groups.\n   */\n  restoreContext() {\n    // start with the samplers and textures\n    this.samplers.forEach((sampler) => {\n      // the samplers have all been recreated by the renderer, just update the reference\n      sampler.createSampler()\n      sampler.binding.resource = sampler.sampler\n    })\n\n    // recreate the textures and resize them\n    this.textures.forEach((texture) => {\n      texture.createTexture()\n      texture.resize()\n    })\n\n    this.renderTextures.forEach((texture) => {\n      texture.resize(texture.size)\n    })\n\n    // now the bind groups\n    ;[...this.bindGroups, ...this.clonedBindGroups, ...this.inputsBindGroups].forEach((bindGroup) => {\n      if (bindGroup.shouldCreateBindGroup) {\n        bindGroup.createBindGroup()\n      }\n\n      // finally re-write all our buffers\n      bindGroup.bufferBindings.forEach((bufferBinding) => (bufferBinding.shouldUpdate = true))\n    })\n  }\n\n  /**\n   * Get the complete code of a given shader including all the WGSL fragment code snippets added by the pipeline\n   * @param [shaderType=\"full\"] - shader to get the code from\n   * @returns - The corresponding shader code\n   */\n  getShaderCode(shaderType: FullShadersType = 'full'): string {\n    if (!this.pipelineEntry) return ''\n\n    shaderType = (() => {\n      switch (shaderType) {\n        case 'vertex':\n        case 'fragment':\n        case 'compute':\n        case 'full':\n          return shaderType\n        default:\n          return 'full'\n      }\n    })()\n\n    return this.pipelineEntry.shaders[shaderType].code\n  }\n\n  /**\n   * Get the added code of a given shader, i.e. all the WGSL fragment code snippets added by the pipeline\n   * @param [shaderType=\"vertex\"] - shader to get the code from\n   * @returns - The corresponding shader code\n   */\n  getAddedShaderCode(shaderType: FullShadersType = 'vertex'): string {\n    if (!this.pipelineEntry) return ''\n\n    shaderType = (() => {\n      switch (shaderType) {\n        case 'vertex':\n        case 'fragment':\n        case 'compute':\n          return shaderType\n        default:\n          return 'vertex'\n      }\n    })()\n\n    return this.pipelineEntry.shaders[shaderType].head\n  }\n\n  /* BIND GROUPS */\n\n  /**\n   * Prepare and set our bind groups based on inputs and bindGroups Material parameters\n   */\n  setBindGroups() {\n    this.uniforms = {}\n    this.storages = {}\n\n    this.inputsBindGroups = []\n    this.inputsBindings = []\n\n    if (this.options.uniforms || this.options.storages || this.options.bindings) {\n      const inputsBindGroup = new BindGroup(this.renderer, {\n        label: this.options.label + ': Bindings bind group',\n        uniforms: this.options.uniforms,\n        storages: this.options.storages,\n        bindings: this.options.bindings,\n      })\n\n      this.processBindGroupBindings(inputsBindGroup)\n      this.inputsBindGroups.push(inputsBindGroup)\n    }\n\n    this.options.bindGroups?.forEach((bindGroup) => {\n      this.processBindGroupBindings(bindGroup)\n      this.inputsBindGroups.push(bindGroup)\n    })\n  }\n\n  /**\n   * Get the main {@link TextureBindGroup | texture bind group} created by this {@link Material} to manage all textures related struct\n   * @readonly\n   */\n  get texturesBindGroup(): TextureBindGroup {\n    return this.texturesBindGroups[0]\n  }\n\n  /**\n   * Process all {@link BindGroup} struct and add them to the corresponding objects based on their binding types. Also store them in a inputsBindings array to facilitate further access to struct.\n   * @param bindGroup - The {@link BindGroup} to process\n   */\n  processBindGroupBindings(bindGroup: BindGroup) {\n    bindGroup.bindings.forEach((inputBinding) => {\n      if (inputBinding.bindingType === 'uniform')\n        this.uniforms = {\n          ...this.uniforms,\n          [inputBinding.name]: (inputBinding as BindGroupBufferBindingElement).inputs,\n        }\n      if (inputBinding.bindingType === 'storage')\n        this.storages = {\n          ...this.storages,\n          [inputBinding.name]: (inputBinding as BindGroupBufferBindingElement).inputs,\n        }\n\n      this.inputsBindings.push(inputBinding)\n    })\n  }\n\n  /**\n   * Create the bind groups if they need to be created\n   */\n  createBindGroups() {\n    // textures first\n    if (this.texturesBindGroup.shouldCreateBindGroup) {\n      this.texturesBindGroup.setIndex(this.bindGroups.length)\n      this.texturesBindGroup.createBindGroup()\n\n      this.bindGroups.push(this.texturesBindGroup)\n    }\n\n    // then uniforms/storages inputs\n    this.inputsBindGroups.forEach((bindGroup) => {\n      if (bindGroup.shouldCreateBindGroup) {\n        bindGroup.setIndex(this.bindGroups.length)\n        bindGroup.createBindGroup()\n\n        this.bindGroups.push(bindGroup)\n      }\n    })\n\n    // finally, bindGroups inputs\n    this.options.bindGroups?.forEach((bindGroup) => {\n      // it has been created but not been added yet? add it!\n      if (!bindGroup.shouldCreateBindGroup && !this.bindGroups.find((bG) => bG.uuid === bindGroup.uuid)) {\n        bindGroup.setIndex(this.bindGroups.length)\n        this.bindGroups.push(bindGroup)\n      }\n\n      // add it to our textures bind groups as well if needed\n      if (bindGroup instanceof TextureBindGroup && !this.texturesBindGroups.find((bG) => bG.uuid === bindGroup.uuid)) {\n        this.texturesBindGroups.push(bindGroup)\n\n        // also add the textures?\n        bindGroup.textures.forEach((texture) => {\n          if (texture instanceof Texture && !this.textures.find((t) => t.uuid === texture.uuid)) {\n            this.textures.push(texture)\n          } else if (texture instanceof RenderTexture && !this.renderTextures.find((t) => t.uuid === texture.uuid)) {\n            this.renderTextures.push(texture)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Clones a {@link BindGroup} from a list of buffers\n   * Useful to create a new bind group with already created buffers, but swapped\n   * @param parameters - parameters used to clone the {@link BindGroup | bind group}\n   * @param parameters.bindGroup - the BindGroup to clone\n   * @param parameters.bindings - our input binding buffers\n   * @param parameters.keepLayout - whether we should keep original bind group layout or not\n   * @returns - the cloned BindGroup\n   */\n  cloneBindGroup({\n    bindGroup,\n    bindings = [],\n    keepLayout = true,\n  }: {\n    bindGroup?: AllowedBindGroups\n    bindings?: BindGroupBindingElement[]\n    keepLayout?: boolean\n  }): AllowedBindGroups | null {\n    if (!bindGroup) return null\n\n    const clone = bindGroup.clone({ bindings, keepLayout })\n    this.clonedBindGroups.push(clone)\n\n    return clone\n  }\n\n  /**\n   * Get a corresponding {@link BindGroup} or {@link TextureBindGroup} from one of its binding name/key\n   * @param bindingName - the binding name/key to look for\n   * @returns - bind group found or null if not found\n   */\n  getBindGroupByBindingName(bindingName: BufferBinding['name'] = ''): AllowedBindGroups | null {\n    return (this.ready ? this.bindGroups : this.inputsBindGroups).find((bindGroup) => {\n      return bindGroup.bindings.find((binding) => binding.name === bindingName)\n    })\n  }\n\n  /**\n   * Destroy a bind group, only if it is not used by another object\n   * @param bindGroup - bind group to eventually destroy\n   */\n  destroyBindGroup(bindGroup: AllowedBindGroups) {\n    // check if this bind group is used by another object before actually destroying it\n    const objectsUsingBindGroup = this.renderer.getObjectsByBindGroup(bindGroup)\n\n    const shouldDestroy =\n      !objectsUsingBindGroup || !objectsUsingBindGroup.find((object) => object.material.uuid !== this.uuid)\n\n    if (shouldDestroy) {\n      bindGroup.destroy()\n    }\n  }\n\n  /**\n   * Destroy all bind groups\n   */\n  destroyBindGroups() {\n    this.bindGroups.forEach((bindGroup) => this.destroyBindGroup(bindGroup))\n    this.clonedBindGroups.forEach((bindGroup) => this.destroyBindGroup(bindGroup))\n    this.texturesBindGroups.forEach((bindGroup) => this.destroyBindGroup(bindGroup))\n    this.texturesBindGroups = []\n    this.inputsBindGroups = []\n    this.bindGroups = []\n    this.clonedBindGroups = []\n  }\n\n  /**\n   * {@link BindGroup#update | Update} all bind groups:\n   * - Update all {@link texturesBindGroups | textures bind groups} textures\n   * - Update its {@link BindGroup#bufferBindings | buffer bindings}\n   * - Check if it eventually needs a {@link BindGroup#resetBindGroup | reset}\n   * - Check if we need to flush the pipeline\n   */\n  updateBindGroups() {\n    // now update all bind groups in use and check if they need to flush the pipeline\n    this.bindGroups.forEach((bindGroup) => {\n      bindGroup.update()\n\n      // if a bind group needs to flush the pipeline\n      // usually happens if one of the struct bindingType has changed,\n      // which means the shader should be re-patched and recreated\n      if (bindGroup.needsPipelineFlush && this.pipelineEntry.ready) {\n        this.pipelineEntry.flushPipelineEntry(this.bindGroups)\n        bindGroup.needsPipelineFlush = false\n      }\n    })\n  }\n\n  /* INPUTS */\n\n  /**\n   * Look for a {@link BindGroupBindingElement | binding} by name in all {@link inputsBindings | input bindings}\n   * @param bindingName - the binding name or key\n   * @returns - the found binding, or null if not found\n   */\n  getBindingByName(bindingName: Binding['name'] = ''): BindGroupBindingElement | undefined {\n    return this.inputsBindings.find((binding) => binding.name === bindingName)\n  }\n\n  /**\n   * Look for a {@link BindGroupBufferBindingElement | buffer binding} by name in all {@link inputsBindings | input bindings}\n   * @param bindingName - the binding name or key\n   * @returns - the found binding, or null if not found\n   */\n  getBufferBindingByName(bindingName: Binding['name'] = ''): BindGroupBufferBindingElement | undefined {\n    return this.inputsBindings.find((binding) => binding.name === bindingName && 'buffer' in binding) as\n      | BindGroupBufferBindingElement\n      | undefined\n  }\n\n  /**\n   * Force a given buffer binding update flag to update it at next render\n   * @param bufferBindingName - the buffer binding name\n   * @param bindingName - the binding name\n   */\n  shouldUpdateInputsBindings(bufferBindingName?: BufferBinding['name'], bindingName?: BufferBindingInput['name']) {\n    if (!bufferBindingName) return\n\n    const bufferBinding = this.getBindingByName(bufferBindingName)\n    if (bufferBinding) {\n      if (!bindingName) {\n        Object.keys((bufferBinding as BindGroupBufferBindingElement).inputs).forEach((bindingKey) =>\n          (bufferBinding as BindGroupBufferBindingElement).shouldUpdateBinding(bindingKey)\n        )\n      } else {\n        ;(bufferBinding as BindGroupBufferBindingElement).shouldUpdateBinding(bindingName)\n      }\n    }\n  }\n\n  /* SAMPLERS & TEXTURES */\n\n  /**\n   * Prepare our textures array and set the {@link TextureBindGroup}\n   */\n  setTextures() {\n    this.textures = []\n    this.renderTextures = []\n    this.texturesBindGroups.push(\n      new TextureBindGroup(this.renderer, {\n        label: this.options.label + ': Textures bind group',\n      })\n    )\n\n    this.options.textures?.forEach((texture) => {\n      this.addTexture(texture)\n    })\n\n    this.options.renderTextures?.forEach((texture) => {\n      this.addTexture(texture)\n    })\n  }\n\n  /**\n   * Add a texture to our array, and add it to the textures bind group only if used in the shaders (avoid binding useless data)\n   * @param texture - texture to add\n   */\n  addTexture(texture: Texture | RenderTexture) {\n    if (texture instanceof Texture) {\n      this.textures.push(texture)\n    } else if (texture instanceof RenderTexture) {\n      this.renderTextures.push(texture)\n    }\n\n    // is it used in our shaders?\n    if (\n      (this.options.shaders.vertex && this.options.shaders.vertex.code.indexOf(texture.options.name) !== -1) ||\n      (this.options.shaders.fragment &&\n        (this.options.shaders.fragment as ShaderOptions).code.indexOf(texture.options.name) !== -1) ||\n      (this.options.shaders.compute && this.options.shaders.compute.code.indexOf(texture.options.name) !== -1)\n    ) {\n      this.texturesBindGroup.addTexture(texture)\n    }\n  }\n\n  /**\n   * Destroy a {@link Texture} or {@link RenderTexture}, only if it is not used by another object or cached.\n   * @param texture - {@link Texture} or {@link RenderTexture} to eventually destroy\n   */\n  destroyTexture(texture: Texture | RenderTexture) {\n    // do not destroy a texture that must stay in cache\n    if ((texture as Texture).options.cache) return\n\n    // check if this texture is used by another object before actually destroying it\n    const objectsUsingTexture = this.renderer.getObjectsByTexture(texture)\n\n    const shouldDestroy =\n      !objectsUsingTexture || !objectsUsingTexture.some((object) => object.material.uuid !== this.uuid)\n\n    if (shouldDestroy) {\n      texture.destroy()\n    }\n  }\n\n  /**\n   * Destroy all the Material textures\n   */\n  destroyTextures() {\n    this.textures?.forEach((texture) => this.destroyTexture(texture))\n    this.renderTextures?.forEach((texture) => this.destroyTexture(texture))\n    this.textures = []\n    this.renderTextures = []\n  }\n\n  /**\n   * Prepare our samplers array and always add a default sampler if not already passed as parameter\n   */\n  setSamplers() {\n    this.samplers = []\n\n    this.options.samplers?.forEach((sampler) => {\n      this.addSampler(sampler)\n    })\n\n    // create our default sampler if needed\n    const hasDefaultSampler = this.samplers.find((sampler) => sampler.name === 'defaultSampler')\n    if (!hasDefaultSampler) {\n      const sampler = new Sampler(this.renderer, { name: 'defaultSampler' })\n      this.addSampler(sampler)\n    }\n  }\n\n  /**\n   * Add a sampler to our array, and add it to the textures bind group only if used in the shaders (avoid binding useless data)\n   * @param sampler - sampler to add\n   */\n  addSampler(sampler: Sampler) {\n    this.samplers.push(sampler)\n\n    // is it used in our shaders?\n    if (\n      (this.options.shaders.vertex && this.options.shaders.vertex.code.indexOf(sampler.name) !== -1) ||\n      (this.options.shaders.fragment &&\n        (this.options.shaders.fragment as ShaderOptions).code.indexOf(sampler.name) !== -1) ||\n      (this.options.shaders.compute && this.options.shaders.compute.code.indexOf(sampler.name) !== -1)\n    ) {\n      this.texturesBindGroup.addSampler(sampler)\n    }\n  }\n\n  /* BUFFER RESULTS */\n\n  /**\n   * Map a {@link GPUBuffer} and put a copy of the data into a {@link Float32Array}\n   * @param buffer - {@link GPUBuffer} to map\n   * @async\n   * @returns - {@link Float32Array} holding the {@link GPUBuffer} data\n   */\n  async getBufferResult(buffer: GPUBuffer): Promise<Float32Array> {\n    await buffer.mapAsync(GPUMapMode.READ)\n    const result = new Float32Array(buffer.getMappedRange().slice(0))\n    buffer.unmap()\n\n    return result\n  }\n\n  /**\n   * Map the content of a {@link BufferBinding#buffer | GPU buffer} and put a copy of the data into a {@link Float32Array}\n   * @param bindingName - The name of the {@link inputsBindings | input bindings} from which to map the {@link BufferBinding#buffer | GPU buffer}\n   * @async\n   * @returns - {@link Float32Array} holding the {@link GPUBuffer} data\n   */\n  async getBufferBindingResultByBindingName(bindingName: Binding['name'] = ''): Promise<Float32Array> {\n    const binding = this.getBufferBindingByName(bindingName)\n    if (binding && 'buffer' in binding) {\n      const dstBuffer = this.renderer.copyBufferToBuffer({\n        srcBuffer: binding.buffer,\n      })\n      return await this.getBufferResult(dstBuffer)\n    } else {\n      return new Float32Array(0)\n    }\n  }\n\n  /**\n   * Map the content of a specific {@link BufferElement | buffer element} belonging to a {@link BufferBinding#buffer | GPU buffer} and put a copy of the data into a {@link Float32Array}\n   * @param parameters - parameters used to get the result\n   * @param parameters.bindingName - The name of the {@link inputsBindings | input bindings} from which to map the {@link BufferBinding#buffer | GPU buffer}\n   * @param parameters.bufferElementName - The name of the {@link BufferElement | buffer element} from which to extract the data afterwards\n   * @returns - {@link Float32Array} holding {@link GPUBuffer} data\n   */\n  async getBufferElementResultByNames({\n    bindingName,\n    bufferElementName,\n  }: {\n    bindingName: Binding['name']\n    bufferElementName: BufferElement['name']\n  }): Promise<Float32Array> {\n    const result = await this.getBufferBindingResultByBindingName(bindingName)\n\n    if (!bufferElementName || result.length) {\n      return result\n    } else {\n      const binding = this.getBufferBindingByName(bindingName)\n      if (binding) {\n        return binding.extractBufferElementDataFromBufferResult({ result, bufferElementName })\n      } else {\n        return result\n      }\n    }\n  }\n\n  /* RENDER */\n\n  /**\n   * Called before rendering the Material.\n   * First, check if we need to create our bind groups or pipeline\n   * Then render the {@link textures}\n   * Finally updates all the {@link bindGroups | bind groups}\n   */\n  onBeforeRender() {\n    // set our material if needed\n    this.compileMaterial()\n\n    // first what needs to be done for all textures\n    this.textures.forEach((texture) => {\n      texture.render()\n    })\n\n    // update bind groups\n    this.updateBindGroups()\n  }\n\n  /**\n   * Set the current pipeline\n   * @param pass - current pass encoder\n   */\n  setPipeline(pass: GPURenderPassEncoder | GPUComputePassEncoder) {\n    this.renderer.pipelineManager.setCurrentPipeline(pass, this.pipelineEntry)\n  }\n\n  /**\n   * Render the material if it is ready:\n   * Set the current pipeline and set the bind groups\n   * @param pass - current pass encoder\n   */\n  render(pass: GPURenderPassEncoder | GPUComputePassEncoder) {\n    // renderer or pipeline are not ready yet\n    // not really needed since meshes/compute passes do already check it beforehand\n    // mostly here as a safeguard\n    if (!this.ready) return\n\n    // set current pipeline\n    this.setPipeline(pass)\n\n    // set bind groups\n    this.bindGroups.forEach((bindGroup) => {\n      pass.setBindGroup(bindGroup.index, bindGroup.bindGroup)\n    })\n  }\n\n  /**\n   * Destroy the Material\n   */\n  destroy() {\n    // destroy all buffers created with createBuffer\n    this.destroyBindGroups()\n    this.destroyTextures()\n  }\n}\n"],"names":[],"mappings":"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"}