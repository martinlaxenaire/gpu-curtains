{"version":3,"file":"TextureBindGroup.mjs","sources":["../../../../src/core/bindGroups/TextureBindGroup.ts"],"sourcesContent":["import { BindGroup } from './BindGroup'\nimport { isRenderer, Renderer } from '../renderers/utils'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\nimport { Texture } from '../textures/Texture'\nimport { Sampler } from '../samplers/Sampler'\nimport { BindGroupParams } from '../../types/BindGroups'\nimport { MaterialTexture } from '../../types/Materials'\n\n/**\n * An object defining all possible {@link TextureBindGroup} class instancing parameters\n */\nexport interface TextureBindGroupParams extends BindGroupParams {\n  /** array of {@link MaterialTexture | textures} to add to a {@link TextureBindGroup} */\n  textures?: MaterialTexture[]\n  /** array of {@link Sampler} to add to a {@link TextureBindGroup} */\n  samplers?: Sampler[]\n}\n\n/**\n * Used to regroup all {@link types/BindGroups.BindGroupBindingElement | bindings} related to textures (texture, texture matrices buffers and samplers) into one single specific {@link BindGroup}.\n *\n * Also responsible for uploading video textures if needed.\n *\n * @example\n * ```javascript\n * // set our main GPUCurtains instance\n * const gpuCurtains = new GPUCurtains({\n *   container: '#canvas' // selector of our WebGPU canvas container\n * })\n *\n * // set the GPU device\n * // note this is asynchronous\n * await gpuCurtains.setDevice()\n *\n * // create a render texture\n * const renderTexture = new RenderTexture(gpuCurtains, {\n *   label: 'Input texture',\n *   name: 'inputTexture',\n * })\n *\n * // create a texture bind group using that render texture\n * const textureBindGroup = new TextureBindGroup(gpuCurtains, {\n *   label: 'My texture bind group',\n *   textures: [renderTexture],\n *   uniforms: {\n *     params: {\n *       struct: {\n *         opacity: {\n *           type: 'f32',\n *           value: 1,\n *         },\n *         mousePosition: {\n *           type: 'vec2f',\n *           value: new Vec2(),\n *         },\n *       },\n *     },\n *   },\n * })\n *\n * // create the GPU buffer, bindGroupLayout and bindGroup\n * textureBindGroup.createBindGroup()\n * ```\n */\nexport class TextureBindGroup extends BindGroup {\n  /**\n   * TextureBindGroup constructor\n   * @param  renderer - a {@link Renderer} class object or a {@link GPUCurtains} class object\n   * @param parameters - {@link TextureBindGroupParams | parameters} used to create our {@link TextureBindGroup}\n   */\n  constructor(\n    renderer: Renderer | GPUCurtains,\n    { label, index = 0, bindings = [], uniforms, storages, textures = [], samplers = [] }: TextureBindGroupParams = {}\n  ) {\n    const type = 'TextureBindGroup'\n\n    // we could pass our curtains object OR our curtains renderer object\n    renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as Renderer)\n\n    isRenderer(renderer, type)\n\n    super(renderer, { label, index, bindings, uniforms, storages })\n\n    this.options = {\n      ...this.options,\n      // will be filled after\n      textures: [],\n      samplers: [],\n    }\n\n    // add initial textures if any\n    if (textures.length) {\n      textures.forEach((texture) => this.addTexture(texture))\n    }\n\n    // add initial samplers if any\n    if (samplers.length) {\n      samplers.forEach((sampler) => this.addSampler(sampler))\n    }\n\n    this.type = type\n  }\n\n  /**\n   * Adds a texture to the textures array and the struct\n   * @param texture - texture to add\n   */\n  addTexture(texture: MaterialTexture) {\n    this.textures.push(texture)\n    this.addBindings([...texture.bindings])\n  }\n\n  /**\n   * Get the current textures array\n   * @readonly\n   */\n  get textures(): MaterialTexture[] {\n    return this.options.textures\n  }\n\n  /**\n   * Adds a sampler to the samplers array and the struct\n   * @param sampler\n   */\n  addSampler(sampler: Sampler) {\n    this.samplers.push(sampler)\n    this.addBindings([sampler.binding])\n  }\n\n  /**\n   * Get the current samplers array\n   * @readonly\n   */\n  get samplers(): Sampler[] {\n    return this.options.samplers\n  }\n\n  /**\n   * Get whether the GPU bind group is ready to be created\n   * It can be created if it has {@link BindGroup#bindings} and has not been created yet and all GPU textures and samplers are created\n   * @readonly\n   */\n  get shouldCreateBindGroup(): boolean {\n    return (\n      !this.bindGroup &&\n      !!this.bindings.length &&\n      !this.textures.find((texture) => !(texture.texture || (texture as Texture).externalTexture)) &&\n      !this.samplers.find((sampler) => !sampler.sampler)\n    )\n  }\n\n  /**\n   * Update the {@link TextureBindGroup#textures | bind group textures}:\n   * - Check if they need to copy their source texture\n   * - Upload video texture if needed\n   */\n  updateTextures() {\n    this.textures.forEach((texture) => {\n      // copy textures that need it on first init, but only when original texture is ready\n      if (texture instanceof Texture) {\n        if (texture.options.fromTexture && texture.options.fromTexture.sourceUploaded && !texture.sourceUploaded) {\n          texture.copy(texture.options.fromTexture)\n        }\n\n        if (texture.shouldUpdate && texture.options.sourceType && texture.options.sourceType === 'externalVideo') {\n          texture.uploadVideoTexture()\n        }\n      }\n    })\n  }\n\n  /**\n   * Update the {@link TextureBindGroup}, which means update its {@link TextureBindGroup#textures | textures}, then update its {@link TextureBindGroup#bufferBindings | buffer bindings} and finally {@link TextureBindGroup#resetBindGroup | reset it} if needed\n   */\n  update() {\n    this.updateTextures()\n    super.update()\n  }\n\n  /**\n   * Destroy our {@link TextureBindGroup}\n   */\n  destroy() {\n    super.destroy()\n    this.options.textures = []\n    this.options.samplers = []\n  }\n}\n"],"names":[],"mappings":";;;;AAgEO,MAAM,yBAAyB,SAAU,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAM9C,YACE,QACA,EAAA,EAAE,OAAO,KAAQ,GAAA,CAAA,EAAG,WAAW,EAAC,EAAG,UAAU,QAAU,EAAA,QAAA,GAAW,EAAI,EAAA,QAAA,GAAW,EAAG,EAAA,GAA4B,EAChH,EAAA;AACA,IAAA,MAAM,IAAO,GAAA,kBAAA,CAAA;AAGb,IAAY,QAAA,GAAA,QAAA,IAAa,SAAyB,QAAc,IAAA,QAAA,CAAA;AAEhE,IAAA,UAAA,CAAW,UAAU,IAAI,CAAA,CAAA;AAEzB,IAAA,KAAA,CAAM,UAAU,EAAE,KAAA,EAAO,OAAO,QAAU,EAAA,QAAA,EAAU,UAAU,CAAA,CAAA;AAE9D,IAAA,IAAA,CAAK,OAAU,GAAA;AAAA,MACb,GAAG,IAAK,CAAA,OAAA;AAAA;AAAA,MAER,UAAU,EAAC;AAAA,MACX,UAAU,EAAC;AAAA,KACb,CAAA;AAGA,IAAA,IAAI,SAAS,MAAQ,EAAA;AACnB,MAAA,QAAA,CAAS,QAAQ,CAAC,OAAA,KAAY,IAAK,CAAA,UAAA,CAAW,OAAO,CAAC,CAAA,CAAA;AAAA,KACxD;AAGA,IAAA,IAAI,SAAS,MAAQ,EAAA;AACnB,MAAA,QAAA,CAAS,QAAQ,CAAC,OAAA,KAAY,IAAK,CAAA,UAAA,CAAW,OAAO,CAAC,CAAA,CAAA;AAAA,KACxD;AAEA,IAAA,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;AAAA,GACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAW,OAA0B,EAAA;AACnC,IAAK,IAAA,CAAA,QAAA,CAAS,KAAK,OAAO,CAAA,CAAA;AAC1B,IAAA,IAAA,CAAK,WAAY,CAAA,CAAC,GAAG,OAAA,CAAQ,QAAQ,CAAC,CAAA,CAAA;AAAA,GACxC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,QAA8B,GAAA;AAChC,IAAA,OAAO,KAAK,OAAQ,CAAA,QAAA,CAAA;AAAA,GACtB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAW,OAAkB,EAAA;AAC3B,IAAK,IAAA,CAAA,QAAA,CAAS,KAAK,OAAO,CAAA,CAAA;AAC1B,IAAA,IAAA,CAAK,WAAY,CAAA,CAAC,OAAQ,CAAA,OAAO,CAAC,CAAA,CAAA;AAAA,GACpC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,QAAsB,GAAA;AACxB,IAAA,OAAO,KAAK,OAAQ,CAAA,QAAA,CAAA;AAAA,GACtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,qBAAiC,GAAA;AACnC,IAAA,OACE,CAAC,IAAA,CAAK,SACN,IAAA,CAAC,CAAC,IAAA,CAAK,QAAS,CAAA,MAAA,IAChB,CAAC,IAAA,CAAK,QAAS,CAAA,IAAA,CAAK,CAAC,OAAA,KAAY,EAAE,OAAA,CAAQ,OAAY,IAAA,OAAA,CAAoB,eAAgB,CAAA,CAAA,IAC3F,CAAC,IAAA,CAAK,QAAS,CAAA,IAAA,CAAK,CAAC,OAAA,KAAY,CAAC,OAAA,CAAQ,OAAO,CAAA,CAAA;AAAA,GAErD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAiB,GAAA;AACf,IAAK,IAAA,CAAA,QAAA,CAAS,OAAQ,CAAA,CAAC,OAAY,KAAA;AAEjC,MAAA,IAAI,mBAAmB,OAAS,EAAA;AAC9B,QAAI,IAAA,OAAA,CAAQ,QAAQ,WAAe,IAAA,OAAA,CAAQ,QAAQ,WAAY,CAAA,cAAA,IAAkB,CAAC,OAAA,CAAQ,cAAgB,EAAA;AACxG,UAAQ,OAAA,CAAA,IAAA,CAAK,OAAQ,CAAA,OAAA,CAAQ,WAAW,CAAA,CAAA;AAAA,SAC1C;AAEA,QAAI,IAAA,OAAA,CAAQ,gBAAgB,OAAQ,CAAA,OAAA,CAAQ,cAAc,OAAQ,CAAA,OAAA,CAAQ,eAAe,eAAiB,EAAA;AACxG,UAAA,OAAA,CAAQ,kBAAmB,EAAA,CAAA;AAAA,SAC7B;AAAA,OACF;AAAA,KACD,CAAA,CAAA;AAAA,GACH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAS,GAAA;AACP,IAAA,IAAA,CAAK,cAAe,EAAA,CAAA;AACpB,IAAA,KAAA,CAAM,MAAO,EAAA,CAAA;AAAA,GACf;AAAA;AAAA;AAAA;AAAA,EAKA,OAAU,GAAA;AACR,IAAA,KAAA,CAAM,OAAQ,EAAA,CAAA;AACd,IAAK,IAAA,CAAA,OAAA,CAAQ,WAAW,EAAC,CAAA;AACzB,IAAK,IAAA,CAAA,OAAA,CAAQ,WAAW,EAAC,CAAA;AAAA,GAC3B;AACF;;;;"}