{"version":3,"file":"BindGroup.mjs","sources":["../../../../src/core/bindGroups/BindGroup.ts"],"sourcesContent":["import { isRenderer, Renderer } from '../renderers/utils'\r\nimport { generateUUID, toKebabCase } from '../../utils/utils'\r\nimport { WritableBufferBinding, WritableBufferBindingParams } from '../bindings/WritableBufferBinding'\r\nimport { BufferBinding } from '../bindings/BufferBinding'\r\nimport {\r\n  AllowedBindGroups,\r\n  BindGroupBindingElement,\r\n  BindGroupBufferBindingElement,\r\n  BindGroupEntries,\r\n  BindGroupParams,\r\n  ReadOnlyInputBindings,\r\n} from '../../types/BindGroups'\r\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\r\nimport { TextureBindGroupParams } from './TextureBindGroup'\r\nimport { BindingType } from '../bindings/Binding'\r\n\r\n/**\r\n * Used to handle all inputs data sent to the GPU.<br>\r\n * In WebGPU, data (buffers, textures or samplers, called bindings) are organised by bind groups, containing those bindings.\r\n *\r\n * ## Bindings\r\n *\r\n * A {@link BindGroup} is responsible for creating each {@link BufferBinding} {@link GPUBuffer} and then the {@link GPUBindGroup} and {@link GPUBindGroupLayout} that are used to create {@link GPUComputePipeline} or {@link GPURenderPipeline}.<br>\r\n * Those are generally automatically created by the {@link core/materials/Material.Material | Material} using this {@link BindGroup}. If you need to manually create them, you will have to call its {@link BindGroup#createBindGroup | `createBindGroup()` method}\r\n *\r\n * ### Samplers and textures\r\n *\r\n * A {@link BindGroup} is best suited to handle {@link GPUBuffer} only bindings. If you need to handle {@link GPUSampler}, a {@link GPUTexture} or a {@link GPUExternalTexture}, you should use a {@link core/bindGroups/TextureBindGroup.TextureBindGroup | TextureBindGroup} instead.\r\n *\r\n * ### Updating a GPUBindGroup or GPUBindGroupLayout\r\n *\r\n * Each time one of the {@link https://developer.mozilla.org/en-US/docs/Web/API/GPUDevice/createBindGroup#resource | binding resource} changes, its {@link BindGroup#bindGroup | bindGroup} will be recreated (usually, when a {@link GPUTexture} is uploaded).<br>\r\n * Each time one of the {@link https://developer.mozilla.org/en-US/docs/Web/API/GPUDevice/createBindGroupLayout#resource_layout_objects | binding resource layout} changes, its {@link BindGroup#bindGroupLayout | bindGroupLayout} and {@link BindGroup#bindGroup | bindGroup} will be recreated, and the {@link GPUComputePipeline} or {@link GPURenderPipeline} will be recreated as well.\r\n *\r\n * @example\r\n * ```javascript\r\n * // set our main GPUCurtains instance\r\n * const gpuCurtains = new GPUCurtains({\r\n *   container: '#canvas' // selector of our WebGPU canvas container\r\n * })\r\n *\r\n * // set the GPU device\r\n * // note this is asynchronous\r\n * await gpuCurtains.setDevice()\r\n *\r\n * const bindGroup = new BindGroup(gpuCurtains, {\r\n *   label: 'My bind group',\r\n *   uniforms: {\r\n *     params: {\r\n *       struct: {\r\n *         opacity: {\r\n *           type: 'f32',\r\n *           value: 1,\r\n *         },\r\n *         mousePosition: {\r\n *           type: 'vec2f',\r\n *           value: new Vec2(),\r\n *         },\r\n *       },\r\n *     },\r\n *   },\r\n * })\r\n *\r\n * // create the GPU buffer, bindGroupLayout and bindGroup\r\n * bindGroup.createBindGroup()\r\n * ```\r\n */\r\nexport class BindGroup {\r\n  /** The type of the {@link BindGroup} */\r\n  type: string\r\n  /** The universal unique id of the {@link BindGroup} */\r\n  uuid: string\r\n  /** The {@link Renderer} used */\r\n  renderer: Renderer\r\n  /** Options used to create this {@link BindGroup} */\r\n  options: TextureBindGroupParams\r\n  /** Index of this {@link BindGroup}, used to link struct in the shaders */\r\n  index: number\r\n\r\n  /** List of {@link BindGroupBindingElement | bindings} (buffers, texture, etc.) handled by this {@link BindGroup} */\r\n  bindings: BindGroupBindingElement[]\r\n\r\n  /** Our {@link BindGroup} {@link BindGroupEntries | entries} objects */\r\n  entries: BindGroupEntries\r\n\r\n  /** Our {@link BindGroup}{@link GPUBindGroupLayout} */\r\n  bindGroupLayout: null | GPUBindGroupLayout\r\n  /** Our {@link BindGroup} {@link GPUBindGroup} */\r\n  bindGroup: null | GPUBindGroup\r\n\r\n  /** Flag indicating whether we need to flush and recreate the pipeline using this {@link BindGroup} s*/\r\n  needsPipelineFlush: boolean\r\n\r\n  /**\r\n   * BindGroup constructor\r\n   * @param renderer - a {@link Renderer} class object or a {@link GPUCurtains} class object\r\n   * @param parameters - {@link BindGroupParams | parameters} used to create our {@link BindGroup}\r\n   */\r\n  constructor(\r\n    renderer: Renderer | GPUCurtains,\r\n    { label = 'BindGroup', index = 0, bindings = [], uniforms, storages }: BindGroupParams = {}\r\n  ) {\r\n    this.type = 'BindGroup'\r\n\r\n    // we could pass our curtains object OR our curtains renderer object\r\n    renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as Renderer)\r\n\r\n    isRenderer(renderer, this.type)\r\n\r\n    this.renderer = renderer\r\n    this.options = {\r\n      label,\r\n      index,\r\n      bindings,\r\n      ...(uniforms && { uniforms }),\r\n      ...(storages && { storages }),\r\n    }\r\n\r\n    this.index = index\r\n    this.uuid = generateUUID()\r\n\r\n    this.bindings = []\r\n    bindings.length && this.addBindings(bindings)\r\n    if (this.options.uniforms || this.options.storages) this.setInputBindings()\r\n\r\n    this.resetEntries()\r\n\r\n    this.bindGroupLayout = null\r\n    this.bindGroup = null\r\n\r\n    // if we ever update our bind group layout\r\n    // we will have to recreate the whole pipeline again\r\n    this.needsPipelineFlush = false\r\n\r\n    this.renderer.addBindGroup(this)\r\n  }\r\n\r\n  /**\r\n   * Sets our {@link BindGroup#index | bind group index}\r\n   * @param index - {@link BindGroup#index | bind group index} to set\r\n   */\r\n  setIndex(index: number) {\r\n    this.index = index\r\n  }\r\n\r\n  /**\r\n   * Adds an array of already created {@link bindings} (buffers, texture, etc.) to the {@link bindings} array\r\n   * @param bindings - {@link bindings} to add\r\n   */\r\n  addBindings(bindings: BindGroupBindingElement[] = []) {\r\n    this.bindings = [...this.bindings, ...bindings]\r\n  }\r\n\r\n  /**\r\n   * Adds an already created {@link bindings} (buffers, texture, etc.) to the {@link bindings} array\r\n   * @param binding - binding to add\r\n   */\r\n  addBinding(binding: BindGroupBindingElement) {\r\n    this.bindings.push(binding)\r\n  }\r\n\r\n  /**\r\n   * Creates Bindings based on a list of inputs\r\n   * @param bindingType - {@link core/bindings/Binding.Binding#bindingType | binding type}\r\n   * @param inputs - {@link ReadOnlyInputBindings | inputs (uniform or storage)} that will be used to create the binding\r\n   * @returns - a {@link bindings} array\r\n   */\r\n  createInputBindings(\r\n    bindingType: BindingType = 'uniform',\r\n    inputs: ReadOnlyInputBindings = {}\r\n  ): BindGroupBindingElement[] {\r\n    return [\r\n      ...Object.keys(inputs).map((inputKey) => {\r\n        const binding = inputs[inputKey] as WritableBufferBindingParams\r\n\r\n        const bindingParams: WritableBufferBindingParams = {\r\n          label: toKebabCase(binding.label || inputKey),\r\n          name: inputKey,\r\n          bindingType,\r\n          useStruct: true, // by default\r\n          visibility: binding.access === 'read_write' ? 'compute' : binding.visibility,\r\n          access: binding.access ?? 'read', // read by default\r\n          struct: binding.struct,\r\n          ...(binding.shouldCopyResult !== undefined && { shouldCopyResult: binding.shouldCopyResult }),\r\n        }\r\n\r\n        const BufferBindingConstructor = bindingParams.access === 'read_write' ? WritableBufferBinding : BufferBinding\r\n\r\n        return binding.useStruct !== false\r\n          ? new BufferBindingConstructor(bindingParams)\r\n          : Object.keys(binding.struct).map((bindingKey) => {\r\n              bindingParams.label = toKebabCase(binding.label ? binding.label + bindingKey : inputKey + bindingKey)\r\n              bindingParams.name = inputKey + bindingKey\r\n              bindingParams.useStruct = false\r\n              bindingParams.struct = { [bindingKey]: binding.struct[bindingKey] }\r\n\r\n              return new BufferBindingConstructor(bindingParams)\r\n            })\r\n      }),\r\n    ].flat()\r\n  }\r\n\r\n  /**\r\n   * Create and adds {@link bindings} based on inputs provided upon creation\r\n   */\r\n  setInputBindings() {\r\n    this.addBindings([\r\n      ...this.createInputBindings('uniform', this.options.uniforms),\r\n      ...this.createInputBindings('storage', this.options.storages),\r\n    ])\r\n  }\r\n\r\n  /**\r\n   * Get whether the GPU bind group is ready to be created\r\n   * It can be created if it has {@link bindings} and has not been created yet\r\n   * @readonly\r\n   */\r\n  get shouldCreateBindGroup(): boolean {\r\n    return !this.bindGroup && !!this.bindings.length\r\n  }\r\n\r\n  /**\r\n   * Reset our {@link BindGroup} {@link entries}\r\n   */\r\n  resetEntries() {\r\n    this.entries = {\r\n      bindGroupLayout: [],\r\n      bindGroup: [],\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create the GPU buffers, {@link bindings}, {@link entries}, {@link bindGroupLayout} and {@link bindGroup}\r\n   */\r\n  createBindGroup() {\r\n    this.fillEntries()\r\n    this.setBindGroupLayout()\r\n    this.setBindGroup()\r\n  }\r\n\r\n  /**\r\n   * Reset the {@link BindGroup#entries.bindGroup | bindGroup entries}, recreates them and then recreate the {@link BindGroup#bindGroup | GPU bind group}\r\n   */\r\n  resetBindGroup() {\r\n    this.entries.bindGroup = []\r\n    this.bindings.forEach((binding) => {\r\n      this.entries.bindGroup.push({\r\n        binding: this.entries.bindGroup.length,\r\n        resource: binding.resource,\r\n      })\r\n    })\r\n\r\n    this.setBindGroup()\r\n  }\r\n\r\n  /**\r\n   * Reset the {@link BindGroup#entries.bindGroupLayout | bindGroupLayout entries}, recreates them and then recreate the {@link BindGroup#bindGroupLayout | GPU bind group layout}\r\n   */\r\n  resetBindGroupLayout() {\r\n    this.entries.bindGroupLayout = []\r\n    this.bindings.forEach((binding) => {\r\n      this.entries.bindGroupLayout.push({\r\n        binding: this.entries.bindGroupLayout.length,\r\n        ...binding.resourceLayout,\r\n        visibility: binding.visibility,\r\n      })\r\n    })\r\n\r\n    this.setBindGroupLayout()\r\n  }\r\n\r\n  /**\r\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been lost to prepare everything for restoration\r\n   */\r\n  loseContext() {\r\n    this.resetEntries()\r\n\r\n    this.bufferBindings.forEach((binding) => {\r\n      binding.buffer = null\r\n\r\n      if ('resultBuffer' in binding) {\r\n        binding.resultBuffer = null\r\n      }\r\n    })\r\n\r\n    this.bindGroup = null\r\n    this.bindGroupLayout = null\r\n    this.needsPipelineFlush = true\r\n  }\r\n\r\n  /**\r\n   * Get all {@link BindGroup#bindings | bind group bindings} that handle a {@link GPUBuffer}\r\n   */\r\n  get bufferBindings(): BindGroupBufferBindingElement[] {\r\n    return this.bindings.filter(\r\n      (binding) => binding instanceof BufferBinding || binding instanceof WritableBufferBinding\r\n    ) as BindGroupBufferBindingElement[]\r\n  }\r\n\r\n  /**\r\n   * Creates binding GPUBuffer with correct params\r\n   * @param binding - the binding element\r\n   */\r\n  createBindingBuffer(binding: BindGroupBufferBindingElement) {\r\n    // TODO user defined usage?\r\n    // [Kangz](https://github.com/Kangz) said:\r\n    // \"In general though COPY_SRC/DST is free (at least in Dawn / Chrome because we add it all the time for our own purpose).\"\r\n    binding.buffer = this.renderer.createBuffer({\r\n      label: this.options.label + ': ' + binding.bindingType + ' buffer from: ' + binding.label,\r\n      size: binding.arrayBuffer.byteLength,\r\n      usage:\r\n        binding.bindingType === 'uniform'\r\n          ? GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC | GPUBufferUsage.VERTEX\r\n          : GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC | GPUBufferUsage.VERTEX,\r\n    })\r\n\r\n    if ('resultBuffer' in binding) {\r\n      binding.resultBuffer = this.renderer.createBuffer({\r\n        label: this.options.label + ': Result buffer from: ' + binding.label,\r\n        size: binding.arrayBuffer.byteLength,\r\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fill in our entries bindGroupLayout and bindGroup arrays with the correct binding resources.\r\n   * For buffer struct, create a GPUBuffer first if needed\r\n   */\r\n  fillEntries() {\r\n    this.bindings.forEach((binding) => {\r\n      // if no visibility specified, just set it to the maximum default capabilities\r\n      if (!binding.visibility) {\r\n        binding.visibility = GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE\r\n      }\r\n\r\n      // if it's a buffer binding, create the GPUBuffer\r\n      if ('buffer' in binding && !binding.buffer) {\r\n        this.createBindingBuffer(binding)\r\n      }\r\n\r\n      // now that everything is ready, fill our entries\r\n      this.entries.bindGroupLayout.push({\r\n        binding: this.entries.bindGroupLayout.length,\r\n        ...binding.resourceLayout,\r\n        visibility: binding.visibility,\r\n      })\r\n\r\n      this.entries.bindGroup.push({\r\n        binding: this.entries.bindGroup.length,\r\n        resource: binding.resource,\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Get a bind group binding by name/key\r\n   * @param bindingName - the binding name or key\r\n   * @returns - the found binding, or null if not found\r\n   */\r\n  getBindingByName(bindingName = ''): BindGroupBindingElement | null {\r\n    return this.bindings.find((binding) => binding.name === bindingName)\r\n  }\r\n\r\n  /**\r\n   * Create a GPUBindGroupLayout and set our {@link bindGroupLayout}\r\n   */\r\n  setBindGroupLayout() {\r\n    this.bindGroupLayout = this.renderer.createBindGroupLayout({\r\n      label: this.options.label + ' layout',\r\n      entries: this.entries.bindGroupLayout,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Create a GPUBindGroup and set our {@link bindGroup}\r\n   */\r\n  setBindGroup() {\r\n    this.bindGroup = this.renderer.createBindGroup({\r\n      label: this.options.label,\r\n      layout: this.bindGroupLayout,\r\n      entries: this.entries.bindGroup,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Check whether we should update (write) our {@link GPUBuffer} or not.\r\n   */\r\n  updateBufferBindings() {\r\n    this.bufferBindings.forEach((binding, index) => {\r\n      // update binding elements\r\n      binding.update()\r\n\r\n      // now write to the GPUBuffer if needed\r\n      if (binding.shouldUpdate) {\r\n        // bufferOffset is always equals to 0 in our case\r\n        if (!binding.useStruct && binding.bufferElements.length > 1) {\r\n          // we're in a non struct buffer binding with multiple entries\r\n          // that should not happen but that way we're covered\r\n          this.renderer.queueWriteBuffer(binding.buffer, 0, binding.bufferElements[index].view)\r\n        } else {\r\n          this.renderer.queueWriteBuffer(binding.buffer, 0, binding.arrayBuffer)\r\n        }\r\n      }\r\n\r\n      // reset update flag\r\n      binding.shouldUpdate = false\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Update the {@link BindGroup}, which means update its {@link BindGroup#bufferBindings | buffer bindings} and {@link BindGroup#resetBindGroup | reset it} if needed.\r\n   * Called at each render from the parentMesh {@link core/materials/Material.Material | material}\r\n   */\r\n  update() {\r\n    this.updateBufferBindings()\r\n\r\n    const needBindGroupReset = this.bindings.some((binding) => binding.shouldResetBindGroup)\r\n    const needBindGroupLayoutReset = this.bindings.some((binding) => binding.shouldResetBindGroupLayout)\r\n\r\n    // since other bind groups might be using that binding\r\n    // wait for the end of the render loop to reset the bindings flags\r\n    if (needBindGroupReset || needBindGroupLayoutReset) {\r\n      this.renderer.onAfterCommandEncoderSubmission.add(\r\n        () => {\r\n          this.bindings.forEach((binding) => {\r\n            binding.shouldResetBindGroup = false\r\n            binding.shouldResetBindGroupLayout = false\r\n          })\r\n        },\r\n        { once: true }\r\n      )\r\n    }\r\n\r\n    if (needBindGroupLayoutReset) {\r\n      this.resetBindGroupLayout()\r\n      // bind group layout has changed, we have to recreate the pipeline\r\n      this.needsPipelineFlush = true\r\n    }\r\n\r\n    if (needBindGroupReset) {\r\n      this.resetBindGroup()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clones a {@link BindGroup} from a list of {@link bindings}\r\n   * Useful to create a new bind group with already created buffers, but swapped\r\n   * @param parameters - parameters to use for cloning\r\n   * @param parameters.bindings - our input {@link bindings}\r\n   * @param [parameters.keepLayout=false] - whether we should keep original {@link bindGroupLayout} or not\r\n   * @returns - the cloned {@link BindGroup}\r\n   */\r\n  clone({\r\n    bindings = [],\r\n    keepLayout = false,\r\n  }: {\r\n    bindings?: BindGroupBindingElement[]\r\n    keepLayout?: boolean\r\n  } = {}): AllowedBindGroups {\r\n    const params = { ...this.options }\r\n    params.label += ' (copy)'\r\n\r\n    const bindGroupCopy = new (this.constructor as typeof BindGroup)(this.renderer, {\r\n      label: params.label,\r\n    })\r\n\r\n    bindGroupCopy.setIndex(this.index)\r\n    bindGroupCopy.options = params\r\n\r\n    const bindingsRef = bindings.length ? bindings : this.bindings\r\n\r\n    bindingsRef.forEach((binding, index) => {\r\n      bindGroupCopy.addBinding(binding)\r\n\r\n      // if it's a buffer binding without a GPUBuffer, create it now\r\n      if ('buffer' in binding && !binding.buffer) {\r\n        bindGroupCopy.createBindingBuffer(binding)\r\n      }\r\n\r\n      // if we should create a new bind group layout, fill it\r\n      if (!keepLayout) {\r\n        bindGroupCopy.entries.bindGroupLayout.push({\r\n          binding: bindGroupCopy.entries.bindGroupLayout.length,\r\n          ...binding.resourceLayout,\r\n          visibility: binding.visibility,\r\n        })\r\n      }\r\n\r\n      bindGroupCopy.entries.bindGroup.push({\r\n        binding: bindGroupCopy.entries.bindGroup.length,\r\n        resource: binding.resource,\r\n      } as GPUBindGroupEntry)\r\n    })\r\n\r\n    // if we should copy the given bind group layout\r\n    if (keepLayout) {\r\n      bindGroupCopy.entries.bindGroupLayout = [...this.entries.bindGroupLayout]\r\n    }\r\n\r\n    bindGroupCopy.setBindGroupLayout()\r\n    bindGroupCopy.setBindGroup()\r\n\r\n    return bindGroupCopy\r\n  }\r\n\r\n  /**\r\n   * Destroy our {@link BindGroup}\r\n   * Most important is to destroy the GPUBuffers to free the memory\r\n   */\r\n  destroy() {\r\n    this.renderer.removeBindGroup(this)\r\n\r\n    this.bufferBindings.forEach((binding) => {\r\n      if ('buffer' in binding) {\r\n        this.renderer.removeBuffer(binding.buffer)\r\n        binding.buffer?.destroy()\r\n        binding.buffer = null\r\n      }\r\n\r\n      if ('resultBuffer' in binding) {\r\n        this.renderer.removeBuffer(binding.resultBuffer)\r\n        binding.resultBuffer?.destroy()\r\n        binding.resultBuffer = null\r\n      }\r\n    })\r\n\r\n    this.bindings = []\r\n    this.bindGroupLayout = null\r\n    this.bindGroup = null\r\n    this.resetEntries()\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}