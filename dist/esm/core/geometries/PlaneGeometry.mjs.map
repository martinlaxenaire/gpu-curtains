{"version":3,"file":"PlaneGeometry.mjs","sources":["../../../../src/core/geometries/PlaneGeometry.ts"],"sourcesContent":["import { IndexedGeometry } from './IndexedGeometry'\nimport { Geometry } from './Geometry'\nimport { GeometryBaseParams, VertexBufferAttributeParams } from '../../types/Geometries'\n\n/**\n * Parameters used to create a {@link PlaneGeometry}\n */\nexport interface PlaneGeometryParams extends GeometryBaseParams {\n  /** Number of segments along the X axis */\n  widthSegments?: number\n  /** Number of segments along the Y axis */\n  heightSegments?: number\n}\n\n/**\n * Used to create an indexed plane geometry based on the number of segments along the X and Y axis.\n *\n * This is how it will look for a 3x2 quad. Indexing will take care of drawing the right vertices in the right order.\n *\n * <pre>\n *  0---1---2---3\n *  |  /|  /|  /|\n *  |/  |/  |/  |\n *  4---5---6---7\n *  |  /|  /|  /|\n *  |/  |/  |/  |\n *  8---9---10--11\n * </pre>\n *\n * @example\n * ```javascript\n * const planeGeometry = new PlaneGeometry()\n * ```\n */\nexport class PlaneGeometry extends IndexedGeometry {\n  /**\n   * Defines our {@link PlaneGeometry} definition based on the provided {@link PlaneGeometryParams | parameters}\n   */\n  definition: {\n    /** unique id based on width and height segments, used to get {@link PlaneGeometry} from cache */\n    id: number\n    /** number of segments along the X axis */\n    width: number\n    /** number of segments along the Y axis */\n    height: number\n    /** total number of segments */\n    count: number\n  }\n\n  /**\n   * PlaneGeometry constructor\n   * @param parameters - {@link PlaneGeometryParams | parameters} used to create our PlaneGeometry\n   */\n  constructor({\n    widthSegments = 1,\n    heightSegments = 1,\n    instancesCount = 1,\n    vertexBuffers = [],\n    topology,\n  }: PlaneGeometryParams = {}) {\n    // plane geometries vertices are defined in the clockwise order\n    super({ verticesOrder: 'cw', topology, instancesCount, vertexBuffers })\n\n    this.type = 'PlaneGeometry'\n\n    widthSegments = Math.floor(widthSegments)\n    heightSegments = Math.floor(heightSegments)\n\n    // unique plane geometry id based on width and height\n    // used to get a geometry from cache\n    this.definition = {\n      id: widthSegments * heightSegments + widthSegments,\n      width: widthSegments,\n      height: heightSegments,\n      count: widthSegments * heightSegments,\n    }\n\n    const verticesCount = (this.definition.width + 1) * (this.definition.height + 1)\n    const attributes = this.getIndexedVerticesAndUVs(verticesCount)\n\n    Object.keys(attributes).forEach((attributeKey) => {\n      this.setAttribute(attributes[attributeKey] as VertexBufferAttributeParams)\n    })\n\n    this.setIndexArray()\n  }\n\n  /**\n   * Set our PlaneGeometry index array\n   */\n  setIndexArray() {\n    const indexArray = this.useUint16IndexArray\n      ? new Uint16Array(this.definition.count * 6)\n      : new Uint32Array(this.definition.count * 6)\n\n    let index = 0\n\n    for (let y = 0; y < this.definition.height; y++) {\n      for (let x = 0; x < this.definition.width; x++) {\n        indexArray[index++] = x + y * (this.definition.width + 1)\n        indexArray[index++] = this.definition.width + x + 1 + y * (this.definition.width + 1)\n        indexArray[index++] = x + 1 + y * (this.definition.width + 1)\n\n        indexArray[index++] = x + 1 + y * (this.definition.width + 1)\n        indexArray[index++] = this.definition.width + x + 1 + y * (this.definition.width + 1)\n        indexArray[index++] = this.definition.width + x + 2 + y * (this.definition.width + 1)\n      }\n    }\n\n    this.setIndexBuffer({\n      array: indexArray,\n      bufferFormat: this.useUint16IndexArray ? 'uint16' : 'uint32',\n    })\n  }\n\n  /**\n   * Compute the UV and position arrays based on our plane widthSegments and heightSegments values and return the corresponding attributes\n   * @param verticesCount - {@link Geometry#verticesCount | number of vertices} of our {@link PlaneGeometry}\n   * @returns - our position and uv {@link VertexBufferAttributeParams | attributes}\n   */\n  getIndexedVerticesAndUVs(verticesCount: Geometry['verticesCount']): Record<string, VertexBufferAttributeParams> {\n    // geometry vertices and UVs\n    const uv = {\n      name: 'uv',\n      type: 'vec2f',\n      bufferFormat: 'float32x2',\n      size: 2,\n      array: new Float32Array(verticesCount * 2),\n    }\n\n    const position = {\n      name: 'position',\n      type: 'vec3f',\n      bufferFormat: 'float32x3',\n      // nb of triangles * 3 vertices per triangle * 3 coordinates per triangle\n      size: 3,\n      array: new Float32Array(verticesCount * 3),\n    }\n\n    const normal = {\n      name: 'normal',\n      type: 'vec3f',\n      bufferFormat: 'float32x3',\n      // nb of triangles * 3 vertices per triangle * 3 coordinates per triangle\n      size: 3,\n      array: new Float32Array(verticesCount * 3),\n    }\n\n    let positionOffset = 0\n    let normalOffset = 0\n    let uvOffset = 0\n\n    // this is how it will look for a 3x2 quad\n    // indexing will take care of drawing the right vertices at the right time\n    // 0---1---2---3\n    // | //| //| //|\n    // |// |// |// |\n    // 4---5---6---7\n    // | //| //| //|\n    // |// |// |// |\n    // 8---9---10--11\n\n    for (let y = 0; y <= this.definition.height; y++) {\n      for (let x = 0; x <= this.definition.width; x++) {\n        // uv\n        uv.array[uvOffset++] = x / this.definition.width\n        uv.array[uvOffset++] = 1 - y / this.definition.height\n\n        // vertex position\n        position.array[positionOffset++] = (x * 2) / this.definition.width - 1\n        position.array[positionOffset++] = (y * 2) / this.definition.height - 1\n        position.array[positionOffset++] = 0\n\n        // normals are simple\n        normal.array[normalOffset++] = 0\n        normal.array[normalOffset++] = 0\n        normal.array[normalOffset++] = 1\n      }\n    }\n\n    return { position, uv, normal } as Record<string, VertexBufferAttributeParams>\n  }\n}\n"],"names":[],"mappings":"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"}