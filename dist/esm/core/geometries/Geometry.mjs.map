{"version":3,"file":"Geometry.mjs","sources":["../../../../src/core/geometries/Geometry.ts"],"sourcesContent":["import { Box3 } from '../../math/Box3'\nimport { throwError, throwWarning } from '../../utils/utils'\nimport {\n  GeometryOptions,\n  GeometryParams,\n  VertexBuffer,\n  VertexBufferAttribute,\n  VertexBufferAttributeParams,\n  VertexBufferParams\n} from '../../types/Geometries'\n\n/**\n * Used to create a {@link Geometry} from given parameters like instances count or geometry attributes (vertices, uvs, normals).<br>\n * Holds all attributes arrays, bounding box and create as WGSL code snippet for the vertex shader input attributes.\n *\n * During the {@link Geometry#render | render}, the {@link Geometry} is responsible for setting the {@link Geometry#vertexBuffers | vertexBuffers} and drawing the vertices.\n *\n * @example\n * ```javascript\n * const vertices = new Float32Array([\n *   // first triangle\n *    1,  1,  0,\n *    1, -1,  0,\n *   -1, -1,  0,\n *\n *   // second triangle\n *    1,  1,  0,\n *   -1, -1,  0,\n *   -1,  1,  0\n * ])\n *\n * // create a quad geometry made of 2 triangles\n * const geometry = new Geometry()\n *\n * geometry.setAttribute({\n *   name: 'position',\n *   type: 'vec3f',\n *   bufferFormat: 'float32x3',\n *   size: 3,\n *   bufferLength: vertices.length,\n *   array: vertices,\n * })\n * ```\n */\nexport class Geometry {\n  /** Number of vertices defined by this geometry */\n  verticesCount: number\n  /** Vertices order to be drawn by the {@link core/pipelines/RenderPipelineEntry.RenderPipelineEntry | render pipeline} */\n  verticesOrder: GPUFrontFace\n  /** {@link https://www.w3.org/TR/webgpu/#enumdef-gpuprimitivetopology | Topology} to use with this {@link Geometry}, i.e. whether to draw triangles or points */\n  topology: GPUPrimitiveTopology\n  /** Number of instances of this geometry to draw */\n  instancesCount: number\n  /** Array of {@link VertexBuffer | vertex buffers} to use with this geometry */\n  vertexBuffers: VertexBuffer[]\n  /** Options used to create this geometry */\n  options: GeometryOptions\n  /** The type of the geometry */\n  type: string\n\n  /** The bounding box of the geometry, i.e. two {@link math/Vec3.Vec3 | Vec3} defining the min and max positions to wrap this geometry in a cube */\n  boundingBox: Box3\n\n  /** A string to append to our shaders code describing the WGSL structure representing this geometry attributes */\n  wgslStructFragment: string\n\n  /**\n   * Geometry constructor\n   * @param parameters - {@link GeometryParams | parameters} used to create our Geometry\n   */\n  constructor({\n    verticesOrder = 'ccw',\n    topology = 'triangle-list',\n    instancesCount = 1,\n    vertexBuffers = [],\n  }: GeometryParams = {}) {\n    this.verticesCount = 0\n    this.verticesOrder = verticesOrder\n    this.topology = topology\n    this.instancesCount = instancesCount\n\n    this.boundingBox = new Box3()\n\n    this.type = 'Geometry'\n\n    this.vertexBuffers = []\n\n    // should contain our vertex position / uv data at least\n    this.addVertexBuffer({\n      name: 'attributes',\n    })\n\n    this.options = {\n      verticesOrder,\n      instancesCount,\n      vertexBuffers,\n      topology,\n    }\n\n    vertexBuffers.forEach((vertexBuffer) => {\n      this.addVertexBuffer({\n        stepMode: vertexBuffer.stepMode ?? 'vertex',\n        name: vertexBuffer.name,\n        attributes: vertexBuffer.attributes,\n      })\n    })\n  }\n\n  /**\n   * Get whether this Geometry is ready to compute, i.e. if its first vertex buffer array has not been created yet\n   * @readonly\n   */\n  get shouldCompute(): boolean {\n    return this.vertexBuffers.length && !this.vertexBuffers[0].array\n  }\n\n  /**\n   * Get whether this geometry is ready to draw, i.e. it has been computed and all its vertex buffers have been created\n   * @readonly\n   */\n  get ready(): boolean {\n    return !this.shouldCompute && !this.vertexBuffers.find((vertexBuffer) => !vertexBuffer.buffer)\n  }\n\n  /**\n   * Add a vertex buffer to our Geometry, set its attributes and return it\n   * @param parameters - vertex buffer {@link VertexBufferParams | parameters}\n   * @returns - newly created {@link VertexBuffer | vertex buffer}\n   */\n  addVertexBuffer({ stepMode = 'vertex', name, attributes = [] }: VertexBufferParams = {}): VertexBuffer {\n    const vertexBuffer = {\n      name: name ?? 'attributes' + this.vertexBuffers.length,\n      stepMode,\n      arrayStride: 0,\n      bufferLength: 0,\n      attributes: [],\n      buffer: null,\n    }\n\n    // set attributes right away if possible\n    attributes?.forEach((attribute) => {\n      this.setAttribute({\n        vertexBuffer,\n        ...attribute,\n      } as VertexBufferAttributeParams)\n    })\n\n    this.vertexBuffers.push(vertexBuffer)\n\n    return vertexBuffer\n  }\n\n  /**\n   * Get a vertex buffer by name\n   * @param name - our vertex buffer name\n   * @returns - found {@link VertexBuffer | vertex buffer} or null if not found\n   */\n  getVertexBufferByName(name = ''): VertexBuffer | null {\n    return this.vertexBuffers.find((vertexBuffer) => vertexBuffer.name === name)\n  }\n\n  /**\n   * Set a vertex buffer attribute\n   * @param parameters - attributes {@link VertexBufferAttributeParams | parameters}\n   */\n  setAttribute({\n    vertexBuffer = this.vertexBuffers[0],\n    name,\n    type = 'vec3f',\n    bufferFormat = 'float32x3',\n    size = 3,\n    array = new Float32Array(this.verticesCount * size),\n    verticesStride = 1,\n  }: VertexBufferAttributeParams) {\n    const attributes = vertexBuffer.attributes\n    const attributesLength = attributes.length\n\n    if (!name) name = 'geometryAttribute' + attributesLength\n\n    if (name === 'position' && (type !== 'vec3f' || bufferFormat !== 'float32x3' || size !== 3)) {\n      throwWarning(\n        `Geometry 'position' attribute must have this exact properties set:\\n\\ttype: 'vec3f',\\n\\tbufferFormat: 'float32x3',\\n\\tsize: 3`\n      )\n      type = 'vec3f'\n      bufferFormat = 'float32x3'\n      size = 3\n    }\n\n    const attributeCount = array.length / size\n\n    if (name === 'position') {\n      this.verticesCount = attributeCount\n    }\n\n    if (\n      vertexBuffer.stepMode === 'vertex' &&\n      this.verticesCount &&\n      this.verticesCount !== attributeCount * verticesStride\n    ) {\n      throwError(\n        `Geometry vertex attribute error. Attribute array of size ${size} must be of length: ${\n          this.verticesCount * size\n        }, current given: ${array.length}. (${this.verticesCount} vertices).`\n      )\n    } else if (vertexBuffer.stepMode === 'instance' && attributeCount !== this.instancesCount) {\n      throwError(\n        `Geometry instance attribute error. Attribute array of size ${size} must be of length: ${\n          this.instancesCount * size\n        }, current given: ${array.length}. (${this.instancesCount} instances).`\n      )\n    }\n\n    const attribute = {\n      name,\n      type,\n      bufferFormat,\n      size,\n      bufferLength: array.length,\n      offset: attributesLength\n        ? attributes.reduce((accumulator: number, currentValue) => {\n            return accumulator + currentValue.bufferLength\n          }, 0)\n        : 0,\n      bufferOffset: attributesLength\n        ? attributes[attributesLength - 1].bufferOffset + attributes[attributesLength - 1].size * 4\n        : 0,\n      array,\n      verticesStride: verticesStride,\n    }\n\n    vertexBuffer.bufferLength += attribute.bufferLength * verticesStride\n    vertexBuffer.arrayStride += attribute.size\n    vertexBuffer.attributes.push(attribute)\n  }\n\n  /**\n   * Get an attribute by name\n   * @param name - name of the attribute to find\n   * @returns - found {@link VertexBufferAttribute | attribute} or null if not found\n   */\n  getAttributeByName(name: string): VertexBufferAttribute | null {\n    let attribute\n    this.vertexBuffers.forEach((vertexBuffer) => {\n      attribute = vertexBuffer.attributes.find((attribute) => attribute.name === name)\n    })\n\n    return attribute\n  }\n\n  /**\n   * Compute a Geometry, which means iterate through all vertex buffers and create the attributes array that will be sent as buffers.\n   * Also compute the Geometry bounding box.\n   */\n  computeGeometry() {\n    if (!this.shouldCompute) return\n\n    this.vertexBuffers.forEach((vertexBuffer, index) => {\n      if (index === 0) {\n        const hasPositionAttribute = vertexBuffer.attributes.find(\n          (attribute) => attribute.name === 'position'\n        ) as VertexBufferAttribute | null\n\n        if (!hasPositionAttribute) {\n          throwError(`Geometry must have a 'position' attribute`)\n        }\n\n        if (\n          hasPositionAttribute.type !== 'vec3f' ||\n          hasPositionAttribute.bufferFormat !== 'float32x3' ||\n          hasPositionAttribute.size !== 3\n        ) {\n          throwWarning(\n            `Geometry 'position' attribute must have this exact properties set:\\n\\ttype: 'vec3f',\\n\\tbufferFormat: 'float32x3',\\n\\tsize: 3`\n          )\n          hasPositionAttribute.type = 'vec3f'\n          hasPositionAttribute.bufferFormat = 'float32x3'\n          hasPositionAttribute.size = 3\n        }\n      }\n\n      vertexBuffer.array = new Float32Array(vertexBuffer.bufferLength)\n\n      let currentIndex = 0\n      let attributeIndex = 0\n      for (let i = 0; i < vertexBuffer.bufferLength; i += vertexBuffer.arrayStride) {\n        for (let j = 0; j < vertexBuffer.attributes.length; j++) {\n          const { name, size, array, verticesStride } = vertexBuffer.attributes[j]\n\n          for (let s = 0; s < size; s++) {\n            const attributeValue = array[Math.floor(attributeIndex / verticesStride) * size + s]\n            vertexBuffer.array[currentIndex] = attributeValue\n\n            // compute bounding box\n            if (name === 'position') {\n              if (s % 3 === 0) {\n                // x\n                if (this.boundingBox.min.x > attributeValue) this.boundingBox.min.x = attributeValue\n                if (this.boundingBox.max.x < attributeValue) this.boundingBox.max.x = attributeValue\n              } else if (s % 3 === 1) {\n                // y\n                if (this.boundingBox.min.y > attributeValue) this.boundingBox.min.y = attributeValue\n                if (this.boundingBox.max.y < attributeValue) this.boundingBox.max.y = attributeValue\n              } else if (s % 3 === 2) {\n                // z\n                if (this.boundingBox.min.z > attributeValue) this.boundingBox.min.z = attributeValue\n                if (this.boundingBox.max.z < attributeValue) this.boundingBox.max.z = attributeValue\n              }\n            }\n\n            currentIndex++\n          }\n        }\n\n        attributeIndex++\n      }\n    })\n\n    this.#setWGSLFragment()\n  }\n\n  /**\n   * Set the WGSL code snippet that will be appended to the vertex shader.\n   * @private\n   */\n  #setWGSLFragment() {\n    let locationIndex = -1\n    this.wgslStructFragment = `struct Attributes {\\n\\t@builtin(vertex_index) vertexIndex : u32,\\n\\t@builtin(instance_index) instanceIndex : u32,${this.vertexBuffers\n      .map((vertexBuffer) => {\n        return vertexBuffer.attributes.map((attribute) => {\n          locationIndex++\n          return `\\n\\t@location(${locationIndex}) ${attribute.name}: ${attribute.type}`\n        })\n      })\n      .join(',')}\\n};`\n  }\n\n  /** RENDER **/\n\n  /**\n   * Set our render pass geometry vertex buffers\n   * @param pass - current render pass\n   */\n  setGeometryBuffers(pass: GPURenderPassEncoder) {\n    this.vertexBuffers.forEach((vertexBuffer, index) => {\n      pass.setVertexBuffer(index, vertexBuffer.buffer)\n    })\n  }\n\n  /**\n   * Draw our geometry\n   * @param pass - current render pass\n   */\n  drawGeometry(pass: GPURenderPassEncoder) {\n    pass.draw(this.verticesCount, this.instancesCount)\n  }\n\n  /**\n   * Set our vertex buffers then draw the geometry\n   * @param pass - current render pass\n   */\n  render(pass: GPURenderPassEncoder) {\n    if (!this.ready) return\n\n    this.setGeometryBuffers(pass)\n    this.drawGeometry(pass)\n  }\n\n  /**\n   * Destroy our geometry vertex buffers\n   */\n  destroy() {\n    this.vertexBuffers.forEach((vertexBuffer) => {\n      vertexBuffer.buffer?.destroy()\n      vertexBuffer.buffer = null\n    })\n  }\n}\n"],"names":["attribute"],"mappings":"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"}