{"version":3,"file":"ShaderPass.mjs","sources":["../../../../src/core/renderPasses/ShaderPass.ts"],"sourcesContent":["import { FullscreenPlane } from '../meshes/FullscreenPlane'\r\nimport { isRenderer, Renderer } from '../renderers/utils'\r\nimport { RenderTarget } from './RenderTarget'\r\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\r\nimport { MeshBaseOptions, MeshBaseRenderParams } from '../meshes/mixins/MeshBaseMixin'\r\nimport { RenderTexture } from '../textures/RenderTexture'\r\nimport default_pass_fsWGSl from '../shaders/chunks/default_pass_fs.wgsl'\r\nimport { throwWarning } from '../../utils/utils'\r\n\r\n/**\r\n * Parameters used to create a {@link ShaderPass}\r\n */\r\nexport interface ShaderPassParams extends MeshBaseRenderParams {\r\n  /** Optional input {@link RenderTarget} to assign to the {@link ShaderPass}. Used to automatically copy the content of the given {@link RenderTarget} texture into the {@link ShaderPass#renderTexture | ShaderPass renderTexture}. */\r\n  inputTarget?: RenderTarget\r\n\r\n  /** Whether the result of this {@link ShaderPass} should be copied to the {@link ShaderPass#renderTexture | renderTexture} after each render. Default to false. */\r\n  copyOutputToRenderTexture?: boolean\r\n}\r\n\r\nexport interface ShaderPassOptions extends MeshBaseOptions {\r\n  /** Whether the result of this {@link ShaderPass} should be copied to the {@link ShaderPass#renderTexture | renderTexture} after each render. Default to false. */\r\n  copyOutputToRenderTexture?: boolean\r\n}\r\n\r\n/**\r\n * Used to apply postprocessing, i.e. draw meshes to a {@link RenderTexture} and then draw a {@link FullscreenPlane} using that texture as an input.\r\n *\r\n * A ShaderPass could either post process the whole scene or just a bunch of meshes using a specific {@link RenderTarget}.\r\n *\r\n * @example\r\n * ```javascript\r\n * // set our main GPUCurtains instance\r\n * const gpuCurtains = new GPUCurtains({\r\n *   container: '#canvas' // selector of our WebGPU canvas container\r\n * })\r\n *\r\n * // set the GPU device\r\n * // note this is asynchronous\r\n * await gpuCurtains.setDevice()\r\n *\r\n * // create a ShaderPass\r\n * const shaderPass = new ShaderPass(gpuCurtain, {\r\n *   label: 'My shader pass',\r\n *   shaders: {\r\n *     fragment: {\r\n *       code: shaderPassCode, // assume it is a valid WGSL fragment shader\r\n *     },\r\n *   },\r\n * })\r\n * ```\r\n */\r\nexport class ShaderPass extends FullscreenPlane {\r\n  /** Optional input {@link RenderTarget} to assign to the {@link ShaderPass}. Used to automatically copy the content of the given {@link RenderTarget} texture into the {@link ShaderPass#renderTexture | ShaderPass renderTexture}. */\r\n  inputTarget: RenderTarget | undefined\r\n\r\n  /** Options used to create this {@link ShaderPass} */\r\n  options: ShaderPassOptions\r\n\r\n  /**\r\n   * ShaderPass constructor\r\n   * @param renderer - {@link Renderer} object or {@link GPUCurtains} class object used to create this {@link ShaderPass}\r\n   * @param parameters - {@link ShaderPassParams | parameters} use to create this {@link ShaderPass}\r\n   */\r\n  constructor(renderer: Renderer | GPUCurtains, parameters: ShaderPassParams = {}) {\r\n    // we could pass our curtains object OR our curtains renderer object\r\n    renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as Renderer)\r\n\r\n    isRenderer(renderer, parameters.label ? parameters.label + ' ShaderPass' : 'ShaderPass')\r\n\r\n    // force transparency to allow for correct blending between successive passes\r\n    parameters.transparent = true\r\n    parameters.label = parameters.label ?? 'ShaderPass ' + renderer.shaderPasses?.length\r\n\r\n    // set default sample count to post processing render pass\r\n    parameters.sampleCount = !!parameters.sampleCount\r\n      ? parameters.sampleCount\r\n      : renderer && renderer.postProcessingPass\r\n      ? renderer && renderer.postProcessingPass.options.sampleCount\r\n      : 1\r\n\r\n    if (!parameters.shaders) {\r\n      parameters.shaders = {}\r\n    }\r\n\r\n    if (!parameters.shaders.fragment) {\r\n      parameters.shaders.fragment = {\r\n        code: default_pass_fsWGSl,\r\n        entryPoint: 'main',\r\n      }\r\n    }\r\n\r\n    // force the postprocessing passes to not use depth\r\n    parameters.depth = false\r\n\r\n    super(renderer, parameters)\r\n\r\n    if (parameters.inputTarget) {\r\n      this.setInputTarget(parameters.inputTarget)\r\n    }\r\n\r\n    if (this.outputTarget) {\r\n      // patch to match outputTarget if needed\r\n      this.setRenderingOptionsForRenderPass(this.outputTarget.renderPass)\r\n    }\r\n\r\n    this.type = 'ShaderPass'\r\n\r\n    this.createRenderTexture({\r\n      label: parameters.label ? `${parameters.label} render texture` : 'Shader pass render texture',\r\n      name: 'renderTexture',\r\n      fromTexture: this.inputTarget ? this.inputTarget.renderTexture : null,\r\n      ...(this.outputTarget &&\r\n        this.outputTarget.options.qualityRatio && { qualityRatio: this.outputTarget.options.qualityRatio }),\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Hook used to clean up parameters before sending them to the material.\r\n   * @param parameters - parameters to clean before sending them to the {@link core/materials/RenderMaterial.RenderMaterial | RenderMaterial}\r\n   * @returns - cleaned parameters\r\n   */\r\n  cleanupRenderMaterialParameters(parameters: ShaderPassParams): MeshBaseRenderParams {\r\n    // patch mesh parameters\r\n    delete parameters.copyOutputToRenderTexture\r\n    delete parameters.inputTarget\r\n\r\n    super.cleanupRenderMaterialParameters(parameters)\r\n\r\n    return parameters\r\n  }\r\n\r\n  /**\r\n   * Get our main {@link RenderTexture} that contains the input content to be used by the {@link ShaderPass}. Can also contain the ouputted content if {@link ShaderPassOptions#copyOutputToRenderTexture | copyOutputToRenderTexture} is set to true.\r\n   * @readonly\r\n   */\r\n  get renderTexture(): RenderTexture | undefined {\r\n    return this.renderTextures.find((texture) => texture.options.name === 'renderTexture')\r\n  }\r\n\r\n  /**\r\n   * Assign or remove an input {@link RenderTarget} to this {@link ShaderPass}, which can be different from what has just been drawn to the {@link core/renderers/GPURenderer.GPURenderer#context | context} current texture.\r\n   *\r\n   * Since this manipulates the {@link core/scenes/Scene.Scene | Scene} stacks, it can be used to remove a RenderTarget as well.\r\n   * Also copy or remove the {@link RenderTarget#renderTexture | render target render texture} into the {@link ShaderPass} {@link renderTexture}\r\n   * @param inputTarget - the {@link RenderTarget} to assign or null if we want to remove the current {@link RenderTarget}\r\n   */\r\n  setInputTarget(inputTarget: RenderTarget | null) {\r\n    if (inputTarget && inputTarget.type !== 'RenderTarget') {\r\n      throwWarning(`${this.options.label ?? this.type}: inputTarget is not a RenderTarget: ${inputTarget}`)\r\n      return\r\n    }\r\n\r\n    // ensure the mesh is in the correct scene stack\r\n    this.removeFromScene()\r\n    this.inputTarget = inputTarget\r\n    this.addToScene()\r\n\r\n    // it might not have been created yet\r\n    if (this.renderTexture) {\r\n      if (inputTarget) {\r\n        this.renderTexture.copy(this.inputTarget.renderTexture)\r\n      } else {\r\n        this.renderTexture.options.fromTexture = null\r\n        this.renderTexture.createTexture()\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add the {@link ShaderPass} to the renderer and the {@link core/scenes/Scene.Scene | Scene}\r\n   */\r\n  addToScene() {\r\n    this.renderer.shaderPasses.push(this)\r\n\r\n    this.setRenderingOptionsForRenderPass(\r\n      this.outputTarget ? this.outputTarget.renderPass : this.renderer.postProcessingPass\r\n    )\r\n\r\n    if (this.autoRender) {\r\n      this.renderer.scene.addShaderPass(this)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove the {@link ShaderPass} from the renderer and the {@link core/scenes/Scene.Scene | Scene}\r\n   */\r\n  removeFromScene() {\r\n    if (this.outputTarget) {\r\n      this.outputTarget.destroy()\r\n    }\r\n\r\n    if (this.autoRender) {\r\n      this.renderer.scene.removeShaderPass(this)\r\n    }\r\n\r\n    this.renderer.shaderPasses = this.renderer.shaderPasses.filter((sP) => sP.uuid !== this.uuid)\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}