{"version":3,"file":"ShaderPass.mjs","sources":["../../../../src/core/renderPasses/ShaderPass.ts"],"sourcesContent":["import { FullscreenPlane } from '../meshes/FullscreenPlane'\nimport { isRenderer, Renderer } from '../renderers/utils'\nimport { RenderTarget } from './RenderTarget'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\nimport { MeshBaseRenderParams } from '../meshes/mixins/MeshBaseMixin'\nimport { RenderTexture } from '../textures/RenderTexture'\nimport default_pass_fsWGSl from '../shaders/chunks/default_pass_fs.wgsl'\nimport { throwWarning } from '../../utils/utils'\n\n/**\n * Parameters used to create a {@link ShaderPass}\n */\nexport interface ShaderPassParams extends MeshBaseRenderParams {\n  /** Optional input {@link RenderTarget} to assign to the {@link ShaderPass}. Used to automatically copy the content of the given {@link RenderTarget} texture into the {@link ShaderPass#renderTexture | ShaderPass renderTexture}. */\n  inputTarget?: RenderTarget\n}\n\n/**\n * Used to apply postprocessing, i.e. draw meshes to a {@link RenderTexture} and then draw a {@link FullscreenPlane} using that texture as an input.\n *\n * A ShaderPass could either post process the whole scene or just a bunch of meshes using a specific {@link RenderTarget}.\n *\n * @example\n * ```javascript\n * // set our main GPUCurtains instance\n * const gpuCurtains = new GPUCurtains({\n *   container: '#canvas' // selector of our WebGPU canvas container\n * })\n *\n * // set the GPU device\n * // note this is asynchronous\n * await gpuCurtains.setDevice()\n *\n * // create a ShaderPass\n * const shaderPass = new ShaderPass(gpuCurtain, {\n *   label: 'My shader pass',\n *   shaders: {\n *     fragment: {\n *       code: shaderPassCode, // assume it is a valid WGSL fragment shader\n *     },\n *   },\n * })\n * ```\n */\nexport class ShaderPass extends FullscreenPlane {\n  /** Optional input {@link RenderTarget} to assign to the {@link ShaderPass}. Used to automatically copy the content of the given {@link RenderTarget} texture into the {@link ShaderPass#renderTexture | ShaderPass renderTexture}. */\n  inputTarget: RenderTarget | undefined\n\n  /**\n   * ShaderPass constructor\n   * @param renderer - {@link Renderer} object or {@link GPUCurtains} class object used to create this {@link ShaderPass}\n   * @param parameters - {@link ShaderPassParams | parameters} use to create this {@link ShaderPass}\n   */\n  constructor(renderer: Renderer | GPUCurtains, parameters: ShaderPassParams = {}) {\n    // we could pass our curtains object OR our curtains renderer object\n    renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as Renderer)\n\n    isRenderer(renderer, parameters.label ? parameters.label + ' ShaderPass' : 'ShaderPass')\n\n    // force transparency to allow for correct blending between successive passes\n    parameters.transparent = true\n    parameters.label = parameters.label ?? 'ShaderPass ' + renderer.shaderPasses?.length\n\n    // set default sample count to post processing render pass\n    parameters.sampleCount = !!parameters.sampleCount\n      ? parameters.sampleCount\n      : renderer && renderer.postProcessingPass\n      ? renderer && renderer.postProcessingPass.options.sampleCount\n      : 1\n\n    if (!parameters.shaders) {\n      parameters.shaders = {}\n    }\n\n    if (!parameters.shaders.fragment) {\n      parameters.shaders.fragment = {\n        code: default_pass_fsWGSl,\n        entryPoint: 'main',\n      }\n    }\n\n    // force the postprocessing passes to not use depth\n    parameters.depth = false\n\n    super(renderer, parameters)\n\n    if (parameters.inputTarget) {\n      this.setInputTarget(parameters.inputTarget)\n    }\n\n    if (this.outputTarget) {\n      // patch to match outputTarget if needed\n      this.setRenderingOptionsForRenderPass(this.outputTarget.renderPass)\n    }\n\n    this.type = 'ShaderPass'\n\n    this.createRenderTexture({\n      label: parameters.label ? `${parameters.label} render texture` : 'Shader pass render texture',\n      name: 'renderTexture',\n      fromTexture: this.inputTarget ? this.inputTarget.renderTexture : null,\n      ...(this.outputTarget &&\n        this.outputTarget.options.qualityRatio && { qualityRatio: this.outputTarget.options.qualityRatio }),\n    })\n  }\n\n  /**\n   * Get our main {@link RenderTexture}, the one that contains our post processed content\n   * @readonly\n   */\n  get renderTexture(): RenderTexture | undefined {\n    return this.renderTextures.find((texture) => texture.options.name === 'renderTexture')\n  }\n\n  // TODO\n  /**\n   * Assign or remove a {@link RenderTarget} to this {@link ShaderPass}\n   * Since this manipulates the {@link core/scenes/Scene.Scene | Scene} stacks, it can be used to remove a RenderTarget as well.\n   * Also copy or remove the {@link RenderTarget#renderTexture | render target render texture} into the {@link ShaderPass} {@link renderTexture}\n   * @param inputTarget - the {@link RenderTarget} to assign or null if we want to remove the current {@link RenderTarget}\n   */\n  setInputTarget(inputTarget: RenderTarget | null) {\n    if (inputTarget && inputTarget.type !== 'RenderTarget') {\n      throwWarning(`${this.options.label ?? this.type}: inputTarget is not a RenderTarget: ${inputTarget}`)\n      return\n    }\n\n    // ensure the mesh is in the correct scene stack\n    this.removeFromScene()\n    this.inputTarget = inputTarget\n    this.addToScene()\n\n    // it might not have been created yet\n    if (this.renderTexture) {\n      if (inputTarget) {\n        this.renderTexture.copy(this.inputTarget.renderTexture)\n      } else {\n        this.renderTexture.options.fromTexture = null\n        this.renderTexture.createTexture()\n      }\n    }\n  }\n\n  /**\n   * Add the {@link ShaderPass} to the renderer and the {@link core/scenes/Scene.Scene | Scene}\n   */\n  addToScene() {\n    this.renderer.shaderPasses.push(this)\n\n    this.setRenderingOptionsForRenderPass(\n      this.outputTarget ? this.outputTarget.renderPass : this.renderer.postProcessingPass\n    )\n\n    if (this.autoRender) {\n      this.renderer.scene.addShaderPass(this)\n    }\n  }\n\n  /**\n   * Remove the {@link ShaderPass} from the renderer and the {@link core/scenes/Scene.Scene | Scene}\n   */\n  removeFromScene() {\n    if (this.outputTarget) {\n      this.outputTarget.destroy()\n    }\n\n    if (this.autoRender) {\n      this.renderer.scene.removeShaderPass(this)\n    }\n\n    this.renderer.shaderPasses = this.renderer.shaderPasses.filter((sP) => sP.uuid !== this.uuid)\n  }\n}\n"],"names":[],"mappings":"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"}