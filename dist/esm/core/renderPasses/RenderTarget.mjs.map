{"version":3,"file":"RenderTarget.mjs","sources":["../../../../src/core/renderPasses/RenderTarget.ts"],"sourcesContent":["import { isRenderer, Renderer } from '../renderers/utils'\nimport { RenderPass, RenderPassParams } from './RenderPass'\nimport { RenderTexture } from '../textures/RenderTexture'\nimport { generateUUID } from '../../utils/utils'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\n\n/**\n * Parameters used to create a {@link RenderTarget}\n */\nexport interface RenderTargetParams extends RenderPassParams {\n  /** Whether we should add this {@link RenderTarget} to our {@link core/scenes/Scene.Scene | Scene} to let it handle the rendering process automatically */\n  autoRender?: boolean\n}\n\n/**\n * Used to draw to {@link RenderPass#viewTextures | RenderPass view textures} (and eventually {@link RenderPass#depthTexture | depth texture}) instead of directly to screen.\n *\n * The meshes assigned to a {@link RenderTarget} will be drawn before the other objects in the {@link core/scenes/Scene.Scene | Scene} rendering loop.\n *\n * Can also be assigned as ShaderPass {@link core/renderPasses/ShaderPass.ShaderPass#inputTarget | input} or {@link core/renderPasses/ShaderPass.ShaderPass#outputTarget | output} targets.\n *\n * If the {@link RenderPass} created handle color attachments, then a {@link RenderTarget#renderTexture | RenderTexture} will be created to update and/or resolve the content of the current view. This {@link RenderTarget#renderTexture | RenderTexture} could therefore usually be used to access the current content of this {@link RenderTarget}.\n *\n * @example\n * ```javascript\n * // set our main GPUCurtains instance\n * const gpuCurtains = new GPUCurtains({\n *   container: '#canvas' // selector of our WebGPU canvas container\n * })\n *\n * // set the GPU device\n * // note this is asynchronous\n * await gpuCurtains.setDevice()\n *\n * const outputTarget = new RenderTarget(gpuCurtains, {\n *   label: 'My render target',\n * })\n * ```\n */\nexport class RenderTarget {\n  /** {@link Renderer} used by this {@link RenderTarget} */\n  renderer: Renderer\n  /** The type of the {@link RenderTarget} */\n  type: string\n  /** The universal unique id of this {@link RenderTarget} */\n  readonly uuid: string\n\n  /** Options used to create this {@link RenderTarget} */\n  options: RenderTargetParams\n\n  /** {@link RenderPass} used by this {@link RenderTarget} */\n  renderPass: RenderPass\n  /** {@link RenderTexture} that will be resolved by the {@link renderPass} when {@link RenderPass#updateView | setting the current texture} */\n  renderTexture?: RenderTexture\n\n  /** Whether we should add this {@link RenderTarget} to our {@link core/scenes/Scene.Scene | Scene} to let it handle the rendering process automatically */\n  #autoRender = true\n\n  /**\n   * RenderTarget constructor\n   * @param renderer - {@link Renderer} object or {@link GPUCurtains} class object used to create this {@link RenderTarget}\n   * @param parameters - {@link RenderTargetParams | parameters} use to create this {@link RenderTarget}\n   */\n  constructor(renderer: Renderer | GPUCurtains, parameters = {} as RenderTargetParams) {\n    // we could pass our curtains object OR our curtains renderer object\n    renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as Renderer)\n\n    isRenderer(renderer, 'RenderTarget')\n\n    this.type = 'RenderTarget'\n    this.renderer = renderer\n    this.uuid = generateUUID()\n\n    const { label, targetFormat, depthTexture, autoRender, ...renderPassParams } = parameters\n\n    this.options = {\n      label,\n      ...renderPassParams,\n      ...(depthTexture && { depthTexture }),\n      targetFormat: targetFormat ?? this.renderer.options.preferredFormat,\n      autoRender: autoRender === undefined ? true : autoRender,\n    } as RenderTargetParams\n\n    if (autoRender !== undefined) {\n      this.#autoRender = autoRender\n    }\n\n    this.renderPass = new RenderPass(this.renderer, {\n      label: this.options.label ? `${this.options.label} Render Pass` : 'Render Target Render Pass',\n      targetFormat: this.options.targetFormat,\n      depthTexture: this.options.depthTexture ?? this.renderer.renderPass.depthTexture, // reuse renderer depth texture for every pass\n      ...renderPassParams,\n    })\n\n    if (renderPassParams.useColorAttachments !== false) {\n      // this is the texture that will be resolved when setting the current render pass texture\n      this.renderTexture = new RenderTexture(this.renderer, {\n        label: this.options.label ? `${this.options.label} Render Texture` : 'Render Target render texture',\n        name: 'renderTexture',\n        format: this.options.targetFormat,\n        ...(this.options.qualityRatio !== undefined && { qualityRatio: this.options.qualityRatio }),\n      })\n    }\n\n    this.addToScene()\n  }\n\n  /**\n   * Add the {@link RenderTarget} to the renderer and the {@link core/scenes/Scene.Scene | Scene}\n   */\n  addToScene() {\n    this.renderer.renderTargets.push(this)\n\n    if (this.#autoRender) {\n      this.renderer.scene.addRenderTarget(this)\n    }\n  }\n\n  /**\n   * Remove the {@link RenderTarget} from the renderer and the {@link core/scenes/Scene.Scene | Scene}\n   */\n  removeFromScene() {\n    if (this.#autoRender) {\n      this.renderer.scene.removeRenderTarget(this)\n    }\n\n    this.renderer.renderTargets = this.renderer.renderTargets.filter((renderTarget) => renderTarget.uuid !== this.uuid)\n  }\n\n  /**\n   * Resize our {@link renderPass}\n   */\n  resize() {\n    // reset the newly created depth texture\n    this.renderPass.options.depthTexture.texture = this.options.depthTexture\n      ? this.options.depthTexture.texture\n      : this.renderer.renderPass.depthTexture.texture\n\n    this.renderPass?.resize()\n  }\n\n  /**\n   * Remove our {@link RenderTarget}. Alias of {@link RenderTarget#destroy}\n   */\n  remove() {\n    this.destroy()\n  }\n\n  /**\n   * Destroy our {@link RenderTarget}\n   */\n  destroy() {\n    // release mesh struct\n    this.renderer.meshes.forEach((mesh) => {\n      if (mesh.outputTarget && mesh.outputTarget.uuid === this.uuid) {\n        mesh.setOutputTarget(null)\n      }\n    })\n\n    // release shader passes struct\n    this.renderer.shaderPasses.forEach((shaderPass) => {\n      if (shaderPass.outputTarget && shaderPass.outputTarget.uuid === this.uuid) {\n        // force render target to null before removing / re-adding to scene\n        shaderPass.outputTarget = null\n        shaderPass.setOutputTarget(null)\n      }\n    })\n\n    // remove from scene and renderer array\n    this.removeFromScene()\n\n    this.renderPass?.destroy()\n    this.renderTexture?.destroy()\n  }\n}\n"],"names":[],"mappings":"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"}