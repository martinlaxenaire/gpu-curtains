{"version":3,"file":"BufferElement.mjs","sources":["../../../../../src/core/bindings/bufferElements/BufferElement.ts"],"sourcesContent":["import { BufferLayout, getBufferLayout, TypedArray, WGSLVariableType } from '../utils'\r\nimport { Vec2 } from '../../../math/Vec2'\r\nimport { Vec3 } from '../../../math/Vec3'\r\nimport { Quat } from '../../../math/Quat'\r\nimport { Mat4 } from '../../../math/Mat4'\r\n\r\n/** Number of slots per row */\r\nexport const slotsPerRow = 4\r\n/** Number of bytes per slot */\r\nexport const bytesPerSlot = 4\r\n/** Number of bytes per row */\r\nexport const bytesPerRow = slotsPerRow * bytesPerSlot\r\n\r\n/**\r\n * Defines a position in our array buffer with a row index and a byte index\r\n */\r\nexport interface BufferElementAlignmentPosition {\r\n  /** row index of that position */\r\n  row: number\r\n  /** byte index of that position */\r\n  byte: number\r\n}\r\n\r\n/**\r\n * Defines our {@link BufferElement} alignment:\r\n * Keep track of an entry start and end row and bytes indexes (16 bytes per row)\r\n */\r\nexport interface BufferElementAlignment {\r\n  /** The row and byte indexes at which this {@link BufferElement} starts */\r\n  start: BufferElementAlignmentPosition\r\n  /** The row and byte indexes at which this {@link BufferElement} ends */\r\n  end: BufferElementAlignmentPosition\r\n}\r\n\r\n/**\r\n * Parameters used to create a {@link BufferElement}\r\n */\r\nexport interface BufferElementParams {\r\n  /** The name of the {@link BufferElement} */\r\n  name: string\r\n  /** The key of the {@link BufferElement} */\r\n  key: string\r\n  /** The WGSL variable type of the {@link BufferElement} */\r\n  type: WGSLVariableType\r\n}\r\n\r\n/**\r\n * Used to handle each {@link core/bindings/BufferBinding.BufferBinding#arrayBuffer | buffer binding array} view and data layout alignment.\r\n * Compute the exact alignment offsets needed to fill an {@link ArrayBuffer} that will be sent to a {@link GPUBuffer}, based on an input type and value.\r\n * Also update the view array at the correct offset.\r\n *\r\n * So all our struct need to be packed into our arrayBuffer using a precise layout.\r\n * They will be stored in rows, each row made of 4 slots and each slots made of 4 bytes. Depending on the binding element type, its row and slot may vary and we may have to insert empty padded values.\r\n * All in all it looks like that:<br>\r\n * <pre>\r\n *          slot 0    slot 1    slot 2    slot 3\r\n * row 0 | _ _ _ _ | _ _ _ _ | _ _ _ _ | _ _ _ _ |\r\n * row 1 | _ _ _ _ | _ _ _ _ | _ _ _ _ | _ _ _ _ |\r\n * row 2 | _ _ _ _ | _ _ _ _ | _ _ _ _ | _ _ _ _ |\r\n * </pre>\r\n * see https://webgpufundamentals.org/webgpu/lessons/resources/wgsl-offset-computer.html\r\n */\r\nexport class BufferElement {\r\n  /** The name of the {@link BufferElement} */\r\n  name: string\r\n  /** The WGSL variable type of the {@link BufferElement} */\r\n  type: WGSLVariableType\r\n  /** The key of the {@link BufferElement} */\r\n  key: string\r\n\r\n  /** {@link BufferLayout} used to fill the {@link core/bindings/BufferBinding.BufferBinding#arrayBuffer | buffer binding array} at the right offsets */\r\n  bufferLayout: BufferLayout\r\n\r\n  /**\r\n   * Object defining exactly at which place a binding should be inserted into the {@link core/bindings/BufferBinding.BufferBinding#arrayBuffer | buffer binding array}\r\n   */\r\n  alignment: BufferElementAlignment\r\n\r\n  /** Array containing the {@link BufferElement} values */\r\n  view?: TypedArray\r\n\r\n  /**\r\n   * BufferElement constructor\r\n   * @param parameters - {@link BufferElementParams | parameters} used to create our {@link BufferElement}\r\n   */\r\n  constructor({ name, key, type = 'f32' }: BufferElementParams) {\r\n    this.name = name\r\n    this.key = key\r\n    this.type = type\r\n\r\n    this.bufferLayout = getBufferLayout(this.type.replace('array', '').replace('<', '').replace('>', ''))\r\n\r\n    // set init alignment\r\n    this.alignment = {\r\n      start: {\r\n        row: 0,\r\n        byte: 0,\r\n      },\r\n      end: {\r\n        row: 0,\r\n        byte: 0,\r\n      },\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the total number of rows used by this {@link BufferElement}\r\n   * @readonly\r\n   */\r\n  get rowCount(): number {\r\n    return this.alignment.end.row - this.alignment.start.row + 1\r\n  }\r\n\r\n  /**\r\n   * Get the total number of bytes used by this {@link BufferElement} based on {@link BufferElementAlignment | alignment} start and end offsets\r\n   * @readonly\r\n   */\r\n  get byteCount(): number {\r\n    return Math.abs(this.endOffset - this.startOffset) + 1\r\n  }\r\n\r\n  /**\r\n   * Get the total number of bytes used by this {@link BufferElement}, including final padding\r\n   * @readonly\r\n   */\r\n  get paddedByteCount(): number {\r\n    return (this.alignment.end.row + 1) * bytesPerRow\r\n  }\r\n\r\n  /**\r\n   * Get the offset (i.e. byte index) at which our {@link BufferElement} starts\r\n   * @readonly\r\n   */\r\n  get startOffset(): number {\r\n    return this.getByteCountAtPosition(this.alignment.start)\r\n  }\r\n\r\n  /**\r\n   * Get the array offset (i.e. array index) at which our {@link BufferElement} starts\r\n   * @readonly\r\n   */\r\n  get startOffsetToIndex(): number {\r\n    return this.startOffset / bytesPerSlot\r\n  }\r\n\r\n  /**\r\n   * Get the offset (i.e. byte index) at which our {@link BufferElement} ends\r\n   * @readonly\r\n   */\r\n  get endOffset(): number {\r\n    return this.getByteCountAtPosition(this.alignment.end)\r\n  }\r\n\r\n  /**\r\n   * Get the array offset (i.e. array index) at which our {@link BufferElement} ends\r\n   * @readonly\r\n   */\r\n  get endOffsetToIndex(): number {\r\n    return Math.floor(this.endOffset / bytesPerSlot)\r\n  }\r\n\r\n  /**\r\n   * Get the position at given offset (i.e. byte index)\r\n   * @param offset - byte index to use\r\n   */\r\n  getPositionAtOffset(offset = 0): BufferElementAlignmentPosition {\r\n    return {\r\n      row: Math.floor(offset / bytesPerRow),\r\n      byte: offset % bytesPerRow,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the number of bytes at a given {@link BufferElementAlignmentPosition | position}\r\n   * @param position - {@link BufferElementAlignmentPosition | position} from which to count\r\n   * @returns - byte count at the given {@link BufferElementAlignmentPosition | position}\r\n   */\r\n  getByteCountAtPosition(position: BufferElementAlignmentPosition = { row: 0, byte: 0 }): number {\r\n    return position.row * bytesPerRow + position.byte\r\n  }\r\n\r\n  /**\r\n   * Check that a {@link BufferElementAlignmentPosition#byte | byte position} does not overflow its max value (16)\r\n   * @param position - {@link BufferElementAlignmentPosition | position}\r\n   * @returns - updated {@link BufferElementAlignmentPosition | position}\r\n   */\r\n  applyOverflowToPosition(\r\n    position: BufferElementAlignmentPosition = { row: 0, byte: 0 }\r\n  ): BufferElementAlignmentPosition {\r\n    if (position.byte > bytesPerRow - 1) {\r\n      const overflow = position.byte % bytesPerRow\r\n      position.row += Math.floor(position.byte / bytesPerRow)\r\n      position.byte = overflow\r\n    }\r\n\r\n    return position\r\n  }\r\n\r\n  /**\r\n   * Get the number of bytes between two {@link BufferElementAlignmentPosition | positions}\r\n   * @param p1 - first {@link BufferElementAlignmentPosition | position}\r\n   * @param p2 - second {@link BufferElementAlignmentPosition | position}\r\n   * @returns - number of bytes\r\n   */\r\n  getByteCountBetweenPositions(\r\n    p1: BufferElementAlignmentPosition = { row: 0, byte: 0 },\r\n    p2: BufferElementAlignmentPosition = { row: 0, byte: 0 }\r\n  ): number {\r\n    return Math.abs(this.getByteCountAtPosition(p2) - this.getByteCountAtPosition(p1))\r\n  }\r\n\r\n  /**\r\n   * Compute the right alignment (i.e. start and end rows and bytes) given the size and align properties and the next available {@link BufferElementAlignmentPosition | position}\r\n   * @param nextPositionAvailable - next {@link BufferElementAlignmentPosition | position} at which we should insert this element\r\n   * @returns - computed {@link BufferElementAlignment | alignment}\r\n   */\r\n  getElementAlignment(\r\n    nextPositionAvailable: BufferElementAlignmentPosition = { row: 0, byte: 0 }\r\n  ): BufferElementAlignment {\r\n    const alignment = {\r\n      start: nextPositionAvailable,\r\n      end: nextPositionAvailable,\r\n    }\r\n\r\n    const { size, align } = this.bufferLayout\r\n\r\n    // check the alignment, i.e. even if there's enough space for our binding\r\n    // we might have to pad the slot because some types need a specific alignment\r\n    if (nextPositionAvailable.byte % align !== 0) {\r\n      nextPositionAvailable.byte += nextPositionAvailable.byte % align\r\n    }\r\n\r\n    // in the case of a binding that could fit on one row\r\n    // but we don't have space on the current row for this binding element\r\n    // go to next row\r\n    if (size <= bytesPerRow && nextPositionAvailable.byte + size > bytesPerRow) {\r\n      nextPositionAvailable.row += 1\r\n      nextPositionAvailable.byte = 0\r\n    }\r\n\r\n    alignment.end = {\r\n      row: nextPositionAvailable.row + Math.ceil(size / bytesPerRow) - 1,\r\n      byte: nextPositionAvailable.byte + (size % bytesPerRow === 0 ? bytesPerRow - 1 : (size % bytesPerRow) - 1), // end of row ? then it ends on slot (bytesPerRow - 1)\r\n    }\r\n\r\n    // now final check, if end slot has overflown\r\n    alignment.end = this.applyOverflowToPosition(alignment.end)\r\n\r\n    return alignment\r\n  }\r\n\r\n  /**\r\n   * Set the {@link BufferElementAlignment | alignment} from a {@link BufferElementAlignmentPosition | position}\r\n   * @param position - {@link BufferElementAlignmentPosition | position} at which to start inserting the values in the {@link !core/bindings/BufferBinding.BufferBinding#arrayBuffer | buffer binding array}\r\n   */\r\n  setAlignmentFromPosition(position: BufferElementAlignmentPosition = { row: 0, byte: 0 }) {\r\n    this.alignment = this.getElementAlignment(position)\r\n  }\r\n\r\n  /**\r\n   * Set the {@link BufferElementAlignment | alignment} from an offset (byte count)\r\n   * @param startOffset - offset at which to start inserting the values in the {@link core/bindings/BufferBinding.BufferBinding#arrayBuffer | buffer binding array}\r\n   */\r\n  setAlignment(startOffset = 0) {\r\n    this.setAlignmentFromPosition(this.getPositionAtOffset(startOffset))\r\n  }\r\n\r\n  /**\r\n   * Set the {@link view}\r\n   * @param arrayBuffer - the {@link core/bindings/BufferBinding.BufferBinding#arrayBuffer | buffer binding array}\r\n   * @param arrayView - the {@link core/bindings/BufferBinding.BufferBinding#arrayView | buffer binding array view}\r\n   */\r\n  setView(arrayBuffer: ArrayBuffer, arrayView: DataView) {\r\n    this.view = new this.bufferLayout.View(\r\n      arrayBuffer,\r\n      this.startOffset,\r\n      this.byteCount / this.bufferLayout.View.BYTES_PER_ELEMENT\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Update the {@link view} based on the new value\r\n   * @param value - new value to use\r\n   */\r\n  update(value) {\r\n    if (this.type === 'f32' || this.type === 'u32' || this.type === 'i32') {\r\n      this.view[0] = value as number\r\n    } else if (this.type === 'vec2f') {\r\n      this.view[0] = (value as Vec2).x ?? value[0] ?? 0\r\n      this.view[1] = (value as Vec2).y ?? value[1] ?? 0\r\n    } else if (this.type === 'vec3f') {\r\n      this.view[0] = (value as Vec3).x ?? value[0] ?? 0\r\n      this.view[1] = (value as Vec3).y ?? value[1] ?? 0\r\n      this.view[2] = (value as Vec3).z ?? value[2] ?? 0\r\n    } else if ((value as Quat | Mat4).elements) {\r\n      this.view.set((value as Quat | Mat4).elements)\r\n    } else if (ArrayBuffer.isView(value) || Array.isArray(value)) {\r\n      this.view.set(value as number[])\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract the data corresponding to this specific {@link BufferElement} from a {@link Float32Array} holding the {@link GPUBuffer} data of the parentMesh {@link core/bindings/BufferBinding.BufferBinding | BufferBinding}\r\n   * @param result - {@link Float32Array} holding {@link GPUBuffer} data\r\n   * @returns - extracted data from the {@link Float32Array}\r\n   */\r\n  extractDataFromBufferResult(result: Float32Array) {\r\n    return result.slice(this.startOffsetToIndex, this.endOffsetToIndex)\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}