{"version":3,"file":"BufferBinding.mjs","sources":["../../../../src/core/bindings/BufferBinding.ts"],"sourcesContent":["import { Binding, BindingParams, BufferBindingMemoryAccessType } from './Binding'\nimport { getBindGroupLayoutBindingType, getBindingWGSLVarType, getBufferLayout, TypedArray } from './utils'\nimport { throwWarning, toCamelCase, toKebabCase } from '../../utils/utils'\nimport { Vec2 } from '../../math/Vec2'\nimport { Vec3 } from '../../math/Vec3'\nimport { Input, InputBase, InputValue } from '../../types/BindGroups'\nimport { BufferElement } from './bufferElements/BufferElement'\nimport { BufferArrayElement } from './bufferElements/BufferArrayElement'\nimport { BufferInterleavedArrayElement } from './bufferElements/BufferInterleavedArrayElement'\n\n/**\n * Defines a {@link BufferBinding} input object that can set a value and run a callback function when this happens\n */\nexport interface BufferBindingInput extends InputBase {\n  /** Original {@link InputValue | input value} */\n  _value: InputValue\n\n  /** Get the {@link InputValue | input value} */\n  get value(): InputValue\n\n  /** Set the {@link InputValue | input value} */\n  set value(value: InputValue)\n\n  /** Whether the {@link InputValue | input value} has changed and we should update the {@link BufferBinding#arrayBuffer | buffer binding array} */\n  shouldUpdate: boolean\n}\n\n/**\n * Base parameters used to create a {@link BufferBinding}\n */\nexport interface BufferBindingBaseParams {\n  /** Whether this {@link BufferBinding} should use structured WGSL variables */\n  useStruct?: boolean\n  /** {@link BufferBinding} memory access types (read only or read/write) */\n  access?: BufferBindingMemoryAccessType\n  /** Object containing one or multiple {@link Input | inputs} describing the structure of the {@link BufferBinding} */\n  struct?: Record<string, Input>\n}\n\n/**\n * Parameters used to create a {@link BufferBinding}\n */\nexport interface BufferBindingParams extends BindingParams, BufferBindingBaseParams {}\n\n/** All allowed {@link BufferElement | buffer elements} */\nexport type AllowedBufferElement = BufferElement | BufferArrayElement | BufferInterleavedArrayElement\n\n/**\n * Used to format {@link BufferBindingParams#struct | uniforms or storages struct inputs} and create a single typed array that will hold all those inputs values. The array needs to be correctly padded depending on every value type, so it can be safely used as a GPUBuffer input.<br>\n * It will also create WGSL Structs and variables according to the BufferBindings inputs parameters.<br>\n * The WGSL structs and variables declaration may vary based on the input types, especially if there's one or more arrays involved (i.e. `array<f32>`, `array<vec3f>` etc.).\n *\n * @example\n * ```javascript\n * // create a GPU buffer binding\n * const bufferBinding = new BufferBinding({\n *   name: 'params', // name of the WGSL object\n *   bindingType: 'uniform', // should be 'storage' for large arrays\n *   struct: {\n *     opacity: {\n *       type: 'f32',\n *       value: 1,\n *     },\n *     mousePosition: {\n *       type: 'vec2f',\n *       value: new Vec2(),\n *     },\n *   },\n * })\n * ```\n */\nexport class BufferBinding extends Binding {\n  /** Flag to indicate whether this {@link BufferBinding} {@link bufferElements | buffer elements} should be packed in a single structured object or if each one of them should be a separate binding. */\n  useStruct: boolean\n  /** All the {@link BufferBinding} data inputs */\n  inputs: Record<string, BufferBindingInput>\n\n  /** Flag to indicate whether one of the {@link inputs} value has changed and we need to update the GPUBuffer linked to the {@link arrayBuffer} array */\n  shouldUpdate: boolean\n\n  /** An array describing how each corresponding {@link inputs} should be inserted into our {@link arrayView} array */\n  bufferElements: AllowedBufferElement[]\n\n  /** Total size of our {@link arrayBuffer} array in bytes */\n  arrayBufferSize: number\n  /** Array buffer that will be sent to the {@link GPUBuffer} */\n  arrayBuffer: ArrayBuffer\n  /** Data view of our {@link arrayBuffer | array buffer} */\n  arrayView: DataView\n\n  /** The GPUBuffer */\n  buffer: GPUBuffer | null\n\n  /** A string to append to our shaders code describing the WGSL structure representing this {@link BufferBinding} */\n  wgslStructFragment: string\n  /** An array of strings to append to our shaders code declaring all the WGSL variables representing this {@link BufferBinding} */\n  wgslGroupFragment: string[]\n  /** Options used to create this {@link BufferBinding} */\n  options: BufferBindingParams\n\n  /**\n   * BufferBinding constructor\n   * @param parameters - {@link BufferBindingParams | parameters} used to create our BufferBindings\n   */\n  constructor({\n    label = 'Uniform',\n    name = 'uniform',\n    bindingType,\n    visibility,\n    useStruct = true,\n    access = 'read',\n    struct = {},\n  }: BufferBindingParams) {\n    bindingType = bindingType ?? 'uniform'\n\n    super({ label, name, bindingType, visibility })\n\n    this.options = {\n      ...this.options,\n      useStruct,\n      access,\n      struct: struct,\n    }\n\n    this.arrayBufferSize = 0\n\n    this.shouldUpdate = false\n    this.useStruct = useStruct\n\n    this.bufferElements = []\n    this.inputs = {}\n    this.buffer = null\n\n    this.setBindings(struct)\n    this.setBufferAttributes()\n    this.setWGSLFragment()\n  }\n\n  /**\n   * Get {@link GPUBindGroupLayoutEntry#buffer | bind group layout entry resource}\n   * @readonly\n   */\n  get resourceLayout(): {\n    /** {@link GPUBindGroupLayout | bind group layout} resource */\n    buffer: GPUBufferBindingLayout\n  } {\n    return {\n      buffer: {\n        type: getBindGroupLayoutBindingType(this),\n      },\n    }\n  }\n\n  /**\n   * Get {@link GPUBindGroupEntry#resource | bind group resource}\n   * @readonly\n   */\n  get resource(): {\n    /** {@link GPUBindGroup | bind group} resource */\n    buffer: GPUBuffer | null\n  } {\n    return { buffer: this.buffer }\n  }\n\n  /**\n   * Format bindings struct and set our {@link inputs}\n   * @param bindings - bindings inputs\n   */\n  setBindings(bindings: Record<string, Input>) {\n    Object.keys(bindings).forEach((bindingKey) => {\n      const binding = {} as BufferBindingInput\n\n      for (const key in bindings[bindingKey]) {\n        if (key !== 'value') {\n          binding[key] = bindings[bindingKey][key]\n        }\n      }\n\n      // force the binding to have a name\n      binding.name = bindings[bindingKey].name ?? bindingKey\n\n      // define a \"value\" getter/setter so we can now when to update the buffer binding\n      Object.defineProperty(binding, 'value', {\n        get() {\n          return binding._value\n        },\n        set(v) {\n          binding._value = v\n          binding.shouldUpdate = true\n        },\n      })\n\n      binding.value = bindings[bindingKey].value\n\n      if (binding.value instanceof Vec2 || binding.value instanceof Vec3) {\n        binding.value.onChange(() => (binding.shouldUpdate = true))\n      }\n\n      this.inputs[bindingKey] = binding\n    })\n  }\n\n  /**\n   * Set our buffer attributes:\n   * Takes all the {@link inputs} and adds them to the {@link bufferElements} array with the correct start and end offsets (padded), then fill our {@link arrayBuffer} typed array accordingly.\n   */\n  setBufferAttributes() {\n    // early on, check if there's at least one array binding\n    // If there's one and only one, put it at the end of the binding elements array, treat it as a single entry of the type, but loop on it by array.length / size to fill the alignment\n    // If there's more than one, create buffer interleaved elements.\n\n    // if length === 0, OK\n    // if length === 1, put it at the end of our struct\n    // if length > 1, create a buffer interleaved elements\n    const arrayBindings = Object.keys(this.inputs).filter(\n      (bindingKey) => this.inputs[bindingKey].type.indexOf('array') !== -1\n    )\n\n    // put the array struct at the end\n    let orderedBindings = Object.keys(this.inputs).sort((bindingKeyA, bindingKeyB) => {\n      // 0 if it's an array, -1 else\n      const isBindingAArray = Math.min(0, this.inputs[bindingKeyA].type.indexOf('array'))\n      const isBindingBArray = Math.min(0, this.inputs[bindingKeyB].type.indexOf('array'))\n\n      return isBindingAArray - isBindingBArray\n    })\n\n    if (arrayBindings.length > 1) {\n      // remove interleaved arrays from the ordered struct key array\n      orderedBindings = orderedBindings.filter((bindingKey) => !arrayBindings.includes(bindingKey))\n    }\n\n    // handle buffer (non interleaved) elements\n    orderedBindings.forEach((bindingKey) => {\n      const binding = this.inputs[bindingKey]\n\n      const bufferElementOptions = {\n        name: toCamelCase(binding.name ?? bindingKey),\n        key: bindingKey,\n        type: binding.type,\n      }\n\n      const isArray =\n        binding.type.indexOf('array') !== -1 && (Array.isArray(binding.value) || ArrayBuffer.isView(binding.value))\n\n      this.bufferElements.push(\n        isArray\n          ? new BufferArrayElement({\n              ...bufferElementOptions,\n              arrayLength: (binding.value as number[]).length,\n            })\n          : new BufferElement(bufferElementOptions)\n      )\n    })\n\n    // set their alignments\n    this.bufferElements.forEach((bufferElement, index) => {\n      const startOffset = index === 0 ? 0 : this.bufferElements[index - 1].endOffset + 1\n\n      bufferElement.setAlignment(startOffset)\n    })\n\n    // now create our interleaved buffer elements\n    if (arrayBindings.length > 1) {\n      // first get the sizes of the arrays\n      const arraySizes = arrayBindings.map((bindingKey) => {\n        const binding = this.inputs[bindingKey]\n        const bufferLayout = getBufferLayout(binding.type.replace('array', '').replace('<', '').replace('>', ''))\n\n        return (binding.value as number[] | TypedArray).length / bufferLayout.numElements\n      })\n\n      // are they all of the same size?\n      const equalSize = arraySizes.every((size, i, array) => size === array[0])\n\n      if (equalSize) {\n        // this will hold our interleaved buffer elements\n        const interleavedBufferElements = arrayBindings.map((bindingKey) => {\n          const binding = this.inputs[bindingKey]\n          return new BufferInterleavedArrayElement({\n            name: toCamelCase(binding.name ?? bindingKey),\n            key: bindingKey,\n            type: binding.type,\n            arrayLength: (binding.value as number[]).length,\n          })\n        })\n\n        // now create temp buffer elements that we'll use to fill the interleaved buffer elements alignments\n        const tempBufferElements = arrayBindings.map((bindingKey) => {\n          const binding = this.inputs[bindingKey]\n          return new BufferElement({\n            name: toCamelCase(binding.name ?? bindingKey),\n            key: bindingKey,\n            type: binding.type.replace('array', '').replace('<', '').replace('>', ''),\n          })\n        })\n\n        // set temp buffer alignments as if it was regular buffer elements\n        tempBufferElements.forEach((bufferElement, index) => {\n          if (index === 0) {\n            if (this.bufferElements.length) {\n              // if there are already buffer elements\n              // get last one end row, and start at the next row\n              bufferElement.setAlignmentFromPosition({\n                row: this.bufferElements[this.bufferElements.length - 1].alignment.end.row + 1,\n                byte: 0,\n              })\n            } else {\n              bufferElement.setAlignment(0)\n            }\n          } else {\n            bufferElement.setAlignment(tempBufferElements[index - 1].endOffset + 1)\n          }\n        })\n\n        // now use last temp buffer end offset as our interleaved arrayStride\n        const totalStride =\n          tempBufferElements[tempBufferElements.length - 1].endOffset + 1 - tempBufferElements[0].startOffset\n\n        // finally, set interleaved buffer elements alignment\n        interleavedBufferElements.forEach((bufferElement, index) => {\n          bufferElement.setAlignment(tempBufferElements[index].startOffset, totalStride)\n        })\n\n        // add to our buffer elements array\n        this.bufferElements = [...this.bufferElements, ...interleavedBufferElements]\n      } else {\n        throwWarning(\n          `BufferBinding: \"${\n            this.label\n          }\" contains multiple array inputs that should use an interleaved array, but their sizes do not match. These inputs cannot be added to the BufferBinding: \"${arrayBindings.join(\n            ', '\n          )}\"`\n        )\n      }\n    }\n\n    this.arrayBufferSize = this.bufferElements.length\n      ? this.bufferElements[this.bufferElements.length - 1].paddedByteCount\n      : 0\n\n    this.arrayBuffer = new ArrayBuffer(this.arrayBufferSize)\n    this.arrayView = new DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength)\n\n    this.bufferElements.forEach((bufferElement) => {\n      bufferElement.setView(this.arrayBuffer, this.arrayView)\n    })\n\n    this.shouldUpdate = this.arrayBufferSize > 0\n  }\n\n  /**\n   * Set the WGSL code snippet to append to the shaders code. It consists of variable (and Struct structures if needed) declarations.\n   */\n  setWGSLFragment() {\n    const kebabCaseLabel = toKebabCase(this.label)\n\n    if (this.useStruct) {\n      const bufferElements = this.bufferElements.filter(\n        (bufferElement) => !(bufferElement instanceof BufferInterleavedArrayElement)\n      )\n      const interleavedBufferElements = this.bufferElements.filter(\n        (bufferElement) => bufferElement instanceof BufferInterleavedArrayElement\n      ) as BufferInterleavedArrayElement[]\n\n      if (interleavedBufferElements.length) {\n        const arrayLength = this.bindingType === 'uniform' ? `, ${interleavedBufferElements[0].numElements}` : ''\n\n        if (bufferElements.length) {\n          this.wgslStructFragment = `struct ${kebabCaseLabel}Element {\\n\\t${interleavedBufferElements\n            .map((binding) => binding.name + ': ' + binding.type.replace('array', '').replace('<', '').replace('>', ''))\n            .join(',\\n\\t')}\n};\\n\\n`\n\n          const interleavedBufferStructDeclaration = `${this.name}Element: array<${kebabCaseLabel}Element${arrayLength}>,`\n\n          this.wgslStructFragment += `struct ${kebabCaseLabel} {\\n\\t${bufferElements\n            .map((bufferElement) => bufferElement.name + ': ' + bufferElement.type)\n            .join(',\\n\\t')}\n\\t${interleavedBufferStructDeclaration}\n};`\n\n          const varType = getBindingWGSLVarType(this)\n          this.wgslGroupFragment = [`${varType} ${this.name}: ${kebabCaseLabel};`]\n        } else {\n          this.wgslStructFragment = `struct ${kebabCaseLabel} {\\n\\t${this.bufferElements\n            .map((binding) => binding.name + ': ' + binding.type.replace('array', '').replace('<', '').replace('>', ''))\n            .join(',\\n\\t')}\n};`\n\n          const varType = getBindingWGSLVarType(this)\n          this.wgslGroupFragment = [`${varType} ${this.name}: array<${kebabCaseLabel}${arrayLength}>;`]\n        }\n      } else {\n        this.wgslStructFragment = `struct ${kebabCaseLabel} {\\n\\t${this.bufferElements\n          .map((binding) => {\n            // now add array length if needed\n            const bindingType =\n              this.bindingType === 'uniform' && 'numElements' in binding\n                ? `array<${binding.type.replace('array', '').replace('<', '').replace('>', '')}, ${\n                    binding.numElements\n                  }>`\n                : binding.type\n            return binding.name + ': ' + bindingType\n          })\n          .join(',\\n\\t')}\n};`\n\n        const varType = getBindingWGSLVarType(this)\n        this.wgslGroupFragment = [`${varType} ${this.name}: ${kebabCaseLabel};`]\n      }\n    } else {\n      this.wgslStructFragment = ''\n      this.wgslGroupFragment = this.bufferElements.map((binding) => {\n        const varType = getBindingWGSLVarType(this)\n        return `${varType} ${binding.name}: ${binding.type};`\n      })\n    }\n  }\n\n  /**\n   * Set a binding shouldUpdate flag to true to update our {@link arrayBuffer} array during next render.\n   * @param bindingName - the binding name/key to update\n   */\n  shouldUpdateBinding(bindingName = '') {\n    const bindingKey = Object.keys(this.inputs).find((bindingKey) => this.inputs[bindingKey].name === bindingName)\n\n    if (bindingKey) this.inputs[bindingKey].shouldUpdate = true\n  }\n\n  /**\n   * Executed at the beginning of a Material render call.\n   * If any of the {@link inputs} has changed, run its onBeforeUpdate callback then updates our {@link arrayBuffer} array.\n   * Also sets the {@link shouldUpdate} property to true so the {@link core/bindGroups/BindGroup.BindGroup | BindGroup} knows it will need to update the {@link GPUBuffer}.\n   */\n  update() {\n    Object.keys(this.inputs).forEach((bindingKey) => {\n      const binding = this.inputs[bindingKey]\n      const bufferElement = this.bufferElements.find((bufferEl) => bufferEl.key === bindingKey)\n\n      if (binding.shouldUpdate && bufferElement) {\n        binding.onBeforeUpdate && binding.onBeforeUpdate()\n        // we're going to directly update the arrayBuffer from the buffer element update method\n        bufferElement.update(binding.value)\n\n        this.shouldUpdate = true\n        binding.shouldUpdate = false\n      }\n    })\n  }\n\n  /**\n   * Extract the data corresponding to a specific {@link BufferElement} from a {@link Float32Array} holding the {@link BufferBinding#buffer | GPU buffer} data of this {@link BufferBinding}\n   * @param parameters - parameters used to extract the data\n   * @param parameters.result - {@link Float32Array} holding {@link GPUBuffer} data\n   * @param parameters.bufferElementName - name of the {@link BufferElement} to use to extract the data\n   * @returns - extracted data from the {@link Float32Array}\n   */\n  extractBufferElementDataFromBufferResult({\n    result,\n    bufferElementName,\n  }: {\n    result: Float32Array\n    bufferElementName: BufferElement['name']\n  }): Float32Array {\n    const bufferElement = this.bufferElements.find((bufferElement) => bufferElement.name === bufferElementName)\n    if (bufferElement) {\n      return bufferElement.extractDataFromBufferResult(result)\n    } else {\n      return result\n    }\n  }\n}\n"],"names":["bindingKey","bufferElement"],"mappings":"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"}