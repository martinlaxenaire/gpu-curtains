{"version":3,"file":"GPUDeviceManager.mjs","sources":["../../../../src/core/renderers/GPUDeviceManager.ts"],"sourcesContent":["import { throwError, throwWarning } from '../../utils/utils'\nimport { generateMips, Renderer } from './utils'\nimport { Sampler } from '../samplers/Sampler'\nimport { PipelineManager } from '../pipelines/PipelineManager'\nimport { SceneObject } from './GPURenderer'\nimport { Texture } from '../textures/Texture'\nimport { AllowedBindGroups } from '../../types/BindGroups'\n\n/**\n * Parameters used to create a {@link GPUDeviceManager}\n */\nexport interface GPUDeviceManagerParams {\n  /** The label of the {@link GPUDeviceManager}, used to create the {@link GPUDevice} for debugging purpose */\n  label?: string\n  /** Flag indicating whether we're running the production mode or not. If not, useful warnings could be logged to the console */\n  production?: boolean\n  /** Callback to run if there's any error while trying to set up the {@link GPUAdapter | adapter} or {@link GPUDevice | device} */\n  onError?: () => void\n  /** Callback to run whenever the {@link GPUDeviceManager#device | device} is lost */\n  onDeviceLost?: (info?: GPUDeviceLostInfo) => void\n}\n\n/**\n * Responsible for the WebGPU {@link GPUAdapter | adapter} and {@link GPUDevice | device} creations, losing and restoration.\n *\n * It will create all the GPU objects that need a {@link GPUDevice | device} to do so, as well as a {@link PipelineManager}. It will also keep a track of all the {@link Renderer}, {@link AllowedBindGroups | bind groups}, {@link Sampler}, {@link Texture} and {@link GPUBuffer | GPU buffers} created.\n *\n * The {@link GPUDeviceManager} is also responsible for creating the {@link GPUCommandBuffer}, rendering all the {@link Renderer} and then submitting the {@link GPUCommandBuffer} at each {@link GPUDeviceManager#render | render} calls.\n */\nexport class GPUDeviceManager {\n  /** Number of times a {@link GPUDevice} has been created */\n  index: number\n  /** The label of the {@link GPUDeviceManager}, used to create the {@link GPUDevice} for debugging purpose */\n  label: string\n\n  /** Flag indicating whether we're running the production mode or not. If not, useful warnings could be logged to the console */\n  production: boolean\n\n  /** The navigator {@link GPU} object */\n  gpu: GPU | undefined\n  /** The WebGPU {@link GPUAdapter | adapter} used */\n  adapter: GPUAdapter | void\n  /** The WebGPU {@link GPUAdapter | adapter} informations */\n  adapterInfos: GPUAdapterInfo | undefined\n  /** The WebGPU {@link GPUDevice | device} used */\n  device: GPUDevice | undefined\n  /** Flag indicating whether the {@link GPUDeviceManager} is ready, i.e. its {@link adapter} and {@link device} have been successfully created */\n  ready: boolean\n\n  /** The {@link PipelineManager} used to cache {@link GPURenderPipeline} and {@link GPUComputePipeline} and set them only when appropriate */\n  pipelineManager: PipelineManager\n\n  /** Array of {@link Renderer | renderers} using that {@link GPUDeviceManager} */\n  renderers: Renderer[]\n  /** An array containing all our created {@link AllowedBindGroups} */\n  bindGroups: AllowedBindGroups[]\n  /** An array containing all our created {@link GPUBuffer} */\n  buffers: GPUBuffer[]\n  /** An array containing all our created {@link Sampler} */\n  samplers: Sampler[]\n  /** An array containing all our created {@link Texture} */\n  textures: Texture[]\n  /** An array to keep track of the newly uploaded {@link Texture | textures} and set their {@link Texture#sourceUploaded | sourceUploaded} property */\n  texturesQueue: Texture[]\n\n  /** Callback to run if there's any error while trying to set up the {@link GPUAdapter | adapter} or {@link GPUDevice | device} */\n  onError: () => void\n  /** Callback to run whenever the {@link device} is lost */\n  onDeviceLost: (info?: GPUDeviceLostInfo) => void\n\n  /**\n   * GPUDeviceManager constructor\n   * @param parameters - {@link GPUDeviceManagerParams | parameters} used to create this {@link GPUDeviceManager}\n   */\n  constructor({\n    label,\n    production = false,\n    onError = () => {\n      /* allow empty callbacks */\n    },\n    onDeviceLost = (info?: GPUDeviceLostInfo) => {\n      /* allow empty callbacks */\n    },\n  }: GPUDeviceManagerParams) {\n    this.index = 0\n    this.label = label ?? 'GPUDeviceManager instance'\n    this.production = production\n    this.ready = false\n\n    this.onError = onError\n    this.onDeviceLost = onDeviceLost\n\n    this.gpu = navigator.gpu\n\n    this.setPipelineManager()\n    this.setDeviceObjects()\n  }\n\n  /**\n   * Set our {@link adapter} and {@link device} if possible\n   */\n  async setAdapterAndDevice() {\n    await this.setAdapter()\n    await this.setDevice()\n  }\n\n  /**\n   * Set up our {@link adapter} and {@link device} and all the already created {@link renderers} contexts\n   */\n  async init() {\n    await this.setAdapterAndDevice()\n\n    // set context\n    if (this.device) {\n      this.renderers.forEach((renderer) => {\n        if (!renderer.context) {\n          renderer.setContext()\n        }\n      })\n    }\n  }\n\n  /**\n   * Set our {@link adapter} if possible.\n   * The adapter represents a specific GPU. Some devices have multiple GPUs.\n   * @async\n   */\n  async setAdapter() {\n    if (!this.gpu) {\n      this.onError()\n      throwError(\"GPURenderer: WebGPU is not supported on your browser/OS. No 'gpu' object in 'navigator'.\")\n    }\n\n    try {\n      this.adapter = await this.gpu?.requestAdapter()\n      ;(this.adapter as GPUAdapter)?.requestAdapterInfo().then((infos) => {\n        this.adapterInfos = infos\n      })\n    } catch (error) {\n      this.onError()\n      throwError(\"GPUDeviceManager: WebGPU is not supported on your browser/OS. 'requestAdapter' failed.\")\n    }\n  }\n\n  /**\n   * Set our {@link device}\n   * @async\n   */\n  async setDevice() {\n    try {\n      this.device = await (this.adapter as GPUAdapter)?.requestDevice({\n        label: this.label + ' ' + this.index,\n      })\n\n      if (this.device) {\n        this.ready = true\n        this.index++\n      }\n    } catch (error) {\n      this.onError()\n      throwError(`${this.label}: WebGPU is not supported on your browser/OS. 'requestDevice' failed: ${error}`)\n    }\n\n    this.device?.lost.then((info) => {\n      throwWarning(`${this.label}: WebGPU device was lost: ${info.message}`)\n\n      this.loseDevice()\n\n      // do not call onDeviceLost event if the device was intentionally destroyed\n      if (info.reason !== 'destroyed') {\n        this.onDeviceLost(info)\n      }\n    })\n  }\n\n  /**\n   * Set our {@link pipelineManager | pipeline manager}\n   */\n  setPipelineManager() {\n    this.pipelineManager = new PipelineManager()\n  }\n\n  /**\n   * Called when the {@link device} is lost.\n   * Reset all our renderers\n   */\n  loseDevice() {\n    this.ready = false\n\n    // first clean all samplers\n    this.samplers.forEach((sampler) => (sampler.sampler = null))\n\n    this.renderers.forEach((renderer) => renderer.loseContext())\n\n    // reset the buffers array, it would eventually be repopulated while restoring the device\n    this.buffers = []\n  }\n\n  /**\n   * Called when the {@link device} should be restored.\n   * Restore all our renderers\n   */\n  async restoreDevice() {\n    await this.setAdapterAndDevice()\n\n    if (this.device) {\n      // now recreate all the samplers\n      this.samplers.forEach((sampler) => {\n        const { type, ...samplerOptions } = sampler.options\n        sampler.sampler = this.device.createSampler({\n          label: sampler.label,\n          ...samplerOptions,\n        })\n      })\n\n      // then the renderers\n      this.renderers.forEach((renderer) => renderer.restoreContext())\n    }\n  }\n\n  /**\n   * Set all objects arrays that we'll keep track of\n   */\n  setDeviceObjects() {\n    // keep track of renderers, bind groups, buffers, samplers, textures\n    this.renderers = []\n    this.bindGroups = []\n    this.buffers = []\n    this.samplers = []\n    this.textures = []\n\n    // keep track of all textures that are being uploaded\n    this.texturesQueue = []\n  }\n\n  /**\n   * Add a {@link Renderer} to our {@link renderers} array\n   * @param renderer - {@link Renderer} to add\n   */\n  addRenderer(renderer: Renderer) {\n    this.renderers.push(renderer)\n  }\n\n  /**\n   * Remove a {@link Renderer} from our {@link renderers} array\n   * @param renderer - {@link Renderer} to remove\n   */\n  removeRenderer(renderer: Renderer) {\n    this.renderers = this.renderers.filter((r) => r.uuid !== renderer.uuid)\n  }\n\n  /**\n   * Get all the rendered objects (i.e. compute passes, meshes, ping pong planes and shader passes) created by this {@link GPUDeviceManager}\n   * @readonly\n   */\n  get deviceRenderedObjects(): SceneObject[] {\n    return this.renderers.map((renderer) => renderer.renderedObjects).flat()\n  }\n\n  /**\n   * Add a {@link AllowedBindGroups | bind group} to our {@link bindGroups | bind groups array}\n   * @param bindGroup - {@link AllowedBindGroups | bind group} to add\n   */\n  addBindGroup(bindGroup: AllowedBindGroups) {\n    if (!this.bindGroups.find((bG) => bG.uuid === bindGroup.uuid)) {\n      this.bindGroups.push(bindGroup)\n    }\n  }\n\n  /**\n   * Remove a {@link AllowedBindGroups | bind group} from our {@link bindGroups | bind groups array}\n   * @param bindGroup - {@link AllowedBindGroups | bind group} to remove\n   */\n  removeBindGroup(bindGroup: AllowedBindGroups) {\n    this.bindGroups = this.bindGroups.filter((bG) => bG.uuid !== bindGroup.uuid)\n  }\n\n  /**\n   * Add a {@link GPUBuffer} to our our {@link buffers} array\n   * @param buffer - {@link GPUBuffer} to add\n   */\n  addBuffer(buffer: GPUBuffer) {\n    this.buffers.push(buffer)\n  }\n\n  /**\n   * Remove a {@link GPUBuffer} from our {@link buffers} array\n   * @param buffer - {@link GPUBuffer} to remove\n   * @param [originalLabel] - original {@link GPUBuffer} label in case the buffer has been swapped and its label has changed\n   */\n  removeBuffer(buffer: GPUBuffer, originalLabel?: string) {\n    if (buffer) {\n      this.buffers = this.buffers.filter((b) => {\n        return !(b.label === (originalLabel ?? buffer.label) && b.size === buffer.size)\n      })\n    }\n  }\n\n  /**\n   * Add a {@link Sampler} to our {@link samplers} array\n   * @param sampler - {@link Sampler} to add\n   */\n  addSampler(sampler: Sampler) {\n    this.samplers.push(sampler)\n  }\n\n  /**\n   * Remove a {@link Sampler} from our {@link samplers} array\n   * @param sampler - {@link Sampler} to remove\n   */\n  removeSampler(sampler: Sampler) {\n    this.samplers = this.samplers.filter((s) => s.uuid !== sampler.uuid)\n  }\n\n  /**\n   * Add a {@link Texture} to our {@link textures} array\n   * @param texture - {@link Texture} to add\n   */\n  addTexture(texture: Texture) {\n    this.textures.push(texture)\n  }\n\n  /**\n   * Upload a {@link Texture#texture | texture} to the GPU\n   * @param texture - {@link Texture} class object with the {@link Texture#texture | texture} to upload\n   */\n  uploadTexture(texture: Texture) {\n    if (texture.source) {\n      try {\n        this.device?.queue.copyExternalImageToTexture(\n          {\n            source: texture.source as GPUImageCopyExternalImageSource,\n            flipY: texture.options.flipY,\n          } as GPUImageCopyExternalImage,\n          { texture: texture.texture as GPUTexture, premultipliedAlpha: texture.options.premultipliedAlpha },\n          { width: texture.size.width, height: texture.size.height }\n        )\n\n        if ((texture.texture as GPUTexture).mipLevelCount > 1) {\n          generateMips(this.device, texture.texture as GPUTexture)\n        }\n\n        // add to our textures queue array to track when it has been uploaded\n        this.texturesQueue.push(texture)\n      } catch ({ message }) {\n        throwError(`GPUDeviceManager: could not upload texture: ${texture.options.name} because: ${message}`)\n      }\n    } else {\n      this.device?.queue.writeTexture(\n        { texture: texture.texture as GPUTexture },\n        new Uint8Array(texture.options.placeholderColor),\n        { bytesPerRow: texture.size.width * 4 },\n        { width: texture.size.width, height: texture.size.height }\n      )\n    }\n  }\n\n  /**\n   * Remove a {@link Texture} from our {@link textures} array\n   * @param texture - {@link Texture} to remove\n   */\n  removeTexture(texture: Texture) {\n    this.textures = this.textures.filter((t) => t.uuid !== texture.uuid)\n  }\n\n  /**\n   * Render everything:\n   * - call all our {@link renderers} {@link core/renderers/GPURenderer.GPURenderer#onBeforeCommandEncoder | onBeforeCommandEncoder} callbacks\n   * - create a {@link GPUCommandEncoder}\n   * - render all our {@link renderers}\n   * - submit our {@link GPUCommandBuffer}\n   * - upload {@link Texture#texture | textures} that do not have a parentMesh\n   * - empty our {@link texturesQueue} array\n   * - call all our {@link renderers} {@link core/renderers/GPURenderer.GPURenderer#onAfterCommandEncoder | onAfterCommandEncoder} callbacks\n   */\n  render() {\n    if (!this.ready) return\n\n    this.renderers.forEach((renderer) => renderer.onBeforeCommandEncoder())\n\n    const commandEncoder = this.device?.createCommandEncoder({ label: this.label + ' command encoder' })\n    !this.production && commandEncoder.pushDebugGroup(this.label + ' command encoder: main render loop')\n\n    this.renderers.forEach((renderer) => renderer.render(commandEncoder))\n\n    !this.production && commandEncoder.popDebugGroup()\n    const commandBuffer = commandEncoder.finish()\n    this.device?.queue.submit([commandBuffer])\n\n    // handle textures\n    // first check if media textures without parentMesh need to be uploaded\n    this.textures\n      .filter((texture) => !texture.parentMesh && texture.sourceLoaded && !texture.sourceUploaded)\n      .forEach((texture) => this.uploadTexture(texture))\n\n    // no need to use device.queue.onSubmittedWorkDone\n    // as [Kai Ninomiya](https://github.com/kainino0x) stated:\n    // \"Anything you submit() after the copyExternalImageToTexture() is guaranteed to see the result of that call.\"\n    this.texturesQueue.forEach((texture) => {\n      texture.sourceUploaded = true\n    })\n\n    // clear texture queue\n    this.texturesQueue = []\n\n    this.renderers.forEach((renderer) => renderer.onAfterCommandEncoder())\n  }\n\n  /**\n   * Destroy the {@link GPUDeviceManager} and its {@link renderers}\n   */\n  destroy() {\n    this.device?.destroy()\n    this.device = null\n\n    this.renderers.forEach((renderer) => renderer.destroy())\n\n    // now clear everything that could have been left behind\n    this.bindGroups.forEach((bindGroup) => bindGroup.destroy())\n    this.buffers.forEach((buffer) => buffer?.destroy())\n\n    this.textures.forEach((texture) => texture.destroy())\n\n    this.setDeviceObjects()\n  }\n}\n"],"names":[],"mappings":";;;;AA6BO,MAAM,gBAAiB,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA6C5B,WAAY,CAAA;AAAA,IACV,KAAA;AAAA,IACA,UAAa,GAAA,KAAA;AAAA,IACb,UAAU,MAAM;AAAA,KAEhB;AAAA,IACA,YAAA,GAAe,CAAC,IAA6B,KAAA;AAAA,KAE7C;AAAA,GACyB,EAAA;AACzB,IAAA,IAAA,CAAK,KAAQ,GAAA,CAAA,CAAA;AACb,IAAA,IAAA,CAAK,QAAQ,KAAS,IAAA,2BAAA,CAAA;AACtB,IAAA,IAAA,CAAK,UAAa,GAAA,UAAA,CAAA;AAClB,IAAA,IAAA,CAAK,KAAQ,GAAA,KAAA,CAAA;AAEb,IAAA,IAAA,CAAK,OAAU,GAAA,OAAA,CAAA;AACf,IAAA,IAAA,CAAK,YAAe,GAAA,YAAA,CAAA;AAEpB,IAAA,IAAA,CAAK,MAAM,SAAU,CAAA,GAAA,CAAA;AAErB,IAAA,IAAA,CAAK,kBAAmB,EAAA,CAAA;AACxB,IAAA,IAAA,CAAK,gBAAiB,EAAA,CAAA;AAAA,GACxB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,mBAAsB,GAAA;AAC1B,IAAA,MAAM,KAAK,UAAW,EAAA,CAAA;AACtB,IAAA,MAAM,KAAK,SAAU,EAAA,CAAA;AAAA,GACvB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IAAO,GAAA;AACX,IAAA,MAAM,KAAK,mBAAoB,EAAA,CAAA;AAG/B,IAAA,IAAI,KAAK,MAAQ,EAAA;AACf,MAAK,IAAA,CAAA,SAAA,CAAU,OAAQ,CAAA,CAAC,QAAa,KAAA;AACnC,QAAI,IAAA,CAAC,SAAS,OAAS,EAAA;AACrB,UAAA,QAAA,CAAS,UAAW,EAAA,CAAA;AAAA,SACtB;AAAA,OACD,CAAA,CAAA;AAAA,KACH;AAAA,GACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,UAAa,GAAA;AACjB,IAAI,IAAA,CAAC,KAAK,GAAK,EAAA;AACb,MAAA,IAAA,CAAK,OAAQ,EAAA,CAAA;AACb,MAAA,UAAA,CAAW,0FAA0F,CAAA,CAAA;AAAA,KACvG;AAEA,IAAI,IAAA;AACF,MAAA,IAAA,CAAK,OAAU,GAAA,MAAM,IAAK,CAAA,GAAA,EAAK,cAAe,EAAA,CAAA;AAC7C,MAAC,KAAK,OAAwB,EAAA,kBAAA,EAAqB,CAAA,IAAA,CAAK,CAAC,KAAU,KAAA;AAClE,QAAA,IAAA,CAAK,YAAe,GAAA,KAAA,CAAA;AAAA,OACrB,CAAA,CAAA;AAAA,aACM,KAAO,EAAA;AACd,MAAA,IAAA,CAAK,OAAQ,EAAA,CAAA;AACb,MAAA,UAAA,CAAW,wFAAwF,CAAA,CAAA;AAAA,KACrG;AAAA,GACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,SAAY,GAAA;AAChB,IAAI,IAAA;AACF,MAAA,IAAA,CAAK,MAAS,GAAA,MAAO,IAAK,CAAA,OAAA,EAAwB,aAAc,CAAA;AAAA,QAC9D,KAAO,EAAA,IAAA,CAAK,KAAQ,GAAA,GAAA,GAAM,IAAK,CAAA,KAAA;AAAA,OAChC,CAAA,CAAA;AAED,MAAA,IAAI,KAAK,MAAQ,EAAA;AACf,QAAA,IAAA,CAAK,KAAQ,GAAA,IAAA,CAAA;AACb,QAAK,IAAA,CAAA,KAAA,EAAA,CAAA;AAAA,OACP;AAAA,aACO,KAAO,EAAA;AACd,MAAA,IAAA,CAAK,OAAQ,EAAA,CAAA;AACb,MAAA,UAAA,CAAW,CAAG,EAAA,IAAA,CAAK,KAAK,CAAA,sEAAA,EAAyE,KAAK,CAAE,CAAA,CAAA,CAAA;AAAA,KAC1G;AAEA,IAAA,IAAA,CAAK,MAAQ,EAAA,IAAA,CAAK,IAAK,CAAA,CAAC,IAAS,KAAA;AAC/B,MAAA,YAAA,CAAa,GAAG,IAAK,CAAA,KAAK,CAA6B,0BAAA,EAAA,IAAA,CAAK,OAAO,CAAE,CAAA,CAAA,CAAA;AAErE,MAAA,IAAA,CAAK,UAAW,EAAA,CAAA;AAGhB,MAAI,IAAA,IAAA,CAAK,WAAW,WAAa,EAAA;AAC/B,QAAA,IAAA,CAAK,aAAa,IAAI,CAAA,CAAA;AAAA,OACxB;AAAA,KACD,CAAA,CAAA;AAAA,GACH;AAAA;AAAA;AAAA;AAAA,EAKA,kBAAqB,GAAA;AACnB,IAAK,IAAA,CAAA,eAAA,GAAkB,IAAI,eAAgB,EAAA,CAAA;AAAA,GAC7C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAa,GAAA;AACX,IAAA,IAAA,CAAK,KAAQ,GAAA,KAAA,CAAA;AAGb,IAAA,IAAA,CAAK,SAAS,OAAQ,CAAA,CAAC,OAAa,KAAA,OAAA,CAAQ,UAAU,IAAK,CAAA,CAAA;AAE3D,IAAA,IAAA,CAAK,UAAU,OAAQ,CAAA,CAAC,QAAa,KAAA,QAAA,CAAS,aAAa,CAAA,CAAA;AAG3D,IAAA,IAAA,CAAK,UAAU,EAAC,CAAA;AAAA,GAClB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,aAAgB,GAAA;AACpB,IAAA,MAAM,KAAK,mBAAoB,EAAA,CAAA;AAE/B,IAAA,IAAI,KAAK,MAAQ,EAAA;AAEf,MAAK,IAAA,CAAA,QAAA,CAAS,OAAQ,CAAA,CAAC,OAAY,KAAA;AACjC,QAAA,MAAM,EAAE,IAAA,EAAM,GAAG,cAAA,KAAmB,OAAQ,CAAA,OAAA,CAAA;AAC5C,QAAQ,OAAA,CAAA,OAAA,GAAU,IAAK,CAAA,MAAA,CAAO,aAAc,CAAA;AAAA,UAC1C,OAAO,OAAQ,CAAA,KAAA;AAAA,UACf,GAAG,cAAA;AAAA,SACJ,CAAA,CAAA;AAAA,OACF,CAAA,CAAA;AAGD,MAAA,IAAA,CAAK,UAAU,OAAQ,CAAA,CAAC,QAAa,KAAA,QAAA,CAAS,gBAAgB,CAAA,CAAA;AAAA,KAChE;AAAA,GACF;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAmB,GAAA;AAEjB,IAAA,IAAA,CAAK,YAAY,EAAC,CAAA;AAClB,IAAA,IAAA,CAAK,aAAa,EAAC,CAAA;AACnB,IAAA,IAAA,CAAK,UAAU,EAAC,CAAA;AAChB,IAAA,IAAA,CAAK,WAAW,EAAC,CAAA;AACjB,IAAA,IAAA,CAAK,WAAW,EAAC,CAAA;AAGjB,IAAA,IAAA,CAAK,gBAAgB,EAAC,CAAA;AAAA,GACxB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY,QAAoB,EAAA;AAC9B,IAAK,IAAA,CAAA,SAAA,CAAU,KAAK,QAAQ,CAAA,CAAA;AAAA,GAC9B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,eAAe,QAAoB,EAAA;AACjC,IAAK,IAAA,CAAA,SAAA,GAAY,KAAK,SAAU,CAAA,MAAA,CAAO,CAAC,CAAM,KAAA,CAAA,CAAE,IAAS,KAAA,QAAA,CAAS,IAAI,CAAA,CAAA;AAAA,GACxE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,qBAAuC,GAAA;AACzC,IAAO,OAAA,IAAA,CAAK,UAAU,GAAI,CAAA,CAAC,aAAa,QAAS,CAAA,eAAe,EAAE,IAAK,EAAA,CAAA;AAAA,GACzE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,aAAa,SAA8B,EAAA;AACzC,IAAI,IAAA,CAAC,IAAK,CAAA,UAAA,CAAW,IAAK,CAAA,CAAC,OAAO,EAAG,CAAA,IAAA,KAAS,SAAU,CAAA,IAAI,CAAG,EAAA;AAC7D,MAAK,IAAA,CAAA,UAAA,CAAW,KAAK,SAAS,CAAA,CAAA;AAAA,KAChC;AAAA,GACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,gBAAgB,SAA8B,EAAA;AAC5C,IAAK,IAAA,CAAA,UAAA,GAAa,KAAK,UAAW,CAAA,MAAA,CAAO,CAAC,EAAO,KAAA,EAAA,CAAG,IAAS,KAAA,SAAA,CAAU,IAAI,CAAA,CAAA;AAAA,GAC7E;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAU,MAAmB,EAAA;AAC3B,IAAK,IAAA,CAAA,OAAA,CAAQ,KAAK,MAAM,CAAA,CAAA;AAAA,GAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAA,CAAa,QAAmB,aAAwB,EAAA;AACtD,IAAA,IAAI,MAAQ,EAAA;AACV,MAAA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAK,OAAQ,CAAA,MAAA,CAAO,CAAC,CAAM,KAAA;AACxC,QAAO,OAAA,EAAE,EAAE,KAAW,MAAA,aAAA,IAAiB,OAAO,KAAU,CAAA,IAAA,CAAA,CAAE,SAAS,MAAO,CAAA,IAAA,CAAA,CAAA;AAAA,OAC3E,CAAA,CAAA;AAAA,KACH;AAAA,GACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAW,OAAkB,EAAA;AAC3B,IAAK,IAAA,CAAA,QAAA,CAAS,KAAK,OAAO,CAAA,CAAA;AAAA,GAC5B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,cAAc,OAAkB,EAAA;AAC9B,IAAK,IAAA,CAAA,QAAA,GAAW,KAAK,QAAS,CAAA,MAAA,CAAO,CAAC,CAAM,KAAA,CAAA,CAAE,IAAS,KAAA,OAAA,CAAQ,IAAI,CAAA,CAAA;AAAA,GACrE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAW,OAAkB,EAAA;AAC3B,IAAK,IAAA,CAAA,QAAA,CAAS,KAAK,OAAO,CAAA,CAAA;AAAA,GAC5B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,cAAc,OAAkB,EAAA;AAC9B,IAAA,IAAI,QAAQ,MAAQ,EAAA;AAClB,MAAI,IAAA;AACF,QAAA,IAAA,CAAK,QAAQ,KAAM,CAAA,0BAAA;AAAA,UACjB;AAAA,YACE,QAAQ,OAAQ,CAAA,MAAA;AAAA,YAChB,KAAA,EAAO,QAAQ,OAAQ,CAAA,KAAA;AAAA,WACzB;AAAA,UACA,EAAE,OAAS,EAAA,OAAA,CAAQ,SAAuB,kBAAoB,EAAA,OAAA,CAAQ,QAAQ,kBAAmB,EAAA;AAAA,UACjG,EAAE,OAAO,OAAQ,CAAA,IAAA,CAAK,OAAO,MAAQ,EAAA,OAAA,CAAQ,KAAK,MAAO,EAAA;AAAA,SAC3D,CAAA;AAEA,QAAK,IAAA,OAAA,CAAQ,OAAuB,CAAA,aAAA,GAAgB,CAAG,EAAA;AACrD,UAAa,YAAA,CAAA,IAAA,CAAK,MAAQ,EAAA,OAAA,CAAQ,OAAqB,CAAA,CAAA;AAAA,SACzD;AAGA,QAAK,IAAA,CAAA,aAAA,CAAc,KAAK,OAAO,CAAA,CAAA;AAAA,OACjC,CAAA,OAAS,EAAE,OAAA,EAAW,EAAA;AACpB,QAAA,UAAA,CAAW,+CAA+C,OAAQ,CAAA,OAAA,CAAQ,IAAI,CAAA,UAAA,EAAa,OAAO,CAAE,CAAA,CAAA,CAAA;AAAA,OACtG;AAAA,KACK,MAAA;AACL,MAAA,IAAA,CAAK,QAAQ,KAAM,CAAA,YAAA;AAAA,QACjB,EAAE,OAAS,EAAA,OAAA,CAAQ,OAAsB,EAAA;AAAA,QACzC,IAAI,UAAA,CAAW,OAAQ,CAAA,OAAA,CAAQ,gBAAgB,CAAA;AAAA,QAC/C,EAAE,WAAA,EAAa,OAAQ,CAAA,IAAA,CAAK,QAAQ,CAAE,EAAA;AAAA,QACtC,EAAE,OAAO,OAAQ,CAAA,IAAA,CAAK,OAAO,MAAQ,EAAA,OAAA,CAAQ,KAAK,MAAO,EAAA;AAAA,OAC3D,CAAA;AAAA,KACF;AAAA,GACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,cAAc,OAAkB,EAAA;AAC9B,IAAK,IAAA,CAAA,QAAA,GAAW,KAAK,QAAS,CAAA,MAAA,CAAO,CAAC,CAAM,KAAA,CAAA,CAAE,IAAS,KAAA,OAAA,CAAQ,IAAI,CAAA,CAAA;AAAA,GACrE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAS,GAAA;AACP,IAAA,IAAI,CAAC,IAAK,CAAA,KAAA;AAAO,MAAA,OAAA;AAEjB,IAAA,IAAA,CAAK,UAAU,OAAQ,CAAA,CAAC,QAAa,KAAA,QAAA,CAAS,wBAAwB,CAAA,CAAA;AAEtE,IAAM,MAAA,cAAA,GAAiB,KAAK,MAAQ,EAAA,oBAAA,CAAqB,EAAE,KAAO,EAAA,IAAA,CAAK,KAAQ,GAAA,kBAAA,EAAoB,CAAA,CAAA;AACnG,IAAA,CAAC,KAAK,UAAc,IAAA,cAAA,CAAe,cAAe,CAAA,IAAA,CAAK,QAAQ,oCAAoC,CAAA,CAAA;AAEnG,IAAA,IAAA,CAAK,UAAU,OAAQ,CAAA,CAAC,aAAa,QAAS,CAAA,MAAA,CAAO,cAAc,CAAC,CAAA,CAAA;AAEpE,IAAC,CAAA,IAAA,CAAK,UAAc,IAAA,cAAA,CAAe,aAAc,EAAA,CAAA;AACjD,IAAM,MAAA,aAAA,GAAgB,eAAe,MAAO,EAAA,CAAA;AAC5C,IAAA,IAAA,CAAK,MAAQ,EAAA,KAAA,CAAM,MAAO,CAAA,CAAC,aAAa,CAAC,CAAA,CAAA;AAIzC,IAAA,IAAA,CAAK,SACF,MAAO,CAAA,CAAC,YAAY,CAAC,OAAA,CAAQ,cAAc,OAAQ,CAAA,YAAA,IAAgB,CAAC,OAAQ,CAAA,cAAc,EAC1F,OAAQ,CAAA,CAAC,YAAY,IAAK,CAAA,aAAA,CAAc,OAAO,CAAC,CAAA,CAAA;AAKnD,IAAK,IAAA,CAAA,aAAA,CAAc,OAAQ,CAAA,CAAC,OAAY,KAAA;AACtC,MAAA,OAAA,CAAQ,cAAiB,GAAA,IAAA,CAAA;AAAA,KAC1B,CAAA,CAAA;AAGD,IAAA,IAAA,CAAK,gBAAgB,EAAC,CAAA;AAEtB,IAAA,IAAA,CAAK,UAAU,OAAQ,CAAA,CAAC,QAAa,KAAA,QAAA,CAAS,uBAAuB,CAAA,CAAA;AAAA,GACvE;AAAA;AAAA;AAAA;AAAA,EAKA,OAAU,GAAA;AACR,IAAA,IAAA,CAAK,QAAQ,OAAQ,EAAA,CAAA;AACrB,IAAA,IAAA,CAAK,MAAS,GAAA,IAAA,CAAA;AAEd,IAAA,IAAA,CAAK,UAAU,OAAQ,CAAA,CAAC,QAAa,KAAA,QAAA,CAAS,SAAS,CAAA,CAAA;AAGvD,IAAA,IAAA,CAAK,WAAW,OAAQ,CAAA,CAAC,SAAc,KAAA,SAAA,CAAU,SAAS,CAAA,CAAA;AAC1D,IAAA,IAAA,CAAK,QAAQ,OAAQ,CAAA,CAAC,MAAW,KAAA,MAAA,EAAQ,SAAS,CAAA,CAAA;AAElD,IAAA,IAAA,CAAK,SAAS,OAAQ,CAAA,CAAC,OAAY,KAAA,OAAA,CAAQ,SAAS,CAAA,CAAA;AAEpD,IAAA,IAAA,CAAK,gBAAiB,EAAA,CAAA;AAAA,GACxB;AACF;;;;"}