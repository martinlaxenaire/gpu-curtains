{"version":3,"file":"GPUCameraRenderer.mjs","sources":["../../../../src/core/renderers/GPUCameraRenderer.ts"],"sourcesContent":["import { GPURenderer, GPURendererParams, ProjectedMesh, RenderedMesh, SceneObject } from './GPURenderer'\r\nimport { Camera, CameraBasePerspectiveOptions } from '../camera/Camera'\r\nimport { BufferBinding } from '../bindings/BufferBinding'\r\nimport { BindGroup } from '../bindGroups/BindGroup'\r\nimport { Vec3 } from '../../math/Vec3'\r\nimport { AllowedBindGroups } from '../../types/BindGroups'\r\n\r\n/**\r\n * Parameters used to create a {@link GPUCameraRenderer}\r\n */\r\nexport interface GPUCameraRendererParams extends GPURendererParams {\r\n  /** An object defining {@link CameraBasePerspectiveOptions | camera perspective parameters} */\r\n  camera: CameraBasePerspectiveOptions\r\n}\r\n\r\n/**\r\n * This renderer also creates a {@link Camera} and its associated {@link cameraBufferBinding | binding} and {@link cameraBindGroup | bind group}.<br>\r\n * Can be safely used to render compute passes and meshes if they do not need to be tied to the DOM.\r\n *\r\n * @example\r\n * ```javascript\r\n * // first, we need a WebGPU device, that's what GPUDeviceManager is for\r\n * const gpuDeviceManager = new GPUDeviceManager({\r\n *   label: 'Custom device manager',\r\n * })\r\n *\r\n * // we need to wait for the WebGPU device to be created\r\n * await gpuDeviceManager.init()\r\n *\r\n * // then we can create a camera renderer\r\n * const gpuCameraRenderer = new GPUCameraRenderer({\r\n *   deviceManager: gpuDeviceManager, // we need the WebGPU device to create the renderer context\r\n *   container: document.querySelector('#canvas'),\r\n * })\r\n * ```\r\n */\r\nexport class GPUCameraRenderer extends GPURenderer {\r\n  /** {@link Camera} used by this {@link GPUCameraRenderer} */\r\n  camera: Camera\r\n  /** {@link BufferBinding | binding} handling the {@link camera} matrices */\r\n  cameraBufferBinding: BufferBinding\r\n  /** {@link BindGroup | bind group} handling the {@link cameraBufferBinding | camera buffer binding} */\r\n  cameraBindGroup: BindGroup\r\n\r\n  /** Options used to create this {@link GPUCameraRenderer} */\r\n  options: GPUCameraRendererParams\r\n\r\n  /**\r\n   * GPUCameraRenderer constructor\r\n   * @param parameters - {@link GPUCameraRendererParams | parameters} used to create this {@link GPUCameraRenderer}\r\n   */\r\n  constructor({\r\n    deviceManager,\r\n    container,\r\n    pixelRatio = 1,\r\n    preferredFormat,\r\n    alphaMode = 'premultiplied',\r\n    renderPass,\r\n    camera = {},\r\n  }: GPUCameraRendererParams) {\r\n    super({\r\n      deviceManager,\r\n      container,\r\n      pixelRatio,\r\n      preferredFormat,\r\n      alphaMode,\r\n      renderPass,\r\n    })\r\n\r\n    this.type = 'GPUCameraRenderer'\r\n\r\n    camera = { ...{ fov: 50, near: 0.1, far: 150 }, ...camera }\r\n\r\n    this.options = {\r\n      ...this.options,\r\n      camera,\r\n    }\r\n\r\n    this.setCamera(camera)\r\n\r\n    this.setCameraBindGroupAndBinding()\r\n  }\r\n\r\n  /**\r\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} is lost.\r\n   * Reset all our samplers, force all our scene objects and camera bind group to lose context.\r\n   */\r\n  loseContext() {\r\n    super.loseContext()\r\n    // lose camera bind group context as well\r\n    this.cameraBindGroup.loseContext()\r\n  }\r\n\r\n  /**\r\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} should be restored.\r\n   * Configure the context again, resize the {@link core/renderPasses/RenderTarget.RenderTarget | render targets} and {@link core/textures/RenderTexture.RenderTexture | render textures}, restore our {@link renderedObjects | rendered objects} context, re-write our {@link cameraBufferBinding | camera buffer binding}.\r\n   * @async\r\n   */\r\n  async restoreContext(): Promise<void> {\r\n    this.cameraBufferBinding.shouldUpdate = true\r\n    return super.restoreContext()\r\n  }\r\n\r\n  /**\r\n   * Set the {@link camera}\r\n   * @param cameraParameters - {@link CameraBasePerspectiveOptions | parameters} used to create the {@link camera}\r\n   */\r\n  setCamera(cameraParameters: CameraBasePerspectiveOptions) {\r\n    const width = this.boundingRect ? this.boundingRect.width : 1\r\n    const height = this.boundingRect ? this.boundingRect.height : 1\r\n\r\n    this.camera = new Camera({\r\n      fov: cameraParameters.fov,\r\n      near: cameraParameters.near,\r\n      far: cameraParameters.far,\r\n      width,\r\n      height,\r\n      pixelRatio: this.pixelRatio,\r\n      onMatricesChanged: () => {\r\n        this.onCameraMatricesChanged()\r\n      },\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Update the {@link ProjectedMesh | projected meshes} sizes and positions when the {@link camera} {@link Camera#position | position} changes\r\n   */\r\n  onCameraMatricesChanged() {\r\n    this.updateCameraBindings()\r\n\r\n    this.meshes.forEach((mesh) => {\r\n      if ('modelViewMatrix' in mesh) {\r\n        mesh.shouldUpdateMatrixStack()\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Set the {@link cameraBufferBinding | camera buffer binding} and {@link cameraBindGroup | camera bind group}\r\n   */\r\n  setCameraBindGroupAndBinding() {\r\n    this.cameraBufferBinding = new BufferBinding({\r\n      label: 'Camera',\r\n      name: 'camera',\r\n      visibility: 'vertex',\r\n      struct: {\r\n        model: {\r\n          // camera model matrix\r\n          name: 'model',\r\n          type: 'mat4x4f',\r\n          value: this.camera.modelMatrix,\r\n        },\r\n        view: {\r\n          // camera view matrix\r\n          name: 'view',\r\n          type: 'mat4x4f',\r\n          value: this.camera.viewMatrix,\r\n        },\r\n        projection: {\r\n          // camera projection matrix\r\n          name: 'projection',\r\n          type: 'mat4x4f',\r\n          value: this.camera.projectionMatrix,\r\n        },\r\n      },\r\n    })\r\n\r\n    // now initialize bind group\r\n    this.cameraBindGroup = new BindGroup(this, {\r\n      label: 'Camera Uniform bind group',\r\n      bindings: [this.cameraBufferBinding],\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Create the {@link cameraBindGroup | camera bind group} buffers\r\n   */\r\n  setCameraBindGroup() {\r\n    if (this.cameraBindGroup && this.cameraBindGroup.shouldCreateBindGroup) {\r\n      this.cameraBindGroup.setIndex(0)\r\n      this.cameraBindGroup.createBindGroup()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Tell our {@link cameraBufferBinding | camera buffer binding} that we should update its struct\r\n   */\r\n  updateCameraBindings() {\r\n    this.cameraBufferBinding?.shouldUpdateBinding('model')\r\n    this.cameraBufferBinding?.shouldUpdateBinding('view')\r\n    this.cameraBufferBinding?.shouldUpdateBinding('projection')\r\n  }\r\n\r\n  /**\r\n   * Get all objects ({@link RenderedMesh | rendered meshes} or {@link core/computePasses/ComputePass.ComputePass | compute passes}) using a given {@link AllowedBindGroups | bind group}, including {@link cameraBindGroup | camera bind group}.\r\n   * Useful to know if a resource is used by multiple objects and if it is safe to destroy it or not.\r\n   * @param bindGroup - {@link AllowedBindGroups | bind group} to check\r\n   */\r\n  getObjectsByBindGroup(bindGroup: AllowedBindGroups): undefined | SceneObject[] {\r\n    return this.deviceRenderedObjects.filter((object) => {\r\n      return [\r\n        ...object.material.bindGroups,\r\n        ...object.material.inputsBindGroups,\r\n        ...object.material.clonedBindGroups,\r\n        this.cameraBindGroup,\r\n      ].some((bG) => bG.uuid === bindGroup.uuid)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Set our {@link camera} perspective matrix new parameters (fov, near plane and far plane)\r\n   * @param parameters - {@link CameraBasePerspectiveOptions | parameters} to use for the perspective\r\n   */\r\n  setPerspective({ fov, near, far }: CameraBasePerspectiveOptions = {}) {\r\n    this.camera?.setPerspective({\r\n      fov,\r\n      near,\r\n      far,\r\n      width: this.boundingRect.width,\r\n      height: this.boundingRect.height,\r\n      pixelRatio: this.pixelRatio,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Set our {@link camera} {@link Camera#position | position}\r\n   * @param position - new {@link Camera#position | position}\r\n   */\r\n  setCameraPosition(position: Vec3 = new Vec3(0, 0, 1)) {\r\n    this.camera.position.copy(position)\r\n  }\r\n\r\n  /**\r\n   * Call our {@link GPURenderer#onResize | GPURenderer onResize method} and resize our {@link camera} as well\r\n   */\r\n  onResize() {\r\n    super.onResize()\r\n    this.setPerspective()\r\n    this.updateCameraBindings()\r\n  }\r\n\r\n  /* RENDER */\r\n\r\n  /**\r\n   * Update the camera model matrix, check if the {@link cameraBindGroup | camera bind group} should be created, create it if needed and then update it\r\n   */\r\n  updateCamera() {\r\n    this.camera?.updateMatrixStack()\r\n    this.setCameraBindGroup()\r\n    this.cameraBindGroup?.update()\r\n  }\r\n\r\n  /**\r\n   * Render a single {@link RenderedMesh | mesh} (binds the {@link cameraBindGroup | camera bind group} if needed)\r\n   * @param commandEncoder - current {@link GPUCommandEncoder}\r\n   * @param mesh - {@link RenderedMesh | mesh} to render\r\n   */\r\n  renderSingleMesh(commandEncoder: GPUCommandEncoder, mesh: RenderedMesh) {\r\n    const pass = commandEncoder.beginRenderPass(this.renderPass.descriptor)\r\n\r\n    // bind camera if needed\r\n    if (mesh.material.options.rendering.useProjection) {\r\n      pass.setBindGroup(this.cameraBindGroup.index, this.cameraBindGroup.bindGroup)\r\n    }\r\n\r\n    mesh.render(pass)\r\n    pass.end()\r\n  }\r\n\r\n  /**\r\n   * {@link updateCamera | Update the camera} and then call our {@link GPURenderer#render | GPURenderer render method}\r\n   * @param commandEncoder - current {@link GPUCommandEncoder}\r\n   */\r\n  render(commandEncoder: GPUCommandEncoder) {\r\n    if (!this.ready) return\r\n\r\n    this.updateCamera()\r\n    super.render(commandEncoder)\r\n  }\r\n\r\n  /**\r\n   * Destroy our {@link GPUCameraRenderer}\r\n   */\r\n  destroy() {\r\n    this.cameraBindGroup?.destroy()\r\n    super.destroy()\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}