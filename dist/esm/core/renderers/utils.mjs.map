{"version":3,"file":"utils.mjs","sources":["../../../../src/core/renderers/utils.ts"],"sourcesContent":["import { throwError } from '../../utils/utils'\nimport { GPURenderer } from './GPURenderer'\nimport { GPUCameraRenderer } from './GPUCameraRenderer'\nimport { GPUCurtainsRenderer } from '../../curtains/renderers/GPUCurtainsRenderer'\nimport { WritableBufferBinding } from '../bindings/WritableBufferBinding'\n\n/**\n * A Renderer could be either a {@link GPURenderer}, a {@link GPUCameraRenderer} or a {@link GPUCurtainsRenderer}\n * @type {Renderer}\n */\nexport type Renderer = GPUCurtainsRenderer | GPUCameraRenderer | GPURenderer\n/**\n * A CameraRenderer could be either a {@link GPUCameraRenderer} or a {@link GPUCurtainsRenderer}\n * @type {CameraRenderer}\n */\nexport type CameraRenderer = GPUCurtainsRenderer | GPUCameraRenderer\n\n/**\n * Format a renderer error based on given renderer, renderer type and object type\n * @param renderer - renderer that failed the test\n * @param rendererType - expected renderer type\n * @param type - object type\n */\nconst formatRendererError = (renderer: Renderer, rendererType = 'GPURenderer', type: string | null): void => {\n  const error = type\n    ? `Unable to create ${type} because the ${rendererType} is not defined: ${renderer}`\n    : `The ${rendererType} is not defined: ${renderer}`\n  throwError(error)\n}\n\n/**\n * Check if the given renderer is a {@link Renderer}\n * @param renderer - renderer to test\n * @param type - object type used to format the error if needed\n * @returns - whether the given renderer is a {@link Renderer}\n */\nexport const isRenderer = (renderer: Renderer | undefined, type: string | null): boolean => {\n  const isRenderer =\n    renderer &&\n    (renderer.type === 'GPURenderer' ||\n      renderer.type === 'GPUCameraRenderer' ||\n      renderer.type === 'GPUCurtainsRenderer')\n\n  if (!isRenderer) {\n    formatRendererError(renderer, 'GPURenderer', type)\n  }\n\n  return isRenderer\n}\n\n/**\n * Check if the given renderer is a {@link CameraRenderer}\n * @param renderer - renderer to test\n * @param type - object type used to format the error if needed\n * @returns - whether the given renderer is a {@link CameraRenderer}\n */\nexport const isCameraRenderer = (renderer: CameraRenderer | undefined, type: string | null): boolean => {\n  const isCameraRenderer =\n    renderer && (renderer.type === 'GPUCameraRenderer' || renderer.type === 'GPUCurtainsRenderer')\n\n  if (!isCameraRenderer) {\n    formatRendererError(renderer, 'GPUCameraRenderer', type)\n  }\n\n  return isCameraRenderer\n}\n\n/**\n * Check if the given renderer is a {@link GPUCurtainsRenderer}\n * @param renderer - renderer to test\n * @param type - object type used to format the error if needed\n * @returns - whether the given renderer is a {@link GPUCurtainsRenderer}\n */\nexport const isCurtainsRenderer = (renderer: GPUCurtainsRenderer | undefined, type: string | null): boolean => {\n  const isCurtainsRenderer = renderer && renderer.type === 'GPUCurtainsRenderer'\n\n  if (!isCurtainsRenderer) {\n    formatRendererError(renderer, 'GPUCurtainsRenderer', type)\n  }\n\n  return isCurtainsRenderer\n}\n\n/**\n * Helper to generate mips on the GPU\n * Taken from https://webgpufundamentals.org/webgpu/lessons/webgpu-importing-textures.html\n */\nexport const generateMips = (() => {\n  let sampler\n  let module\n  const pipelineByFormat = {}\n\n  return function generateMips(device: GPUDevice, texture: GPUTexture) {\n    if (!module) {\n      module = device.createShaderModule({\n        label: 'textured quad shaders for mip level generation',\n        code: `\n            struct VSOutput {\n              @builtin(position) position: vec4f,\n              @location(0) texcoord: vec2f,\n            };\n\n            @vertex fn vs(\n              @builtin(vertex_index) vertexIndex : u32\n            ) -> VSOutput {\n              var pos = array<vec2f, 6>(\n\n                vec2f( 0.0,  0.0),  // center\n                vec2f( 1.0,  0.0),  // right, center\n                vec2f( 0.0,  1.0),  // center, top\n\n                // 2st triangle\n                vec2f( 0.0,  1.0),  // center, top\n                vec2f( 1.0,  0.0),  // right, center\n                vec2f( 1.0,  1.0),  // right, top\n              );\n\n              var vsOutput: VSOutput;\n              let xy = pos[vertexIndex];\n              vsOutput.position = vec4f(xy * 2.0 - 1.0, 0.0, 1.0);\n              vsOutput.texcoord = vec2f(xy.x, 1.0 - xy.y);\n              return vsOutput;\n            }\n\n            @group(0) @binding(0) var ourSampler: sampler;\n            @group(0) @binding(1) var ourTexture: texture_2d<f32>;\n\n            @fragment fn fs(fsInput: VSOutput) -> @location(0) vec4f {\n              return textureSample(ourTexture, ourSampler, fsInput.texcoord);\n            }\n          `,\n      })\n\n      sampler = device.createSampler({\n        minFilter: 'linear',\n      })\n    }\n\n    if (!pipelineByFormat[texture.format]) {\n      pipelineByFormat[texture.format] = device.createRenderPipeline({\n        label: 'mip level generator pipeline',\n        layout: 'auto',\n        vertex: {\n          module,\n          entryPoint: 'vs',\n        },\n        fragment: {\n          module,\n          entryPoint: 'fs',\n          targets: [{ format: texture.format }],\n        },\n      })\n    }\n    const pipeline = pipelineByFormat[texture.format]\n\n    const encoder = device.createCommandEncoder({\n      label: 'mip gen encoder',\n    })\n\n    let width = texture.width\n    let height = texture.height\n    let baseMipLevel = 0\n    while (width > 1 || height > 1) {\n      width = Math.max(1, (width / 2) | 0)\n      height = Math.max(1, (height / 2) | 0)\n\n      const bindGroup = device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [\n          { binding: 0, resource: sampler },\n          {\n            binding: 1,\n            resource: texture.createView({\n              baseMipLevel,\n              mipLevelCount: 1,\n            }),\n          },\n        ],\n      })\n\n      ++baseMipLevel\n\n      const renderPassDescriptor = {\n        label: 'our basic canvas renderPass',\n        colorAttachments: [\n          {\n            view: texture.createView({ baseMipLevel, mipLevelCount: 1 }),\n            loadOp: 'clear',\n            storeOp: 'store',\n          },\n        ],\n      }\n\n      const pass = encoder.beginRenderPass(renderPassDescriptor as GPURenderPassDescriptor)\n      pass.setPipeline(pipeline)\n      pass.setBindGroup(0, bindGroup)\n      pass.draw(6) // call our vertex shader 6 times\n      pass.end()\n    }\n\n    const commandBuffer = encoder.finish()\n    device.queue.submit([commandBuffer])\n  }\n})()\n"],"names":["isRenderer","isCameraRenderer","isCurtainsRenderer","generateMips"],"mappings":"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"}