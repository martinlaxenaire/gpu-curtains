{"version":3,"file":"GPURenderer.mjs","sources":["../../../../src/core/renderers/GPURenderer.ts"],"sourcesContent":["import { PipelineManager } from '../pipelines/PipelineManager'\nimport { DOMElement, DOMElementBoundingRect } from '../DOM/DOMElement'\nimport { Scene } from '../scenes/Scene'\nimport { RenderPass, RenderPassParams } from '../renderPasses/RenderPass'\nimport { generateUUID, throwWarning } from '../../utils/utils'\n\nimport { ComputePass } from '../computePasses/ComputePass'\nimport { PingPongPlane } from '../../curtains/meshes/PingPongPlane'\nimport { ShaderPass } from '../renderPasses/ShaderPass'\nimport { RenderTarget } from '../renderPasses/RenderTarget'\nimport { Texture } from '../textures/Texture'\nimport { Sampler } from '../samplers/Sampler'\n\nimport { DOMMesh } from '../../curtains/meshes/DOMMesh'\nimport { Plane } from '../../curtains/meshes/Plane'\nimport { Mesh } from '../meshes/Mesh'\nimport { TasksQueueManager } from '../../utils/TasksQueueManager'\nimport { AllowedBindGroups } from '../../types/BindGroups'\nimport { RenderTexture } from '../textures/RenderTexture'\nimport { GPUDeviceManager } from './GPUDeviceManager'\nimport { FullscreenPlane } from '../meshes/FullscreenPlane'\n\n/**\n * Parameters used to create a {@link GPURenderer}\n */\nexport interface GPURendererParams {\n  /** The {@link GPUDeviceManager} used to create this {@link GPURenderer} */\n  deviceManager: GPUDeviceManager\n  /** {@link HTMLElement} or selector used as a container for our {@link GPURenderer#canvas | canvas} */\n  container: string | HTMLElement\n  /** Pixel ratio to use for rendering */\n  pixelRatio?: number\n  /** Texture rendering {@link GPUTextureFormat | preferred format} */\n  preferredFormat?: GPUTextureFormat\n  /** Set the {@link GPUCanvasContext | context} alpha mode */\n  alphaMode?: GPUCanvasAlphaMode\n\n  /** The {@link GPURenderer#renderPass | renderer RenderPass} parameters */\n  renderPass?: {\n    /** Whether the {@link GPURenderer#renderPass | renderer RenderPass} should handle depth. Default to `true` */\n    useDepth: RenderPassParams['useDepth']\n    /** The {@link GPURenderer#renderPass | renderer RenderPass} sample count (i.e. whether it should use multisampled antialiasing). Default to `4` */\n    sampleCount: RenderPassParams['sampleCount']\n    /** The {@link GPUColor | color values} to clear to before drawing the {@link GPURenderer#renderPass | renderer RenderPass}. Default to `[0, 0, 0, 0]` */\n    clearValue: GPUColor\n  }\n}\n\n/** Any Mesh that is bound to a DOM Element */\nexport type DOMProjectedMesh = DOMMesh | Plane\n/** Any Mesh that is projected (i.e use a {@link core/camera/Camera.Camera | Camera} to compute a model view projection matrix) */\nexport type ProjectedMesh = Mesh | DOMProjectedMesh\n/** Any Mesh that can be drawn, including fullscreen quad meshes used for post processing */\nexport type RenderedMesh = ProjectedMesh | PingPongPlane | ShaderPass | FullscreenPlane\n/** Any Mesh or Compute pass */\nexport type SceneObject = RenderedMesh | ComputePass\n\n/**\n * Base renderer class, that could technically be used to render compute passes and draw fullscreen quads, even tho it is strongly advised to use at least the {@link core/renderers/GPUCameraRenderer.GPUCameraRenderer | GPUCameraRenderer} class instead.\n * A renderer is responsible for:\n * - Setting a {@link GPUCanvasContext | context}\n * - Handling the {@link HTMLCanvasElement | canvas} onto everything is drawn\n * - Creating a {@link RenderPass} that will handle our render and depth textures and the render pass descriptor\n * - Keeping track of every specific class objects created relative to computing and rendering\n * - Creating a {@link Scene} class that will take care of the rendering process of all previously mentioned objects\n */\nexport class GPURenderer {\n  /** The type of the {@link GPURenderer} */\n  type: string\n  /** The universal unique id of this {@link GPURenderer} */\n  readonly uuid: string\n\n  /** The {@link GPUDeviceManager} used to create this {@link GPURenderer} */\n  deviceManager: GPUDeviceManager\n\n  /** {@link HTMLCanvasElement} onto everything is drawn */\n  canvas: HTMLCanvasElement\n  /** The WebGPU {@link GPUCanvasContext | context} used */\n  context: null | GPUCanvasContext\n  /** Set the {@link GPUCanvasContext | context} alpha mode */\n  alphaMode?: GPUCanvasAlphaMode\n\n  /** Options used to create this {@link GPURenderer} */\n  options: GPURendererParams\n\n  /** The {@link RenderPass | render pass} used to render our result to screen */\n  renderPass: RenderPass\n  /** Additional {@link RenderPass | render pass} used by {@link ShaderPass} for compositing / post processing. Does not handle depth */\n  postProcessingPass: RenderPass\n\n  /** The {@link Scene} used */\n  scene: Scene\n\n  /** An array containing all our created {@link ComputePass} */\n  computePasses: ComputePass[]\n  /** An array containing all our created {@link PingPongPlane} */\n  pingPongPlanes: PingPongPlane[]\n  /** An array containing all our created {@link ShaderPass} */\n  shaderPasses: ShaderPass[]\n  /** An array containing all our created {@link RenderTarget} */\n  renderTargets: RenderTarget[]\n  /** An array containing all our created {@link ProjectedMesh | projected meshes} */\n  meshes: ProjectedMesh[]\n  /** An array containing all our created {@link RenderTexture} */\n  renderTextures: RenderTexture[]\n\n  /** Pixel ratio to use for rendering */\n  pixelRatio: number\n\n  /** {@link DOMElement} that will track our canvas container size */\n  domElement: DOMElement\n\n  /** Allow to add callbacks to be executed at each render before the {@link GPUCommandEncoder} is created */\n  onBeforeCommandEncoderCreation: TasksQueueManager\n  /** Allow to add callbacks to be executed at each render after the {@link GPUCommandEncoder} has been created but before the {@link Scene} is rendered */\n  onBeforeRenderScene: TasksQueueManager\n  /** Allow to add callbacks to be executed at each render after the {@link GPUCommandEncoder} has been created and after the {@link Scene} has been rendered */\n  onAfterRenderScene: TasksQueueManager\n  /** Allow to add callbacks to be executed at each render after the {@link Scene} has been rendered and the {@link GPUCommandEncoder} has been submitted */\n  onAfterCommandEncoderSubmission: TasksQueueManager\n\n  // callbacks / events\n  /** function assigned to the {@link onBeforeRender} callback */\n  _onBeforeRenderCallback = (commandEncoder: GPUCommandEncoder) => {\n    /* allow empty callback */\n  }\n  /** function assigned to the {@link onAfterRender} callback */\n  _onAfterRenderCallback = (commandEncoder: GPUCommandEncoder) => {\n    /* allow empty callback */\n  }\n  /** function assigned to the {@link onAfterResize} callback */\n  _onAfterResizeCallback: () => void = () => {\n    /* allow empty callback */\n  }\n\n  /**\n   * GPURenderer constructor\n   * @param parameters - {@link GPURendererParams | parameters} used to create this {@link GPURenderer}\n   */\n  constructor({\n    deviceManager,\n    container,\n    pixelRatio = 1,\n    preferredFormat,\n    alphaMode = 'premultiplied',\n    renderPass,\n  }: GPURendererParams) {\n    this.type = 'GPURenderer'\n    this.uuid = generateUUID()\n\n    this.deviceManager = deviceManager\n    this.deviceManager.addRenderer(this)\n\n    // render pass default values\n    renderPass = { ...{ useDepth: true, sampleCount: 4, clearValue: [0, 0, 0, 0] }, ...renderPass }\n    preferredFormat = preferredFormat ?? this.deviceManager.gpu?.getPreferredCanvasFormat()\n\n    this.options = {\n      deviceManager,\n      container,\n      pixelRatio,\n      preferredFormat,\n      alphaMode,\n      renderPass,\n    }\n\n    this.pixelRatio = pixelRatio ?? window.devicePixelRatio ?? 1\n    this.alphaMode = alphaMode\n\n    this.setTasksQueues()\n    this.setRendererObjects()\n\n    // create the canvas\n    const isContainerCanvas = container instanceof HTMLCanvasElement\n    this.canvas = isContainerCanvas ? (container as HTMLCanvasElement) : document.createElement('canvas')\n\n    // needed to get container bounding box\n    this.domElement = new DOMElement({\n      element: container,\n      priority: 5, // renderer callback need to be called first\n      onSizeChanged: (boundingRect) => this.resize(boundingRect),\n    })\n\n    if (!isContainerCanvas) {\n      // append the canvas\n      this.domElement.element.appendChild(this.canvas)\n    }\n\n    // device is already available? create the context!\n    if (this.deviceManager.device) {\n      this.setContext()\n    }\n  }\n\n  /**\n   * Set {@link canvas} size\n   * @param boundingRect - new {@link domElement | DOM Element} {@link DOMElement#boundingRect | bounding rectangle}\n   */\n  setSize(boundingRect: DOMElementBoundingRect) {\n    this.canvas.style.width = Math.floor(boundingRect.width) + 'px'\n    this.canvas.style.height = Math.floor(boundingRect.height) + 'px'\n\n    this.canvas.width = this.getScaledDisplayBoundingRect(boundingRect).width\n    this.canvas.height = this.getScaledDisplayBoundingRect(boundingRect).height\n  }\n\n  /**\n   * Resize our {@link GPURenderer}\n   * @param boundingRect - new {@link domElement | DOM Element} {@link DOMElement#boundingRect | bounding rectangle}\n   */\n  resize(boundingRect: DOMElementBoundingRect | null = null) {\n    if (!this.domElement && !boundingRect) return\n\n    if (!boundingRect) boundingRect = this.domElement.element.getBoundingClientRect()\n\n    this.setSize(boundingRect)\n\n    this.onResize()\n\n    this._onAfterResizeCallback && this._onAfterResizeCallback()\n  }\n\n  /**\n   * Resize all tracked objects\n   */\n  onResize() {\n    // resize render textures first\n    this.renderTextures.forEach((renderTexture) => {\n      renderTexture.resize()\n    })\n\n    // resize render & shader passes\n    this.renderPass?.resize()\n    this.postProcessingPass?.resize()\n\n    this.renderTargets.forEach((renderTarget) => renderTarget.resize())\n\n    // force compute passes onAfterResize callback\n    this.computePasses.forEach((computePass) => computePass.resize())\n\n    // now resize meshes that are bound to the renderer size\n    // especially useful to resize render textures\n    this.pingPongPlanes.forEach((pingPongPlane) => pingPongPlane.resize(this.boundingRect))\n    this.shaderPasses.forEach((shaderPass) => shaderPass.resize(this.boundingRect))\n    this.meshes.forEach((mesh) => {\n      if (!('domElement' in mesh)) {\n        // resize meshes that do not have a bound DOM element\n        mesh.resize(this.boundingRect)\n      } else {\n        this.onBeforeCommandEncoderCreation.add(\n          () => {\n            // update position for DOM meshes only if they're not currently being resized\n            if (!mesh.domElement.isResizing) {\n              mesh.domElement.setSize()\n            }\n          },\n          { once: true }\n        )\n      }\n    })\n  }\n\n  /**\n   * Get our {@link domElement | DOM Element} {@link DOMElement#boundingRect | bounding rectangle}\n   */\n  get boundingRect(): DOMElementBoundingRect {\n    if (!!this.domElement.boundingRect) {\n      return this.domElement.boundingRect\n    } else {\n      const boundingRect = this.domElement.element?.getBoundingClientRect()\n      return {\n        top: boundingRect.top,\n        right: boundingRect.right,\n        bottom: boundingRect.bottom,\n        left: boundingRect.left,\n        width: boundingRect.width,\n        height: boundingRect.height,\n        x: boundingRect.x,\n        y: boundingRect.y,\n      }\n    }\n  }\n\n  /**\n   * Get our {@link domElement | DOM Element} {@link DOMElement#boundingRect | bounding rectangle} accounting for current {@link pixelRatio | pixel ratio}\n   */\n  get displayBoundingRect(): DOMElementBoundingRect {\n    return this.getScaledDisplayBoundingRect(this.boundingRect)\n  }\n\n  /**\n   * Get the display bounding rectangle accounting for current {@link pixelRatio | pixel ratio} and max texture dimensions\n   * @param boundingRect - bounding rectangle to check against\n   */\n  getScaledDisplayBoundingRect(boundingRect: DOMElementBoundingRect): DOMElementBoundingRect {\n    const devicePixelRatio = window.devicePixelRatio ?? 1\n    const scaleBoundingRect = this.pixelRatio / devicePixelRatio\n\n    const displayBoundingRect = Object.keys(boundingRect).reduce(\n      (a, key) => ({ ...a, [key]: boundingRect[key] * scaleBoundingRect }),\n      {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0,\n      }\n    )\n\n    // clamp width and height based on limits\n    if (this.device) {\n      displayBoundingRect.width = Math.min(this.device.limits.maxTextureDimension2D, displayBoundingRect.width)\n      displayBoundingRect.height = Math.min(this.device.limits.maxTextureDimension2D, displayBoundingRect.height)\n\n      displayBoundingRect.right = Math.min(\n        displayBoundingRect.width + displayBoundingRect.left,\n        displayBoundingRect.right\n      )\n      displayBoundingRect.bottom = Math.min(\n        displayBoundingRect.height + displayBoundingRect.top,\n        displayBoundingRect.bottom\n      )\n    }\n\n    return displayBoundingRect\n  }\n\n  /* USEFUL DEVICE MANAGER OBJECTS */\n\n  /**\n   * Get our {@link GPUDeviceManager#device | device}\n   * @readonly\n   */\n  get device(): GPUDevice | undefined {\n    return this.deviceManager.device\n  }\n\n  /**\n   * Get whether our {@link GPUDeviceManager} is ready (i.e. its {@link GPUDeviceManager#adapter | adapter} and {@link GPUDeviceManager#device | device} are set) its {@link context} is set and its size is set\n   * @readonly\n   */\n  get ready(): boolean {\n    return this.deviceManager.ready && !!this.context && !!this.canvas.style.width\n  }\n\n  /**\n   * Get our {@link GPUDeviceManager#production | GPUDeviceManager production flag}\n   * @readonly\n   */\n  get production(): boolean {\n    return this.deviceManager.production\n  }\n\n  /**\n   * Get all the created {@link GPUDeviceManager#samplers | samplers}\n   * @readonly\n   */\n  get samplers(): Sampler[] {\n    return this.deviceManager.samplers\n  }\n\n  /**\n   * Get all the created {@link GPUDeviceManager#buffers | GPU buffers}\n   * @readonly\n   */\n  get buffers(): GPUBuffer[] {\n    return this.deviceManager.buffers\n  }\n\n  /**\n   * Get the {@link GPUDeviceManager#pipelineManager | pipeline manager}\n   * @readonly\n   */\n  get pipelineManager(): PipelineManager {\n    return this.deviceManager.pipelineManager\n  }\n\n  /**\n   * Get all the rendered objects (i.e. compute passes, meshes, ping pong planes and shader passes) created by the {@link GPUDeviceManager}\n   * @readonly\n   */\n  get deviceRenderedObjects(): SceneObject[] {\n    return this.deviceManager.deviceRenderedObjects\n  }\n\n  /**\n   * Configure our {@link context} with the given options\n   */\n  configureContext() {\n    this.context.configure({\n      device: this.device,\n      format: this.options.preferredFormat,\n      alphaMode: this.alphaMode,\n      // needed so we can copy textures for post processing usage\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n      //viewFormats: []\n    })\n  }\n\n  /**\n   * Set our {@link context} if possible and set {@link renderPass | main render pass} and {@link scene}\n   */\n  setContext() {\n    this.context = this.canvas.getContext('webgpu')\n\n    if (this.device) {\n      this.configureContext()\n\n      this.setMainRenderPasses()\n      this.setScene()\n    }\n  }\n\n  /**\n   * Called when the {@link GPUDeviceManager#device | device} is lost.\n   * Force all our scene objects to lose context.\n   */\n  loseContext() {\n    // force all our scene objects to lose context\n    this.renderedObjects.forEach((sceneObject) => sceneObject.loseContext())\n  }\n\n  /**\n   * Called when the {@link GPUDeviceManager#device | device} should be restored.\n   * Configure the context again, resize the {@link RenderTarget | render targets} and {@link RenderTexture | render textures}, restore our {@link renderedObjects | rendered objects} context.\n   * @async\n   */\n  restoreContext() {\n    this.configureContext()\n\n    // recreate all render textures first\n    this.renderTextures.forEach((renderTexture) => {\n      renderTexture.createTexture()\n    })\n\n    // resize render passes/recreate their textures\n    this.renderPass?.resize()\n    this.postProcessingPass?.resize()\n\n    this.renderTargets.forEach((renderTarget) => renderTarget.resize())\n\n    // restore context of all our scene objects\n    this.renderedObjects.forEach((sceneObject) => sceneObject.restoreContext())\n  }\n\n  /* PIPELINES, SCENE & MAIN RENDER PASS */\n\n  /**\n   * Set our {@link renderPass | main render pass} that will be used to render the result of our draw commands back to the screen and our {@link postProcessingPass | postprocessing pass} that will be used for any additional postprocessing render passes.\n   */\n  setMainRenderPasses() {\n    this.renderPass = new RenderPass(this, {\n      label: 'Main render pass',\n      targetFormat: this.options.preferredFormat,\n      ...this.options.renderPass,\n    } as RenderPassParams)\n\n    this.postProcessingPass = new RenderPass(this, {\n      label: 'Post processing render pass',\n      targetFormat: this.options.preferredFormat,\n      // no need to handle depth or perform MSAA on a fullscreen quad\n      useDepth: false,\n      sampleCount: 1,\n    })\n  }\n\n  /**\n   * Set our {@link scene}\n   */\n  setScene() {\n    this.scene = new Scene({ renderer: this })\n  }\n\n  /* BUFFERS & BINDINGS */\n\n  /**\n   * Create a {@link GPUBuffer}\n   * @param bufferDescriptor - {@link GPUBufferDescriptor | GPU buffer descriptor}\n   * @returns - newly created {@link GPUBuffer}\n   */\n  createBuffer(bufferDescriptor: GPUBufferDescriptor): GPUBuffer {\n    const buffer = this.device?.createBuffer(bufferDescriptor)\n    this.deviceManager.addBuffer(buffer)\n    return buffer\n  }\n\n  /**\n   * Remove a {@link GPUBuffer} from our {@link GPUDeviceManager#buffers | GPU buffers array}\n   * @param buffer - {@link GPUBuffer} to remove\n   * @param [originalLabel] - original {@link GPUBuffer} label in case the buffer has been swapped and its label has changed\n   */\n  removeBuffer(buffer: GPUBuffer, originalLabel?: string) {\n    this.deviceManager.removeBuffer(buffer, originalLabel)\n  }\n\n  /**\n   * Write to a {@link GPUBuffer}\n   * @param buffer - {@link GPUBuffer} to write to\n   * @param bufferOffset - {@link GPUSize64 | buffer offset}\n   * @param data - {@link BufferSource | data} to write\n   */\n  queueWriteBuffer(buffer: GPUBuffer, bufferOffset: GPUSize64, data: BufferSource) {\n    this.device?.queue.writeBuffer(buffer, bufferOffset, data)\n  }\n\n  /**\n   * Copy a source {@link GPUBuffer} into a destination {@link GPUBuffer}\n   * @param parameters - parameters used to realize the copy\n   * @param parameters.srcBuffer - source {@link GPUBuffer}\n   * @param [parameters.dstBuffer] - destination {@link GPUBuffer}. Will create a new one if none provided.\n   * @param [parameters.commandEncoder] - {@link GPUCommandEncoder} to use for the copy. Will create a new one and submit the command buffer if none provided.\n   * @returns - destination {@link GPUBuffer} after copy\n   */\n  copyBufferToBuffer({\n    srcBuffer,\n    dstBuffer,\n    commandEncoder,\n  }: {\n    srcBuffer: GPUBuffer\n    dstBuffer?: GPUBuffer\n    commandEncoder?: GPUCommandEncoder\n  }): GPUBuffer | null {\n    if (!srcBuffer) {\n      throwWarning(`${this.type}: cannot copy to buffer because the source buffer has not been provided`)\n      return null\n    }\n\n    if (!dstBuffer) {\n      dstBuffer = this.createBuffer({\n        label: this.type + ': destination copy buffer from: ' + srcBuffer.label,\n        size: srcBuffer.size,\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n      })\n    }\n\n    if (srcBuffer.mapState !== 'unmapped') {\n      throwWarning(`${this.type}: Cannot copy from ${srcBuffer} because it is currently mapped`)\n      return\n    }\n    if (dstBuffer.mapState !== 'unmapped') {\n      throwWarning(`${this.type}: Cannot copy from ${dstBuffer} because it is currently mapped`)\n      return\n    }\n\n    // if there's no command encoder provided, we'll have to create one and submit it after the copy process\n    const hasCommandEncoder = !!commandEncoder\n\n    if (!hasCommandEncoder) {\n      commandEncoder = this.device?.createCommandEncoder({ label: 'Copy buffer command encoder' })\n      !this.production && commandEncoder.pushDebugGroup('Copy buffer command encoder')\n    }\n\n    commandEncoder.copyBufferToBuffer(srcBuffer, 0, dstBuffer, 0, dstBuffer.size)\n\n    if (!hasCommandEncoder) {\n      !this.production && commandEncoder.popDebugGroup()\n      const commandBuffer = commandEncoder.finish()\n      this.device?.queue.submit([commandBuffer])\n    }\n\n    return dstBuffer\n  }\n\n  /* BIND GROUPS & LAYOUTS */\n\n  /**\n   * Get all created {@link AllowedBindGroups | bind group} tracked by our {@link GPUDeviceManager}\n   * @readonly\n   */\n  get bindGroups(): AllowedBindGroups[] {\n    return this.deviceManager.bindGroups\n  }\n\n  /**\n   * Add a {@link AllowedBindGroups | bind group} to our {@link GPUDeviceManager#bindGroups | bind groups array}\n   * @param bindGroup - {@link AllowedBindGroups | bind group} to add\n   */\n  addBindGroup(bindGroup: AllowedBindGroups) {\n    this.deviceManager.addBindGroup(bindGroup)\n  }\n\n  /**\n   * Remove a {@link AllowedBindGroups | bind group} from our {@link GPUDeviceManager#bindGroups | bind groups array}\n   * @param bindGroup - {@link AllowedBindGroups | bind group} to remove\n   */\n  removeBindGroup(bindGroup: AllowedBindGroups) {\n    this.deviceManager.removeBindGroup(bindGroup)\n  }\n\n  /**\n   * Create a {@link GPUBindGroupLayout}\n   * @param bindGroupLayoutDescriptor - {@link GPUBindGroupLayoutDescriptor | GPU bind group layout descriptor}\n   * @returns - newly created {@link GPUBindGroupLayout}\n   */\n  createBindGroupLayout(bindGroupLayoutDescriptor: GPUBindGroupLayoutDescriptor): GPUBindGroupLayout {\n    return this.device?.createBindGroupLayout(bindGroupLayoutDescriptor)\n  }\n\n  /**\n   * Create a {@link GPUBindGroup}\n   * @param bindGroupDescriptor - {@link GPUBindGroupDescriptor | GPU bind group descriptor}\n   * @returns - newly created {@link GPUBindGroup}\n   */\n  createBindGroup(bindGroupDescriptor: GPUBindGroupDescriptor): GPUBindGroup {\n    return this.device?.createBindGroup(bindGroupDescriptor)\n  }\n\n  /* SHADERS & PIPELINES */\n\n  /**\n   * Create a {@link GPUShaderModule}\n   * @param shaderModuleDescriptor - {@link shaderModuleDescriptor | shader module descriptor}\n   * @returns - newly created {@link GPUShaderModule}\n   */\n  createShaderModule(shaderModuleDescriptor: GPUShaderModuleDescriptor): GPUShaderModule {\n    return this.device?.createShaderModule(shaderModuleDescriptor)\n  }\n\n  /**\n   * Create a {@link GPUPipelineLayout}\n   * @param pipelineLayoutDescriptor - {@link GPUPipelineLayoutDescriptor | GPU pipeline layout descriptor}\n   * @returns - newly created {@link GPUPipelineLayout}\n   */\n  createPipelineLayout(pipelineLayoutDescriptor: GPUPipelineLayoutDescriptor): GPUPipelineLayout {\n    return this.device?.createPipelineLayout(pipelineLayoutDescriptor)\n  }\n\n  /**\n   * Create a {@link GPURenderPipeline}\n   * @param pipelineDescriptor - {@link GPURenderPipelineDescriptor | GPU render pipeline descriptor}\n   * @returns - newly created {@link GPURenderPipeline}\n   */\n  createRenderPipeline(pipelineDescriptor: GPURenderPipelineDescriptor): GPURenderPipeline {\n    return this.device?.createRenderPipeline(pipelineDescriptor)\n  }\n\n  /**\n   * Asynchronously create a {@link GPURenderPipeline}\n   * @async\n   * @param pipelineDescriptor - {@link GPURenderPipelineDescriptor | GPU render pipeline descriptor}\n   * @returns - newly created {@link GPURenderPipeline}\n   */\n  async createRenderPipelineAsync(pipelineDescriptor: GPURenderPipelineDescriptor): Promise<GPURenderPipeline> {\n    return await this.device?.createRenderPipelineAsync(pipelineDescriptor)\n  }\n\n  /**\n   * Create a {@link GPUComputePipeline}\n   * @param pipelineDescriptor - {@link GPUComputePipelineDescriptor | GPU compute pipeline descriptor}\n   * @returns - newly created {@link GPUComputePipeline}\n   */\n  createComputePipeline(pipelineDescriptor: GPUComputePipelineDescriptor): GPUComputePipeline {\n    return this.device?.createComputePipeline(pipelineDescriptor)\n  }\n\n  /**\n   * Asynchronously create a {@link GPUComputePipeline}\n   * @async\n   * @param pipelineDescriptor - {@link GPUComputePipelineDescriptor | GPU compute pipeline descriptor}\n   * @returns - newly created {@link GPUComputePipeline}\n   */\n  async createComputePipelineAsync(pipelineDescriptor: GPUComputePipelineDescriptor): Promise<GPUComputePipeline> {\n    return await this.device?.createComputePipelineAsync(pipelineDescriptor)\n  }\n\n  /* TEXTURES */\n\n  /**\n   * Get all created {@link Texture} tracked by our {@link GPUDeviceManager}\n   * @readonly\n   */\n  get textures(): Texture[] {\n    return this.deviceManager.textures\n  }\n\n  /**\n   * Add a {@link Texture} to our {@link GPUDeviceManager#textures | textures array}\n   * @param texture - {@link Texture} to add\n   */\n  addTexture(texture: Texture) {\n    this.deviceManager.addTexture(texture)\n  }\n\n  /**\n   * Remove a {@link Texture} from our {@link GPUDeviceManager#textures | textures array}\n   * @param texture - {@link Texture} to remove\n   */\n  removeTexture(texture: Texture) {\n    this.deviceManager.removeTexture(texture)\n  }\n\n  /**\n   * Add a {@link RenderTexture} to our {@link renderTextures} array\n   * @param texture - {@link RenderTexture} to add\n   */\n  addRenderTexture(texture: RenderTexture) {\n    this.renderTextures.push(texture)\n  }\n\n  /**\n   * Remove a {@link RenderTexture} from our {@link renderTextures} array\n   * @param texture - {@link RenderTexture} to remove\n   */\n  removeRenderTexture(texture: RenderTexture) {\n    this.renderTextures = this.renderTextures.filter((t) => t.uuid !== texture.uuid)\n  }\n\n  /**\n   * Create a {@link GPUTexture}\n   * @param textureDescriptor - {@link GPUTextureDescriptor | GPU texture descriptor}\n   * @returns - newly created {@link GPUTexture}\n   */\n  createTexture(textureDescriptor: GPUTextureDescriptor): GPUTexture {\n    return this.device?.createTexture(textureDescriptor)\n  }\n\n  /**\n   * Upload a {@link Texture#texture | texture} to the GPU\n   * @param texture - {@link Texture} class object with the {@link Texture#texture | texture} to upload\n   */\n  uploadTexture(texture: Texture) {\n    this.deviceManager.uploadTexture(texture)\n  }\n\n  /**\n   * Import a {@link GPUExternalTexture}\n   * @param video - {@link HTMLVideoElement} source\n   * @returns - {@link GPUExternalTexture}\n   */\n  importExternalTexture(video: HTMLVideoElement): GPUExternalTexture {\n    // TODO WebCodecs may be the way to go when time comes!\n    // https://developer.chrome.com/blog/new-in-webgpu-113/#use-webcodecs-videoframe-source-in-importexternaltexture\n    // see onVideoFrameCallback method in Texture class\n    // const videoFrame = new VideoFrame(video)\n    // return this.device?.importExternalTexture({ source: videoFrame })\n    return this.device?.importExternalTexture({ source: video })\n  }\n\n  /**\n   * Check if a {@link Sampler} has already been created with the same {@link Sampler#options | parameters}.\n   * Use it if found, else create a new one and add it to the {@link GPUDeviceManager#samplers | samplers array}.\n   * @param sampler - {@link Sampler} to create\n   * @returns - the {@link GPUSampler}\n   */\n  createSampler(sampler: Sampler): GPUSampler {\n    const existingSampler = this.samplers.find((existingSampler) => {\n      return JSON.stringify(existingSampler.options) === JSON.stringify(sampler.options) && existingSampler.sampler\n    })\n\n    if (existingSampler) {\n      return existingSampler.sampler\n    } else {\n      const { type, ...samplerOptions } = sampler.options\n      const gpuSampler: GPUSampler = this.device?.createSampler({\n        label: sampler.label,\n        ...samplerOptions,\n      })\n\n      this.deviceManager.addSampler(sampler)\n\n      return gpuSampler\n    }\n  }\n\n  /**\n   * Remove a {@link Sampler} from our {@link GPUDeviceManager#samplers | samplers array}\n   * @param sampler - {@link Sampler} to remove\n   */\n  removeSampler(sampler: Sampler) {\n    this.deviceManager.removeSampler(sampler)\n  }\n\n  /* OBJECTS & TASKS */\n\n  /**\n   * Set different tasks queue managers to execute callbacks at different phases of our render call:\n   * - {@link onBeforeCommandEncoderCreation}: callbacks executed before the creation of the command encoder\n   * - {@link onBeforeRenderScene}: callbacks executed after the creation of the command encoder and before rendering the {@link Scene}\n   * - {@link onAfterRenderScene}: callbacks executed after the creation of the command encoder and after rendering the {@link Scene}\n   * - {@link onAfterCommandEncoderSubmission}: callbacks executed after the submission of the command encoder\n   */\n  setTasksQueues() {\n    this.onBeforeCommandEncoderCreation = new TasksQueueManager()\n    this.onBeforeRenderScene = new TasksQueueManager()\n    this.onAfterRenderScene = new TasksQueueManager()\n    this.onAfterCommandEncoderSubmission = new TasksQueueManager()\n  }\n\n  /**\n   * Set all objects arrays that we'll keep track of\n   */\n  setRendererObjects() {\n    // keep track of compute passes, meshes, etc.\n    this.computePasses = []\n    this.pingPongPlanes = []\n    this.shaderPasses = []\n    this.renderTargets = []\n    this.meshes = []\n    this.renderTextures = []\n  }\n\n  /**\n   * Get all this {@link GPURenderer} rendered objects (i.e. compute passes, meshes, ping pong planes and shader passes)\n   * @readonly\n   */\n  get renderedObjects(): SceneObject[] {\n    return [...this.computePasses, ...this.meshes, ...this.shaderPasses, ...this.pingPongPlanes]\n  }\n\n  /**\n   * Get all objects ({@link RenderedMesh | rendered meshes} or {@link ComputePass | compute passes}) using a given {@link AllowedBindGroups | bind group}.\n   * Useful to know if a resource is used by multiple objects and if it is safe to destroy it or not.\n   * @param bindGroup - {@link AllowedBindGroups | bind group} to check\n   */\n  getObjectsByBindGroup(bindGroup: AllowedBindGroups): undefined | SceneObject[] {\n    return this.deviceRenderedObjects.filter((object) => {\n      return [\n        ...object.material.bindGroups,\n        ...object.material.inputsBindGroups,\n        ...object.material.clonedBindGroups,\n      ].some((bG) => bG.uuid === bindGroup.uuid)\n    })\n  }\n\n  /**\n   * Get all objects ({@link RenderedMesh | rendered meshes} or {@link ComputePass | compute passes}) using a given {@link Texture} or {@link RenderTexture}.\n   * Useful to know if a resource is used by multiple objects and if it is safe to destroy it or not.\n   * @param texture - {@link Texture} or {@link RenderTexture} to check\n   */\n  getObjectsByTexture(texture: Texture | RenderTexture): undefined | SceneObject[] {\n    return this.deviceRenderedObjects.filter((object) => {\n      return [...object.material.textures, ...object.material.renderTextures].some((t) => t.uuid === texture.uuid)\n    })\n  }\n\n  /* EVENTS */\n\n  /**\n   * Assign a callback function to _onBeforeRenderCallback\n   * @param callback - callback to run just before the {@link render} method will be executed\n   * @returns - our {@link GPURenderer}\n   */\n  onBeforeRender(callback: (commandEncoder?: GPUCommandEncoder) => void) {\n    if (callback) {\n      this._onBeforeRenderCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Assign a callback function to _onAfterRenderCallback\n   * @param callback - callback to run just after the {@link render} method has been executed\n   * @returns - our {@link GPURenderer}\n   */\n  onAfterRender(callback: (commandEncoder?: GPUCommandEncoder) => void) {\n    if (callback) {\n      this._onAfterRenderCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Assign a callback function to _onAfterResizeCallback\n   * @param callback - callback to run just after the {@link GPURenderer} has been resized\n   * @returns - our {@link GPURenderer}\n   */\n  onAfterResize(callback: (commandEncoder?: GPUCommandEncoder) => void) {\n    if (callback) {\n      this._onAfterResizeCallback = callback\n    }\n\n    return this\n  }\n\n  /* RENDER */\n\n  /**\n   * Render a single {@link ComputePass}\n   * @param commandEncoder - current {@link GPUCommandEncoder}\n   * @param computePass - {@link ComputePass}\n   */\n  renderSingleComputePass(commandEncoder: GPUCommandEncoder, computePass: ComputePass) {\n    const pass = commandEncoder.beginComputePass()\n    computePass.render(pass)\n    pass.end()\n\n    computePass.copyBufferToResult(commandEncoder)\n  }\n\n  /**\n   * Render a single {@link RenderedMesh | Mesh}\n   * @param commandEncoder - current {@link GPUCommandEncoder}\n   * @param mesh - {@link RenderedMesh | Mesh} to render\n   */\n  renderSingleMesh(commandEncoder: GPUCommandEncoder, mesh: RenderedMesh) {\n    const pass = commandEncoder.beginRenderPass(this.renderPass.descriptor)\n    mesh.render(pass)\n    pass.end()\n  }\n\n  /**\n   * Render an array of objects (either {@link RenderedMesh | Meshes} or {@link ComputePass}) once. This method won't call any of the renderer render hooks like {@link onBeforeRender}, {@link onAfterRender}\n   * @param objects - Array of {@link RenderedMesh | Meshes} or {@link ComputePass} to render\n   */\n  renderOnce(objects: SceneObject[]) {\n    const commandEncoder = this.device?.createCommandEncoder({\n      label: 'Render once command encoder',\n    })\n    !this.production && commandEncoder.pushDebugGroup('Render once command encoder')\n\n    this.pipelineManager.resetCurrentPipeline()\n\n    objects.forEach((object) => {\n      if (object instanceof ComputePass) {\n        this.renderSingleComputePass(commandEncoder, object)\n      } else {\n        this.renderSingleMesh(commandEncoder, object)\n      }\n    })\n\n    !this.production && commandEncoder.popDebugGroup()\n    const commandBuffer = commandEncoder.finish()\n    this.device?.queue.submit([commandBuffer])\n\n    this.pipelineManager.resetCurrentPipeline()\n  }\n\n  /**\n   * Force to clear a {@link GPURenderer} content to its {@link RenderPass#options.clearValue | clear value} by rendering and empty pass.\n   * @param commandEncoder\n   */\n  forceClear(commandEncoder?: GPUCommandEncoder) {\n    // if there's no command encoder provided, we'll have to create one and submit it after the copy process\n    const hasCommandEncoder = !!commandEncoder\n\n    if (!hasCommandEncoder) {\n      commandEncoder = this.device?.createCommandEncoder({ label: 'Force clear command encoder' })\n      !this.production && commandEncoder.pushDebugGroup('Force clear command encoder')\n    }\n\n    this.renderPass.updateView()\n    const pass = commandEncoder.beginRenderPass(this.renderPass.descriptor)\n    pass.end()\n\n    if (!hasCommandEncoder) {\n      !this.production && commandEncoder.popDebugGroup()\n      const commandBuffer = commandEncoder.finish()\n      this.device?.queue.submit([commandBuffer])\n    }\n  }\n\n  /**\n   * Called by the {@link GPUDeviceManager#render | GPUDeviceManager render method} before the {@link GPUCommandEncoder} has been created\n   */\n  onBeforeCommandEncoder() {\n    if (!this.ready) return\n    // now render!\n    this.onBeforeCommandEncoderCreation.execute()\n  }\n\n  /**\n   * Called by the {@link GPUDeviceManager#render | GPUDeviceManager render method} after the {@link GPUCommandEncoder} has been created.\n   */\n  onAfterCommandEncoder() {\n    if (!this.ready) return\n\n    this.onAfterCommandEncoderSubmission.execute()\n  }\n\n  /**\n   * Called at each draw call to render our scene and its content\n   * @param commandEncoder - current {@link GPUCommandEncoder}\n   */\n  render(commandEncoder: GPUCommandEncoder) {\n    if (!this.ready) return\n\n    this._onBeforeRenderCallback && this._onBeforeRenderCallback(commandEncoder)\n    this.onBeforeRenderScene.execute(commandEncoder)\n\n    this.scene?.render(commandEncoder)\n\n    this._onAfterRenderCallback && this._onAfterRenderCallback(commandEncoder)\n    this.onAfterRenderScene.execute(commandEncoder)\n  }\n\n  /**\n   * Destroy our {@link GPURenderer} and everything that needs to be destroyed as well\n   */\n  destroy() {\n    this.domElement?.destroy()\n\n    // destroy render passes\n    this.renderPass?.destroy()\n    this.postProcessingPass?.destroy()\n\n    this.renderTargets.forEach((renderTarget) => renderTarget.destroy())\n    this.renderedObjects.forEach((sceneObject) => sceneObject.remove())\n\n    this.renderTextures.forEach((texture) => texture.destroy())\n\n    this.context?.unconfigure()\n  }\n}\n"],"names":["existingSampler"],"mappings":"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"}