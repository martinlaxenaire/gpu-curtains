{"version":3,"file":"GPURenderer.mjs","sources":["../../../../src/core/renderers/GPURenderer.ts"],"sourcesContent":["import { PipelineManager } from '../pipelines/PipelineManager'\r\nimport { DOMElement, DOMElementBoundingRect } from '../DOM/DOMElement'\r\nimport { Scene } from '../scenes/Scene'\r\nimport { RenderPass, RenderPassParams } from '../renderPasses/RenderPass'\r\nimport { generateUUID, throwWarning } from '../../utils/utils'\r\n\r\nimport { ComputePass } from '../computePasses/ComputePass'\r\nimport { PingPongPlane } from '../../curtains/meshes/PingPongPlane'\r\nimport { ShaderPass } from '../renderPasses/ShaderPass'\r\nimport { RenderTarget } from '../renderPasses/RenderTarget'\r\nimport { Texture } from '../textures/Texture'\r\nimport { Sampler } from '../samplers/Sampler'\r\n\r\nimport { DOMMesh } from '../../curtains/meshes/DOMMesh'\r\nimport { Plane } from '../../curtains/meshes/Plane'\r\nimport { Mesh } from '../meshes/Mesh'\r\nimport { TasksQueueManager } from '../../utils/TasksQueueManager'\r\nimport { AllowedBindGroups } from '../../types/BindGroups'\r\nimport { RenderTexture } from '../textures/RenderTexture'\r\nimport { GPUDeviceManager } from './GPUDeviceManager'\r\nimport { FullscreenPlane } from '../meshes/FullscreenPlane'\r\n\r\n/**\r\n * Parameters used to create a {@link GPURenderer}\r\n */\r\nexport interface GPURendererParams {\r\n  /** The {@link GPUDeviceManager} used to create this {@link GPURenderer} */\r\n  deviceManager: GPUDeviceManager\r\n  /** {@link HTMLElement} or selector used as a container for our {@link GPURenderer#canvas | canvas} */\r\n  container: string | HTMLElement\r\n  /** Pixel ratio to use for rendering */\r\n  pixelRatio?: number\r\n  /** Texture rendering {@link GPUTextureFormat | preferred format} */\r\n  preferredFormat?: GPUTextureFormat\r\n  /** Set the {@link GPUCanvasContext | context} alpha mode */\r\n  alphaMode?: GPUCanvasAlphaMode\r\n\r\n  /** The {@link GPURenderer#renderPass | renderer RenderPass} parameters */\r\n  renderPass?: {\r\n    /** Whether the {@link GPURenderer#renderPass | renderer RenderPass} should handle depth. Default to `true` */\r\n    useDepth: RenderPassParams['useDepth']\r\n    /** The {@link GPURenderer#renderPass | renderer RenderPass} sample count (i.e. whether it should use multisampled antialiasing). Default to `4` */\r\n    sampleCount: RenderPassParams['sampleCount']\r\n    /** The {@link GPUColor | color values} to clear to before drawing the {@link GPURenderer#renderPass | renderer RenderPass}. Default to `[0, 0, 0, 0]` */\r\n    clearValue: GPUColor\r\n  }\r\n}\r\n\r\n/** Any Mesh that is bound to a DOM Element */\r\nexport type DOMProjectedMesh = DOMMesh | Plane\r\n/** Any Mesh that is projected (i.e use a {@link core/camera/Camera.Camera | Camera} to compute a model view projection matrix) */\r\nexport type ProjectedMesh = Mesh | DOMProjectedMesh\r\n/** Any Mesh that can be drawn, including fullscreen quad meshes used for post processing */\r\nexport type RenderedMesh = ProjectedMesh | PingPongPlane | ShaderPass | FullscreenPlane\r\n/** Any Mesh or Compute pass */\r\nexport type SceneObject = RenderedMesh | ComputePass\r\n\r\n/**\r\n * Base renderer class, that could technically be used to render compute passes and draw fullscreen quads, even tho it is strongly advised to use at least the {@link core/renderers/GPUCameraRenderer.GPUCameraRenderer | GPUCameraRenderer} class instead.\r\n * A renderer is responsible for:\r\n * - Setting a {@link GPUCanvasContext | context}\r\n * - Handling the {@link HTMLCanvasElement | canvas} onto everything is drawn\r\n * - Creating a {@link RenderPass} that will handle our render and depth textures and the render pass descriptor\r\n * - Keeping track of every specific class objects created relative to computing and rendering\r\n * - Creating a {@link Scene} class that will take care of the rendering process of all previously mentioned objects\r\n */\r\nexport class GPURenderer {\r\n  /** The type of the {@link GPURenderer} */\r\n  type: string\r\n  /** The universal unique id of this {@link GPURenderer} */\r\n  readonly uuid: string\r\n\r\n  /** The {@link GPUDeviceManager} used to create this {@link GPURenderer} */\r\n  deviceManager: GPUDeviceManager\r\n\r\n  /** {@link HTMLCanvasElement} onto everything is drawn */\r\n  canvas: HTMLCanvasElement\r\n  /** The WebGPU {@link GPUCanvasContext | context} used */\r\n  context: null | GPUCanvasContext\r\n  /** Set the {@link GPUCanvasContext | context} alpha mode */\r\n  alphaMode?: GPUCanvasAlphaMode\r\n\r\n  /** Options used to create this {@link GPURenderer} */\r\n  options: GPURendererParams\r\n\r\n  /** The {@link RenderPass | render pass} used to render our result to screen */\r\n  renderPass: RenderPass\r\n  /** Additional {@link RenderPass | render pass} used by {@link ShaderPass} for compositing / post processing. Does not handle depth */\r\n  postProcessingPass: RenderPass\r\n\r\n  /** The {@link Scene} used */\r\n  scene: Scene\r\n\r\n  /** An array containing all our created {@link ComputePass} */\r\n  computePasses: ComputePass[]\r\n  /** An array containing all our created {@link PingPongPlane} */\r\n  pingPongPlanes: PingPongPlane[]\r\n  /** An array containing all our created {@link ShaderPass} */\r\n  shaderPasses: ShaderPass[]\r\n  /** An array containing all our created {@link RenderTarget} */\r\n  renderTargets: RenderTarget[]\r\n  /** An array containing all our created {@link ProjectedMesh | projected meshes} */\r\n  meshes: ProjectedMesh[]\r\n  /** An array containing all our created {@link RenderTexture} */\r\n  renderTextures: RenderTexture[]\r\n\r\n  /** Pixel ratio to use for rendering */\r\n  pixelRatio: number\r\n\r\n  /** {@link DOMElement} that will track our canvas container size */\r\n  domElement: DOMElement\r\n\r\n  /** Allow to add callbacks to be executed at each render before the {@link GPUCommandEncoder} is created */\r\n  onBeforeCommandEncoderCreation: TasksQueueManager\r\n  /** Allow to add callbacks to be executed at each render after the {@link GPUCommandEncoder} has been created but before the {@link Scene} is rendered */\r\n  onBeforeRenderScene: TasksQueueManager\r\n  /** Allow to add callbacks to be executed at each render after the {@link GPUCommandEncoder} has been created and after the {@link Scene} has been rendered */\r\n  onAfterRenderScene: TasksQueueManager\r\n  /** Allow to add callbacks to be executed at each render after the {@link Scene} has been rendered and the {@link GPUCommandEncoder} has been submitted */\r\n  onAfterCommandEncoderSubmission: TasksQueueManager\r\n\r\n  // callbacks / events\r\n  /** function assigned to the {@link onBeforeRender} callback */\r\n  _onBeforeRenderCallback = (commandEncoder: GPUCommandEncoder) => {\r\n    /* allow empty callback */\r\n  }\r\n  /** function assigned to the {@link onAfterRender} callback */\r\n  _onAfterRenderCallback = (commandEncoder: GPUCommandEncoder) => {\r\n    /* allow empty callback */\r\n  }\r\n  /** function assigned to the {@link onAfterResize} callback */\r\n  _onAfterResizeCallback: () => void = () => {\r\n    /* allow empty callback */\r\n  }\r\n\r\n  /**\r\n   * GPURenderer constructor\r\n   * @param parameters - {@link GPURendererParams | parameters} used to create this {@link GPURenderer}\r\n   */\r\n  constructor({\r\n    deviceManager,\r\n    container,\r\n    pixelRatio = 1,\r\n    preferredFormat,\r\n    alphaMode = 'premultiplied',\r\n    renderPass,\r\n  }: GPURendererParams) {\r\n    this.type = 'GPURenderer'\r\n    this.uuid = generateUUID()\r\n\r\n    this.deviceManager = deviceManager\r\n    this.deviceManager.addRenderer(this)\r\n\r\n    // render pass default values\r\n    renderPass = { ...{ useDepth: true, sampleCount: 4, clearValue: [0, 0, 0, 0] }, ...renderPass }\r\n    preferredFormat = preferredFormat ?? this.deviceManager.gpu?.getPreferredCanvasFormat()\r\n\r\n    this.options = {\r\n      deviceManager,\r\n      container,\r\n      pixelRatio,\r\n      preferredFormat,\r\n      alphaMode,\r\n      renderPass,\r\n    }\r\n\r\n    this.pixelRatio = pixelRatio ?? window.devicePixelRatio ?? 1\r\n    this.alphaMode = alphaMode\r\n\r\n    this.setTasksQueues()\r\n    this.setRendererObjects()\r\n\r\n    // create the canvas\r\n    const isContainerCanvas = container instanceof HTMLCanvasElement\r\n    this.canvas = isContainerCanvas ? (container as HTMLCanvasElement) : document.createElement('canvas')\r\n\r\n    // needed to get container bounding box\r\n    this.domElement = new DOMElement({\r\n      element: container,\r\n      priority: 5, // renderer callback need to be called first\r\n      onSizeChanged: (boundingRect) => this.resize(boundingRect),\r\n    })\r\n\r\n    if (!isContainerCanvas) {\r\n      // append the canvas\r\n      this.domElement.element.appendChild(this.canvas)\r\n    }\r\n\r\n    // device is already available? create the context!\r\n    if (this.deviceManager.device) {\r\n      this.setContext()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set {@link canvas} size\r\n   * @param boundingRect - new {@link domElement | DOM Element} {@link DOMElement#boundingRect | bounding rectangle}\r\n   */\r\n  setSize(boundingRect: DOMElementBoundingRect) {\r\n    this.canvas.style.width = Math.floor(boundingRect.width) + 'px'\r\n    this.canvas.style.height = Math.floor(boundingRect.height) + 'px'\r\n\r\n    this.canvas.width = this.getScaledDisplayBoundingRect(boundingRect).width\r\n    this.canvas.height = this.getScaledDisplayBoundingRect(boundingRect).height\r\n  }\r\n\r\n  /**\r\n   * Resize our {@link GPURenderer}\r\n   * @param boundingRect - new {@link domElement | DOM Element} {@link DOMElement#boundingRect | bounding rectangle}\r\n   */\r\n  resize(boundingRect: DOMElementBoundingRect | null = null) {\r\n    if (!this.domElement && !boundingRect) return\r\n\r\n    if (!boundingRect) boundingRect = this.domElement.element.getBoundingClientRect()\r\n\r\n    this.setSize(boundingRect)\r\n\r\n    this.onResize()\r\n\r\n    this._onAfterResizeCallback && this._onAfterResizeCallback()\r\n  }\r\n\r\n  /**\r\n   * Resize all tracked objects\r\n   */\r\n  onResize() {\r\n    // resize render textures first\r\n    this.renderTextures.forEach((renderTexture) => {\r\n      renderTexture.resize()\r\n    })\r\n\r\n    // resize render & shader passes\r\n    this.renderPass?.resize()\r\n    this.postProcessingPass?.resize()\r\n\r\n    this.renderTargets.forEach((renderTarget) => renderTarget.resize())\r\n\r\n    // force compute passes onAfterResize callback\r\n    this.computePasses.forEach((computePass) => computePass.resize())\r\n\r\n    // now resize meshes that are bound to the renderer size\r\n    // especially useful to resize render textures\r\n    this.pingPongPlanes.forEach((pingPongPlane) => pingPongPlane.resize(this.boundingRect))\r\n    this.shaderPasses.forEach((shaderPass) => shaderPass.resize(this.boundingRect))\r\n    this.meshes.forEach((mesh) => {\r\n      if (!('domElement' in mesh)) {\r\n        // resize meshes that do not have a bound DOM element\r\n        mesh.resize(this.boundingRect)\r\n      } else {\r\n        this.onBeforeCommandEncoderCreation.add(\r\n          () => {\r\n            // update position for DOM meshes only if they're not currently being resized\r\n            if (!mesh.domElement.isResizing) {\r\n              mesh.domElement.setSize()\r\n            }\r\n          },\r\n          { once: true }\r\n        )\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Get our {@link domElement | DOM Element} {@link DOMElement#boundingRect | bounding rectangle}\r\n   */\r\n  get boundingRect(): DOMElementBoundingRect {\r\n    if (!!this.domElement.boundingRect) {\r\n      return this.domElement.boundingRect\r\n    } else {\r\n      const boundingRect = this.domElement.element?.getBoundingClientRect()\r\n      return {\r\n        top: boundingRect.top,\r\n        right: boundingRect.right,\r\n        bottom: boundingRect.bottom,\r\n        left: boundingRect.left,\r\n        width: boundingRect.width,\r\n        height: boundingRect.height,\r\n        x: boundingRect.x,\r\n        y: boundingRect.y,\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get our {@link domElement | DOM Element} {@link DOMElement#boundingRect | bounding rectangle} accounting for current {@link pixelRatio | pixel ratio}\r\n   */\r\n  get displayBoundingRect(): DOMElementBoundingRect {\r\n    return this.getScaledDisplayBoundingRect(this.boundingRect)\r\n  }\r\n\r\n  /**\r\n   * Get the display bounding rectangle accounting for current {@link pixelRatio | pixel ratio} and max texture dimensions\r\n   * @param boundingRect - bounding rectangle to check against\r\n   */\r\n  getScaledDisplayBoundingRect(boundingRect: DOMElementBoundingRect): DOMElementBoundingRect {\r\n    const devicePixelRatio = window.devicePixelRatio ?? 1\r\n    const scaleBoundingRect = this.pixelRatio / devicePixelRatio\r\n\r\n    const displayBoundingRect = Object.keys(boundingRect).reduce(\r\n      (a, key) => ({ ...a, [key]: boundingRect[key] * scaleBoundingRect }),\r\n      {\r\n        x: 0,\r\n        y: 0,\r\n        width: 0,\r\n        height: 0,\r\n        top: 0,\r\n        right: 0,\r\n        bottom: 0,\r\n        left: 0,\r\n      }\r\n    )\r\n\r\n    // clamp width and height based on limits\r\n    if (this.device) {\r\n      displayBoundingRect.width = Math.min(this.device.limits.maxTextureDimension2D, displayBoundingRect.width)\r\n      displayBoundingRect.height = Math.min(this.device.limits.maxTextureDimension2D, displayBoundingRect.height)\r\n\r\n      displayBoundingRect.right = Math.min(\r\n        displayBoundingRect.width + displayBoundingRect.left,\r\n        displayBoundingRect.right\r\n      )\r\n      displayBoundingRect.bottom = Math.min(\r\n        displayBoundingRect.height + displayBoundingRect.top,\r\n        displayBoundingRect.bottom\r\n      )\r\n    }\r\n\r\n    return displayBoundingRect\r\n  }\r\n\r\n  /* USEFUL DEVICE MANAGER OBJECTS */\r\n\r\n  /**\r\n   * Get our {@link GPUDeviceManager#device | device}\r\n   * @readonly\r\n   */\r\n  get device(): GPUDevice | undefined {\r\n    return this.deviceManager.device\r\n  }\r\n\r\n  /**\r\n   * Get whether our {@link GPUDeviceManager} is ready (i.e. its {@link GPUDeviceManager#adapter | adapter} and {@link GPUDeviceManager#device | device} are set) its {@link context} is set and its size is set\r\n   * @readonly\r\n   */\r\n  get ready(): boolean {\r\n    return this.deviceManager.ready && !!this.context && !!this.canvas.style.width\r\n  }\r\n\r\n  /**\r\n   * Get our {@link GPUDeviceManager#production | GPUDeviceManager production flag}\r\n   * @readonly\r\n   */\r\n  get production(): boolean {\r\n    return this.deviceManager.production\r\n  }\r\n\r\n  /**\r\n   * Get all the created {@link GPUDeviceManager#samplers | samplers}\r\n   * @readonly\r\n   */\r\n  get samplers(): Sampler[] {\r\n    return this.deviceManager.samplers\r\n  }\r\n\r\n  /**\r\n   * Get all the created {@link GPUDeviceManager#buffers | GPU buffers}\r\n   * @readonly\r\n   */\r\n  get buffers(): GPUBuffer[] {\r\n    return this.deviceManager.buffers\r\n  }\r\n\r\n  /**\r\n   * Get the {@link GPUDeviceManager#pipelineManager | pipeline manager}\r\n   * @readonly\r\n   */\r\n  get pipelineManager(): PipelineManager {\r\n    return this.deviceManager.pipelineManager\r\n  }\r\n\r\n  /**\r\n   * Get all the rendered objects (i.e. compute passes, meshes, ping pong planes and shader passes) created by the {@link GPUDeviceManager}\r\n   * @readonly\r\n   */\r\n  get deviceRenderedObjects(): SceneObject[] {\r\n    return this.deviceManager.deviceRenderedObjects\r\n  }\r\n\r\n  /**\r\n   * Configure our {@link context} with the given options\r\n   */\r\n  configureContext() {\r\n    this.context.configure({\r\n      device: this.device,\r\n      format: this.options.preferredFormat,\r\n      alphaMode: this.alphaMode,\r\n      // needed so we can copy textures for post processing usage\r\n      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\r\n      //viewFormats: []\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Set our {@link context} if possible and set {@link renderPass | main render pass} and {@link scene}\r\n   */\r\n  setContext() {\r\n    this.context = this.canvas.getContext('webgpu')\r\n\r\n    if (this.device) {\r\n      this.configureContext()\r\n\r\n      this.setMainRenderPasses()\r\n      this.setScene()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when the {@link GPUDeviceManager#device | device} is lost.\r\n   * Force all our scene objects to lose context.\r\n   */\r\n  loseContext() {\r\n    // force all our scene objects to lose context\r\n    this.renderedObjects.forEach((sceneObject) => sceneObject.loseContext())\r\n  }\r\n\r\n  /**\r\n   * Called when the {@link GPUDeviceManager#device | device} should be restored.\r\n   * Configure the context again, resize the {@link RenderTarget | render targets} and {@link RenderTexture | render textures}, restore our {@link renderedObjects | rendered objects} context.\r\n   * @async\r\n   */\r\n  restoreContext() {\r\n    this.configureContext()\r\n\r\n    // recreate all render textures first\r\n    this.renderTextures.forEach((renderTexture) => {\r\n      renderTexture.createTexture()\r\n    })\r\n\r\n    // resize render passes/recreate their textures\r\n    this.renderPass?.resize()\r\n    this.postProcessingPass?.resize()\r\n\r\n    this.renderTargets.forEach((renderTarget) => renderTarget.resize())\r\n\r\n    // restore context of all our scene objects\r\n    this.renderedObjects.forEach((sceneObject) => sceneObject.restoreContext())\r\n  }\r\n\r\n  /* PIPELINES, SCENE & MAIN RENDER PASS */\r\n\r\n  /**\r\n   * Set our {@link renderPass | main render pass} that will be used to render the result of our draw commands back to the screen and our {@link postProcessingPass | postprocessing pass} that will be used for any additional postprocessing render passes.\r\n   */\r\n  setMainRenderPasses() {\r\n    this.renderPass = new RenderPass(this, {\r\n      label: 'Main render pass',\r\n      targetFormat: this.options.preferredFormat,\r\n      ...this.options.renderPass,\r\n    } as RenderPassParams)\r\n\r\n    this.postProcessingPass = new RenderPass(this, {\r\n      label: 'Post processing render pass',\r\n      targetFormat: this.options.preferredFormat,\r\n      // no need to handle depth or perform MSAA on a fullscreen quad\r\n      useDepth: false,\r\n      sampleCount: 1,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Set our {@link scene}\r\n   */\r\n  setScene() {\r\n    this.scene = new Scene({ renderer: this })\r\n  }\r\n\r\n  /* BUFFERS & BINDINGS */\r\n\r\n  /**\r\n   * Create a {@link GPUBuffer}\r\n   * @param bufferDescriptor - {@link GPUBufferDescriptor | GPU buffer descriptor}\r\n   * @returns - newly created {@link GPUBuffer}\r\n   */\r\n  createBuffer(bufferDescriptor: GPUBufferDescriptor): GPUBuffer {\r\n    const buffer = this.device?.createBuffer(bufferDescriptor)\r\n    this.deviceManager.addBuffer(buffer)\r\n    return buffer\r\n  }\r\n\r\n  /**\r\n   * Remove a {@link GPUBuffer} from our {@link GPUDeviceManager#buffers | GPU buffers array}\r\n   * @param buffer - {@link GPUBuffer} to remove\r\n   * @param [originalLabel] - original {@link GPUBuffer} label in case the buffer has been swapped and its label has changed\r\n   */\r\n  removeBuffer(buffer: GPUBuffer, originalLabel?: string) {\r\n    this.deviceManager.removeBuffer(buffer, originalLabel)\r\n  }\r\n\r\n  /**\r\n   * Write to a {@link GPUBuffer}\r\n   * @param buffer - {@link GPUBuffer} to write to\r\n   * @param bufferOffset - {@link GPUSize64 | buffer offset}\r\n   * @param data - {@link BufferSource | data} to write\r\n   */\r\n  queueWriteBuffer(buffer: GPUBuffer, bufferOffset: GPUSize64, data: BufferSource) {\r\n    this.device?.queue.writeBuffer(buffer, bufferOffset, data)\r\n  }\r\n\r\n  /**\r\n   * Copy a source {@link GPUBuffer} into a destination {@link GPUBuffer}\r\n   * @param parameters - parameters used to realize the copy\r\n   * @param parameters.srcBuffer - source {@link GPUBuffer}\r\n   * @param [parameters.dstBuffer] - destination {@link GPUBuffer}. Will create a new one if none provided.\r\n   * @param [parameters.commandEncoder] - {@link GPUCommandEncoder} to use for the copy. Will create a new one and submit the command buffer if none provided.\r\n   * @returns - destination {@link GPUBuffer} after copy\r\n   */\r\n  copyBufferToBuffer({\r\n    srcBuffer,\r\n    dstBuffer,\r\n    commandEncoder,\r\n  }: {\r\n    srcBuffer: GPUBuffer\r\n    dstBuffer?: GPUBuffer\r\n    commandEncoder?: GPUCommandEncoder\r\n  }): GPUBuffer | null {\r\n    if (!srcBuffer) {\r\n      throwWarning(`${this.type}: cannot copy to buffer because the source buffer has not been provided`)\r\n      return null\r\n    }\r\n\r\n    if (!dstBuffer) {\r\n      dstBuffer = this.createBuffer({\r\n        label: this.type + ': destination copy buffer from: ' + srcBuffer.label,\r\n        size: srcBuffer.size,\r\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\r\n      })\r\n    }\r\n\r\n    if (srcBuffer.mapState !== 'unmapped') {\r\n      throwWarning(`${this.type}: Cannot copy from ${srcBuffer} because it is currently mapped`)\r\n      return\r\n    }\r\n    if (dstBuffer.mapState !== 'unmapped') {\r\n      throwWarning(`${this.type}: Cannot copy from ${dstBuffer} because it is currently mapped`)\r\n      return\r\n    }\r\n\r\n    // if there's no command encoder provided, we'll have to create one and submit it after the copy process\r\n    const hasCommandEncoder = !!commandEncoder\r\n\r\n    if (!hasCommandEncoder) {\r\n      commandEncoder = this.device?.createCommandEncoder({ label: 'Copy buffer command encoder' })\r\n      !this.production && commandEncoder.pushDebugGroup('Copy buffer command encoder')\r\n    }\r\n\r\n    commandEncoder.copyBufferToBuffer(srcBuffer, 0, dstBuffer, 0, dstBuffer.size)\r\n\r\n    if (!hasCommandEncoder) {\r\n      !this.production && commandEncoder.popDebugGroup()\r\n      const commandBuffer = commandEncoder.finish()\r\n      this.device?.queue.submit([commandBuffer])\r\n    }\r\n\r\n    return dstBuffer\r\n  }\r\n\r\n  /* BIND GROUPS & LAYOUTS */\r\n\r\n  /**\r\n   * Get all created {@link AllowedBindGroups | bind group} tracked by our {@link GPUDeviceManager}\r\n   * @readonly\r\n   */\r\n  get bindGroups(): AllowedBindGroups[] {\r\n    return this.deviceManager.bindGroups\r\n  }\r\n\r\n  /**\r\n   * Add a {@link AllowedBindGroups | bind group} to our {@link GPUDeviceManager#bindGroups | bind groups array}\r\n   * @param bindGroup - {@link AllowedBindGroups | bind group} to add\r\n   */\r\n  addBindGroup(bindGroup: AllowedBindGroups) {\r\n    this.deviceManager.addBindGroup(bindGroup)\r\n  }\r\n\r\n  /**\r\n   * Remove a {@link AllowedBindGroups | bind group} from our {@link GPUDeviceManager#bindGroups | bind groups array}\r\n   * @param bindGroup - {@link AllowedBindGroups | bind group} to remove\r\n   */\r\n  removeBindGroup(bindGroup: AllowedBindGroups) {\r\n    this.deviceManager.removeBindGroup(bindGroup)\r\n  }\r\n\r\n  /**\r\n   * Create a {@link GPUBindGroupLayout}\r\n   * @param bindGroupLayoutDescriptor - {@link GPUBindGroupLayoutDescriptor | GPU bind group layout descriptor}\r\n   * @returns - newly created {@link GPUBindGroupLayout}\r\n   */\r\n  createBindGroupLayout(bindGroupLayoutDescriptor: GPUBindGroupLayoutDescriptor): GPUBindGroupLayout {\r\n    return this.device?.createBindGroupLayout(bindGroupLayoutDescriptor)\r\n  }\r\n\r\n  /**\r\n   * Create a {@link GPUBindGroup}\r\n   * @param bindGroupDescriptor - {@link GPUBindGroupDescriptor | GPU bind group descriptor}\r\n   * @returns - newly created {@link GPUBindGroup}\r\n   */\r\n  createBindGroup(bindGroupDescriptor: GPUBindGroupDescriptor): GPUBindGroup {\r\n    return this.device?.createBindGroup(bindGroupDescriptor)\r\n  }\r\n\r\n  /* SHADERS & PIPELINES */\r\n\r\n  /**\r\n   * Create a {@link GPUShaderModule}\r\n   * @param shaderModuleDescriptor - {@link shaderModuleDescriptor | shader module descriptor}\r\n   * @returns - newly created {@link GPUShaderModule}\r\n   */\r\n  createShaderModule(shaderModuleDescriptor: GPUShaderModuleDescriptor): GPUShaderModule {\r\n    return this.device?.createShaderModule(shaderModuleDescriptor)\r\n  }\r\n\r\n  /**\r\n   * Create a {@link GPUPipelineLayout}\r\n   * @param pipelineLayoutDescriptor - {@link GPUPipelineLayoutDescriptor | GPU pipeline layout descriptor}\r\n   * @returns - newly created {@link GPUPipelineLayout}\r\n   */\r\n  createPipelineLayout(pipelineLayoutDescriptor: GPUPipelineLayoutDescriptor): GPUPipelineLayout {\r\n    return this.device?.createPipelineLayout(pipelineLayoutDescriptor)\r\n  }\r\n\r\n  /**\r\n   * Create a {@link GPURenderPipeline}\r\n   * @param pipelineDescriptor - {@link GPURenderPipelineDescriptor | GPU render pipeline descriptor}\r\n   * @returns - newly created {@link GPURenderPipeline}\r\n   */\r\n  createRenderPipeline(pipelineDescriptor: GPURenderPipelineDescriptor): GPURenderPipeline {\r\n    return this.device?.createRenderPipeline(pipelineDescriptor)\r\n  }\r\n\r\n  /**\r\n   * Asynchronously create a {@link GPURenderPipeline}\r\n   * @async\r\n   * @param pipelineDescriptor - {@link GPURenderPipelineDescriptor | GPU render pipeline descriptor}\r\n   * @returns - newly created {@link GPURenderPipeline}\r\n   */\r\n  async createRenderPipelineAsync(pipelineDescriptor: GPURenderPipelineDescriptor): Promise<GPURenderPipeline> {\r\n    return await this.device?.createRenderPipelineAsync(pipelineDescriptor)\r\n  }\r\n\r\n  /**\r\n   * Create a {@link GPUComputePipeline}\r\n   * @param pipelineDescriptor - {@link GPUComputePipelineDescriptor | GPU compute pipeline descriptor}\r\n   * @returns - newly created {@link GPUComputePipeline}\r\n   */\r\n  createComputePipeline(pipelineDescriptor: GPUComputePipelineDescriptor): GPUComputePipeline {\r\n    return this.device?.createComputePipeline(pipelineDescriptor)\r\n  }\r\n\r\n  /**\r\n   * Asynchronously create a {@link GPUComputePipeline}\r\n   * @async\r\n   * @param pipelineDescriptor - {@link GPUComputePipelineDescriptor | GPU compute pipeline descriptor}\r\n   * @returns - newly created {@link GPUComputePipeline}\r\n   */\r\n  async createComputePipelineAsync(pipelineDescriptor: GPUComputePipelineDescriptor): Promise<GPUComputePipeline> {\r\n    return await this.device?.createComputePipelineAsync(pipelineDescriptor)\r\n  }\r\n\r\n  /* TEXTURES */\r\n\r\n  /**\r\n   * Get all created {@link Texture} tracked by our {@link GPUDeviceManager}\r\n   * @readonly\r\n   */\r\n  get textures(): Texture[] {\r\n    return this.deviceManager.textures\r\n  }\r\n\r\n  /**\r\n   * Add a {@link Texture} to our {@link GPUDeviceManager#textures | textures array}\r\n   * @param texture - {@link Texture} to add\r\n   */\r\n  addTexture(texture: Texture) {\r\n    this.deviceManager.addTexture(texture)\r\n  }\r\n\r\n  /**\r\n   * Remove a {@link Texture} from our {@link GPUDeviceManager#textures | textures array}\r\n   * @param texture - {@link Texture} to remove\r\n   */\r\n  removeTexture(texture: Texture) {\r\n    this.deviceManager.removeTexture(texture)\r\n  }\r\n\r\n  /**\r\n   * Add a {@link RenderTexture} to our {@link renderTextures} array\r\n   * @param texture - {@link RenderTexture} to add\r\n   */\r\n  addRenderTexture(texture: RenderTexture) {\r\n    this.renderTextures.push(texture)\r\n  }\r\n\r\n  /**\r\n   * Remove a {@link RenderTexture} from our {@link renderTextures} array\r\n   * @param texture - {@link RenderTexture} to remove\r\n   */\r\n  removeRenderTexture(texture: RenderTexture) {\r\n    this.renderTextures = this.renderTextures.filter((t) => t.uuid !== texture.uuid)\r\n  }\r\n\r\n  /**\r\n   * Create a {@link GPUTexture}\r\n   * @param textureDescriptor - {@link GPUTextureDescriptor | GPU texture descriptor}\r\n   * @returns - newly created {@link GPUTexture}\r\n   */\r\n  createTexture(textureDescriptor: GPUTextureDescriptor): GPUTexture {\r\n    return this.device?.createTexture(textureDescriptor)\r\n  }\r\n\r\n  /**\r\n   * Upload a {@link Texture#texture | texture} to the GPU\r\n   * @param texture - {@link Texture} class object with the {@link Texture#texture | texture} to upload\r\n   */\r\n  uploadTexture(texture: Texture) {\r\n    this.deviceManager.uploadTexture(texture)\r\n  }\r\n\r\n  /**\r\n   * Import a {@link GPUExternalTexture}\r\n   * @param video - {@link HTMLVideoElement} source\r\n   * @returns - {@link GPUExternalTexture}\r\n   */\r\n  importExternalTexture(video: HTMLVideoElement): GPUExternalTexture {\r\n    // TODO WebCodecs may be the way to go when time comes!\r\n    // https://developer.chrome.com/blog/new-in-webgpu-113/#use-webcodecs-videoframe-source-in-importexternaltexture\r\n    // see onVideoFrameCallback method in Texture class\r\n    // const videoFrame = new VideoFrame(video)\r\n    // return this.device?.importExternalTexture({ source: videoFrame })\r\n    return this.device?.importExternalTexture({ source: video })\r\n  }\r\n\r\n  /**\r\n   * Check if a {@link Sampler} has already been created with the same {@link Sampler#options | parameters}.\r\n   * Use it if found, else create a new one and add it to the {@link GPUDeviceManager#samplers | samplers array}.\r\n   * @param sampler - {@link Sampler} to create\r\n   * @returns - the {@link GPUSampler}\r\n   */\r\n  createSampler(sampler: Sampler): GPUSampler {\r\n    const existingSampler = this.samplers.find((existingSampler) => {\r\n      return JSON.stringify(existingSampler.options) === JSON.stringify(sampler.options) && existingSampler.sampler\r\n    })\r\n\r\n    if (existingSampler) {\r\n      return existingSampler.sampler\r\n    } else {\r\n      const { type, ...samplerOptions } = sampler.options\r\n      const gpuSampler: GPUSampler = this.device?.createSampler({\r\n        label: sampler.label,\r\n        ...samplerOptions,\r\n      })\r\n\r\n      this.deviceManager.addSampler(sampler)\r\n\r\n      return gpuSampler\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a {@link Sampler} from our {@link GPUDeviceManager#samplers | samplers array}\r\n   * @param sampler - {@link Sampler} to remove\r\n   */\r\n  removeSampler(sampler: Sampler) {\r\n    this.deviceManager.removeSampler(sampler)\r\n  }\r\n\r\n  /* OBJECTS & TASKS */\r\n\r\n  /**\r\n   * Set different tasks queue managers to execute callbacks at different phases of our render call:\r\n   * - {@link onBeforeCommandEncoderCreation}: callbacks executed before the creation of the command encoder\r\n   * - {@link onBeforeRenderScene}: callbacks executed after the creation of the command encoder and before rendering the {@link Scene}\r\n   * - {@link onAfterRenderScene}: callbacks executed after the creation of the command encoder and after rendering the {@link Scene}\r\n   * - {@link onAfterCommandEncoderSubmission}: callbacks executed after the submission of the command encoder\r\n   */\r\n  setTasksQueues() {\r\n    this.onBeforeCommandEncoderCreation = new TasksQueueManager()\r\n    this.onBeforeRenderScene = new TasksQueueManager()\r\n    this.onAfterRenderScene = new TasksQueueManager()\r\n    this.onAfterCommandEncoderSubmission = new TasksQueueManager()\r\n  }\r\n\r\n  /**\r\n   * Set all objects arrays that we'll keep track of\r\n   */\r\n  setRendererObjects() {\r\n    // keep track of compute passes, meshes, etc.\r\n    this.computePasses = []\r\n    this.pingPongPlanes = []\r\n    this.shaderPasses = []\r\n    this.renderTargets = []\r\n    this.meshes = []\r\n    this.renderTextures = []\r\n  }\r\n\r\n  /**\r\n   * Get all this {@link GPURenderer} rendered objects (i.e. compute passes, meshes, ping pong planes and shader passes)\r\n   * @readonly\r\n   */\r\n  get renderedObjects(): SceneObject[] {\r\n    return [...this.computePasses, ...this.meshes, ...this.shaderPasses, ...this.pingPongPlanes]\r\n  }\r\n\r\n  /**\r\n   * Get all objects ({@link RenderedMesh | rendered meshes} or {@link ComputePass | compute passes}) using a given {@link AllowedBindGroups | bind group}.\r\n   * Useful to know if a resource is used by multiple objects and if it is safe to destroy it or not.\r\n   * @param bindGroup - {@link AllowedBindGroups | bind group} to check\r\n   */\r\n  getObjectsByBindGroup(bindGroup: AllowedBindGroups): undefined | SceneObject[] {\r\n    return this.deviceRenderedObjects.filter((object) => {\r\n      return [\r\n        ...object.material.bindGroups,\r\n        ...object.material.inputsBindGroups,\r\n        ...object.material.clonedBindGroups,\r\n      ].some((bG) => bG.uuid === bindGroup.uuid)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Get all objects ({@link RenderedMesh | rendered meshes} or {@link ComputePass | compute passes}) using a given {@link Texture} or {@link RenderTexture}.\r\n   * Useful to know if a resource is used by multiple objects and if it is safe to destroy it or not.\r\n   * @param texture - {@link Texture} or {@link RenderTexture} to check\r\n   */\r\n  getObjectsByTexture(texture: Texture | RenderTexture): undefined | SceneObject[] {\r\n    return this.deviceRenderedObjects.filter((object) => {\r\n      return [...object.material.textures, ...object.material.renderTextures].some((t) => t.uuid === texture.uuid)\r\n    })\r\n  }\r\n\r\n  /* EVENTS */\r\n\r\n  /**\r\n   * Assign a callback function to _onBeforeRenderCallback\r\n   * @param callback - callback to run just before the {@link render} method will be executed\r\n   * @returns - our {@link GPURenderer}\r\n   */\r\n  onBeforeRender(callback: (commandEncoder?: GPUCommandEncoder) => void) {\r\n    if (callback) {\r\n      this._onBeforeRenderCallback = callback\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Assign a callback function to _onAfterRenderCallback\r\n   * @param callback - callback to run just after the {@link render} method has been executed\r\n   * @returns - our {@link GPURenderer}\r\n   */\r\n  onAfterRender(callback: (commandEncoder?: GPUCommandEncoder) => void) {\r\n    if (callback) {\r\n      this._onAfterRenderCallback = callback\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Assign a callback function to _onAfterResizeCallback\r\n   * @param callback - callback to run just after the {@link GPURenderer} has been resized\r\n   * @returns - our {@link GPURenderer}\r\n   */\r\n  onAfterResize(callback: (commandEncoder?: GPUCommandEncoder) => void) {\r\n    if (callback) {\r\n      this._onAfterResizeCallback = callback\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  /* RENDER */\r\n\r\n  /**\r\n   * Render a single {@link ComputePass}\r\n   * @param commandEncoder - current {@link GPUCommandEncoder}\r\n   * @param computePass - {@link ComputePass}\r\n   */\r\n  renderSingleComputePass(commandEncoder: GPUCommandEncoder, computePass: ComputePass) {\r\n    const pass = commandEncoder.beginComputePass()\r\n    computePass.render(pass)\r\n    pass.end()\r\n\r\n    computePass.copyBufferToResult(commandEncoder)\r\n  }\r\n\r\n  /**\r\n   * Render a single {@link RenderedMesh | Mesh}\r\n   * @param commandEncoder - current {@link GPUCommandEncoder}\r\n   * @param mesh - {@link RenderedMesh | Mesh} to render\r\n   */\r\n  renderSingleMesh(commandEncoder: GPUCommandEncoder, mesh: RenderedMesh) {\r\n    const pass = commandEncoder.beginRenderPass(this.renderPass.descriptor)\r\n    mesh.render(pass)\r\n    pass.end()\r\n  }\r\n\r\n  /**\r\n   * Render an array of objects (either {@link RenderedMesh | Meshes} or {@link ComputePass}) once. This method won't call any of the renderer render hooks like {@link onBeforeRender}, {@link onAfterRender}\r\n   * @param objects - Array of {@link RenderedMesh | Meshes} or {@link ComputePass} to render\r\n   */\r\n  renderOnce(objects: SceneObject[]) {\r\n    const commandEncoder = this.device?.createCommandEncoder({\r\n      label: 'Render once command encoder',\r\n    })\r\n    !this.production && commandEncoder.pushDebugGroup('Render once command encoder')\r\n\r\n    this.pipelineManager.resetCurrentPipeline()\r\n\r\n    objects.forEach((object) => {\r\n      if (object instanceof ComputePass) {\r\n        this.renderSingleComputePass(commandEncoder, object)\r\n      } else {\r\n        this.renderSingleMesh(commandEncoder, object)\r\n      }\r\n    })\r\n\r\n    !this.production && commandEncoder.popDebugGroup()\r\n    const commandBuffer = commandEncoder.finish()\r\n    this.device?.queue.submit([commandBuffer])\r\n\r\n    this.pipelineManager.resetCurrentPipeline()\r\n  }\r\n\r\n  /**\r\n   * Force to clear a {@link GPURenderer} content to its {@link RenderPass#options.clearValue | clear value} by rendering and empty pass.\r\n   * @param commandEncoder\r\n   */\r\n  forceClear(commandEncoder?: GPUCommandEncoder) {\r\n    // if there's no command encoder provided, we'll have to create one and submit it after the copy process\r\n    const hasCommandEncoder = !!commandEncoder\r\n\r\n    if (!hasCommandEncoder) {\r\n      commandEncoder = this.device?.createCommandEncoder({ label: 'Force clear command encoder' })\r\n      !this.production && commandEncoder.pushDebugGroup('Force clear command encoder')\r\n    }\r\n\r\n    this.renderPass.updateView()\r\n    const pass = commandEncoder.beginRenderPass(this.renderPass.descriptor)\r\n    pass.end()\r\n\r\n    if (!hasCommandEncoder) {\r\n      !this.production && commandEncoder.popDebugGroup()\r\n      const commandBuffer = commandEncoder.finish()\r\n      this.device?.queue.submit([commandBuffer])\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called by the {@link GPUDeviceManager#render | GPUDeviceManager render method} before the {@link GPUCommandEncoder} has been created\r\n   */\r\n  onBeforeCommandEncoder() {\r\n    if (!this.ready) return\r\n    // now render!\r\n    this.onBeforeCommandEncoderCreation.execute()\r\n  }\r\n\r\n  /**\r\n   * Called by the {@link GPUDeviceManager#render | GPUDeviceManager render method} after the {@link GPUCommandEncoder} has been created.\r\n   */\r\n  onAfterCommandEncoder() {\r\n    if (!this.ready) return\r\n\r\n    this.onAfterCommandEncoderSubmission.execute()\r\n  }\r\n\r\n  /**\r\n   * Called at each draw call to render our scene and its content\r\n   * @param commandEncoder - current {@link GPUCommandEncoder}\r\n   */\r\n  render(commandEncoder: GPUCommandEncoder) {\r\n    if (!this.ready) return\r\n\r\n    this._onBeforeRenderCallback && this._onBeforeRenderCallback(commandEncoder)\r\n    this.onBeforeRenderScene.execute(commandEncoder)\r\n\r\n    this.scene?.render(commandEncoder)\r\n\r\n    this._onAfterRenderCallback && this._onAfterRenderCallback(commandEncoder)\r\n    this.onAfterRenderScene.execute(commandEncoder)\r\n  }\r\n\r\n  /**\r\n   * Destroy our {@link GPURenderer} and everything that needs to be destroyed as well\r\n   */\r\n  destroy() {\r\n    this.domElement?.destroy()\r\n\r\n    // destroy render passes\r\n    this.renderPass?.destroy()\r\n    this.postProcessingPass?.destroy()\r\n\r\n    this.renderTargets.forEach((renderTarget) => renderTarget.destroy())\r\n    this.renderedObjects.forEach((sceneObject) => sceneObject.remove())\r\n\r\n    this.renderTextures.forEach((texture) => texture.destroy())\r\n\r\n    this.context?.unconfigure()\r\n  }\r\n}\r\n"],"names":["existingSampler"],"mappings":"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"}