{"version":3,"file":"MeshBaseMixin.mjs","sources":["../../../../../src/core/meshes/mixins/MeshBaseMixin.ts"],"sourcesContent":["import { generateUUID, throwWarning } from '../../../utils/utils'\nimport { isRenderer, Renderer } from '../../renderers/utils'\nimport { RenderMaterial } from '../../materials/RenderMaterial'\nimport { Texture } from '../../textures/Texture'\nimport { Geometry } from '../../geometries/Geometry'\nimport { RenderTexture, RenderTextureParams } from '../../textures/RenderTexture'\nimport { ExternalTextureParams, TextureParams, TextureParent } from '../../../types/Textures'\nimport { RenderTarget } from '../../renderPasses/RenderTarget'\nimport { GPUCurtains } from '../../../curtains/GPUCurtains'\nimport { ProjectedMesh } from '../../renderers/GPURenderer'\nimport { Material } from '../../materials/Material'\nimport { DOMElementBoundingRect } from '../../DOM/DOMElement'\nimport { AllowedGeometries, RenderMaterialParams, ShaderOptions } from '../../../types/Materials'\nimport { ProjectedMeshBaseClass } from './ProjectedMeshBaseMixin'\nimport default_vsWgsl from '../../shaders/chunks/default_vs.wgsl'\nimport default_fsWgsl from '../../shaders/chunks/default_fs.wgsl'\nimport { RenderPass } from '../../renderPasses/RenderPass'\n\nlet meshIndex = 0\n\nexport interface MeshBaseRenderParams extends RenderMaterialParams {\n  /** Whether we should add this Mesh to our {@link core/scenes/Scene.Scene | Scene} to let it handle the rendering process automatically */\n  autoRender?: boolean\n  /** Flag indicating whether to draw this Mesh or not */\n  visible?: boolean\n  /** Controls the order in which this Mesh should be rendered by our {@link core/scenes/Scene.Scene | Scene} */\n  renderOrder?: number\n  /** Optional {@link RenderTarget} to render this Mesh to instead of the canvas context. */\n  outputTarget?: RenderTarget\n  /** Parameters used by this Mesh to create a {@link Texture} */\n  texturesOptions?: ExternalTextureParams\n}\n\n/**\n * Base parameters used to create a Mesh\n */\nexport interface MeshBaseParams extends MeshBaseRenderParams {\n  /** Geometry to use */\n  geometry: AllowedGeometries\n}\n\n/**\n *  Base options used to create this Mesh\n */\nexport interface MeshBaseOptions {\n  /** The label of this Mesh, sent to various GPU objects for debugging purpose */\n  label?: MeshBaseParams['label']\n  /** Shaders to use by this Mesh {@link RenderMaterial} */\n  shaders?: MeshBaseParams['shaders']\n  /** Parameters used by this Mesh to create a {@link Texture} */\n  texturesOptions?: ExternalTextureParams\n  /** {@link RenderTarget} to render this Mesh to instead of the canvas context, if any. */\n  outputTarget?: RenderTarget | null\n  /** Whether we should add this Mesh to our {@link core/scenes/Scene.Scene | Scene} to let it handle the rendering process automatically */\n  autoRender?: boolean\n  /** Whether to compile this Mesh {@link RenderMaterial} {@link core/pipelines/RenderPipelineEntry.RenderPipelineEntry#pipeline | render pipeline} asynchronously or not */\n  useAsyncPipeline?: boolean\n}\n\n/** @const - Default Mesh parameters to merge with user defined parameters */\nconst defaultMeshBaseParams: MeshBaseParams = {\n  // geometry\n  geometry: new Geometry(),\n  // material\n  shaders: {},\n  autoRender: true,\n  useProjection: false,\n  useAsyncPipeline: true,\n  // rendering\n  cullMode: 'back',\n  depth: true,\n  depthWriteEnabled: true,\n  depthCompare: 'less',\n  depthFormat: 'depth24plus',\n  transparent: false,\n  visible: true,\n  renderOrder: 0,\n  // textures\n  texturesOptions: {},\n}\n\n// based on https://stackoverflow.com/a/75673107/13354068\n// we declare first a class, and then the mixin with a return type\n/**\n * This class describes the properties and methods to set up a basic Mesh, implemented in the {@link MeshBaseMixin}:\n * - Set and render the {@link Geometry} and {@link RenderMaterial}\n * - Add helpers to create {@link Texture} and {@link RenderTexture}\n * - Handle resizing, device lost/restoration and destroying the resources\n */\nexport declare class MeshBaseClass {\n  /** The type of the {@link MeshBaseClass} */\n  type: string\n  /** The universal unique id of the {@link MeshBaseClass} */\n  readonly uuid: string\n  /** Index of this {@link MeshBaseClass}, i.e. creation order */\n  readonly index: number\n  /** The {@link Renderer} used */\n  renderer: Renderer\n\n  /** Options used to create this {@link MeshBaseClass} */\n  options: MeshBaseOptions\n\n  /** {@link RenderMaterial} used by this {@link MeshBaseClass} */\n  material: RenderMaterial\n  /** {@link AllowedGeometries | Geometry} used by this {@link MeshBaseClass} */\n  geometry: MeshBaseParams['geometry']\n\n  /** {@link RenderTarget} to render this Mesh to instead of the canvas context, if any. */\n  outputTarget: null | RenderTarget\n\n  /** Controls the order in which this {@link MeshBaseClass} should be rendered by our {@link core/scenes/Scene.Scene | Scene} */\n  renderOrder: number\n  /** Whether this {@link MeshBaseClass} should be treated as transparent. Impacts the {@link core/pipelines/RenderPipelineEntry.RenderPipelineEntry#pipeline | render pipeline} blend properties */\n  transparent: boolean\n\n  /** Flag indicating whether to draw this {@link MeshBaseClass} or not */\n  visible: boolean\n  /** Flag indicating whether this {@link MeshBaseClass} is ready to be drawn */\n  _ready: boolean\n\n  /** Empty object to store any additional data or custom properties into your Mesh. */\n  userData: Record<string, unknown>\n\n  // callbacks\n  /** function assigned to the {@link onReady} callback */\n  _onReadyCallback: () => void\n  /** function assigned to the {@link onBeforeRender} callback */\n  _onBeforeRenderCallback: () => void\n  /** function assigned to the {@link onRender} callback */\n  _onRenderCallback: () => void\n  /** function assigned to the {@link onAfterRender} callback */\n  _onAfterRenderCallback: () => void\n  /** function assigned to the {@link onAfterResize} callback */\n  _onAfterResizeCallback: () => void\n  /**\n   * Assign a callback function to _onReadyCallback\n   * @param callback - callback to run when {@link MeshBaseClass} is ready\n   * @returns - our Mesh\n   */\n  onReady: (callback: () => void) => MeshBaseClass | ProjectedMeshBaseClass\n  /**\n   * Assign a callback function to _onBeforeRenderCallback\n   * @param callback - callback to run just before {@link MeshBaseClass} will be rendered\n   * @returns - our Mesh\n   */\n  onBeforeRender: (callback: () => void) => MeshBaseClass | ProjectedMeshBaseClass\n  /**\n   * Assign a callback function to _onRenderCallback\n   * @param callback - callback to run when {@link MeshBaseClass} is rendered\n   * @returns - our Mesh\n   */\n  onRender: (callback: () => void) => MeshBaseClass | ProjectedMeshBaseClass\n  /**\n   * Assign a callback function to _onAfterRenderCallback\n   * @param callback - callback to run just after {@link MeshBaseClass} has been rendered\n   * @returns - our Mesh\n   */\n  onAfterRender: (callback: () => void) => MeshBaseClass | ProjectedMeshBaseClass\n  /**\n   * Assign a callback function to _onBeforeRenderCallback\n   * @param callback - callback to run just after {@link MeshBaseClass} has been resized\n   * @returns - our Mesh\n   */\n  onAfterResize: (callback: () => void) => MeshBaseClass | ProjectedMeshBaseClass\n\n  /**\n   * {@link MeshBaseClass} constructor\n   * @param renderer - our {@link Renderer} class object\n   * @param element - a DOM HTML Element that can be bound to a Mesh\n   * @param parameters - {@link MeshBaseParams | Mesh base parameters}\n   */\n  constructor(renderer: Renderer, element: HTMLElement | null, parameters: MeshBaseParams)\n\n  /**\n   * Get private #autoRender value\n   * @readonly\n   */\n  get autoRender(): boolean // allow to read value from child classes\n\n  /**\n   * Get/set whether a Mesh is ready or not\n   * @readonly\n   */\n  get ready(): boolean\n  set ready(value: boolean)\n\n  /**\n   * Add a Mesh to the renderer and the {@link core/scenes/Scene.Scene | Scene}\n   */\n  addToScene(): void\n\n  /**\n   * Remove a Mesh from the renderer and the {@link core/scenes/Scene.Scene | Scene}\n   */\n  removeFromScene(): void\n\n  /**\n   * Set or update the {@link RenderMaterial} {@link types/Materials.RenderMaterialRenderingOptions | rendering options} to match the {@link RenderPass#descriptor | RenderPass descriptor} used to draw this Mesh.\n   * @param renderPass - {@link RenderPass | RenderPass} used to draw this Mesh, default to the {@link core/renderers/GPURenderer.GPURenderer#renderPass | renderer renderPass}.\n   */\n  setRenderingOptionsForRenderPass(renderPass: RenderPass): void\n\n  /**\n   * Set a new {@link Renderer} for this Mesh\n   * @param renderer - new {@link Renderer} to set\n   */\n  setRenderer(renderer: Renderer | GPUCurtains): void\n\n  /**\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been lost to prepare everything for restoration.\n   * Basically set all the {@link GPUBuffer} to null so they will be reset next time we try to draw the Mesh\n   */\n  loseContext(): void\n\n  /**\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been restored\n   */\n  restoreContext(): void\n\n  /**\n   * Set default shaders if one or both of them are missing\n   */\n  setShaders(): void\n\n  /**\n   * Compute the Mesh geometry if needed\n   */\n  computeGeometry(): void\n\n  /**\n   * Create the Mesh Geometry vertex and index buffers if needed\n   */\n  createGeometryBuffers(): void\n\n  /**\n   * Set our Mesh geometry: create buffers and add attributes to material\n   */\n  setGeometry(): void\n\n  /**\n   * Set a Mesh transparent property, then set its material\n   * @param meshParameters - {@link RenderMaterialParams | RenderMaterial parameters}\n   */\n  setMaterial(meshParameters: RenderMaterialParams): void\n\n  /**\n   * Set Mesh material attributes\n   */\n  setMaterialGeometryAttributes(): void\n\n  /**\n   * Get our {@link RenderMaterial#textures | RenderMaterial textures array}\n   * @readonly\n   */\n  get textures(): Texture[]\n\n  /**\n   * Get our {@link RenderMaterial#renderTextures | RenderMaterial render textures array}\n   * @readonly\n   */\n  get renderTextures(): RenderTexture[]\n\n  /**\n   * Create a new {@link Texture}\n   * @param options - {@link TextureParams | Texture parameters}\n   * @returns - newly created Texture\n   */\n  createTexture(options: TextureParams): Texture\n\n  /**\n   * Add a {@link Texture}\n   * @param texture - {@link Texture} to add\n   */\n  addTexture(texture: Texture)\n\n  /**\n   * Callback run when a new {@link Texture} has been created\n   * @param texture - newly created Texture\n   */\n  onTextureAdded(texture: Texture): void\n\n  /**\n   * Create a new {@link RenderTexture}\n   * @param  options - {@link RenderTextureParams | RenderTexture parameters}\n   * @returns - newly created RenderTexture\n   */\n  createRenderTexture(options: RenderTextureParams): RenderTexture\n\n  /**\n   * Add a {@link RenderTexture}\n   * @param renderTexture - {@link RenderTexture} to add\n   */\n  addRenderTexture(renderTexture: RenderTexture)\n\n  /**\n   * Assign or remove a {@link RenderTarget} to this Mesh\n   * Since this manipulates the {@link core/scenes/Scene.Scene | Scene} stacks, it can be used to remove a RenderTarget as well.\n   * @param outputTarget - the RenderTarget to assign or null if we want to remove the current RenderTarget\n   */\n  setOutputTarget(outputTarget: RenderTarget | null): void\n\n  /**\n   * Get the current {@link RenderMaterial} uniforms\n   * @readonly\n   */\n  get uniforms(): Material['uniforms']\n\n  /**\n   * Get the current {@link RenderMaterial} storages\n   * @readonly\n   */\n  get storages(): Material['storages']\n\n  /**\n   * Resize the Mesh's textures\n   * @param boundingRect\n   */\n  resize(boundingRect?: DOMElementBoundingRect): void\n\n  /**\n   * Called before rendering the Mesh\n   * Set the geometry if needed (create buffers and add attributes to the {@link RenderMaterial})\n   * Then executes {@link RenderMaterial#onBeforeRender}: create its bind groups and pipeline if needed and eventually update its struct\n   */\n  onBeforeRenderPass(): void\n\n  /**\n   * Render our {@link MeshBaseClass} if the {@link RenderMaterial} is ready\n   * @param pass - current render pass encoder\n   */\n  onRenderPass(pass: GPURenderPassEncoder): void\n\n  /**\n   * Called after having rendered the Mesh\n   */\n  onAfterRenderPass(): void\n\n  /**\n   * Render our Mesh\n   * - Execute {@link onBeforeRenderPass}\n   * - Stop here if {@link Renderer} is not ready or Mesh is not {@link visible}\n   * - Execute super render call if it exists\n   * - {@link onRenderPass | render} our {@link material} and {@link geometry}\n   * - Execute {@link onAfterRenderPass}\n   * @param pass - current render pass encoder\n   */\n  render(pass: GPURenderPassEncoder): void\n\n  /**\n   * Remove the Mesh from the {@link core/scenes/Scene.Scene | Scene} and destroy it\n   */\n  remove(): void\n\n  /**\n   * Destroy the Mesh\n   */\n  destroy(): void\n}\n\n/**\n * To get started, we need a type which we'll use to extend\n * other classes from. The main responsibility is to declare\n * that the type being passed in is a class.\n * We use a generic version which can apply a constraint on\n * the class which this mixin is applied to\n * @typeParam T - the base constructor\n */\nexport type MixinConstructor<T = {}> = new (...args: any[]) => T\n\n/**\n * Used to mix the basic Mesh properties and methods defined in {@link MeshBaseClass} (basically, set a {@link Geometry} and a {@link RenderMaterial} and render them, add helpers to create {@link Texture} and {@link RenderTexture}) with a given Base of type {@link core/objects3D/Object3D.Object3D | Object3D}, {@link core/objects3D/ProjectedObject3D.ProjectedObject3D | ProjectedObject3D}, {@link curtains/objects3D/DOMObject3D.DOMObject3D | DOMObject3D} or an empty class.\n * @exports MeshBaseMixin\n * @param Base - the class to mix onto\n * @returns - the mixed classes, creating a basic Mesh.\n */\nfunction MeshBaseMixin<TBase extends MixinConstructor>(Base: TBase): MixinConstructor<MeshBaseClass> & TBase {\n  /**\n   * MeshBase defines our base properties and methods\n   */\n  return class MeshBase extends Base implements MeshBaseClass {\n    /** The type of the {@link MeshBase} */\n    type: string\n    /** The universal unique id of the {@link MeshBase} */\n    readonly uuid: string\n    /** Index of this {@link MeshBase}, i.e. creation order */\n    readonly index: number\n    /** The {@link Renderer} used */\n    renderer: Renderer\n\n    /** Options used to create this {@link MeshBase} */\n    options: MeshBaseOptions\n\n    /** {@link RenderMaterial} used by this {@link MeshBase} */\n    material: RenderMaterial\n    /** {@link AllowedGeometries | Geometry} used by this {@link MeshBase} */\n    geometry: MeshBaseParams['geometry']\n\n    /** {@link RenderTarget} to render this Mesh to, if any */\n    outputTarget: null | RenderTarget\n\n    /** Controls the order in which this {@link MeshBase} should be rendered by our {@link core/scenes/Scene.Scene | Scene} */\n    renderOrder: number\n    /** Whether this {@link MeshBase} should be treated as transparent. Impacts the {@link core/pipelines/RenderPipelineEntry.RenderPipelineEntry#pipeline | render pipeline} blend properties */\n    transparent: boolean\n\n    /** Flag indicating whether to draw this {@link MeshBase} or not */\n    visible: boolean\n    /** Flag indicating whether this {@link MeshBase} is ready to be drawn */\n    _ready: boolean\n\n    /** Empty object to store any additional data or custom properties into your {@link MeshBase}. */\n    userData: Record<string, unknown>\n\n    /** Whether we should add this {@link MeshBase} to our {@link core/scenes/Scene.Scene | Scene} to let it handle the rendering process automatically */\n    #autoRender = true\n\n    // callbacks / events\n    /** function assigned to the {@link onReady} callback */\n    _onReadyCallback: () => void = () => {\n      /* allow empty callback */\n    }\n    /** function assigned to the {@link onBeforeRender} callback */\n    _onBeforeRenderCallback: () => void = () => {\n      /* allow empty callback */\n    }\n    /** function assigned to the {@link onRender} callback */\n    _onRenderCallback: () => void = () => {\n      /* allow empty callback */\n    }\n    /** function assigned to the {@link onAfterRender} callback */\n    _onAfterRenderCallback: () => void = () => {\n      /* allow empty callback */\n    }\n    /** function assigned to the {@link onAfterResize} callback */\n    _onAfterResizeCallback: () => void = () => {\n      /* allow empty callback */\n    }\n\n    /**\n     * MeshBase constructor\n     *\n     * @typedef MeshBaseArrayParams\n     * @type {array}\n     * @property {(Renderer|GPUCurtains)} 0 - our {@link Renderer} class object\n     * @property {(string|HTMLElement|null)} 1 - a DOM HTML Element that can be bound to a Mesh\n     * @property {MeshBaseParams} 2 - {@link MeshBaseParams | Mesh base parameters}\n     *\n     * @param {MeshBaseArrayParams} params - our MeshBaseMixin parameters\n     */\n    constructor(...params: any[]) {\n      super(\n        params[0] as Renderer | GPUCurtains,\n        params[1] as HTMLElement | string | null,\n        { ...defaultMeshBaseParams, ...params[2] } as MeshBaseParams\n      )\n\n      let renderer = params[0]\n      const parameters = { ...defaultMeshBaseParams, ...params[2] }\n\n      this.type = 'MeshBase'\n\n      this.uuid = generateUUID()\n      Object.defineProperty(this as MeshBase, 'index', { value: meshIndex++ })\n\n      // we could pass our curtains object OR our curtains renderer object\n      renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as Renderer)\n\n      isRenderer(renderer, parameters.label ? parameters.label + ' ' + this.type : this.type)\n\n      this.renderer = renderer\n\n      const {\n        label,\n        shaders,\n        geometry,\n        visible,\n        renderOrder,\n        outputTarget,\n        texturesOptions,\n        autoRender,\n        ...meshParameters\n      } = parameters\n\n      this.outputTarget = outputTarget ?? null\n\n      // set default sample count\n      meshParameters.sampleCount = !!meshParameters.sampleCount\n        ? meshParameters.sampleCount\n        : this.outputTarget\n        ? this.outputTarget.renderPass.options.sampleCount\n        : this.renderer && this.renderer.renderPass\n        ? this.renderer.renderPass.options.sampleCount\n        : 1\n\n      this.options = {\n        ...(this.options ?? {}), // merge possible lower options?\n        label: label ?? 'Mesh ' + this.renderer.meshes.length,\n        shaders,\n        texturesOptions,\n        ...(outputTarget !== undefined && { outputTarget }),\n        ...(autoRender !== undefined && { autoRender }),\n        ...(meshParameters.useAsyncPipeline !== undefined && { useAsyncPipeline: meshParameters.useAsyncPipeline }),\n      }\n\n      this.geometry = geometry\n\n      if (autoRender !== undefined) {\n        this.#autoRender = autoRender\n      }\n\n      this.visible = visible\n      this.renderOrder = renderOrder\n      this.ready = false\n\n      this.userData = {}\n\n      this.computeGeometry()\n\n      this.setMaterial({\n        label: this.options.label,\n        shaders: this.options.shaders,\n        ...{ ...meshParameters, verticesOrder: geometry.verticesOrder, topology: geometry.topology },\n      } as RenderMaterialParams)\n\n      this.addToScene()\n    }\n\n    /**\n     * Get private #autoRender value\n     * @readonly\n     */\n    get autoRender(): boolean {\n      return this.#autoRender\n    }\n\n    /**\n     * Get/set whether a Mesh is ready or not\n     * @readonly\n     */\n    get ready(): boolean {\n      return this._ready\n    }\n\n    set ready(value: boolean) {\n      if (value) {\n        this._onReadyCallback && this._onReadyCallback()\n      }\n      this._ready = value\n    }\n\n    /* SCENE */\n\n    /**\n     * Add a Mesh to the renderer and the {@link core/scenes/Scene.Scene | Scene}. Can patch the {@link RenderMaterial} render options to match the {@link RenderPass} used to draw this Mesh.\n     */\n    addToScene() {\n      this.renderer.meshes.push(this as unknown as ProjectedMesh)\n\n      this.setRenderingOptionsForRenderPass(this.outputTarget ? this.outputTarget.renderPass : this.renderer.renderPass)\n\n      if (this.#autoRender) {\n        this.renderer.scene.addMesh(this as unknown as ProjectedMesh)\n      }\n    }\n\n    /**\n     * Remove a Mesh from the renderer and the {@link core/scenes/Scene.Scene | Scene}\n     */\n    removeFromScene() {\n      if (this.#autoRender) {\n        this.renderer.scene.removeMesh(this as unknown as ProjectedMesh)\n      }\n\n      this.renderer.meshes = this.renderer.meshes.filter((m) => m.uuid !== this.uuid)\n    }\n\n    /**\n     * Set or update the {@link RenderMaterial} {@link types/Materials.RenderMaterialRenderingOptions | rendering options} to match the {@link RenderPass#descriptor | RenderPass descriptor} used to draw this Mesh.\n     * @param renderPass - {@link RenderPass | RenderPass} used to draw this Mesh, default to the {@link core/renderers/GPURenderer.GPURenderer#renderPass | renderer renderPass}.\n     */\n    setRenderingOptionsForRenderPass(renderPass: RenderPass) {\n      // a Mesh render material rendering options MUST match the render pass descriptor used to draw it!\n      const renderingOptions = {\n        sampleCount: renderPass.options.sampleCount,\n        // color attachments\n        ...(renderPass.options.colorAttachments.length && {\n          targetFormat: renderPass.options.colorAttachments[0].targetFormat,\n          // multiple render targets?\n          ...(renderPass.options.colorAttachments.length > 1 && {\n            additionalTargets: renderPass.options.colorAttachments\n              .filter((c, i) => i > 0)\n              .map((colorAttachment) => {\n                return {\n                  format: colorAttachment.targetFormat,\n                }\n              }),\n          }),\n        }),\n        // depth\n        depth: renderPass.options.useDepth,\n        ...(renderPass.options.useDepth && {\n          depthFormat: renderPass.options.depthFormat,\n        }),\n      }\n\n      this.material?.setRenderingOptions(renderingOptions)\n    }\n\n    /**\n     * Set a new {@link Renderer} for this Mesh\n     * @param renderer - new {@link Renderer} to set\n     */\n    setRenderer(renderer: Renderer | GPUCurtains) {\n      // we could pass our curtains object OR our curtains renderer object\n      renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as Renderer)\n\n      if (\n        !renderer ||\n        !(\n          renderer.type === 'GPURenderer' ||\n          renderer.type === 'GPUCameraRenderer' ||\n          renderer.type === 'GPUCurtainsRenderer'\n        )\n      ) {\n        throwWarning(\n          `${this.options.label}: Cannot set ${renderer} as a renderer because it is not of a valid Renderer type.`\n        )\n        return\n      }\n\n      const oldRenderer = this.renderer\n      this.removeFromScene()\n      this.renderer = renderer\n      this.addToScene()\n\n      // if old renderer does not contain any meshes any more\n      // clear it\n      if (!oldRenderer.meshes.length) {\n        oldRenderer.onBeforeRenderScene.add(\n          (commandEncoder) => {\n            oldRenderer.forceClear(commandEncoder)\n          },\n          { once: true }\n        )\n      }\n    }\n\n    /**\n     * Assign or remove a {@link RenderTarget} to this Mesh\n     * Since this manipulates the {@link core/scenes/Scene.Scene | Scene} stacks, it can be used to remove a RenderTarget as well.\n     * @param outputTarget - the RenderTarget to assign or null if we want to remove the current RenderTarget\n     */\n    setOutputTarget(outputTarget: RenderTarget | null) {\n      if (outputTarget && outputTarget.type !== 'RenderTarget') {\n        throwWarning(`${this.options.label ?? this.type}: outputTarget is not a RenderTarget: ${outputTarget}`)\n        return\n      }\n\n      // ensure the mesh is in the correct scene stack\n      this.removeFromScene()\n      this.outputTarget = outputTarget\n      this.addToScene()\n    }\n\n    /**\n     * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been lost to prepare everything for restoration.\n     * Basically set all the {@link GPUBuffer} to null so they will be reset next time we try to draw the Mesh\n     */\n    loseContext() {\n      // first the geometry\n      this.geometry.vertexBuffers.forEach((vertexBuffer) => {\n        vertexBuffer.buffer = null\n      })\n\n      if ('indexBuffer' in this.geometry) {\n        this.geometry.indexBuffer.buffer = null\n      }\n\n      // then the material\n      this.material.loseContext()\n    }\n\n    /**\n     * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been restored\n     */\n    restoreContext() {\n      this.material.restoreContext()\n    }\n\n    /* SHADERS */\n\n    /**\n     * Set default shaders if one or both of them are missing\n     */\n    setShaders() {\n      let { shaders } = this.options\n\n      if (!shaders) {\n        shaders = {\n          vertex: {\n            code: default_vsWgsl,\n            entryPoint: 'main',\n          },\n          fragment: {\n            code: default_fsWgsl,\n            entryPoint: 'main',\n          },\n        }\n      } else {\n        if (!shaders.vertex || !shaders.vertex.code) {\n          shaders.vertex = {\n            code: default_vsWgsl,\n            entryPoint: 'main',\n          }\n        }\n\n        if (shaders.fragment === undefined || (shaders.fragment && !(shaders.fragment as ShaderOptions).code)) {\n          shaders.fragment = {\n            code: default_fsWgsl,\n            entryPoint: 'main',\n          }\n        }\n      }\n    }\n\n    /* GEOMETRY */\n\n    /**\n     * Compute the Mesh geometry if needed\n     */\n    computeGeometry() {\n      if (this.geometry.shouldCompute) {\n        this.geometry.computeGeometry()\n      }\n    }\n\n    /**\n     * Create the Mesh Geometry vertex and index buffers if needed\n     */\n    createGeometryBuffers() {\n      if (!this.geometry.ready) {\n        this.geometry.vertexBuffers.forEach((vertexBuffer) => {\n          if (!vertexBuffer.buffer) {\n            vertexBuffer.buffer = this.renderer.createBuffer({\n              label: this.options.label + ' geometry: ' + vertexBuffer.name + ' buffer',\n              size: vertexBuffer.array.byteLength,\n              usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n            })\n\n            this.renderer.queueWriteBuffer(vertexBuffer.buffer, 0, vertexBuffer.array)\n          }\n        })\n\n        // if it's an indexed geometry, create index GPUBuffer as well\n        if ('indexBuffer' in this.geometry && this.geometry.indexBuffer && !this.geometry.indexBuffer.buffer) {\n          this.geometry.indexBuffer.buffer = this.renderer.createBuffer({\n            label: this.options.label + ' geometry: index buffer',\n            size: this.geometry.indexBuffer.array.byteLength,\n            usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,\n          })\n\n          this.renderer.queueWriteBuffer(this.geometry.indexBuffer.buffer, 0, this.geometry.indexBuffer.array)\n        }\n      }\n    }\n\n    /**\n     * Set our Mesh geometry: create buffers and add attributes to material\n     */\n    setGeometry() {\n      if (this.geometry && this.renderer.ready) {\n        this.createGeometryBuffers()\n        this.setMaterialGeometryAttributes()\n      }\n    }\n\n    /* MATERIAL */\n\n    /**\n     * Set a Mesh transparent property, then set its material\n     * @param meshParameters - {@link RenderMaterialParams | RenderMaterial parameters}\n     */\n    setMaterial(meshParameters: RenderMaterialParams) {\n      this.transparent = meshParameters.transparent\n\n      this.setShaders()\n\n      this.material = new RenderMaterial(this.renderer, meshParameters)\n      // add eventual textures passed as parameters\n      this.material.options.textures\n        ?.filter((texture) => texture instanceof Texture)\n        .forEach((texture) => this.onTextureAdded(texture))\n    }\n\n    /**\n     * Set Mesh material attributes\n     */\n    setMaterialGeometryAttributes() {\n      if (this.material && !this.material.attributes) {\n        this.material.setAttributesFromGeometry(this.geometry)\n      }\n    }\n\n    /* TEXTURES */\n\n    /**\n     * Get our {@link RenderMaterial#textures | RenderMaterial textures array}\n     * @readonly\n     */\n    get textures(): Texture[] {\n      return this.material?.textures || []\n    }\n\n    /**\n     * Get our {@link RenderMaterial#renderTextures | RenderMaterial render textures array}\n     * @readonly\n     */\n    get renderTextures(): RenderTexture[] {\n      return this.material?.renderTextures || []\n    }\n\n    /**\n     * Create a new {@link Texture}\n     * @param options - {@link TextureParams | Texture parameters}\n     * @returns - newly created {@link Texture}\n     */\n    createTexture(options: TextureParams): Texture {\n      if (!options.name) {\n        options.name = 'texture' + this.textures.length\n      }\n\n      if (!options.label) {\n        options.label = this.options.label + ' ' + options.name\n      }\n\n      const texture = new Texture(this.renderer, { ...options, ...this.options.texturesOptions })\n\n      this.addTexture(texture)\n\n      return texture\n    }\n\n    /**\n     * Add a {@link Texture}\n     * @param texture - {@link Texture} to add\n     */\n    addTexture(texture: Texture) {\n      this.material.addTexture(texture)\n      this.onTextureAdded(texture)\n    }\n\n    /**\n     * Callback run when a new {@link Texture} has been added\n     * @param texture - newly created Texture\n     */\n    onTextureAdded(texture: Texture) {\n      texture.parentMesh = this as unknown as TextureParent\n    }\n\n    /**\n     * Create a new {@link RenderTexture}\n     * @param  options - {@link RenderTextureParams | RenderTexture parameters}\n     * @returns - newly created {@link RenderTexture}\n     */\n    createRenderTexture(options: RenderTextureParams): RenderTexture {\n      if (!options.name) {\n        options.name = 'renderTexture' + this.renderTextures.length\n      }\n\n      const renderTexture = new RenderTexture(this.renderer, options)\n\n      this.addRenderTexture(renderTexture)\n\n      return renderTexture\n    }\n\n    /**\n     * Add a {@link RenderTexture}\n     * @param renderTexture - {@link RenderTexture} to add\n     */\n    addRenderTexture(renderTexture: RenderTexture) {\n      this.material.addTexture(renderTexture)\n    }\n\n    /* BINDINGS */\n\n    /**\n     * Get the current {@link RenderMaterial} uniforms\n     * @readonly\n     */\n    get uniforms(): Material['uniforms'] {\n      return this.material?.uniforms\n    }\n\n    /**\n     * Get the current {@link RenderMaterial} storages\n     * @readonly\n     */\n    get storages(): Material['storages'] {\n      return this.material?.storages\n    }\n\n    /* RESIZE */\n\n    /**\n     * Resize the Mesh's textures\n     * @param boundingRect\n     */\n    resize(boundingRect?: DOMElementBoundingRect | null) {\n      // @ts-ignore\n      if (super.resize) {\n        // @ts-ignore\n        super.resize(boundingRect)\n      }\n\n      this.renderTextures?.forEach((renderTexture) => {\n        // copy from original textures again if needed\n        if (renderTexture.options.fromTexture) {\n          renderTexture.copy(renderTexture.options.fromTexture)\n        }\n      })\n\n      // resize textures\n      this.textures?.forEach((texture) => {\n        texture.resize()\n      })\n\n      this._onAfterResizeCallback && this._onAfterResizeCallback()\n    }\n\n    /* EVENTS */\n\n    /**\n     * Assign a callback function to _onReadyCallback\n     * @param callback - callback to run when {@link MeshBase} is ready\n     * @returns - our Mesh\n     */\n    onReady(callback: () => void): MeshBase | ProjectedMeshBaseClass {\n      if (callback) {\n        this._onReadyCallback = callback\n      }\n\n      return this\n    }\n\n    /**\n     * Assign a callback function to _onBeforeRenderCallback\n     * @param callback - callback to run just before {@link MeshBase} will be rendered\n     * @returns - our Mesh\n     */\n    onBeforeRender(callback: () => void): MeshBase | ProjectedMeshBaseClass {\n      if (callback) {\n        this._onBeforeRenderCallback = callback\n      }\n\n      return this\n    }\n\n    /**\n     * Assign a callback function to _onRenderCallback\n     * @param callback - callback to run when {@link MeshBase} is rendered\n     * @returns - our Mesh\n     */\n    onRender(callback: () => void): MeshBase | ProjectedMeshBaseClass {\n      if (callback) {\n        this._onRenderCallback = callback\n      }\n\n      return this\n    }\n\n    /**\n     * Assign a callback function to _onAfterRenderCallback\n     * @param callback - callback to run just after {@link MeshBase} has been rendered\n     * @returns - our Mesh\n     */\n    onAfterRender(callback: () => void): MeshBase | ProjectedMeshBaseClass {\n      if (callback) {\n        this._onAfterRenderCallback = callback\n      }\n\n      return this\n    }\n\n    /**\n     * Assign a callback function to _onAfterResizeCallback\n     * @param callback - callback to run just after {@link MeshBase} has been resized\n     * @returns - our Mesh\n     */\n    onAfterResize(callback: () => void): MeshBase | ProjectedMeshBaseClass {\n      if (callback) {\n        this._onAfterResizeCallback = callback\n      }\n\n      return this\n    }\n\n    /* RENDER */\n\n    /**\n     * Called before rendering the Mesh\n     * Set the geometry if needed (create buffers and add attributes to the {@link RenderMaterial})\n     * Then executes {@link RenderMaterial#onBeforeRender}: create its bind groups and pipeline if needed and eventually update its struct\n     */\n    onBeforeRenderPass() {\n      if (!this.renderer.ready) return\n\n      if (this.material && this.material.ready && this.geometry && this.geometry.ready && !this.ready) {\n        this.ready = true\n      }\n\n      this.setGeometry()\n\n      this._onBeforeRenderCallback && this._onBeforeRenderCallback()\n\n      this.material.onBeforeRender()\n    }\n\n    /**\n     * Render our {@link MeshBase} if the {@link RenderMaterial} is ready\n     * @param pass - current render pass encoder\n     */\n    onRenderPass(pass: GPURenderPassEncoder) {\n      if (!this.material.ready) return\n\n      this._onRenderCallback && this._onRenderCallback()\n\n      // render ou material\n      this.material.render(pass)\n      // then render our geometry\n      this.geometry.render(pass)\n    }\n\n    /**\n     * Called after having rendered the Mesh\n     */\n    onAfterRenderPass() {\n      this._onAfterRenderCallback && this._onAfterRenderCallback()\n    }\n\n    /**\n     * Render our Mesh\n     * - Execute {@link onBeforeRenderPass}\n     * - Stop here if {@link Renderer} is not ready or Mesh is not {@link visible}\n     * - Execute super render call if it exists\n     * - {@link onRenderPass | render} our {@link material} and {@link geometry}\n     * - Execute {@link onAfterRenderPass}\n     * @param pass - current render pass encoder\n     */\n    render(pass: GPURenderPassEncoder) {\n      this.onBeforeRenderPass()\n\n      // no point to render if the WebGPU device is not ready\n      if (!this.renderer.ready || !this.visible) return\n\n      // @ts-ignore\n      if (super.render) {\n        // @ts-ignore\n        super.render()\n      }\n\n      !this.renderer.production && pass.pushDebugGroup(this.options.label)\n\n      this.onRenderPass(pass)\n\n      !this.renderer.production && pass.popDebugGroup()\n\n      this.onAfterRenderPass()\n    }\n\n    /* DESTROY */\n\n    /**\n     * Remove the Mesh from the {@link core/scenes/Scene.Scene | Scene} and destroy it\n     */\n    remove() {\n      this.removeFromScene()\n      this.destroy()\n\n      // if the renderer does not contain any meshes any more\n      // clear it\n      if (!this.renderer.meshes.length) {\n        this.renderer.onBeforeRenderScene.add(\n          (commandEncoder) => {\n            this.renderer.forceClear(commandEncoder)\n          },\n          { once: true }\n        )\n      }\n    }\n\n    /**\n     * Destroy the Mesh\n     */\n    destroy() {\n      // @ts-ignore\n      if (super.destroy) {\n        // @ts-ignore\n        super.destroy()\n      }\n\n      this.material?.destroy()\n\n      // remove geometry buffers from device cache\n      this.geometry.vertexBuffers.forEach((vertexBuffer) => {\n        // use original vertex buffer label in case it has been swapped (usually by a compute pass)\n        this.renderer.removeBuffer(\n          vertexBuffer.buffer,\n          this.options.label + ' geometry: ' + vertexBuffer.name + ' buffer'\n        )\n      })\n\n      if ('indexBuffer' in this.geometry) {\n        this.renderer.removeBuffer(this.geometry.indexBuffer.buffer)\n      }\n\n      this.geometry?.destroy()\n    }\n  }\n}\n\nexport { MeshBaseMixin }\n"],"names":[],"mappings":"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"}