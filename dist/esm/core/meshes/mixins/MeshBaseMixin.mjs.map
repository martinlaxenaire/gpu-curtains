{"version":3,"file":"MeshBaseMixin.mjs","sources":["../../../../../src/core/meshes/mixins/MeshBaseMixin.ts"],"sourcesContent":["import { generateUUID, throwWarning } from '../../../utils/utils'\r\nimport { isRenderer, Renderer } from '../../renderers/utils'\r\nimport { RenderMaterial } from '../../materials/RenderMaterial'\r\nimport { Texture } from '../../textures/Texture'\r\nimport { Geometry } from '../../geometries/Geometry'\r\nimport { RenderTexture, RenderTextureParams } from '../../textures/RenderTexture'\r\nimport { ExternalTextureParams, TextureParams, TextureParent } from '../../../types/Textures'\r\nimport { RenderTarget } from '../../renderPasses/RenderTarget'\r\nimport { GPUCurtains } from '../../../curtains/GPUCurtains'\r\nimport { ProjectedMesh } from '../../renderers/GPURenderer'\r\nimport { Material } from '../../materials/Material'\r\nimport { DOMElementBoundingRect } from '../../DOM/DOMElement'\r\nimport { AllowedGeometries, RenderMaterialParams, ShaderOptions } from '../../../types/Materials'\r\nimport { ProjectedMeshBaseClass } from './ProjectedMeshBaseMixin'\r\nimport default_vsWgsl from '../../shaders/chunks/default_vs.wgsl'\r\nimport default_fsWgsl from '../../shaders/chunks/default_fs.wgsl'\r\nimport { RenderPass } from '../../renderPasses/RenderPass'\r\n\r\nlet meshIndex = 0\r\n\r\nexport interface MeshBaseRenderParams extends RenderMaterialParams {\r\n  /** Whether we should add this Mesh to our {@link core/scenes/Scene.Scene | Scene} to let it handle the rendering process automatically */\r\n  autoRender?: boolean\r\n  /** Flag indicating whether to draw this Mesh or not */\r\n  visible?: boolean\r\n  /** Controls the order in which this Mesh should be rendered by our {@link core/scenes/Scene.Scene | Scene} */\r\n  renderOrder?: number\r\n  /** Optional {@link RenderTarget} to render this Mesh to instead of the canvas context. */\r\n  outputTarget?: RenderTarget\r\n  /** Parameters used by this Mesh to create a {@link Texture} */\r\n  texturesOptions?: ExternalTextureParams\r\n}\r\n\r\n/**\r\n * Base parameters used to create a Mesh\r\n */\r\nexport interface MeshBaseParams extends MeshBaseRenderParams {\r\n  /** Geometry to use */\r\n  geometry: AllowedGeometries\r\n}\r\n\r\n/**\r\n *  Base options used to create this Mesh\r\n */\r\nexport interface MeshBaseOptions {\r\n  /** The label of this Mesh, sent to various GPU objects for debugging purpose */\r\n  label?: MeshBaseParams['label']\r\n  /** Shaders to use by this Mesh {@link RenderMaterial} */\r\n  shaders?: MeshBaseParams['shaders']\r\n  /** Parameters used by this Mesh to create a {@link Texture} */\r\n  texturesOptions?: ExternalTextureParams\r\n  /** {@link RenderTarget} to render this Mesh to instead of the canvas context, if any. */\r\n  outputTarget?: RenderTarget | null\r\n  /** Whether we should add this Mesh to our {@link core/scenes/Scene.Scene | Scene} to let it handle the rendering process automatically */\r\n  autoRender?: boolean\r\n  /** Whether to compile this Mesh {@link RenderMaterial} {@link core/pipelines/RenderPipelineEntry.RenderPipelineEntry#pipeline | render pipeline} asynchronously or not */\r\n  useAsyncPipeline?: boolean\r\n}\r\n\r\n/** @const - Default Mesh parameters to merge with user defined parameters */\r\nconst defaultMeshBaseParams: MeshBaseParams = {\r\n  // geometry\r\n  geometry: new Geometry(),\r\n  // material\r\n  shaders: {},\r\n  autoRender: true,\r\n  useProjection: false,\r\n  useAsyncPipeline: true,\r\n  // rendering\r\n  cullMode: 'back',\r\n  depth: true,\r\n  depthWriteEnabled: true,\r\n  depthCompare: 'less',\r\n  depthFormat: 'depth24plus',\r\n  transparent: false,\r\n  visible: true,\r\n  renderOrder: 0,\r\n  // textures\r\n  texturesOptions: {},\r\n}\r\n\r\n// based on https://stackoverflow.com/a/75673107/13354068\r\n// we declare first a class, and then the mixin with a return type\r\n/**\r\n * This class describes the properties and methods to set up a basic Mesh, implemented in the {@link MeshBaseMixin}:\r\n * - Set and render the {@link Geometry} and {@link RenderMaterial}\r\n * - Add helpers to create {@link Texture} and {@link RenderTexture}\r\n * - Handle resizing, device lost/restoration and destroying the resources\r\n */\r\nexport declare class MeshBaseClass {\r\n  /** The type of the {@link MeshBaseClass} */\r\n  type: string\r\n  /** The universal unique id of the {@link MeshBaseClass} */\r\n  readonly uuid: string\r\n  /** Index of this {@link MeshBaseClass}, i.e. creation order */\r\n  readonly index: number\r\n  /** The {@link Renderer} used */\r\n  renderer: Renderer\r\n\r\n  /** Options used to create this {@link MeshBaseClass} */\r\n  options: MeshBaseOptions\r\n\r\n  /** {@link RenderMaterial} used by this {@link MeshBaseClass} */\r\n  material: RenderMaterial\r\n  /** {@link AllowedGeometries | Geometry} used by this {@link MeshBaseClass} */\r\n  geometry: MeshBaseParams['geometry']\r\n\r\n  /** {@link RenderTarget} to render this Mesh to instead of the canvas context, if any. */\r\n  outputTarget: null | RenderTarget\r\n\r\n  /** Controls the order in which this {@link MeshBaseClass} should be rendered by our {@link core/scenes/Scene.Scene | Scene} */\r\n  renderOrder: number\r\n  /** Whether this {@link MeshBaseClass} should be treated as transparent. Impacts the {@link core/pipelines/RenderPipelineEntry.RenderPipelineEntry#pipeline | render pipeline} blend properties */\r\n  transparent: boolean\r\n\r\n  /** Flag indicating whether to draw this {@link MeshBaseClass} or not */\r\n  visible: boolean\r\n  /** Flag indicating whether this {@link MeshBaseClass} is ready to be drawn */\r\n  _ready: boolean\r\n\r\n  /** Empty object to store any additional data or custom properties into your Mesh. */\r\n  userData: Record<string, unknown>\r\n\r\n  // callbacks\r\n  /** function assigned to the {@link onReady} callback */\r\n  _onReadyCallback: () => void\r\n  /** function assigned to the {@link onBeforeRender} callback */\r\n  _onBeforeRenderCallback: () => void\r\n  /** function assigned to the {@link onRender} callback */\r\n  _onRenderCallback: () => void\r\n  /** function assigned to the {@link onAfterRender} callback */\r\n  _onAfterRenderCallback: () => void\r\n  /** function assigned to the {@link onAfterResize} callback */\r\n  _onAfterResizeCallback: () => void\r\n  /**\r\n   * Assign a callback function to _onReadyCallback\r\n   * @param callback - callback to run when {@link MeshBaseClass} is ready\r\n   * @returns - our Mesh\r\n   */\r\n  onReady: (callback: () => void) => MeshBaseClass | ProjectedMeshBaseClass\r\n  /**\r\n   * Assign a callback function to _onBeforeRenderCallback\r\n   * @param callback - callback to run just before {@link MeshBaseClass} will be rendered\r\n   * @returns - our Mesh\r\n   */\r\n  onBeforeRender: (callback: () => void) => MeshBaseClass | ProjectedMeshBaseClass\r\n  /**\r\n   * Assign a callback function to _onRenderCallback\r\n   * @param callback - callback to run when {@link MeshBaseClass} is rendered\r\n   * @returns - our Mesh\r\n   */\r\n  onRender: (callback: () => void) => MeshBaseClass | ProjectedMeshBaseClass\r\n  /**\r\n   * Assign a callback function to _onAfterRenderCallback\r\n   * @param callback - callback to run just after {@link MeshBaseClass} has been rendered\r\n   * @returns - our Mesh\r\n   */\r\n  onAfterRender: (callback: () => void) => MeshBaseClass | ProjectedMeshBaseClass\r\n  /**\r\n   * Assign a callback function to _onBeforeRenderCallback\r\n   * @param callback - callback to run just after {@link MeshBaseClass} has been resized\r\n   * @returns - our Mesh\r\n   */\r\n  onAfterResize: (callback: () => void) => MeshBaseClass | ProjectedMeshBaseClass\r\n\r\n  /**\r\n   * {@link MeshBaseClass} constructor\r\n   * @param renderer - our {@link Renderer} class object\r\n   * @param element - a DOM HTML Element that can be bound to a Mesh\r\n   * @param parameters - {@link MeshBaseParams | Mesh base parameters}\r\n   */\r\n  constructor(renderer: Renderer, element: HTMLElement | null, parameters: MeshBaseParams)\r\n\r\n  /**\r\n   * Get private #autoRender value\r\n   * @readonly\r\n   */\r\n  get autoRender(): boolean // allow to read value from child classes\r\n\r\n  /**\r\n   * Get/set whether a Mesh is ready or not\r\n   * @readonly\r\n   */\r\n  get ready(): boolean\r\n  set ready(value: boolean)\r\n\r\n  /**\r\n   * Add a Mesh to the renderer and the {@link core/scenes/Scene.Scene | Scene}\r\n   */\r\n  addToScene(): void\r\n\r\n  /**\r\n   * Remove a Mesh from the renderer and the {@link core/scenes/Scene.Scene | Scene}\r\n   */\r\n  removeFromScene(): void\r\n\r\n  /**\r\n   * Set a new {@link Renderer} for this Mesh\r\n   * @param renderer - new {@link Renderer} to set\r\n   */\r\n  setRenderer(renderer: Renderer | GPUCurtains): void\r\n\r\n  /**\r\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been lost to prepare everything for restoration.\r\n   * Basically set all the {@link GPUBuffer} to null so they will be reset next time we try to draw the Mesh\r\n   */\r\n  loseContext(): void\r\n\r\n  /**\r\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been restored\r\n   */\r\n  restoreContext(): void\r\n\r\n  /**\r\n   * Set default shaders if one or both of them are missing\r\n   */\r\n  setShaders(): void\r\n\r\n  /**\r\n   * Compute the Mesh geometry if needed\r\n   */\r\n  computeGeometry(): void\r\n\r\n  /**\r\n   * Create the Mesh Geometry vertex and index buffers if needed\r\n   */\r\n  createGeometryBuffers(): void\r\n\r\n  /**\r\n   * Set our Mesh geometry: create buffers and add attributes to material\r\n   */\r\n  setGeometry(): void\r\n\r\n  /**\r\n   * Set or update the {@link RenderMaterial} {@link types/Materials.RenderMaterialRenderingOptions | rendering options} to match the {@link RenderPass#descriptor | RenderPass descriptor} used to draw this Mesh.\r\n   * @param renderPass - {@link RenderPass | RenderPass} used to draw this Mesh, default to the {@link core/renderers/GPURenderer.GPURenderer#renderPass | renderer renderPass}.\r\n   */\r\n  setRenderingOptionsForRenderPass(renderPass: RenderPass): void\r\n\r\n  /**\r\n   * Hook used to clean up parameters before sending them to the material.\r\n   * @param parameters - parameters to clean before sending them to the {@link RenderMaterial}\r\n   * @returns - cleaned parameters\r\n   */\r\n  cleanupRenderMaterialParameters(parameters: MeshBaseRenderParams): MeshBaseRenderParams\r\n\r\n  /**\r\n   * Set a Mesh transparent property, then set its material\r\n   * @param meshParameters - {@link RenderMaterialParams | RenderMaterial parameters}\r\n   */\r\n  setMaterial(meshParameters: RenderMaterialParams): void\r\n\r\n  /**\r\n   * Set Mesh material attributes\r\n   */\r\n  setMaterialGeometryAttributes(): void\r\n\r\n  /**\r\n   * Get our {@link RenderMaterial#textures | RenderMaterial textures array}\r\n   * @readonly\r\n   */\r\n  get textures(): Texture[]\r\n\r\n  /**\r\n   * Get our {@link RenderMaterial#renderTextures | RenderMaterial render textures array}\r\n   * @readonly\r\n   */\r\n  get renderTextures(): RenderTexture[]\r\n\r\n  /**\r\n   * Create a new {@link Texture}\r\n   * @param options - {@link TextureParams | Texture parameters}\r\n   * @returns - newly created Texture\r\n   */\r\n  createTexture(options: TextureParams): Texture\r\n\r\n  /**\r\n   * Add a {@link Texture}\r\n   * @param texture - {@link Texture} to add\r\n   */\r\n  addTexture(texture: Texture)\r\n\r\n  /**\r\n   * Callback run when a new {@link Texture} has been created\r\n   * @param texture - newly created Texture\r\n   */\r\n  onTextureAdded(texture: Texture): void\r\n\r\n  /**\r\n   * Create a new {@link RenderTexture}\r\n   * @param  options - {@link RenderTextureParams | RenderTexture parameters}\r\n   * @returns - newly created RenderTexture\r\n   */\r\n  createRenderTexture(options: RenderTextureParams): RenderTexture\r\n\r\n  /**\r\n   * Add a {@link RenderTexture}\r\n   * @param renderTexture - {@link RenderTexture} to add\r\n   */\r\n  addRenderTexture(renderTexture: RenderTexture)\r\n\r\n  /**\r\n   * Assign or remove a {@link RenderTarget} to this Mesh\r\n   * Since this manipulates the {@link core/scenes/Scene.Scene | Scene} stacks, it can be used to remove a RenderTarget as well.\r\n   * @param outputTarget - the RenderTarget to assign or null if we want to remove the current RenderTarget\r\n   */\r\n  setOutputTarget(outputTarget: RenderTarget | null): void\r\n\r\n  /**\r\n   * Get the current {@link RenderMaterial} uniforms\r\n   * @readonly\r\n   */\r\n  get uniforms(): Material['uniforms']\r\n\r\n  /**\r\n   * Get the current {@link RenderMaterial} storages\r\n   * @readonly\r\n   */\r\n  get storages(): Material['storages']\r\n\r\n  /**\r\n   * Resize the Mesh's textures\r\n   * @param boundingRect\r\n   */\r\n  resize(boundingRect?: DOMElementBoundingRect): void\r\n\r\n  /**\r\n   * Called before rendering the Mesh\r\n   * Set the geometry if needed (create buffers and add attributes to the {@link RenderMaterial})\r\n   * Then executes {@link RenderMaterial#onBeforeRender}: create its bind groups and pipeline if needed and eventually update its struct\r\n   */\r\n  onBeforeRenderPass(): void\r\n\r\n  /**\r\n   * Render our {@link MeshBaseClass} if the {@link RenderMaterial} is ready\r\n   * @param pass - current render pass encoder\r\n   */\r\n  onRenderPass(pass: GPURenderPassEncoder): void\r\n\r\n  /**\r\n   * Called after having rendered the Mesh\r\n   */\r\n  onAfterRenderPass(): void\r\n\r\n  /**\r\n   * Render our Mesh\r\n   * - Execute {@link onBeforeRenderPass}\r\n   * - Stop here if {@link Renderer} is not ready or Mesh is not {@link visible}\r\n   * - Execute super render call if it exists\r\n   * - {@link onRenderPass | render} our {@link material} and {@link geometry}\r\n   * - Execute {@link onAfterRenderPass}\r\n   * @param pass - current render pass encoder\r\n   */\r\n  render(pass: GPURenderPassEncoder): void\r\n\r\n  /**\r\n   * Remove the Mesh from the {@link core/scenes/Scene.Scene | Scene} and destroy it\r\n   */\r\n  remove(): void\r\n\r\n  /**\r\n   * Destroy the Mesh\r\n   */\r\n  destroy(): void\r\n}\r\n\r\n/**\r\n * To get started, we need a type which we'll use to extend\r\n * other classes from. The main responsibility is to declare\r\n * that the type being passed in is a class.\r\n * We use a generic version which can apply a constraint on\r\n * the class which this mixin is applied to\r\n * @typeParam T - the base constructor\r\n */\r\nexport type MixinConstructor<T = {}> = new (...args: any[]) => T\r\n\r\n/**\r\n * Used to mix the basic Mesh properties and methods defined in {@link MeshBaseClass} (basically, set a {@link Geometry} and a {@link RenderMaterial} and render them, add helpers to create {@link Texture} and {@link RenderTexture}) with a given Base of type {@link core/objects3D/Object3D.Object3D | Object3D}, {@link core/objects3D/ProjectedObject3D.ProjectedObject3D | ProjectedObject3D}, {@link curtains/objects3D/DOMObject3D.DOMObject3D | DOMObject3D} or an empty class.\r\n * @exports MeshBaseMixin\r\n * @param Base - the class to mix onto\r\n * @returns - the mixed classes, creating a basic Mesh.\r\n */\r\nfunction MeshBaseMixin<TBase extends MixinConstructor>(Base: TBase): MixinConstructor<MeshBaseClass> & TBase {\r\n  /**\r\n   * MeshBase defines our base properties and methods\r\n   */\r\n  return class MeshBase extends Base implements MeshBaseClass {\r\n    /** The type of the {@link MeshBase} */\r\n    type: string\r\n    /** The universal unique id of the {@link MeshBase} */\r\n    readonly uuid: string\r\n    /** Index of this {@link MeshBase}, i.e. creation order */\r\n    readonly index: number\r\n    /** The {@link Renderer} used */\r\n    renderer: Renderer\r\n\r\n    /** Options used to create this {@link MeshBase} */\r\n    options: MeshBaseOptions\r\n\r\n    /** {@link RenderMaterial} used by this {@link MeshBase} */\r\n    material: RenderMaterial\r\n    /** {@link AllowedGeometries | Geometry} used by this {@link MeshBase} */\r\n    geometry: MeshBaseParams['geometry']\r\n\r\n    /** {@link RenderTarget} to render this Mesh to, if any */\r\n    outputTarget: null | RenderTarget\r\n\r\n    /** Controls the order in which this {@link MeshBase} should be rendered by our {@link core/scenes/Scene.Scene | Scene} */\r\n    renderOrder: number\r\n    /** Whether this {@link MeshBase} should be treated as transparent. Impacts the {@link core/pipelines/RenderPipelineEntry.RenderPipelineEntry#pipeline | render pipeline} blend properties */\r\n    transparent: boolean\r\n\r\n    /** Flag indicating whether to draw this {@link MeshBase} or not */\r\n    visible: boolean\r\n    /** Flag indicating whether this {@link MeshBase} is ready to be drawn */\r\n    _ready: boolean\r\n\r\n    /** Empty object to store any additional data or custom properties into your {@link MeshBase}. */\r\n    userData: Record<string, unknown>\r\n\r\n    /** Whether we should add this {@link MeshBase} to our {@link core/scenes/Scene.Scene | Scene} to let it handle the rendering process automatically */\r\n    #autoRender = true\r\n\r\n    // callbacks / events\r\n    /** function assigned to the {@link onReady} callback */\r\n    _onReadyCallback: () => void = () => {\r\n      /* allow empty callback */\r\n    }\r\n    /** function assigned to the {@link onBeforeRender} callback */\r\n    _onBeforeRenderCallback: () => void = () => {\r\n      /* allow empty callback */\r\n    }\r\n    /** function assigned to the {@link onRender} callback */\r\n    _onRenderCallback: () => void = () => {\r\n      /* allow empty callback */\r\n    }\r\n    /** function assigned to the {@link onAfterRender} callback */\r\n    _onAfterRenderCallback: () => void = () => {\r\n      /* allow empty callback */\r\n    }\r\n    /** function assigned to the {@link onAfterResize} callback */\r\n    _onAfterResizeCallback: () => void = () => {\r\n      /* allow empty callback */\r\n    }\r\n\r\n    /**\r\n     * MeshBase constructor\r\n     *\r\n     * @typedef MeshBaseArrayParams\r\n     * @type {array}\r\n     * @property {(Renderer|GPUCurtains)} 0 - our {@link Renderer} class object\r\n     * @property {(string|HTMLElement|null)} 1 - a DOM HTML Element that can be bound to a Mesh\r\n     * @property {MeshBaseParams} 2 - {@link MeshBaseParams | Mesh base parameters}\r\n     *\r\n     * @param {MeshBaseArrayParams} params - our MeshBaseMixin parameters\r\n     */\r\n    constructor(...params: any[]) {\r\n      super(\r\n        params[0] as Renderer | GPUCurtains,\r\n        params[1] as HTMLElement | string | null,\r\n        { ...defaultMeshBaseParams, ...params[2] } as MeshBaseParams\r\n      )\r\n\r\n      let renderer = params[0]\r\n      const parameters = { ...defaultMeshBaseParams, ...params[2] }\r\n\r\n      this.type = 'MeshBase'\r\n\r\n      this.uuid = generateUUID()\r\n      Object.defineProperty(this as MeshBase, 'index', { value: meshIndex++ })\r\n\r\n      // we could pass our curtains object OR our curtains renderer object\r\n      renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as Renderer)\r\n\r\n      isRenderer(renderer, parameters.label ? parameters.label + ' ' + this.type : this.type)\r\n\r\n      this.renderer = renderer\r\n\r\n      const {\r\n        label,\r\n        shaders,\r\n        geometry,\r\n        visible,\r\n        renderOrder,\r\n        outputTarget,\r\n        texturesOptions,\r\n        autoRender,\r\n        ...meshParameters\r\n      } = parameters\r\n\r\n      this.outputTarget = outputTarget ?? null\r\n\r\n      // set default sample count\r\n      meshParameters.sampleCount = !!meshParameters.sampleCount\r\n        ? meshParameters.sampleCount\r\n        : this.outputTarget\r\n        ? this.outputTarget.renderPass.options.sampleCount\r\n        : this.renderer && this.renderer.renderPass\r\n        ? this.renderer.renderPass.options.sampleCount\r\n        : 1\r\n\r\n      this.options = {\r\n        ...(this.options ?? {}), // merge possible lower options?\r\n        label: label ?? 'Mesh ' + this.renderer.meshes.length,\r\n        shaders,\r\n        texturesOptions,\r\n        ...(outputTarget !== undefined && { outputTarget }),\r\n        ...(autoRender !== undefined && { autoRender }),\r\n        ...meshParameters,\r\n      }\r\n\r\n      this.geometry = geometry\r\n\r\n      if (autoRender !== undefined) {\r\n        this.#autoRender = autoRender\r\n      }\r\n\r\n      this.visible = visible\r\n      this.renderOrder = renderOrder\r\n      this.ready = false\r\n\r\n      this.userData = {}\r\n\r\n      this.computeGeometry()\r\n\r\n      this.setMaterial({\r\n        ...this.cleanupRenderMaterialParameters({ ...this.options }),\r\n        verticesOrder: geometry.verticesOrder,\r\n        topology: geometry.topology,\r\n      } as RenderMaterialParams)\r\n\r\n      this.addToScene()\r\n    }\r\n\r\n    /**\r\n     * Get private #autoRender value\r\n     * @readonly\r\n     */\r\n    get autoRender(): boolean {\r\n      return this.#autoRender\r\n    }\r\n\r\n    /**\r\n     * Get/set whether a Mesh is ready or not\r\n     * @readonly\r\n     */\r\n    get ready(): boolean {\r\n      return this._ready\r\n    }\r\n\r\n    set ready(value: boolean) {\r\n      if (value) {\r\n        this._onReadyCallback && this._onReadyCallback()\r\n      }\r\n      this._ready = value\r\n    }\r\n\r\n    /* SCENE */\r\n\r\n    /**\r\n     * Add a Mesh to the renderer and the {@link core/scenes/Scene.Scene | Scene}. Can patch the {@link RenderMaterial} render options to match the {@link RenderPass} used to draw this Mesh.\r\n     */\r\n    addToScene() {\r\n      this.renderer.meshes.push(this as unknown as ProjectedMesh)\r\n\r\n      this.setRenderingOptionsForRenderPass(this.outputTarget ? this.outputTarget.renderPass : this.renderer.renderPass)\r\n\r\n      if (this.#autoRender) {\r\n        this.renderer.scene.addMesh(this as unknown as ProjectedMesh)\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Remove a Mesh from the renderer and the {@link core/scenes/Scene.Scene | Scene}\r\n     */\r\n    removeFromScene() {\r\n      if (this.#autoRender) {\r\n        this.renderer.scene.removeMesh(this as unknown as ProjectedMesh)\r\n      }\r\n\r\n      this.renderer.meshes = this.renderer.meshes.filter((m) => m.uuid !== this.uuid)\r\n    }\r\n\r\n    /**\r\n     * Set a new {@link Renderer} for this Mesh\r\n     * @param renderer - new {@link Renderer} to set\r\n     */\r\n    setRenderer(renderer: Renderer | GPUCurtains) {\r\n      // we could pass our curtains object OR our curtains renderer object\r\n      renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as Renderer)\r\n\r\n      if (\r\n        !renderer ||\r\n        !(\r\n          renderer.type === 'GPURenderer' ||\r\n          renderer.type === 'GPUCameraRenderer' ||\r\n          renderer.type === 'GPUCurtainsRenderer'\r\n        )\r\n      ) {\r\n        throwWarning(\r\n          `${this.options.label}: Cannot set ${renderer} as a renderer because it is not of a valid Renderer type.`\r\n        )\r\n        return\r\n      }\r\n\r\n      const oldRenderer = this.renderer\r\n      this.removeFromScene()\r\n      this.renderer = renderer\r\n      this.addToScene()\r\n\r\n      // if old renderer does not contain any meshes any more\r\n      // clear it\r\n      if (!oldRenderer.meshes.length) {\r\n        oldRenderer.onBeforeRenderScene.add(\r\n          (commandEncoder) => {\r\n            oldRenderer.forceClear(commandEncoder)\r\n          },\r\n          { once: true }\r\n        )\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Assign or remove a {@link RenderTarget} to this Mesh\r\n     * Since this manipulates the {@link core/scenes/Scene.Scene | Scene} stacks, it can be used to remove a RenderTarget as well.\r\n     * @param outputTarget - the RenderTarget to assign or null if we want to remove the current RenderTarget\r\n     */\r\n    setOutputTarget(outputTarget: RenderTarget | null) {\r\n      if (outputTarget && outputTarget.type !== 'RenderTarget') {\r\n        throwWarning(`${this.options.label ?? this.type}: outputTarget is not a RenderTarget: ${outputTarget}`)\r\n        return\r\n      }\r\n\r\n      // ensure the mesh is in the correct scene stack\r\n      this.removeFromScene()\r\n      this.outputTarget = outputTarget\r\n      this.addToScene()\r\n    }\r\n\r\n    /**\r\n     * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been lost to prepare everything for restoration.\r\n     * Basically set all the {@link GPUBuffer} to null so they will be reset next time we try to draw the Mesh\r\n     */\r\n    loseContext() {\r\n      // first the geometry\r\n      this.geometry.vertexBuffers.forEach((vertexBuffer) => {\r\n        vertexBuffer.buffer = null\r\n      })\r\n\r\n      if ('indexBuffer' in this.geometry) {\r\n        this.geometry.indexBuffer.buffer = null\r\n      }\r\n\r\n      // then the material\r\n      this.material.loseContext()\r\n    }\r\n\r\n    /**\r\n     * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been restored\r\n     */\r\n    restoreContext() {\r\n      this.material.restoreContext()\r\n    }\r\n\r\n    /* SHADERS */\r\n\r\n    /**\r\n     * Set default shaders if one or both of them are missing\r\n     */\r\n    setShaders() {\r\n      let { shaders } = this.options\r\n\r\n      if (!shaders) {\r\n        shaders = {\r\n          vertex: {\r\n            code: default_vsWgsl,\r\n            entryPoint: 'main',\r\n          },\r\n          fragment: {\r\n            code: default_fsWgsl,\r\n            entryPoint: 'main',\r\n          },\r\n        }\r\n      } else {\r\n        if (!shaders.vertex || !shaders.vertex.code) {\r\n          shaders.vertex = {\r\n            code: default_vsWgsl,\r\n            entryPoint: 'main',\r\n          }\r\n        }\r\n\r\n        if (shaders.fragment === undefined || (shaders.fragment && !(shaders.fragment as ShaderOptions).code)) {\r\n          shaders.fragment = {\r\n            code: default_fsWgsl,\r\n            entryPoint: 'main',\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /* GEOMETRY */\r\n\r\n    /**\r\n     * Compute the Mesh geometry if needed\r\n     */\r\n    computeGeometry() {\r\n      if (this.geometry.shouldCompute) {\r\n        this.geometry.computeGeometry()\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Create the Mesh Geometry vertex and index buffers if needed\r\n     */\r\n    createGeometryBuffers() {\r\n      if (!this.geometry.ready) {\r\n        this.geometry.vertexBuffers.forEach((vertexBuffer) => {\r\n          if (!vertexBuffer.buffer) {\r\n            vertexBuffer.buffer = this.renderer.createBuffer({\r\n              label: this.options.label + ' geometry: ' + vertexBuffer.name + ' buffer',\r\n              size: vertexBuffer.array.byteLength,\r\n              usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\r\n            })\r\n\r\n            this.renderer.queueWriteBuffer(vertexBuffer.buffer, 0, vertexBuffer.array)\r\n          }\r\n        })\r\n\r\n        // if it's an indexed geometry, create index GPUBuffer as well\r\n        if ('indexBuffer' in this.geometry && this.geometry.indexBuffer && !this.geometry.indexBuffer.buffer) {\r\n          this.geometry.indexBuffer.buffer = this.renderer.createBuffer({\r\n            label: this.options.label + ' geometry: index buffer',\r\n            size: this.geometry.indexBuffer.array.byteLength,\r\n            usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,\r\n          })\r\n\r\n          this.renderer.queueWriteBuffer(this.geometry.indexBuffer.buffer, 0, this.geometry.indexBuffer.array)\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Set our Mesh geometry: create buffers and add attributes to material\r\n     */\r\n    setGeometry() {\r\n      if (this.geometry && this.renderer.ready) {\r\n        this.createGeometryBuffers()\r\n        this.setMaterialGeometryAttributes()\r\n      }\r\n    }\r\n\r\n    /* MATERIAL */\r\n\r\n    /**\r\n     * Set or update the {@link RenderMaterial} {@link types/Materials.RenderMaterialRenderingOptions | rendering options} to match the {@link RenderPass#descriptor | RenderPass descriptor} used to draw this Mesh.\r\n     * @param renderPass - {@link RenderPass | RenderPass} used to draw this Mesh, default to the {@link core/renderers/GPURenderer.GPURenderer#renderPass | renderer renderPass}.\r\n     */\r\n    setRenderingOptionsForRenderPass(renderPass: RenderPass) {\r\n      // a Mesh render material rendering options MUST match the render pass descriptor used to draw it!\r\n      const renderingOptions = {\r\n        sampleCount: renderPass.options.sampleCount,\r\n        // color attachments\r\n        ...(renderPass.options.colorAttachments.length && {\r\n          targetFormat: renderPass.options.colorAttachments[0].targetFormat,\r\n          // multiple render targets?\r\n          ...(renderPass.options.colorAttachments.length > 1 && {\r\n            additionalTargets: renderPass.options.colorAttachments\r\n              .filter((c, i) => i > 0)\r\n              .map((colorAttachment) => {\r\n                return {\r\n                  format: colorAttachment.targetFormat,\r\n                }\r\n              }),\r\n          }),\r\n        }),\r\n        // depth\r\n        depth: renderPass.options.useDepth,\r\n        ...(renderPass.options.useDepth && {\r\n          depthFormat: renderPass.options.depthFormat,\r\n        }),\r\n      }\r\n\r\n      this.material?.setRenderingOptions(renderingOptions)\r\n    }\r\n\r\n    /**\r\n     * Hook used to clean up parameters before sending them to the {@link RenderMaterial}.\r\n     * @param parameters - parameters to clean before sending them to the {@link RenderMaterial}\r\n     * @returns - cleaned parameters\r\n     */\r\n    cleanupRenderMaterialParameters(parameters: MeshBaseRenderParams): MeshBaseRenderParams {\r\n      // patch and set options, return mesh parameters\r\n      delete parameters.texturesOptions\r\n      delete parameters.outputTarget\r\n      delete parameters.autoRender\r\n\r\n      return parameters\r\n    }\r\n\r\n    /**\r\n     * Set a Mesh transparent property, then set its material\r\n     * @param meshParameters - {@link RenderMaterialParams | RenderMaterial parameters}\r\n     */\r\n    setMaterial(meshParameters: RenderMaterialParams) {\r\n      this.transparent = meshParameters.transparent\r\n\r\n      this.setShaders()\r\n\r\n      this.material = new RenderMaterial(this.renderer, meshParameters)\r\n      // add eventual textures passed as parameters\r\n      this.material.options.textures\r\n        ?.filter((texture) => texture instanceof Texture)\r\n        .forEach((texture) => this.onTextureAdded(texture))\r\n    }\r\n\r\n    /**\r\n     * Set Mesh material attributes\r\n     */\r\n    setMaterialGeometryAttributes() {\r\n      if (this.material && !this.material.attributes) {\r\n        this.material.setAttributesFromGeometry(this.geometry)\r\n      }\r\n    }\r\n\r\n    /* TEXTURES */\r\n\r\n    /**\r\n     * Get our {@link RenderMaterial#textures | RenderMaterial textures array}\r\n     * @readonly\r\n     */\r\n    get textures(): Texture[] {\r\n      return this.material?.textures || []\r\n    }\r\n\r\n    /**\r\n     * Get our {@link RenderMaterial#renderTextures | RenderMaterial render textures array}\r\n     * @readonly\r\n     */\r\n    get renderTextures(): RenderTexture[] {\r\n      return this.material?.renderTextures || []\r\n    }\r\n\r\n    /**\r\n     * Create a new {@link Texture}\r\n     * @param options - {@link TextureParams | Texture parameters}\r\n     * @returns - newly created {@link Texture}\r\n     */\r\n    createTexture(options: TextureParams): Texture {\r\n      if (!options.name) {\r\n        options.name = 'texture' + this.textures.length\r\n      }\r\n\r\n      if (!options.label) {\r\n        options.label = this.options.label + ' ' + options.name\r\n      }\r\n\r\n      const texture = new Texture(this.renderer, { ...options, ...this.options.texturesOptions })\r\n\r\n      this.addTexture(texture)\r\n\r\n      return texture\r\n    }\r\n\r\n    /**\r\n     * Add a {@link Texture}\r\n     * @param texture - {@link Texture} to add\r\n     */\r\n    addTexture(texture: Texture) {\r\n      this.material.addTexture(texture)\r\n      this.onTextureAdded(texture)\r\n    }\r\n\r\n    /**\r\n     * Callback run when a new {@link Texture} has been added\r\n     * @param texture - newly created Texture\r\n     */\r\n    onTextureAdded(texture: Texture) {\r\n      texture.parentMesh = this as unknown as TextureParent\r\n    }\r\n\r\n    /**\r\n     * Create a new {@link RenderTexture}\r\n     * @param  options - {@link RenderTextureParams | RenderTexture parameters}\r\n     * @returns - newly created {@link RenderTexture}\r\n     */\r\n    createRenderTexture(options: RenderTextureParams): RenderTexture {\r\n      if (!options.name) {\r\n        options.name = 'renderTexture' + this.renderTextures.length\r\n      }\r\n\r\n      const renderTexture = new RenderTexture(this.renderer, options)\r\n\r\n      this.addRenderTexture(renderTexture)\r\n\r\n      return renderTexture\r\n    }\r\n\r\n    /**\r\n     * Add a {@link RenderTexture}\r\n     * @param renderTexture - {@link RenderTexture} to add\r\n     */\r\n    addRenderTexture(renderTexture: RenderTexture) {\r\n      this.material.addTexture(renderTexture)\r\n    }\r\n\r\n    /* BINDINGS */\r\n\r\n    /**\r\n     * Get the current {@link RenderMaterial} uniforms\r\n     * @readonly\r\n     */\r\n    get uniforms(): Material['uniforms'] {\r\n      return this.material?.uniforms\r\n    }\r\n\r\n    /**\r\n     * Get the current {@link RenderMaterial} storages\r\n     * @readonly\r\n     */\r\n    get storages(): Material['storages'] {\r\n      return this.material?.storages\r\n    }\r\n\r\n    /* RESIZE */\r\n\r\n    /**\r\n     * Resize the Mesh's textures\r\n     * @param boundingRect\r\n     */\r\n    resize(boundingRect?: DOMElementBoundingRect | null) {\r\n      // @ts-ignore\r\n      if (super.resize) {\r\n        // @ts-ignore\r\n        super.resize(boundingRect)\r\n      }\r\n\r\n      this.renderTextures?.forEach((renderTexture) => {\r\n        // copy from original textures again if needed\r\n        if (renderTexture.options.fromTexture) {\r\n          renderTexture.copy(renderTexture.options.fromTexture)\r\n        }\r\n      })\r\n\r\n      // resize textures\r\n      this.textures?.forEach((texture) => {\r\n        texture.resize()\r\n      })\r\n\r\n      this._onAfterResizeCallback && this._onAfterResizeCallback()\r\n    }\r\n\r\n    /* EVENTS */\r\n\r\n    /**\r\n     * Assign a callback function to _onReadyCallback\r\n     * @param callback - callback to run when {@link MeshBase} is ready\r\n     * @returns - our Mesh\r\n     */\r\n    onReady(callback: () => void): MeshBase | ProjectedMeshBaseClass {\r\n      if (callback) {\r\n        this._onReadyCallback = callback\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    /**\r\n     * Assign a callback function to _onBeforeRenderCallback\r\n     * @param callback - callback to run just before {@link MeshBase} will be rendered\r\n     * @returns - our Mesh\r\n     */\r\n    onBeforeRender(callback: () => void): MeshBase | ProjectedMeshBaseClass {\r\n      if (callback) {\r\n        this._onBeforeRenderCallback = callback\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    /**\r\n     * Assign a callback function to _onRenderCallback\r\n     * @param callback - callback to run when {@link MeshBase} is rendered\r\n     * @returns - our Mesh\r\n     */\r\n    onRender(callback: () => void): MeshBase | ProjectedMeshBaseClass {\r\n      if (callback) {\r\n        this._onRenderCallback = callback\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    /**\r\n     * Assign a callback function to _onAfterRenderCallback\r\n     * @param callback - callback to run just after {@link MeshBase} has been rendered\r\n     * @returns - our Mesh\r\n     */\r\n    onAfterRender(callback: () => void): MeshBase | ProjectedMeshBaseClass {\r\n      if (callback) {\r\n        this._onAfterRenderCallback = callback\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    /**\r\n     * Assign a callback function to _onAfterResizeCallback\r\n     * @param callback - callback to run just after {@link MeshBase} has been resized\r\n     * @returns - our Mesh\r\n     */\r\n    onAfterResize(callback: () => void): MeshBase | ProjectedMeshBaseClass {\r\n      if (callback) {\r\n        this._onAfterResizeCallback = callback\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    /* RENDER */\r\n\r\n    /**\r\n     * Called before rendering the Mesh\r\n     * Set the geometry if needed (create buffers and add attributes to the {@link RenderMaterial})\r\n     * Then executes {@link RenderMaterial#onBeforeRender}: create its bind groups and pipeline if needed and eventually update its struct\r\n     */\r\n    onBeforeRenderPass() {\r\n      if (!this.renderer.ready) return\r\n\r\n      if (this.material && this.material.ready && this.geometry && this.geometry.ready && !this.ready) {\r\n        this.ready = true\r\n      }\r\n\r\n      this.setGeometry()\r\n\r\n      this._onBeforeRenderCallback && this._onBeforeRenderCallback()\r\n\r\n      this.material.onBeforeRender()\r\n    }\r\n\r\n    /**\r\n     * Render our {@link MeshBase} if the {@link RenderMaterial} is ready\r\n     * @param pass - current render pass encoder\r\n     */\r\n    onRenderPass(pass: GPURenderPassEncoder) {\r\n      if (!this.material.ready) return\r\n\r\n      this._onRenderCallback && this._onRenderCallback()\r\n\r\n      // render ou material\r\n      this.material.render(pass)\r\n      // then render our geometry\r\n      this.geometry.render(pass)\r\n    }\r\n\r\n    /**\r\n     * Called after having rendered the Mesh\r\n     */\r\n    onAfterRenderPass() {\r\n      this._onAfterRenderCallback && this._onAfterRenderCallback()\r\n    }\r\n\r\n    /**\r\n     * Render our Mesh\r\n     * - Execute {@link onBeforeRenderPass}\r\n     * - Stop here if {@link Renderer} is not ready or Mesh is not {@link visible}\r\n     * - Execute super render call if it exists\r\n     * - {@link onRenderPass | render} our {@link material} and {@link geometry}\r\n     * - Execute {@link onAfterRenderPass}\r\n     * @param pass - current render pass encoder\r\n     */\r\n    render(pass: GPURenderPassEncoder) {\r\n      this.onBeforeRenderPass()\r\n\r\n      // no point to render if the WebGPU device is not ready\r\n      if (!this.renderer.ready || !this.visible) return\r\n\r\n      // @ts-ignore\r\n      if (super.render) {\r\n        // @ts-ignore\r\n        super.render()\r\n      }\r\n\r\n      !this.renderer.production && pass.pushDebugGroup(this.options.label)\r\n\r\n      this.onRenderPass(pass)\r\n\r\n      !this.renderer.production && pass.popDebugGroup()\r\n\r\n      this.onAfterRenderPass()\r\n    }\r\n\r\n    /* DESTROY */\r\n\r\n    /**\r\n     * Remove the Mesh from the {@link core/scenes/Scene.Scene | Scene} and destroy it\r\n     */\r\n    remove() {\r\n      this.removeFromScene()\r\n      this.destroy()\r\n\r\n      // if the renderer does not contain any meshes any more\r\n      // clear it\r\n      if (!this.renderer.meshes.length) {\r\n        this.renderer.onBeforeRenderScene.add(\r\n          (commandEncoder) => {\r\n            this.renderer.forceClear(commandEncoder)\r\n          },\r\n          { once: true }\r\n        )\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Destroy the Mesh\r\n     */\r\n    destroy() {\r\n      // @ts-ignore\r\n      if (super.destroy) {\r\n        // @ts-ignore\r\n        super.destroy()\r\n      }\r\n\r\n      this.material?.destroy()\r\n\r\n      // remove geometry buffers from device cache\r\n      this.geometry.vertexBuffers.forEach((vertexBuffer) => {\r\n        // use original vertex buffer label in case it has been swapped (usually by a compute pass)\r\n        this.renderer.removeBuffer(\r\n          vertexBuffer.buffer,\r\n          this.options.label + ' geometry: ' + vertexBuffer.name + ' buffer'\r\n        )\r\n      })\r\n\r\n      if ('indexBuffer' in this.geometry) {\r\n        this.renderer.removeBuffer(this.geometry.indexBuffer.buffer)\r\n      }\r\n\r\n      this.geometry?.destroy()\r\n    }\r\n  }\r\n}\r\n\r\nexport { MeshBaseMixin }\r\n"],"names":[],"mappings":"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"}