{"version":3,"file":"ProjectedMeshBaseMixin.mjs","sources":["../../../../../src/core/meshes/mixins/ProjectedMeshBaseMixin.ts"],"sourcesContent":["import { CameraRenderer, isCameraRenderer } from '../../renderers/utils'\r\nimport { DOMFrustum } from '../../DOM/DOMFrustum'\r\nimport {\r\n  MeshBaseClass,\r\n  MeshBaseMixin,\r\n  MeshBaseOptions,\r\n  MeshBaseParams,\r\n  MeshBaseRenderParams,\r\n  MixinConstructor,\r\n} from './MeshBaseMixin'\r\nimport { GPUCurtains } from '../../../curtains/GPUCurtains'\r\nimport { DOMElementBoundingRect, RectCoords } from '../../DOM/DOMElement'\r\nimport { RenderMaterialParams, ShaderOptions } from '../../../types/Materials'\r\nimport { ProjectedObject3D } from '../../objects3D/ProjectedObject3D'\r\nimport { DOMObject3D } from '../../../curtains/objects3D/DOMObject3D'\r\nimport default_projected_vsWgsl from '../../shaders/chunks/default_projected_vs.wgsl'\r\nimport default_normal_fsWgsl from '../../shaders/chunks/default_normal_fs.wgsl'\r\nimport { ShaderPassParams } from '../../renderPasses/ShaderPass'\r\n\r\n/**\r\n * Base parameters used to create a ProjectedMesh\r\n */\r\nexport interface ProjectedMeshBaseParams {\r\n  /** Whether this ProjectedMesh should be frustum culled (not drawn when outside of {@link CameraRenderer#camera | camera} frustum) */\r\n  frustumCulled?: boolean\r\n  /** Margins (in pixels) to applied to the {@link ProjectedMeshBaseClass#domFrustum | DOM Frustum} to determine if this ProjectedMesh should be frustum culled or not */\r\n  DOMFrustumMargins?: RectCoords\r\n}\r\n\r\n/** Parameters used to create a ProjectedMesh */\r\nexport interface ProjectedMeshParameters extends MeshBaseParams, ProjectedMeshBaseParams {}\r\n\r\nexport interface ProjectedRenderMaterialParams extends RenderMaterialParams, ProjectedMeshBaseParams {}\r\n\r\n/** @const - Default ProjectedMesh parameters to merge with user defined parameters */\r\nconst defaultProjectedMeshParams: ProjectedMeshBaseParams = {\r\n  // frustum culling and visibility\r\n  frustumCulled: true,\r\n  DOMFrustumMargins: {\r\n    top: 0,\r\n    right: 0,\r\n    bottom: 0,\r\n    left: 0,\r\n  },\r\n}\r\n\r\n/** Base options used to create this ProjectedMesh */\r\nexport interface ProjectedMeshBaseOptions extends MeshBaseOptions, Partial<ProjectedMeshBaseParams> {}\r\n\r\n/**\r\n * This class describes the properties and methods to set up a Projected Mesh (i.e. a basic {@link MeshBaseClass | Mesh} with {@link ProjectedObject3D} transformations matrices and a {@link core/camera/Camera.Camera | Camera} to use for projection), implemented in the {@link ProjectedMeshBaseMixin}:\r\n * - Handle the frustum culling (check if the {@link ProjectedObject3D} currently lies inside the {@link core/camera/Camera.Camera | Camera} frustum)\r\n * - Add callbacks for when the Mesh enters or leaves the {@link core/camera/Camera.Camera | Camera} frustum\r\n */\r\nexport declare class ProjectedMeshBaseClass extends MeshBaseClass {\r\n  /** The {@link CameraRenderer} used */\r\n  renderer: CameraRenderer\r\n  /** The ProjectedMesh {@link DOMFrustum} class object */\r\n  domFrustum: DOMFrustum\r\n  /** Whether this ProjectedMesh should be frustum culled (not drawn when outside of {@link CameraRenderer#camera | camera} frustum) */\r\n  frustumCulled: boolean\r\n  /** Margins (in pixels) to applied to the {@link ProjectedMeshBaseClass#domFrustum | DOM Frustum} to determine if this ProjectedMesh should be frustum culled or not */\r\n  DOMFrustumMargins: RectCoords\r\n\r\n  // callbacks\r\n  /** function assigned to the {@link onReEnterView} callback */\r\n  _onReEnterViewCallback: () => void\r\n  /** function assigned to the {@link onLeaveView} callback */\r\n  _onLeaveViewCallback: () => void\r\n\r\n  /**\r\n   * {@link ProjectedMeshBaseClass} constructor\r\n   * @param renderer - our {@link CameraRenderer} class object\r\n   * @param element - a DOM HTML Element that can be bound to a Mesh\r\n   * @param parameters - {@link ProjectedMeshParameters | Projected Mesh base parameters}\r\n   */\r\n  constructor(renderer: CameraRenderer, element: HTMLElement | null, parameters: ProjectedMeshParameters)\r\n\r\n  /**\r\n   * Set default shaders if one or both of them are missing\r\n   */\r\n  setShaders(): void\r\n\r\n  /**\r\n   * Override {@link MeshBaseClass} method to add the domFrustum\r\n   */\r\n  computeGeometry(): void\r\n\r\n  /**\r\n   * Set a Mesh matrices uniforms inputs then call {@link MeshBaseClass} super method\r\n   * @param meshParameters - {@link RenderMaterialParams | RenderMaterial parameters}\r\n   */\r\n  setMaterial(meshParameters: ProjectedRenderMaterialParams): void\r\n\r\n  /**\r\n   * Resize our Mesh\r\n   * @param boundingRect - the new bounding rectangle\r\n   */\r\n  resize(boundingRect: DOMElementBoundingRect | null): void\r\n\r\n  /**\r\n   * Apply scale and resize textures\r\n   */\r\n  applyScale(): void\r\n\r\n  /**\r\n   * Get our {@link DOMFrustum} projected bounding rectangle\r\n   * @readonly\r\n   */\r\n  get projectedBoundingRect(): DOMElementBoundingRect\r\n\r\n  /**\r\n   * At least one of the matrix has been updated, update according uniforms and frustum\r\n   */\r\n  onAfterMatrixStackUpdate(): void\r\n\r\n  /**\r\n   * Assign a callback function to _onReEnterViewCallback\r\n   * @param callback - callback to run when {@link ProjectedMeshBaseClass} is reentering the view frustum\r\n   * @returns - our Mesh\r\n   */\r\n  onReEnterView: (callback: () => void) => ProjectedMeshBaseClass\r\n  /**\r\n   * Assign a callback function to _onLeaveViewCallback\r\n   * @param callback - callback to run when {@link ProjectedMeshBaseClass} is leaving the view frustum\r\n   * @returns - our Mesh\r\n   */\r\n  onLeaveView: (callback: () => void) => ProjectedMeshBaseClass\r\n\r\n  /**\r\n   * Called before rendering the Mesh to update matrices and {@link DOMFrustum}.\r\n   * First, we update our matrices to have fresh results. It eventually calls onAfterMatrixStackUpdate() if at least one matrix has been updated.\r\n   * Then we check if we need to update the {@link DOMFrustum} projected bounding rectangle.\r\n   * Finally we call {@link MeshBaseClass#onBeforeRenderPass | Mesh base onBeforeRenderPass} super\r\n   */\r\n  onBeforeRenderPass(): void\r\n\r\n  /**\r\n   * Only render the Mesh if it is in view frustum.\r\n   * Since render() is actually called before onRenderPass(), we are sure to have fresh frustum bounding rectangle values here.\r\n   * @param pass - current render pass\r\n   */\r\n  onRenderPass(pass: GPURenderPassEncoder): void\r\n}\r\n\r\n/**\r\n * Used to add the properties and methods defined in {@link ProjectedMeshBaseClass} to the {@link MeshBaseClass} and mix it with a given Base of type {@link ProjectedObject3D} or {@link DOMObject3D}.\r\n * @exports\r\n * @param Base - the class to mix onto, should be of {@link ProjectedObject3D} or {@link DOMObject3D} type\r\n * @returns - the mixed classes, creating a Projected Mesh.\r\n */\r\nfunction ProjectedMeshBaseMixin<TBase extends MixinConstructor<ProjectedObject3D>>(\r\n  Base: TBase\r\n): MixinConstructor<ProjectedMeshBaseClass> & TBase {\r\n  /**\r\n   * ProjectedMeshBase defines our base properties and methods\r\n   */\r\n  return class ProjectedMeshBase extends MeshBaseMixin(Base) {\r\n    /** The {@link CameraRenderer} used */\r\n    renderer: CameraRenderer\r\n    /** The ProjectedMesh {@link DOMFrustum} class object */\r\n    domFrustum: DOMFrustum\r\n    /** Whether this ProjectedMesh should be frustum culled (not drawn when outside of {@link CameraRenderer#camera | camera} frustum) */\r\n    frustumCulled: boolean\r\n    /** Margins (in pixels) to applied to the {@link ProjectedMeshBaseClass#domFrustum | DOM Frustum} to determine if this ProjectedMesh should be frustum culled or not */\r\n    DOMFrustumMargins: RectCoords\r\n\r\n    /** Options used to create this {@link ProjectedMeshBaseClass} */\r\n    options: ProjectedMeshBaseOptions\r\n\r\n    // callbacks / events\r\n    /** function assigned to the {@link onReEnterView} callback */\r\n    _onReEnterViewCallback: () => void = () => {\r\n      /* allow empty callback */\r\n    }\r\n    /** function assigned to the {@link onLeaveView} callback */\r\n    _onLeaveViewCallback: () => void = () => {\r\n      /* allow empty callback */\r\n    }\r\n\r\n    /**\r\n     * ProjectedMeshBase constructor\r\n     *\r\n     * @typedef MeshBaseArrayParams\r\n     * @type {array}\r\n     * @property {(CameraRenderer|GPUCurtains)} 0 - our renderer class object\r\n     * @property {(string|HTMLElement|null)} 1 - the DOM HTML Element that can be bound to a Mesh\r\n     * @property {ProjectedMeshParameters} 2 - Projected Mesh parameters\r\n     *\r\n     * @param {MeshBaseArrayParams} params - our MeshBaseMixin parameters\r\n     */\r\n    constructor(...params: any[]) {\r\n      super(\r\n        params[0] as CameraRenderer | GPUCurtains,\r\n        params[1] as HTMLElement | string,\r\n        { ...defaultProjectedMeshParams, ...params[2], ...{ useProjection: true } } as ProjectedMeshParameters\r\n      )\r\n\r\n      let renderer = params[0]\r\n\r\n      // force this mesh to use projection!\r\n      const parameters = {\r\n        ...defaultProjectedMeshParams,\r\n        ...params[2],\r\n        ...{ useProjection: true },\r\n      } as ProjectedMeshParameters\r\n\r\n      this.type = 'MeshTransformed'\r\n\r\n      // we could pass our curtains object OR our curtains renderer object\r\n      renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as CameraRenderer)\r\n\r\n      isCameraRenderer(renderer, parameters.label ? parameters.label + ' ' + this.type : this.type)\r\n\r\n      this.renderer = renderer\r\n\r\n      const { geometry, frustumCulled, DOMFrustumMargins } = parameters\r\n\r\n      this.options = {\r\n        ...(this.options ?? {}), // merge possible lower options?\r\n        frustumCulled,\r\n        DOMFrustumMargins,\r\n      }\r\n\r\n      this.setDOMFrustum()\r\n\r\n      // explicitly needed for DOM Frustum\r\n      this.geometry = geometry\r\n\r\n      // tell the model and projection matrices to update right away\r\n      this.shouldUpdateMatrixStack()\r\n    }\r\n\r\n    /* SHADERS */\r\n\r\n    /**\r\n     * Set default shaders if one or both of them are missing\r\n     */\r\n    setShaders() {\r\n      let { shaders } = this.options\r\n\r\n      if (!shaders) {\r\n        shaders = {\r\n          vertex: {\r\n            code: default_projected_vsWgsl,\r\n            entryPoint: 'main',\r\n          },\r\n          fragment: {\r\n            code: default_normal_fsWgsl,\r\n            entryPoint: 'main',\r\n          },\r\n        }\r\n      } else {\r\n        if (!shaders.vertex || !shaders.vertex.code) {\r\n          shaders.vertex = {\r\n            code: default_projected_vsWgsl,\r\n            entryPoint: 'main',\r\n          }\r\n        }\r\n\r\n        if (shaders.fragment === undefined || (shaders.fragment && !(shaders.fragment as ShaderOptions).code)) {\r\n          shaders.fragment = {\r\n            code: default_normal_fsWgsl,\r\n            entryPoint: 'main',\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /* GEOMETRY */\r\n\r\n    /**\r\n     * Set the Mesh frustum culling\r\n     */\r\n    setDOMFrustum() {\r\n      this.domFrustum = new DOMFrustum({\r\n        boundingBox: this.geometry.boundingBox,\r\n        modelViewProjectionMatrix: this.modelViewProjectionMatrix,\r\n        containerBoundingRect: this.renderer.boundingRect,\r\n        DOMFrustumMargins: this.options.DOMFrustumMargins,\r\n        onReEnterView: () => {\r\n          this._onReEnterViewCallback && this._onReEnterViewCallback()\r\n        },\r\n        onLeaveView: () => {\r\n          this._onLeaveViewCallback && this._onLeaveViewCallback()\r\n        },\r\n      })\r\n\r\n      this.DOMFrustumMargins = this.domFrustum.DOMFrustumMargins\r\n      this.frustumCulled = this.options.frustumCulled\r\n      this.domFrustum.shouldUpdate = this.frustumCulled\r\n    }\r\n\r\n    /* MATERIAL */\r\n\r\n    /**\r\n     * Hook used to clean up parameters before sending them to the material.\r\n     * @param parameters - parameters to clean before sending them to the {@link core/materials/RenderMaterial.RenderMaterial | RenderMaterial}\r\n     * @returns - cleaned parameters\r\n     */\r\n    cleanupRenderMaterialParameters(parameters: ProjectedRenderMaterialParams): MeshBaseRenderParams {\r\n      // patch mesh parameters\r\n      delete parameters.frustumCulled\r\n      delete parameters.DOMFrustumMargins\r\n\r\n      super.cleanupRenderMaterialParameters(parameters)\r\n\r\n      return parameters\r\n    }\r\n\r\n    /**\r\n     * Set a Mesh matrices uniforms inputs then call {@link MeshBaseClass} super method\r\n     * @param meshParameters - {@link RenderMaterialParams | RenderMaterial parameters}\r\n     */\r\n    setMaterial(meshParameters: RenderMaterialParams) {\r\n      // add matrices uniforms\r\n      const matricesUniforms = {\r\n        label: 'Matrices',\r\n        struct: {\r\n          model: {\r\n            name: 'model',\r\n            type: 'mat4x4f',\r\n            value: this.modelMatrix,\r\n          },\r\n          world: {\r\n            name: 'world',\r\n            type: 'mat4x4f',\r\n            value: this.worldMatrix,\r\n          },\r\n          modelView: {\r\n            // model view matrix (world matrix multiplied by camera view matrix)\r\n            name: 'modelView',\r\n            type: 'mat4x4f',\r\n            value: this.modelViewMatrix,\r\n          },\r\n          modelViewProjection: {\r\n            name: 'modelViewProjection',\r\n            type: 'mat4x4f',\r\n            value: this.modelViewProjectionMatrix,\r\n          },\r\n        },\r\n      }\r\n\r\n      if (!meshParameters.uniforms) meshParameters.uniforms = {}\r\n      meshParameters.uniforms.matrices = matricesUniforms\r\n\r\n      super.setMaterial(meshParameters)\r\n    }\r\n\r\n    /* SIZE & TRANSFORMS */\r\n\r\n    /**\r\n     * Resize our {@link ProjectedMeshBaseClass}\r\n     * @param boundingRect - the new bounding rectangle\r\n     */\r\n    resize(boundingRect?: DOMElementBoundingRect | null) {\r\n      if (this.domFrustum) this.domFrustum.setContainerBoundingRect(this.renderer.boundingRect)\r\n\r\n      super.resize(boundingRect)\r\n    }\r\n\r\n    /**\r\n     * Apply scale and resize textures\r\n     */\r\n    applyScale() {\r\n      super.applyScale()\r\n\r\n      // resize textures on scale change!\r\n      this.textures.forEach((texture) => texture.resize())\r\n    }\r\n\r\n    /**\r\n     * Get our {@link DOMFrustum} projected bounding rectangle\r\n     * @readonly\r\n     */\r\n    get projectedBoundingRect(): DOMElementBoundingRect {\r\n      return this.domFrustum?.projectedBoundingRect\r\n    }\r\n\r\n    /**\r\n     * At least one of the matrix has been updated, update according uniforms and frustum\r\n     */\r\n    onAfterMatrixStackUpdate() {\r\n      if (this.material) {\r\n        this.material.shouldUpdateInputsBindings('matrices')\r\n      }\r\n\r\n      if (this.domFrustum) this.domFrustum.shouldUpdate = true\r\n    }\r\n\r\n    /* EVENTS */\r\n\r\n    /**\r\n     * Assign a callback function to _onReEnterViewCallback\r\n     * @param callback - callback to run when {@link ProjectedMeshBaseClass} is reentering the view frustum\r\n     * @returns - our Mesh\r\n     */\r\n    onReEnterView(callback: () => void): ProjectedMeshBaseClass {\r\n      if (callback) {\r\n        this._onReEnterViewCallback = callback\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    /**\r\n     * Assign a callback function to _onLeaveViewCallback\r\n     * @param callback - callback to run when {@link ProjectedMeshBaseClass} is leaving the view frustum\r\n     * @returns - our Mesh\r\n     */\r\n    onLeaveView(callback: () => void): ProjectedMeshBaseClass {\r\n      if (callback) {\r\n        this._onLeaveViewCallback = callback\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    /* RENDER */\r\n\r\n    /**\r\n     * Called before rendering the Mesh to update matrices and {@link DOMFrustum}.\r\n     * First, we update our matrices to have fresh results. It eventually calls onAfterMatrixStackUpdate() if at least one matrix has been updated.\r\n     * Then we check if we need to update the {@link DOMFrustum} projected bounding rectangle.\r\n     * Finally we call {@link MeshBaseClass#onBeforeRenderPass | Mesh base onBeforeRenderPass} super\r\n     */\r\n    onBeforeRenderPass() {\r\n      this.updateMatrixStack()\r\n\r\n      if (this.domFrustum && this.domFrustum.shouldUpdate && this.frustumCulled) {\r\n        this.domFrustum.computeProjectedToDocumentCoords()\r\n        this.domFrustum.shouldUpdate = false\r\n      }\r\n\r\n      super.onBeforeRenderPass()\r\n    }\r\n\r\n    /**\r\n     * Only render the Mesh if it is in view frustum.\r\n     * Since render() is actually called before onRenderPass(), we are sure to have fresh frustum bounding rectangle values here.\r\n     * @param pass - current render pass\r\n     */\r\n    onRenderPass(pass: GPURenderPassEncoder) {\r\n      if (!this.material.ready) return\r\n\r\n      this._onRenderCallback && this._onRenderCallback()\r\n\r\n      if ((this.domFrustum && this.domFrustum.isIntersecting) || !this.frustumCulled) {\r\n        // render ou material\r\n        this.material.render(pass)\r\n        // then render our geometry\r\n        this.geometry.render(pass)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport { ProjectedMeshBaseMixin }\r\n"],"names":[],"mappings":"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"}