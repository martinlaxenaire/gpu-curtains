{"version":3,"file":"ProjectedMeshBaseMixin.mjs","sources":["../../../../../src/core/meshes/mixins/ProjectedMeshBaseMixin.ts"],"sourcesContent":["import { CameraRenderer, isCameraRenderer } from '../../renderers/utils'\nimport { DOMFrustum } from '../../DOM/DOMFrustum'\nimport {\n  MeshBaseClass,\n  MeshBaseMixin,\n  MeshBaseOptions,\n  MeshBaseParams,\n  MeshBaseRenderParams,\n  MixinConstructor,\n} from './MeshBaseMixin'\nimport { GPUCurtains } from '../../../curtains/GPUCurtains'\nimport { DOMElementBoundingRect, RectCoords } from '../../DOM/DOMElement'\nimport { RenderMaterialParams, ShaderOptions } from '../../../types/Materials'\nimport { ProjectedObject3D } from '../../objects3D/ProjectedObject3D'\nimport { DOMObject3D } from '../../../curtains/objects3D/DOMObject3D'\nimport default_projected_vsWgsl from '../../shaders/chunks/default_projected_vs.wgsl'\nimport default_normal_fsWgsl from '../../shaders/chunks/default_normal_fs.wgsl'\nimport { ShaderPassParams } from '../../renderPasses/ShaderPass'\n\n/**\n * Base parameters used to create a ProjectedMesh\n */\nexport interface ProjectedMeshBaseParams {\n  /** Whether this ProjectedMesh should be frustum culled (not drawn when outside of {@link CameraRenderer#camera | camera} frustum) */\n  frustumCulled?: boolean\n  /** Margins (in pixels) to applied to the {@link ProjectedMeshBaseClass#domFrustum | DOM Frustum} to determine if this ProjectedMesh should be frustum culled or not */\n  DOMFrustumMargins?: RectCoords\n}\n\n/** Parameters used to create a ProjectedMesh */\nexport interface ProjectedMeshParameters extends MeshBaseParams, ProjectedMeshBaseParams {}\n\nexport interface ProjectedRenderMaterialParams extends RenderMaterialParams, ProjectedMeshBaseParams {}\n\n/** @const - Default ProjectedMesh parameters to merge with user defined parameters */\nconst defaultProjectedMeshParams: ProjectedMeshBaseParams = {\n  // frustum culling and visibility\n  frustumCulled: true,\n  DOMFrustumMargins: {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n  },\n}\n\n/** Base options used to create this ProjectedMesh */\nexport interface ProjectedMeshBaseOptions extends MeshBaseOptions, Partial<ProjectedMeshBaseParams> {}\n\n/**\n * This class describes the properties and methods to set up a Projected Mesh (i.e. a basic {@link MeshBaseClass | Mesh} with {@link ProjectedObject3D} transformations matrices and a {@link core/camera/Camera.Camera | Camera} to use for projection), implemented in the {@link ProjectedMeshBaseMixin}:\n * - Handle the frustum culling (check if the {@link ProjectedObject3D} currently lies inside the {@link core/camera/Camera.Camera | Camera} frustum)\n * - Add callbacks for when the Mesh enters or leaves the {@link core/camera/Camera.Camera | Camera} frustum\n */\nexport declare class ProjectedMeshBaseClass extends MeshBaseClass {\n  /** The {@link CameraRenderer} used */\n  renderer: CameraRenderer\n  /** The ProjectedMesh {@link DOMFrustum} class object */\n  domFrustum: DOMFrustum\n  /** Whether this ProjectedMesh should be frustum culled (not drawn when outside of {@link CameraRenderer#camera | camera} frustum) */\n  frustumCulled: boolean\n  /** Margins (in pixels) to applied to the {@link ProjectedMeshBaseClass#domFrustum | DOM Frustum} to determine if this ProjectedMesh should be frustum culled or not */\n  DOMFrustumMargins: RectCoords\n\n  // callbacks\n  /** function assigned to the {@link onReEnterView} callback */\n  _onReEnterViewCallback: () => void\n  /** function assigned to the {@link onLeaveView} callback */\n  _onLeaveViewCallback: () => void\n\n  /**\n   * {@link ProjectedMeshBaseClass} constructor\n   * @param renderer - our {@link CameraRenderer} class object\n   * @param element - a DOM HTML Element that can be bound to a Mesh\n   * @param parameters - {@link ProjectedMeshParameters | Projected Mesh base parameters}\n   */\n  constructor(renderer: CameraRenderer, element: HTMLElement | null, parameters: ProjectedMeshParameters)\n\n  /**\n   * Set default shaders if one or both of them are missing\n   */\n  setShaders(): void\n\n  /**\n   * Override {@link MeshBaseClass} method to add the domFrustum\n   */\n  computeGeometry(): void\n\n  /**\n   * Set a Mesh matrices uniforms inputs then call {@link MeshBaseClass} super method\n   * @param meshParameters - {@link RenderMaterialParams | RenderMaterial parameters}\n   */\n  setMaterial(meshParameters: ProjectedRenderMaterialParams): void\n\n  /**\n   * Resize our Mesh\n   * @param boundingRect - the new bounding rectangle\n   */\n  resize(boundingRect: DOMElementBoundingRect | null): void\n\n  /**\n   * Apply scale and resize textures\n   */\n  applyScale(): void\n\n  /**\n   * Get our {@link DOMFrustum} projected bounding rectangle\n   * @readonly\n   */\n  get projectedBoundingRect(): DOMElementBoundingRect\n\n  /**\n   * At least one of the matrix has been updated, update according uniforms and frustum\n   */\n  onAfterMatrixStackUpdate(): void\n\n  /**\n   * Assign a callback function to _onReEnterViewCallback\n   * @param callback - callback to run when {@link ProjectedMeshBaseClass} is reentering the view frustum\n   * @returns - our Mesh\n   */\n  onReEnterView: (callback: () => void) => ProjectedMeshBaseClass\n  /**\n   * Assign a callback function to _onLeaveViewCallback\n   * @param callback - callback to run when {@link ProjectedMeshBaseClass} is leaving the view frustum\n   * @returns - our Mesh\n   */\n  onLeaveView: (callback: () => void) => ProjectedMeshBaseClass\n\n  /**\n   * Called before rendering the Mesh to update matrices and {@link DOMFrustum}.\n   * First, we update our matrices to have fresh results. It eventually calls onAfterMatrixStackUpdate() if at least one matrix has been updated.\n   * Then we check if we need to update the {@link DOMFrustum} projected bounding rectangle.\n   * Finally we call {@link MeshBaseClass#onBeforeRenderPass | Mesh base onBeforeRenderPass} super\n   */\n  onBeforeRenderPass(): void\n\n  /**\n   * Only render the Mesh if it is in view frustum.\n   * Since render() is actually called before onRenderPass(), we are sure to have fresh frustum bounding rectangle values here.\n   * @param pass - current render pass\n   */\n  onRenderPass(pass: GPURenderPassEncoder): void\n}\n\n/**\n * Used to add the properties and methods defined in {@link ProjectedMeshBaseClass} to the {@link MeshBaseClass} and mix it with a given Base of type {@link ProjectedObject3D} or {@link DOMObject3D}.\n * @exports\n * @param Base - the class to mix onto, should be of {@link ProjectedObject3D} or {@link DOMObject3D} type\n * @returns - the mixed classes, creating a Projected Mesh.\n */\nfunction ProjectedMeshBaseMixin<TBase extends MixinConstructor<ProjectedObject3D>>(\n  Base: TBase\n): MixinConstructor<ProjectedMeshBaseClass> & TBase {\n  /**\n   * ProjectedMeshBase defines our base properties and methods\n   */\n  return class ProjectedMeshBase extends MeshBaseMixin(Base) {\n    /** The {@link CameraRenderer} used */\n    renderer: CameraRenderer\n    /** The ProjectedMesh {@link DOMFrustum} class object */\n    domFrustum: DOMFrustum\n    /** Whether this ProjectedMesh should be frustum culled (not drawn when outside of {@link CameraRenderer#camera | camera} frustum) */\n    frustumCulled: boolean\n    /** Margins (in pixels) to applied to the {@link ProjectedMeshBaseClass#domFrustum | DOM Frustum} to determine if this ProjectedMesh should be frustum culled or not */\n    DOMFrustumMargins: RectCoords\n\n    /** Options used to create this {@link ProjectedMeshBaseClass} */\n    options: ProjectedMeshBaseOptions\n\n    // callbacks / events\n    /** function assigned to the {@link onReEnterView} callback */\n    _onReEnterViewCallback: () => void = () => {\n      /* allow empty callback */\n    }\n    /** function assigned to the {@link onLeaveView} callback */\n    _onLeaveViewCallback: () => void = () => {\n      /* allow empty callback */\n    }\n\n    /**\n     * ProjectedMeshBase constructor\n     *\n     * @typedef MeshBaseArrayParams\n     * @type {array}\n     * @property {(CameraRenderer|GPUCurtains)} 0 - our renderer class object\n     * @property {(string|HTMLElement|null)} 1 - the DOM HTML Element that can be bound to a Mesh\n     * @property {ProjectedMeshParameters} 2 - Projected Mesh parameters\n     *\n     * @param {MeshBaseArrayParams} params - our MeshBaseMixin parameters\n     */\n    constructor(...params: any[]) {\n      super(\n        params[0] as CameraRenderer | GPUCurtains,\n        params[1] as HTMLElement | string,\n        { ...defaultProjectedMeshParams, ...params[2], ...{ useProjection: true } } as ProjectedMeshParameters\n      )\n\n      let renderer = params[0]\n\n      // force this mesh to use projection!\n      const parameters = {\n        ...defaultProjectedMeshParams,\n        ...params[2],\n        ...{ useProjection: true },\n      } as ProjectedMeshParameters\n\n      this.type = 'MeshTransformed'\n\n      // we could pass our curtains object OR our curtains renderer object\n      renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as CameraRenderer)\n\n      isCameraRenderer(renderer, parameters.label ? parameters.label + ' ' + this.type : this.type)\n\n      this.renderer = renderer\n\n      const { geometry, frustumCulled, DOMFrustumMargins } = parameters\n\n      this.options = {\n        ...(this.options ?? {}), // merge possible lower options?\n        frustumCulled,\n        DOMFrustumMargins,\n      }\n\n      this.setDOMFrustum()\n\n      // explicitly needed for DOM Frustum\n      this.geometry = geometry\n\n      // tell the model and projection matrices to update right away\n      this.shouldUpdateMatrixStack()\n    }\n\n    /* SHADERS */\n\n    /**\n     * Set default shaders if one or both of them are missing\n     */\n    setShaders() {\n      let { shaders } = this.options\n\n      if (!shaders) {\n        shaders = {\n          vertex: {\n            code: default_projected_vsWgsl,\n            entryPoint: 'main',\n          },\n          fragment: {\n            code: default_normal_fsWgsl,\n            entryPoint: 'main',\n          },\n        }\n      } else {\n        if (!shaders.vertex || !shaders.vertex.code) {\n          shaders.vertex = {\n            code: default_projected_vsWgsl,\n            entryPoint: 'main',\n          }\n        }\n\n        if (shaders.fragment === undefined || (shaders.fragment && !(shaders.fragment as ShaderOptions).code)) {\n          shaders.fragment = {\n            code: default_normal_fsWgsl,\n            entryPoint: 'main',\n          }\n        }\n      }\n    }\n\n    /* GEOMETRY */\n\n    /**\n     * Set the Mesh frustum culling\n     */\n    setDOMFrustum() {\n      this.domFrustum = new DOMFrustum({\n        boundingBox: this.geometry.boundingBox,\n        modelViewProjectionMatrix: this.modelViewProjectionMatrix,\n        containerBoundingRect: this.renderer.boundingRect,\n        DOMFrustumMargins: this.options.DOMFrustumMargins,\n        onReEnterView: () => {\n          this._onReEnterViewCallback && this._onReEnterViewCallback()\n        },\n        onLeaveView: () => {\n          this._onLeaveViewCallback && this._onLeaveViewCallback()\n        },\n      })\n\n      this.DOMFrustumMargins = this.domFrustum.DOMFrustumMargins\n      this.frustumCulled = this.options.frustumCulled\n      this.domFrustum.shouldUpdate = this.frustumCulled\n    }\n\n    /* MATERIAL */\n\n    /**\n     * Hook used to clean up parameters before sending them to the material.\n     * @param parameters - parameters to clean before sending them to the {@link core/materials/RenderMaterial.RenderMaterial | RenderMaterial}\n     * @returns - cleaned parameters\n     */\n    cleanupRenderMaterialParameters(parameters: ProjectedRenderMaterialParams): MeshBaseRenderParams {\n      // patch mesh parameters\n      delete parameters.frustumCulled\n      delete parameters.DOMFrustumMargins\n\n      super.cleanupRenderMaterialParameters(parameters)\n\n      return parameters\n    }\n\n    /**\n     * Set a Mesh matrices uniforms inputs then call {@link MeshBaseClass} super method\n     * @param meshParameters - {@link RenderMaterialParams | RenderMaterial parameters}\n     */\n    setMaterial(meshParameters: RenderMaterialParams) {\n      // add matrices uniforms\n      const matricesUniforms = {\n        label: 'Matrices',\n        struct: {\n          model: {\n            name: 'model',\n            type: 'mat4x4f',\n            value: this.modelMatrix,\n          },\n          world: {\n            name: 'world',\n            type: 'mat4x4f',\n            value: this.worldMatrix,\n          },\n          modelView: {\n            // model view matrix (world matrix multiplied by camera view matrix)\n            name: 'modelView',\n            type: 'mat4x4f',\n            value: this.modelViewMatrix,\n          },\n          modelViewProjection: {\n            name: 'modelViewProjection',\n            type: 'mat4x4f',\n            value: this.modelViewProjectionMatrix,\n          },\n        },\n      }\n\n      if (!meshParameters.uniforms) meshParameters.uniforms = {}\n      meshParameters.uniforms.matrices = matricesUniforms\n\n      super.setMaterial(meshParameters)\n    }\n\n    /* SIZE & TRANSFORMS */\n\n    /**\n     * Resize our {@link ProjectedMeshBaseClass}\n     * @param boundingRect - the new bounding rectangle\n     */\n    resize(boundingRect?: DOMElementBoundingRect | null) {\n      if (this.domFrustum) this.domFrustum.setContainerBoundingRect(this.renderer.boundingRect)\n\n      super.resize(boundingRect)\n    }\n\n    /**\n     * Apply scale and resize textures\n     */\n    applyScale() {\n      super.applyScale()\n\n      // resize textures on scale change!\n      this.textures.forEach((texture) => texture.resize())\n    }\n\n    /**\n     * Get our {@link DOMFrustum} projected bounding rectangle\n     * @readonly\n     */\n    get projectedBoundingRect(): DOMElementBoundingRect {\n      return this.domFrustum?.projectedBoundingRect\n    }\n\n    /**\n     * At least one of the matrix has been updated, update according uniforms and frustum\n     */\n    onAfterMatrixStackUpdate() {\n      if (this.material) {\n        this.material.shouldUpdateInputsBindings('matrices')\n      }\n\n      if (this.domFrustum) this.domFrustum.shouldUpdate = true\n    }\n\n    /* EVENTS */\n\n    /**\n     * Assign a callback function to _onReEnterViewCallback\n     * @param callback - callback to run when {@link ProjectedMeshBaseClass} is reentering the view frustum\n     * @returns - our Mesh\n     */\n    onReEnterView(callback: () => void): ProjectedMeshBaseClass {\n      if (callback) {\n        this._onReEnterViewCallback = callback\n      }\n\n      return this\n    }\n\n    /**\n     * Assign a callback function to _onLeaveViewCallback\n     * @param callback - callback to run when {@link ProjectedMeshBaseClass} is leaving the view frustum\n     * @returns - our Mesh\n     */\n    onLeaveView(callback: () => void): ProjectedMeshBaseClass {\n      if (callback) {\n        this._onLeaveViewCallback = callback\n      }\n\n      return this\n    }\n\n    /* RENDER */\n\n    /**\n     * Called before rendering the Mesh to update matrices and {@link DOMFrustum}.\n     * First, we update our matrices to have fresh results. It eventually calls onAfterMatrixStackUpdate() if at least one matrix has been updated.\n     * Then we check if we need to update the {@link DOMFrustum} projected bounding rectangle.\n     * Finally we call {@link MeshBaseClass#onBeforeRenderPass | Mesh base onBeforeRenderPass} super\n     */\n    onBeforeRenderPass() {\n      this.updateMatrixStack()\n\n      if (this.domFrustum && this.domFrustum.shouldUpdate && this.frustumCulled) {\n        this.domFrustum.computeProjectedToDocumentCoords()\n        this.domFrustum.shouldUpdate = false\n      }\n\n      super.onBeforeRenderPass()\n    }\n\n    /**\n     * Only render the Mesh if it is in view frustum.\n     * Since render() is actually called before onRenderPass(), we are sure to have fresh frustum bounding rectangle values here.\n     * @param pass - current render pass\n     */\n    onRenderPass(pass: GPURenderPassEncoder) {\n      if (!this.material.ready) return\n\n      this._onRenderCallback && this._onRenderCallback()\n\n      if ((this.domFrustum && this.domFrustum.isIntersecting) || !this.frustumCulled) {\n        // render ou material\n        this.material.render(pass)\n        // then render our geometry\n        this.geometry.render(pass)\n      }\n    }\n  }\n}\n\nexport { ProjectedMeshBaseMixin }\n"],"names":[],"mappings":"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"}