{"version":3,"file":"ComputePass.mjs","sources":["../../../../src/core/computePasses/ComputePass.ts"],"sourcesContent":["import { isRenderer, Renderer } from '../renderers/utils'\nimport { generateUUID } from '../../utils/utils'\nimport { ComputeMaterial } from '../materials/ComputeMaterial'\nimport { ComputeMaterialParams, MaterialParams, MaterialShaders } from '../../types/Materials'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\nimport { RenderTexture, RenderTextureParams } from '../textures/RenderTexture'\nimport { Texture } from '../textures/Texture'\nimport { ExternalTextureParams, TextureParams } from '../../types/Textures'\n\n/** Defines {@link ComputePass} options */\nexport interface ComputePassOptions {\n  /** The label of the {@link ComputePass} */\n  label: string\n  /** Controls the order in which this {@link ComputePass} should be rendered by our {@link core/scenes/Scene.Scene | Scene} */\n  renderOrder?: number\n  /** Whether the {@link ComputePass} should be added to our {@link core/scenes/Scene.Scene | Scene} to let it handle the rendering process automatically */\n  autoRender?: boolean\n  /** Compute shader passed to the {@link ComputePass} following the {@link types/Materials.ShaderOptions | shader object} notation */\n  shaders: MaterialShaders\n  /** whether the {@link core/pipelines/ComputePipelineEntry.ComputePipelineEntry#pipeline | compute pipeline} should be compiled asynchronously */\n  useAsyncPipeline?: boolean\n  /** Parameters used by this {@link ComputePass} to create a {@link Texture} */\n  texturesOptions?: ExternalTextureParams\n  /** Default {@link ComputeMaterial} work group dispatch size to use with this {@link ComputePass} */\n  dispatchSize?: number | number[]\n}\n\n/**\n * An object defining all possible {@link ComputePass} class instancing parameters\n */\nexport interface ComputePassParams extends Partial<ComputePassOptions>, MaterialParams {}\n\nlet computePassIndex = 0\n\n/**\n * Used to create a {@link ComputePass}, i.e. run computations on the GPU.<br>\n * A {@link ComputePass} is basically a wrapper around a {@link ComputeMaterial} that handles most of the process.\n *\n * The default render behaviour of a {@link ComputePass} is to set its {@link core/bindGroups/BindGroup.BindGroup | bind groups} and then dispatch the workgroups based on the provided {@link ComputeMaterial#dispatchSize | dispatchSize}.<br>\n * However, most of the time you'd want a slightly more complex behaviour. The {@link ComputePass#useCustomRender | `useCustomRender` hook} lets you define a totally custom behaviour, but you'll have to set all the {@link core/bindGroups/BindGroup.BindGroup | bind groups} and dispatch the workgroups by yourself.\n *\n * @example\n * ```javascript\n * // set our main GPUCurtains instance\n * const gpuCurtains = new GPUCurtains({\n *   container: '#canvas' // selector of our WebGPU canvas container\n * })\n *\n * // set the GPU device\n * // note this is asynchronous\n * await gpuCurtains.setDevice()\n *\n * // let's assume we are going to compute the positions of 100.000 particles\n * const nbParticles = 100_000\n *\n * const computePass = new ComputePass(gpuCurtains, {\n *   label: 'My compute pass',\n *   shaders: {\n *     compute: {\n *       code: computeShaderCode, // assume it is a valid WGSL compute shader\n *     },\n *   },\n *   dispatchSize: Math.ceil(nbParticles / 64),\n *   storages: {\n *     particles: {\n *       access: 'read_write',\n *       struct: {\n *         position: {\n *           type: 'array<vec4f>',\n *           value: new Float32Array(nbParticles * 4),\n *         },\n *       },\n *     },\n *   },\n * })\n * ```\n */\nexport class ComputePass {\n  /** The type of the {@link ComputePass} */\n  type: string\n  /** The universal unique id of the {@link ComputePass} */\n  uuid: string\n  /** The index of the {@link ComputePass}, incremented each time a new one is instanced */\n  index: number\n  /** The {@link Renderer} used */\n  renderer: Renderer\n  /** Controls the order in which this {@link ComputePass} should be rendered by our {@link core/scenes/Scene.Scene | Scene} */\n  renderOrder: number\n\n  /** Options used to create this {@link ComputePass} */\n  options: ComputePassOptions\n\n  /** {@link ComputeMaterial} used by this {@link ComputePass} */\n  material: ComputeMaterial\n\n  /** Flag indicating whether this {@link ComputePass} is ready to be rendered */\n  _ready: boolean\n\n  /** Empty object to store any additional data or custom properties into your {@link ComputePass} */\n  userData: Record<string, unknown>\n\n  /**\n   * Whether this {@link ComputePass} should be added to our {@link core/scenes/Scene.Scene | Scene} to let it handle the rendering process automatically\n   * @private\n   */\n  #autoRender = true\n\n  // callbacks / events\n  /** function assigned to the {@link onReady} callback */\n  _onReadyCallback: () => void = () => {\n    /* allow empty callback */\n  }\n  /** function assigned to the {@link onBeforeRender} callback */\n  _onBeforeRenderCallback: () => void = () => {\n    /* allow empty callback */\n  }\n  /** function assigned to the {@link onRender} callback */\n  _onRenderCallback: () => void = () => {\n    /* allow empty callback */\n  }\n  /** function assigned to the {@link onAfterRender} callback */\n  _onAfterRenderCallback: () => void = () => {\n    /* allow empty callback */\n  }\n  /** function assigned to the {@link onAfterResize} callback */\n  _onAfterResizeCallback: () => void = () => {\n    /* allow empty callback */\n  }\n\n  /**\n   * ComputePass constructor\n   * @param renderer - a {@link Renderer} class object or a {@link GPUCurtains} class object\n   * @param parameters - {@link ComputePassParams | parameters} used to create our {@link ComputePass}\n   */\n  constructor(renderer: Renderer | GPUCurtains, parameters: ComputePassParams = {}) {\n    const type = 'ComputePass'\n\n    // we could pass our curtains object OR our curtains renderer object\n    renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as Renderer)\n\n    isRenderer(renderer, parameters.label ? `${parameters.label} ${type}` : type)\n\n    parameters.label = parameters.label ?? 'ComputePass ' + renderer.computePasses?.length\n\n    this.renderer = renderer\n    this.type = type\n    this.uuid = generateUUID()\n    Object.defineProperty(this as ComputePass, 'index', { value: computePassIndex++ })\n\n    const {\n      label,\n      shaders,\n      renderOrder,\n      uniforms,\n      storages,\n      bindGroups,\n      samplers,\n      textures,\n      renderTextures,\n      autoRender,\n      useAsyncPipeline,\n      texturesOptions,\n      dispatchSize,\n    } = parameters\n\n    this.options = {\n      label,\n      shaders,\n      ...(autoRender !== undefined && { autoRender }),\n      ...(renderOrder !== undefined && { renderOrder }),\n      ...(dispatchSize !== undefined && { dispatchSize }),\n      useAsyncPipeline: useAsyncPipeline === undefined ? true : useAsyncPipeline,\n      texturesOptions, // TODO default\n    }\n\n    this.renderOrder = renderOrder ?? 0\n\n    if (autoRender !== undefined) {\n      this.#autoRender = autoRender\n    }\n\n    this.userData = {}\n\n    this.ready = false\n\n    this.setComputeMaterial({\n      label: this.options.label,\n      shaders: this.options.shaders,\n      uniforms,\n      storages,\n      bindGroups,\n      samplers,\n      textures,\n      renderTextures,\n      useAsyncPipeline,\n      dispatchSize,\n    })\n\n    this.addToScene()\n  }\n\n  /**\n   * Get or set whether the compute pass is ready to render (the material has been successfully compiled)\n   * @readonly\n   */\n  get ready(): boolean {\n    return this._ready\n  }\n\n  set ready(value: boolean) {\n    if (value) {\n      this._onReadyCallback && this._onReadyCallback()\n    }\n    this._ready = value\n  }\n\n  /**\n   * Add our compute pass to the scene and the renderer\n   */\n  addToScene() {\n    this.renderer.computePasses.push(this)\n\n    if (this.#autoRender) {\n      this.renderer.scene.addComputePass(this)\n    }\n  }\n\n  /**\n   * Remove our compute pass from the scene and the renderer\n   */\n  removeFromScene() {\n    if (this.#autoRender) {\n      this.renderer.scene.removeComputePass(this)\n    }\n\n    this.renderer.computePasses = this.renderer.computePasses.filter((computePass) => computePass.uuid !== this.uuid)\n  }\n\n  /**\n   * Create the compute pass material\n   * @param computeParameters - {@link ComputeMaterial} parameters\n   */\n  setComputeMaterial(computeParameters: ComputeMaterialParams) {\n    this.material = new ComputeMaterial(this.renderer, computeParameters)\n  }\n\n  /**\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been lost to prepare everything for restoration.\n   * Basically set all the {@link GPUBuffer} to null so they will be reset next time we try to render\n   */\n  loseContext() {\n    this.material.loseContext()\n  }\n\n  /**\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been restored\n   */\n  restoreContext() {\n    this.material.restoreContext()\n  }\n\n  /* TEXTURES */\n\n  /**\n   * Get our {@link ComputeMaterial#textures | ComputeMaterial textures array}\n   * @readonly\n   */\n  get textures(): Texture[] {\n    return this.material?.textures || []\n  }\n\n  /**\n   * Get our {@link ComputeMaterial#renderTextures | ComputeMaterial render textures array}\n   * @readonly\n   */\n  get renderTextures(): RenderTexture[] {\n    return this.material?.renderTextures || []\n  }\n\n  /**\n   * Create a new {@link Texture}\n   * @param options - {@link TextureParams | Texture parameters}\n   * @returns - newly created {@link Texture}\n   */\n  createTexture(options: TextureParams): Texture {\n    if (!options.name) {\n      options.name = 'texture' + this.textures.length\n    }\n\n    if (!options.label) {\n      options.label = this.options.label + ' ' + options.name\n    }\n\n    const texture = new Texture(this.renderer, { ...options, ...this.options.texturesOptions })\n\n    this.addTexture(texture)\n\n    return texture\n  }\n\n  /**\n   * Add a {@link Texture}\n   * @param texture - {@link Texture} to add\n   */\n  addTexture(texture: Texture) {\n    this.material.addTexture(texture)\n  }\n\n  /**\n   * Create a new {@link RenderTexture}\n   * @param  options - {@link RenderTextureParams | RenderTexture parameters}\n   * @returns - newly created {@link RenderTexture}\n   */\n  createRenderTexture(options: RenderTextureParams): RenderTexture {\n    if (!options.name) {\n      options.name = 'renderTexture' + this.renderTextures.length\n    }\n\n    const renderTexture = new RenderTexture(this.renderer, options)\n\n    this.addRenderTexture(renderTexture)\n\n    return renderTexture\n  }\n\n  /**\n   * Add a {@link RenderTexture}\n   * @param renderTexture - {@link RenderTexture} to add\n   */\n  addRenderTexture(renderTexture: RenderTexture) {\n    this.material.addTexture(renderTexture)\n  }\n\n  /**\n   * Get our {@link ComputeMaterial#uniforms | ComputeMaterial uniforms}\n   * @readonly\n   */\n  get uniforms(): ComputeMaterial['uniforms'] {\n    return this.material?.uniforms\n  }\n\n  /**\n   * Get our {@link ComputeMaterial#storages | ComputeMaterial storages}\n   * @readonly\n   */\n  get storages(): ComputeMaterial['storages'] {\n    return this.material?.storages\n  }\n\n  /**\n   * Called from the renderer, useful to trigger an after resize callback.\n   */\n  resize() {\n    this._onAfterResizeCallback && this._onAfterResizeCallback()\n  }\n\n  /** EVENTS **/\n\n  /**\n   * Callback to run when the {@link ComputePass} is ready\n   * @param callback - callback to run when {@link ComputePass} is ready\n   */\n  onReady(callback: () => void): ComputePass {\n    if (callback) {\n      this._onReadyCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Callback to run before the {@link ComputePass} is rendered\n   * @param callback - callback to run just before {@link ComputePass} will be rendered\n   */\n  onBeforeRender(callback: () => void): ComputePass {\n    if (callback) {\n      this._onBeforeRenderCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Callback to run when the {@link ComputePass} is rendered\n   * @param callback - callback to run when {@link ComputePass} is rendered\n   */\n  onRender(callback: () => void): ComputePass {\n    if (callback) {\n      this._onRenderCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Callback to run after the {@link ComputePass} has been rendered\n   * @param callback - callback to run just after {@link ComputePass} has been rendered\n   */\n  onAfterRender(callback: () => void): ComputePass {\n    if (callback) {\n      this._onAfterRenderCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Callback used to run a custom render function instead of the default one.\n   * @param callback - Your custom render function where you will have to set all the {@link core/bindGroups/BindGroup.BindGroup | bind groups} and dispatch the workgroups by yourself.\n   */\n  useCustomRender(callback: (pass: GPUComputePassEncoder) => void): ComputePass {\n    this.material.useCustomRender(callback)\n    return this\n  }\n\n  /**\n   * Callback to run after the {@link core/renderers/GPURenderer.GPURenderer | renderer} has been resized\n   * @param callback - callback to run just after {@link core/renderers/GPURenderer.GPURenderer | renderer} has been resized\n   */\n  onAfterResize(callback: () => void): ComputePass {\n    if (callback) {\n      this._onAfterResizeCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Called before rendering the ComputePass\n   * Checks if the material is ready and eventually update its struct\n   */\n  onBeforeRenderPass() {\n    if (!this.renderer.ready) return\n\n    if (this.material && this.material.ready && !this.ready) {\n      this.ready = true\n    }\n\n    this._onBeforeRenderCallback && this._onBeforeRenderCallback()\n\n    this.material.onBeforeRender()\n  }\n\n  /**\n   * Render our {@link ComputeMaterial}\n   * @param pass - current compute pass encoder\n   */\n  onRenderPass(pass: GPUComputePassEncoder) {\n    if (!this.material.ready) return\n\n    this._onRenderCallback && this._onRenderCallback()\n\n    this.material.render(pass)\n  }\n\n  /**\n   * Called after having rendered the ComputePass\n   */\n  onAfterRenderPass() {\n    this._onAfterRenderCallback && this._onAfterRenderCallback()\n  }\n\n  /**\n   * Render our compute pass\n   * Basically just check if our {@link core/renderers/GPURenderer.GPURenderer | renderer} is ready, and then render our {@link ComputeMaterial}\n   * @param pass\n   */\n  render(pass: GPUComputePassEncoder) {\n    this.onBeforeRenderPass()\n\n    // no point to render if the WebGPU device is not ready\n    if (!this.renderer.ready) return\n\n    !this.renderer.production && pass.pushDebugGroup(this.options.label)\n\n    this.onRenderPass(pass)\n\n    !this.renderer.production && pass.popDebugGroup()\n\n    this.onAfterRenderPass()\n  }\n\n  /**\n   * Copy the result of our read/write GPUBuffer into our result binding array\n   * @param commandEncoder - current GPU command encoder\n   */\n  copyBufferToResult(commandEncoder: GPUCommandEncoder) {\n    this.material?.copyBufferToResult(commandEncoder)\n  }\n\n  /**\n   * Get the {@link core/bindings/WritableBufferBinding.WritableBufferBinding#resultBuffer | result GPU buffer} content by {@link core/bindings/WritableBufferBinding.WritableBufferBinding | binding} and {@link core/bindings/bufferElements/BufferElement.BufferElement | buffer element} names\n   * @param parameters - parameters used to get the result\n   * @param parameters.bindingName - {@link core/bindings/WritableBufferBinding.WritableBufferBinding#name | binding name} from which to get the result\n   * @param parameters.bufferElementName - optional {@link core/bindings/bufferElements/BufferElement.BufferElement | buffer element} (i.e. struct member) name if the result needs to be restrained to only one element\n   * @async\n   * @returns - the mapped content of the {@link GPUBuffer} as a {@link Float32Array}\n   */\n  async getComputeResult({\n    bindingName,\n    bufferElementName,\n  }: {\n    bindingName?: string\n    bufferElementName?: string\n  }): Promise<Float32Array> {\n    return await this.material?.getComputeResult({ bindingName, bufferElementName })\n  }\n\n  /**\n   * Remove the ComputePass from the scene and destroy it\n   */\n  remove() {\n    this.removeFromScene()\n    this.destroy()\n  }\n\n  /**\n   * Destroy the ComputePass\n   */\n  destroy() {\n    this.material?.destroy()\n  }\n}\n"],"names":[],"mappings":"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"}