{"version":3,"file":"ComputePipelineEntry.mjs","sources":["../../../../src/core/pipelines/ComputePipelineEntry.ts"],"sourcesContent":["import { PipelineEntry } from './PipelineEntry'\nimport { isRenderer, Renderer } from '../renderers/utils'\nimport { throwError } from '../../utils/utils'\nimport { PipelineEntryParams, PipelineEntryPropertiesParams, PipelineEntryShaders } from '../../types/PipelineEntries'\nimport { BindGroupBufferBindingElement } from '../../types/BindGroups'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\n\n/**\n * Used to create a {@link PipelineEntry} specifically designed to handle {@link core/materials/ComputeMaterial.ComputeMaterial | ComputeMaterial}.\n *\n * ## Shaders patching\n *\n * The {@link ComputePipelineEntry} uses each of its {@link ComputePipelineEntry#bindGroups | bind groups} {@link core/bindings/Binding.Binding | Binding} to patch the given compute shader before creating the {@link GPUShaderModule}.<br>\n * It will prepend every {@link core/bindings/Binding.Binding | Binding} WGSL code snippets (or fragments) with the correct bind group and bindings indices.\n *\n * ## Pipeline compilation\n *\n * The {@link ComputePipelineEntry} will then create a {@link GPUComputePipeline} (asynchronously by default).\n */\nexport class ComputePipelineEntry extends PipelineEntry {\n  /** Shaders to use with this {@link ComputePipelineEntry} */\n  shaders: PipelineEntryShaders\n  /** {@link GPUComputePipelineDescriptor | Compute pipeline descriptor} based on {@link layout} and {@link shaders} */\n  descriptor: GPUComputePipelineDescriptor | null\n\n  /**\n   * ComputePipelineEntry constructor\n   * @param parameters - {@link PipelineEntryParams | parameters} used to create this {@link ComputePipelineEntry}\n   */\n  constructor(parameters: PipelineEntryParams) {\n    let { renderer } = parameters\n    const { label } = parameters\n\n    // we could pass our curtains object OR our curtains renderer object\n    renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as Renderer)\n\n    const type = 'ComputePipelineEntry'\n\n    isRenderer(renderer, label ? label + ' ' + type : type)\n\n    super(parameters)\n\n    this.type = type\n\n    this.shaders = {\n      compute: {\n        head: '',\n        code: '',\n        module: null,\n      },\n    }\n\n    this.descriptor = null\n  }\n\n  /**\n   * Set {@link ComputePipelineEntry} properties (in this case the {@link bindGroups | bind groups})\n   * @param parameters - the {@link core/materials/ComputeMaterial.ComputeMaterial#bindGroups | bind groups} to use\n   */\n  setPipelineEntryProperties(parameters: PipelineEntryPropertiesParams) {\n    const { bindGroups } = parameters\n\n    this.setPipelineEntryBindGroups(bindGroups)\n  }\n\n  /* SHADERS */\n\n  /**\n   * Patch the shaders by appending all the {@link bindGroups | bind groups}) WGSL code fragments to the given {@link PipelineEntryParams#shaders | parameter shader code}\n   */\n  patchShaders() {\n    this.shaders.compute.head = ''\n    this.shaders.compute.code = ''\n\n    const groupsBindings = []\n    this.bindGroups.forEach((bindGroup) => {\n      let bindIndex = 0\n      bindGroup.bindings.forEach((binding, bindingIndex) => {\n        binding.wgslGroupFragment.forEach((groupFragment, groupFragmentIndex) => {\n          groupsBindings.push({\n            groupIndex: bindGroup.index,\n            visibility: binding.visibility,\n            bindIndex,\n            wgslStructFragment: (binding as BindGroupBufferBindingElement).wgslStructFragment,\n            wgslGroupFragment: groupFragment,\n            newLine:\n              bindingIndex === bindGroup.bindings.length - 1 &&\n              groupFragmentIndex === binding.wgslGroupFragment.length - 1,\n          })\n\n          bindIndex++\n        })\n      })\n    })\n\n    groupsBindings.forEach((groupBinding) => {\n      // do not duplicate structs\n      if (\n        groupBinding.wgslStructFragment &&\n        this.shaders.compute.head.indexOf(groupBinding.wgslStructFragment) === -1\n      ) {\n        this.shaders.compute.head = `\\n${groupBinding.wgslStructFragment}\\n${this.shaders.compute.head}`\n      }\n\n      // do not duplicate struct var as well\n      if (this.shaders.compute.head.indexOf(groupBinding.wgslGroupFragment) === -1) {\n        this.shaders.compute.head = `${this.shaders.compute.head}\\n@group(${groupBinding.groupIndex}) @binding(${groupBinding.bindIndex}) ${groupBinding.wgslGroupFragment}`\n      }\n\n      if (groupBinding.newLine) this.shaders.compute.head += `\\n`\n    })\n\n    this.shaders.compute.code = this.shaders.compute.head + this.options.shaders.compute.code\n  }\n\n  /* SETUP */\n\n  /**\n   * Create the {@link shaders}: patch them and create the {@link GPUShaderModule}\n   */\n  createShaders() {\n    this.patchShaders()\n\n    this.shaders.compute.module = this.createShaderModule({\n      code: this.shaders.compute.code,\n      type: 'compute',\n    })\n  }\n\n  /**\n   * Create the compute pipeline {@link descriptor}\n   */\n  createPipelineDescriptor() {\n    if (!this.shaders.compute.module) return\n\n    this.descriptor = {\n      label: this.options.label,\n      layout: this.layout,\n      compute: {\n        module: this.shaders.compute.module,\n        entryPoint: this.options.shaders.compute.entryPoint,\n      },\n    }\n  }\n\n  /**\n   * Create the compute {@link pipeline}\n   */\n  createComputePipeline() {\n    if (!this.shaders.compute.module) return\n\n    try {\n      this.pipeline = this.renderer.createComputePipeline(this.descriptor)\n    } catch (error) {\n      this.status.error = error\n      throwError(error)\n    }\n  }\n\n  /**\n   * Asynchronously create the compute {@link pipeline}\n   * @async\n   * @returns - void promise result\n   */\n  async createComputePipelineAsync(): Promise<void> {\n    if (!this.shaders.compute.module) return\n\n    try {\n      this.pipeline = await this.renderer.createComputePipelineAsync(this.descriptor)\n      this.status.compiled = true\n      this.status.compiling = false\n      this.status.error = null\n    } catch (error) {\n      this.status.error = error\n      throwError(error)\n    }\n  }\n\n  /**\n   * Call {@link PipelineEntry#compilePipelineEntry | PipelineEntry compilePipelineEntry} method, then create our compute {@link pipeline}\n   * @async\n   */\n  async compilePipelineEntry(): Promise<void> {\n    super.compilePipelineEntry()\n\n    if (this.options.useAsync) {\n      await this.createComputePipelineAsync()\n    } else {\n      this.createComputePipeline()\n      this.status.compiled = true\n      this.status.compiling = false\n      this.status.error = null\n    }\n  }\n}\n"],"names":[],"mappings":"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"}