{"version":3,"file":"PipelineManager.mjs","sources":["../../../../src/core/pipelines/PipelineManager.ts"],"sourcesContent":["import { RenderPipelineEntry } from './RenderPipelineEntry'\nimport { ComputePipelineEntry } from './ComputePipelineEntry'\nimport { PipelineEntryParams, RenderPipelineEntryParams } from '../../types/PipelineEntries'\nimport { ShaderOptions } from '../../types/Materials'\n\n/** Defines all types of allowed {@link core/pipelines/PipelineEntry.PipelineEntry | PipelineEntry} class objects */\nexport type AllowedPipelineEntries = RenderPipelineEntry | ComputePipelineEntry\n\n/**\n * Used to create and keep track of both {@link ComputePipelineEntry} and {@link RenderPipelineEntry}.<br>\n * Perform checks to eventually use a cached pipeline entry instead of creating a new one.<br>\n * The end goal is to cache pipelines and reuse them (as well as bind groups).<br>\n * Also responsible for setting the current pass encoder pipeline in order to avoid redundant setPipeline calls.<br>\n * Created internally by the {@link core/renderers/GPUDeviceManager.GPUDeviceManager | GPUDeviceManager}.<br>\n * @see {@link https://toji.dev/webgpu-best-practices/bind-groups#grouping-resources-based-on-frequency-of-change | WebGPU Bind Group best practices}\n */\nexport class PipelineManager {\n  /** The type of the {@link PipelineManager} */\n  type: string\n  /** Keep track of the current bound pipeline in order to avoid redundant setPipeline calls */\n  currentPipelineIndex: number | null\n  /** Array of already created {@link ComputePipelineEntry} and {@link RenderPipelineEntry} */\n  pipelineEntries: AllowedPipelineEntries[]\n\n  constructor() {\n    this.type = 'PipelineManager'\n\n    this.currentPipelineIndex = null\n    this.pipelineEntries = []\n  }\n\n  /**\n   * Compare two {@link ShaderOptions | shader objects}\n   * @param shaderA - first {@link ShaderOptions | shader object} to compare\n   * @param shaderB - second {@link ShaderOptions | shader object} to compare\n   * @returns - whether the two {@link ShaderOptions | shader objects} code and entryPoint match\n   */\n  compareShaders(shaderA: ShaderOptions, shaderB: ShaderOptions): boolean {\n    return shaderA.code?.localeCompare(shaderB.code) === 0 && shaderA.entryPoint === shaderB.entryPoint\n  }\n\n  /**\n   * Checks if the provided {@link RenderPipelineEntryParams | RenderPipelineEntry parameters} belongs to an already created {@link RenderPipelineEntry}.\n   * @param parameters - {@link RenderPipelineEntryParams | RenderPipelineEntry parameters}\n   * @returns - the found {@link RenderPipelineEntry}, or null if not found\n   */\n  isSameRenderPipeline(parameters: RenderPipelineEntryParams): RenderPipelineEntry | null {\n    return this.pipelineEntries\n      .filter((pipelineEntry) => pipelineEntry instanceof RenderPipelineEntry)\n      .find((pipelineEntry: RenderPipelineEntry) => {\n        const { options } = pipelineEntry\n        const { shaders, rendering } = parameters\n\n        const sameVertexShader = this.compareShaders(shaders.vertex, options.shaders.vertex)\n        const sameFragmentShader =\n          (!shaders.fragment && !options.shaders.fragment) ||\n          this.compareShaders(shaders.fragment as ShaderOptions, options.shaders.fragment as ShaderOptions)\n\n        const differentParams = Object.keys(options.rendering).filter(\n          (key) => options.rendering[key] !== rendering[key]\n        )\n\n        // TODO might break with unused bindings!\n\n        return !differentParams.length && sameVertexShader && sameFragmentShader\n      }) as RenderPipelineEntry | null\n  }\n\n  /**\n   * Check if a {@link RenderPipelineEntry} has already been created with the given {@link RenderPipelineEntryParams | parameters}.\n   * Use it if found, else create a new one and add it to the {@link pipelineEntries} array.\n   * @param parameters - {@link RenderPipelineEntryParams | RenderPipelineEntry parameters}\n   * @returns - {@link RenderPipelineEntry}, either from cache or newly created\n   */\n  createRenderPipeline(parameters: RenderPipelineEntryParams): RenderPipelineEntry {\n    const existingPipelineEntry = this.isSameRenderPipeline(parameters)\n\n    if (existingPipelineEntry) {\n      return existingPipelineEntry\n    } else {\n      const pipelineEntry = new RenderPipelineEntry(parameters)\n\n      this.pipelineEntries.push(pipelineEntry)\n\n      return pipelineEntry\n    }\n  }\n\n  /**\n   * Checks if the provided {@link PipelineEntryParams | parameters} belongs to an already created {@link ComputePipelineEntry}.\n   * @param parameters - {@link PipelineEntryParams | PipelineEntry parameters}\n   * @returns - the found {@link ComputePipelineEntry}, or null if not found\n   */\n  isSameComputePipeline(parameters: PipelineEntryParams) {\n    const { shaders } = parameters\n\n    return this.pipelineEntries\n      .filter((pipelineEntry) => pipelineEntry instanceof ComputePipelineEntry)\n      .find((pipelineEntry: ComputePipelineEntry) => {\n        const { options } = pipelineEntry\n\n        return this.compareShaders(shaders.compute, options.shaders.compute)\n      }) as ComputePipelineEntry | null\n  }\n\n  /**\n   * Check if a {@link ComputePipelineEntry} has already been created with the given {@link PipelineEntryParams | parameters}.\n   * Use it if found, else create a new one and add it to the {@link pipelineEntries} array.\n   * @param parameters - {@link PipelineEntryParams | PipelineEntry parameters}\n   * @returns - newly created {@link ComputePipelineEntry}\n   */\n  createComputePipeline(parameters: PipelineEntryParams): ComputePipelineEntry {\n    const existingPipelineEntry = this.isSameComputePipeline(parameters)\n\n    if (existingPipelineEntry) {\n      return existingPipelineEntry\n    } else {\n      const pipelineEntry = new ComputePipelineEntry(parameters)\n\n      this.pipelineEntries.push(pipelineEntry)\n\n      return pipelineEntry\n    }\n  }\n\n  /**\n   * Check if the given {@link AllowedPipelineEntries | PipelineEntry} is already set, if not set it\n   * @param pass - current pass encoder\n   * @param pipelineEntry - the {@link AllowedPipelineEntries | PipelineEntry} to set\n   */\n  setCurrentPipeline(pass: GPURenderPassEncoder | GPUComputePassEncoder, pipelineEntry: AllowedPipelineEntries) {\n    if (pipelineEntry.index !== this.currentPipelineIndex) {\n      pass.setPipeline(pipelineEntry.pipeline as GPURenderPipeline & GPUComputePipeline)\n      this.currentPipelineIndex = pipelineEntry.index\n    }\n  }\n\n  /**\n   * Reset the {@link PipelineManager#currentPipelineIndex | current pipeline index} so the next {@link AllowedPipelineEntries | PipelineEntry} will be set for sure\n   */\n  resetCurrentPipeline() {\n    this.currentPipelineIndex = null\n  }\n}\n"],"names":[],"mappings":"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"}