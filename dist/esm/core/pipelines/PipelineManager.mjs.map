{"version":3,"file":"PipelineManager.mjs","sources":["../../../../src/core/pipelines/PipelineManager.ts"],"sourcesContent":["import { RenderPipelineEntry } from './RenderPipelineEntry'\nimport { ComputePipelineEntry } from './ComputePipelineEntry'\nimport {\n  PipelineEntryParams,\n  RenderPipelineEntryBaseParams,\n  RenderPipelineEntryParams,\n} from '../../types/PipelineEntries'\nimport { ShaderOptions } from '../../types/Materials'\n\n/** Defines all types of allowed {@link core/pipelines/PipelineEntry.PipelineEntry | PipelineEntry} class objects */\nexport type AllowedPipelineEntries = RenderPipelineEntry | ComputePipelineEntry\n\n/**\n * Used to create and keep track of both {@link ComputePipelineEntry} and {@link RenderPipelineEntry}.<br>\n * Perform checks to eventually use a cached pipeline entry instead of creating a new one.<br>\n * The end goal is to cache pipelines and reuse them (as well as bind groups).<br>\n * Also responsible for setting the current pass encoder pipeline in order to avoid redundant setPipeline calls.<br>\n * Created internally by the {@link core/renderers/GPUDeviceManager.GPUDeviceManager | GPUDeviceManager}.<br>\n * @see {@link https://toji.dev/webgpu-best-practices/bind-groups#grouping-resources-based-on-frequency-of-change | WebGPU Bind Group best practices}\n */\nexport class PipelineManager {\n  /** The type of the {@link PipelineManager} */\n  type: string\n  /** Keep track of the current bound pipeline in order to avoid redundant setPipeline calls */\n  currentPipelineIndex: number | null\n  /** Array of already created {@link ComputePipelineEntry} and {@link RenderPipelineEntry} */\n  pipelineEntries: AllowedPipelineEntries[]\n\n  constructor() {\n    this.type = 'PipelineManager'\n\n    this.currentPipelineIndex = null\n    this.pipelineEntries = []\n  }\n\n  /**\n   * Checks if the provided {@link RenderPipelineEntryBaseParams | RenderPipelineEntry parameters} belongs to an already created {@link RenderPipelineEntry}.\n   * @param parameters - {@link RenderPipelineEntryBaseParams | RenderPipelineEntry parameters}\n   * @returns - the found {@link RenderPipelineEntry}, or null if not found\n   */\n  isSameRenderPipeline(parameters: RenderPipelineEntryBaseParams): RenderPipelineEntry | null {\n    const {\n      shaders,\n      cullMode,\n      depth,\n      depthWriteEnabled,\n      depthCompare,\n      transparent,\n      verticesOrder,\n      topology,\n      sampleCount,\n    } = parameters\n\n    return this.pipelineEntries\n      .filter((pipelineEntry) => pipelineEntry instanceof RenderPipelineEntry)\n      .find((pipelineEntry: RenderPipelineEntry) => {\n        const { options } = pipelineEntry\n\n        // TODO ugly :(\n\n        const sameFragmentShader =\n          (!shaders.fragment && !options.shaders.fragment) ||\n          ((shaders.fragment as ShaderOptions).code?.localeCompare((options.shaders.fragment as ShaderOptions).code) ===\n            0 &&\n            (shaders.fragment as ShaderOptions).entryPoint === (options.shaders.fragment as ShaderOptions).entryPoint)\n\n        return (\n          shaders.vertex.code.localeCompare(options.shaders.vertex.code) === 0 &&\n          shaders.vertex.entryPoint === options.shaders.vertex.entryPoint &&\n          sameFragmentShader &&\n          cullMode === options.cullMode &&\n          depth === options.depth &&\n          depthWriteEnabled === options.depthWriteEnabled &&\n          depthCompare === options.depthCompare &&\n          transparent === options.transparent &&\n          sampleCount === options.sampleCount &&\n          verticesOrder === options.verticesOrder &&\n          topology === options.topology\n        )\n      }) as RenderPipelineEntry | null\n  }\n\n  /**\n   * Check if a {@link RenderPipelineEntry} has already been created with the given {@link RenderPipelineEntryParams | parameters}.\n   * Use it if found, else create a new one and add it to the {@link pipelineEntries} array.\n   * @param parameters - {@link RenderPipelineEntryParams | RenderPipelineEntry parameters}\n   * @returns - {@link RenderPipelineEntry}, either from cache or newly created\n   */\n  createRenderPipeline(parameters: RenderPipelineEntryParams): RenderPipelineEntry {\n    const existingPipelineEntry = this.isSameRenderPipeline(parameters)\n\n    if (existingPipelineEntry) {\n      return existingPipelineEntry\n    } else {\n      const pipelineEntry = new RenderPipelineEntry(parameters)\n\n      this.pipelineEntries.push(pipelineEntry)\n\n      return pipelineEntry\n    }\n  }\n\n  /**\n   * Checks if the provided {@link PipelineEntryParams | parameters} belongs to an already created {@link ComputePipelineEntry}.\n   * @param parameters - {@link PipelineEntryParams | PipelineEntry parameters}\n   * @returns - the found {@link ComputePipelineEntry}, or null if not found\n   */\n  isSameComputePipeline(parameters: PipelineEntryParams) {\n    const { shaders } = parameters\n\n    return this.pipelineEntries\n      .filter((pipelineEntry) => pipelineEntry instanceof ComputePipelineEntry)\n      .find((pipelineEntry: ComputePipelineEntry) => {\n        const { options } = pipelineEntry\n\n        return (\n          shaders.compute.code.localeCompare(options.shaders.compute.code) === 0 &&\n          shaders.compute.entryPoint === options.shaders.compute.entryPoint\n        )\n      }) as ComputePipelineEntry | null\n  }\n\n  /**\n   * Check if a {@link ComputePipelineEntry} has already been created with the given {@link PipelineEntryParams | parameters}.\n   * Use it if found, else create a new one and add it to the {@link pipelineEntries} array.\n   * @param parameters - {@link PipelineEntryParams | PipelineEntry parameters}\n   * @returns - newly created {@link ComputePipelineEntry}\n   */\n  createComputePipeline(parameters: PipelineEntryParams): ComputePipelineEntry {\n    const existingPipelineEntry = this.isSameComputePipeline(parameters)\n\n    if (existingPipelineEntry) {\n      return existingPipelineEntry\n    } else {\n      const pipelineEntry = new ComputePipelineEntry(parameters)\n\n      this.pipelineEntries.push(pipelineEntry)\n\n      return pipelineEntry\n    }\n  }\n\n  /**\n   * Check if the given {@link AllowedPipelineEntries | PipelineEntry} is already set, if not set it\n   * @param pass - current pass encoder\n   * @param pipelineEntry - the {@link AllowedPipelineEntries | PipelineEntry} to set\n   */\n  setCurrentPipeline(pass: GPURenderPassEncoder | GPUComputePassEncoder, pipelineEntry: AllowedPipelineEntries) {\n    if (pipelineEntry.index !== this.currentPipelineIndex) {\n      pass.setPipeline(pipelineEntry.pipeline as GPURenderPipeline & GPUComputePipeline)\n      this.currentPipelineIndex = pipelineEntry.index\n    }\n  }\n\n  /**\n   * Reset the {@link PipelineManager#currentPipelineIndex | current pipeline index} so the next {@link AllowedPipelineEntries | PipelineEntry} will be set for sure\n   */\n  resetCurrentPipeline() {\n    this.currentPipelineIndex = null\n  }\n}\n"],"names":[],"mappings":"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"}