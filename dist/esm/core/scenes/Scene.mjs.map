{"version":3,"file":"Scene.mjs","sources":["../../../../src/core/scenes/Scene.ts"],"sourcesContent":["import { CameraRenderer, isRenderer, Renderer } from '../renderers/utils'\r\nimport { DOMProjectedMesh, ProjectedMesh, RenderedMesh } from '../renderers/GPURenderer'\r\nimport { ShaderPass } from '../renderPasses/ShaderPass'\r\nimport { PingPongPlane } from '../../curtains/meshes/PingPongPlane'\r\nimport { ComputePass } from '../computePasses/ComputePass'\r\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\r\nimport { RenderTarget } from '../renderPasses/RenderTarget'\r\nimport { DOMMesh } from '../../curtains/meshes/DOMMesh'\r\nimport { Plane } from '../../curtains/meshes/Plane'\r\nimport { RenderPass } from '../renderPasses/RenderPass'\r\nimport { RenderTexture } from '../textures/RenderTexture'\r\n\r\n/**\r\n * Meshes rendering order is dependant of their transparency setting\r\n */\r\nexport interface ProjectionStack {\r\n  /** opaque Meshes will be drawn first */\r\n  opaque: ProjectedMesh[]\r\n  /** transparent Meshes will be drawn last */\r\n  transparent: ProjectedMesh[]\r\n}\r\n\r\n/** Meshes will be stacked in 2 different objects whether they are projected (use a {@link core/camera/Camera.Camera | Camera}) or not */\r\nexport type ProjectionType = 'unProjected' | 'projected'\r\n\r\n/**\r\n * Meshes will be put into two stacks of projected/unprojected transparent and opaques meshes arrays\r\n */\r\nexport type Stack = Record<ProjectionType, ProjectionStack>\r\n\r\n/**\r\n * A RenderPassEntry object is used to group Meshes based on their rendering target\r\n */\r\nexport interface RenderPassEntry {\r\n  /** {@link RenderPass} target used onto which render */\r\n  renderPass: RenderPass\r\n  /** {@link RenderTexture} to render to if any (if not specified then this {@link RenderPassEntry} Meshes will be rendered directly to screen) */\r\n  renderTexture: RenderTexture | null\r\n  /** Optional function to execute just before rendering the Meshes, useful for eventual texture copy */\r\n  onBeforeRenderPass: ((commandEncoder?: GPUCommandEncoder, swapChainTexture?: GPUTexture) => void) | null\r\n  /** Optional function to execute just after rendering the Meshes, useful for eventual texture copy */\r\n  onAfterRenderPass: ((commandEncoder?: GPUCommandEncoder, swapChainTexture?: GPUTexture) => void) | null\r\n  /** If this {@link RenderPassEntry} needs to render only one Mesh */\r\n  element: PingPongPlane | ShaderPass | null\r\n  /** If this {@link RenderPassEntry} needs to render multiple Meshes, then use a {@link Stack} object */\r\n  stack: Stack | null\r\n}\r\n\r\n/** Defines all our possible render targets */\r\nexport type RenderPassEntriesType = 'pingPong' | 'renderTarget' | 'screen'\r\n/** Defines our render pass entries object */\r\nexport type RenderPassEntries = Record<RenderPassEntriesType, RenderPassEntry[]>\r\n\r\n/**\r\n * Used to by the {@link Renderer} render everything that needs to be rendered (compute passes and meshes) in the right order with the right pass descriptors and target textures, perform textures copy at the right time, etc.\r\n *\r\n * ## Render order\r\n *\r\n * - Run all the {@link ComputePass} first, sorted by their {@link ComputePass#renderOrder | renderOrder}\r\n * - Then render all {@link renderPassEntries} pingPong entries Meshes, sorted by their {@link PingPongPlane#renderOrder | renderOrder}\r\n * - Then all Meshes that need to be rendered into specific {@link renderPassEntries} outputTarget entries:\r\n *   - First, the opaque unprojected Meshes (i.e. opaque {@link core/meshes/FullscreenPlane.FullscreenPlane | FullscreenPlane}, if any), sorted by their {@link core/meshes/FullscreenPlane.FullscreenPlane#renderOrder | renderOrder}\r\n *   - Then, the transparent unprojected Meshes (i.e. transparent {@link core/meshes/FullscreenPlane.FullscreenPlane | FullscreenPlane}, if any), sorted by their {@link core/meshes/FullscreenPlane.FullscreenPlane#renderOrder | renderOrder}\r\n *   - Then, the opaque projected Meshes (i.e. opaque {@link core/meshes/Mesh.Mesh | Mesh}, {@link DOMMesh} or {@link Plane}), sorted by their {@link core/meshes/Mesh.Mesh#renderOrder | renderOrder}\r\n *   - Finally, the transparent projected Meshes (i.e. transparent {@link core/meshes/Mesh.Mesh | Mesh}, {@link DOMMesh} or {@link Plane}), sorted by their Z position and then their {@link core/meshes/Mesh.Mesh#renderOrder | renderOrder}\r\n * - Finally all Meshes that need to be rendered directly to the {@link renderPassEntries} screen (the {@link Renderer} current texture), in the same order than above.\r\n */\r\nexport class Scene {\r\n  /** {@link Renderer} used by this {@link Scene} */\r\n  renderer: Renderer\r\n  /** Array of {@link ComputePass} to render, ordered by {@link ComputePass#renderOrder | renderOrder} */\r\n  computePassEntries: ComputePass[]\r\n  /**\r\n   * A {@link RenderPassEntries} object that will contain every Meshes that need to be drawn, put inside each one of our three entries type arrays: 'pingPong', 'outputTarget' and 'screen'.\r\n   * - The {@link Scene} will first render all {@link renderPassEntries} pingPong entries Meshes\r\n   * - Then all Meshes that need to be rendered into specific {@link renderPassEntries} outputTarget entries\r\n   * - Finally all Meshes that need to be rendered to the {@link renderPassEntries} screen\r\n   */\r\n  renderPassEntries: RenderPassEntries\r\n\r\n  /**\r\n   * Scene constructor\r\n   * @param renderer - {@link Renderer} object or {@link GPUCurtains} class object used to create this {@link Scene}\r\n   */\r\n  constructor({ renderer }: { renderer: Renderer | GPUCurtains }) {\r\n    // we could pass our curtains object OR our curtains renderer object\r\n    renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as Renderer)\r\n\r\n    isRenderer(renderer, 'Scene')\r\n\r\n    this.renderer = renderer\r\n\r\n    this.computePassEntries = []\r\n\r\n    this.renderPassEntries = {\r\n      /** Array of {@link RenderPassEntry} that will handle {@link PingPongPlane}. Each {@link PingPongPlane} will be added as a distinct {@link RenderPassEntry} here */\r\n      pingPong: [] as RenderPassEntry[],\r\n      /** Array of {@link RenderPassEntry} that will render to a specific {@link RenderTarget}. Each {@link RenderTarget} will be added as a distinct {@link RenderPassEntry} here */\r\n      renderTarget: [] as RenderPassEntry[],\r\n      /** Array of {@link RenderPassEntry} that will render directly to the screen. Our first entry will contain all the Meshes that do not have any {@link RenderTarget} assigned. Following entries will be created for every global {@link ShaderPass} */\r\n      screen: [\r\n        // add our basic scene entry\r\n        {\r\n          renderPass: this.renderer.renderPass,\r\n          renderTexture: null,\r\n          onBeforeRenderPass: null,\r\n          onAfterRenderPass: null,\r\n          element: null, // explicitly set to null\r\n          stack: {\r\n            unProjected: {\r\n              opaque: [],\r\n              transparent: [],\r\n            },\r\n            projected: {\r\n              opaque: [],\r\n              transparent: [],\r\n            },\r\n          },\r\n        },\r\n      ] as RenderPassEntry[],\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the number of meshes a {@link RenderPassEntry | render pass entry} should draw.\r\n   * @param renderPassEntry - The {@link RenderPassEntry | render pass entry} to test\r\n   */\r\n  getRenderPassEntryLength(renderPassEntry: RenderPassEntry): number {\r\n    if (!renderPassEntry) {\r\n      return 0\r\n    } else {\r\n      return renderPassEntry.element\r\n        ? renderPassEntry.element.visible\r\n          ? 1\r\n          : 0\r\n        : renderPassEntry.stack.unProjected.opaque.length +\r\n            renderPassEntry.stack.unProjected.transparent.length +\r\n            renderPassEntry.stack.projected.opaque.length +\r\n            renderPassEntry.stack.projected.transparent.length\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a {@link ComputePass} to our scene {@link computePassEntries} array\r\n   * @param computePass - {@link ComputePass} to add\r\n   */\r\n  addComputePass(computePass: ComputePass) {\r\n    this.computePassEntries.push(computePass)\r\n    this.computePassEntries.sort((a, b) => {\r\n      if (a.renderOrder !== b.renderOrder) {\r\n        return a.renderOrder - b.renderOrder\r\n      } else {\r\n        return a.index - b.index\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Remove a {@link ComputePass} from our scene {@link computePassEntries} array\r\n   * @param computePass - {@link ComputePass} to remove\r\n   */\r\n  removeComputePass(computePass: ComputePass) {\r\n    this.computePassEntries = this.computePassEntries.filter((cP) => cP.uuid !== computePass.uuid)\r\n  }\r\n\r\n  /**\r\n   * Add a {@link RenderTarget} to our scene {@link renderPassEntries} outputTarget array.\r\n   * Every Meshes later added to this {@link RenderTarget} will be rendered to the {@link RenderTarget#renderTexture | RenderTarget RenderTexture} using the {@link RenderTarget#renderPass.descriptor | RenderTarget RenderPass descriptor}\r\n   * @param renderTarget - {@link RenderTarget} to add\r\n   */\r\n  addRenderTarget(renderTarget: RenderTarget) {\r\n    // if RT is not already in the render pass entries\r\n    if (!this.renderPassEntries.renderTarget.find((entry) => entry.renderPass.uuid === renderTarget.renderPass.uuid))\r\n      this.renderPassEntries.renderTarget.push({\r\n        renderPass: renderTarget.renderPass,\r\n        renderTexture: renderTarget.renderTexture,\r\n        onBeforeRenderPass: null,\r\n        onAfterRenderPass: null,\r\n        element: null, // explicitly set to null\r\n        stack: {\r\n          unProjected: {\r\n            opaque: [],\r\n            transparent: [],\r\n          },\r\n          projected: {\r\n            opaque: [],\r\n            transparent: [],\r\n          },\r\n        },\r\n      } as RenderPassEntry)\r\n  }\r\n\r\n  /**\r\n   * Remove a {@link RenderTarget} from our scene {@link renderPassEntries} outputTarget array.\r\n   * @param renderTarget - {@link RenderTarget} to add\r\n   */\r\n  removeRenderTarget(renderTarget: RenderTarget) {\r\n    this.renderPassEntries.renderTarget = this.renderPassEntries.renderTarget.filter(\r\n      (entry) => entry.renderPass.uuid !== renderTarget.renderPass.uuid\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Get the correct {@link renderPassEntries | render pass entry} (either {@link renderPassEntries} outputTarget or {@link renderPassEntries} screen) {@link Stack} onto which this Mesh should be added, depending on whether it's projected or not\r\n   * @param mesh - Mesh to check\r\n   * @returns - the corresponding render pass entry {@link Stack}\r\n   */\r\n  getMeshProjectionStack(mesh: ProjectedMesh): ProjectionStack {\r\n    // first get correct render pass enty and stack\r\n    const renderPassEntry = mesh.outputTarget\r\n      ? this.renderPassEntries.renderTarget.find(\r\n          (passEntry) => passEntry.renderPass.uuid === mesh.outputTarget.renderPass.uuid\r\n        )\r\n      : this.renderPassEntries.screen[0]\r\n\r\n    const { stack } = renderPassEntry\r\n\r\n    return mesh.material.options.rendering.useProjection ? stack.projected : stack.unProjected\r\n  }\r\n\r\n  /**\r\n   * Add a Mesh to the correct {@link renderPassEntries | render pass entry} {@link Stack} array.\r\n   * Meshes are then ordered by their {@link core/meshes/mixins/MeshBaseMixin.MeshBaseClass#index | indexes (order of creation]}, position along the Z axis in case they are transparent and then {@link core/meshes/mixins/MeshBaseMixin.MeshBaseClass#renderOrder | renderOrder}\r\n   * @param mesh - Mesh to add\r\n   */\r\n  addMesh(mesh: ProjectedMesh) {\r\n    const projectionStack = this.getMeshProjectionStack(mesh)\r\n\r\n    // rebuild stack\r\n    const similarMeshes = mesh.transparent ? [...projectionStack.transparent] : [...projectionStack.opaque]\r\n\r\n    // find if there's already a plane with the same pipeline with a findLastIndex function\r\n    let siblingMeshIndex = -1\r\n\r\n    for (let i = similarMeshes.length - 1; i >= 0; i--) {\r\n      if (similarMeshes[i].material.pipelineEntry.index === mesh.material.pipelineEntry.index) {\r\n        siblingMeshIndex = i + 1\r\n        break\r\n      }\r\n    }\r\n\r\n    // if findIndex returned -1 (no matching pipeline)\r\n    siblingMeshIndex = Math.max(0, siblingMeshIndex)\r\n\r\n    // add it to our stack plane array\r\n    similarMeshes.splice(siblingMeshIndex, 0, mesh)\r\n    similarMeshes.sort((a, b) => a.index - b.index)\r\n\r\n    // sort by Z pos if transparent\r\n    if ((mesh instanceof DOMMesh || mesh instanceof Plane) && mesh.transparent) {\r\n      similarMeshes.sort(\r\n        (a, b) => (b as DOMProjectedMesh).documentPosition.z - (a as DOMProjectedMesh).documentPosition.z\r\n      )\r\n    }\r\n\r\n    // then sort by their render order\r\n    similarMeshes.sort((a, b) => a.renderOrder - b.renderOrder)\r\n\r\n    mesh.transparent ? (projectionStack.transparent = similarMeshes) : (projectionStack.opaque = similarMeshes)\r\n  }\r\n\r\n  /**\r\n   * Remove a Mesh from our {@link Scene}\r\n   * @param mesh - Mesh to remove\r\n   */\r\n  removeMesh(mesh: ProjectedMesh) {\r\n    const projectionStack = this.getMeshProjectionStack(mesh)\r\n\r\n    if (mesh.transparent) {\r\n      projectionStack.transparent = projectionStack.transparent.filter((m) => m.uuid !== mesh.uuid)\r\n    } else {\r\n      projectionStack.opaque = projectionStack.opaque.filter((m) => m.uuid !== mesh.uuid)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a {@link ShaderPass} to our scene {@link renderPassEntries} screen array.\r\n   * Before rendering the {@link ShaderPass}, we will copy the correct input texture into its {@link ShaderPass#renderTexture | renderTexture}\r\n   * This also handles the {@link renderPassEntries} screen array entries order: We will first draw selective passes, then our main screen pass and finally global post processing passes.\r\n   * @see {@link https://codesandbox.io/p/sandbox/webgpu-render-to-2-textures-without-texture-copy-c4sx4s?file=%2Fsrc%2Findex.js%3A10%2C4 | minimal code example}\r\n   * @param shaderPass - {@link ShaderPass} to add\r\n   */\r\n  addShaderPass(shaderPass: ShaderPass) {\r\n    const onBeforeRenderPass =\r\n      shaderPass.inputTarget || shaderPass.outputTarget\r\n        ? null\r\n        : (commandEncoder, swapChainTexture) => {\r\n            // draw the content into our render texture\r\n            // if it's a global postprocessing pass, copy the context current texture into its renderTexture\r\n            // we don't need to do that if it has an inputTarget\r\n            // because in this case its renderTexture is already a copy of the render target content\r\n            if (shaderPass.renderTexture && swapChainTexture) {\r\n              commandEncoder.copyTextureToTexture(\r\n                {\r\n                  texture: swapChainTexture,\r\n                },\r\n                {\r\n                  texture: shaderPass.renderTexture.texture,\r\n                },\r\n                [shaderPass.renderTexture.size.width, shaderPass.renderTexture.size.height]\r\n              )\r\n            }\r\n\r\n            // if we want to post process the whole scene, clear render pass content\r\n            this.renderer.postProcessingPass.setLoadOp('clear')\r\n          }\r\n\r\n    const onAfterRenderPass =\r\n      !shaderPass.outputTarget && shaderPass.options.copyOutputToRenderTexture\r\n        ? (commandEncoder, swapChainTexture) => {\r\n            // if we rendered to the screen,\r\n            // copy the context current texture result back into the shaderPass renderTexture\r\n            if (shaderPass.renderTexture && swapChainTexture) {\r\n              commandEncoder.copyTextureToTexture(\r\n                {\r\n                  texture: swapChainTexture,\r\n                },\r\n                {\r\n                  texture: shaderPass.renderTexture.texture,\r\n                },\r\n                [shaderPass.renderTexture.size.width, shaderPass.renderTexture.size.height]\r\n              )\r\n            }\r\n          }\r\n        : null\r\n\r\n    const shaderPassEntry = {\r\n      // use output target or postprocessing render pass\r\n      renderPass: shaderPass.outputTarget ? shaderPass.outputTarget.renderPass : this.renderer.postProcessingPass,\r\n      // render to output target renderTexture or directly to screen\r\n      renderTexture: shaderPass.outputTarget ? shaderPass.outputTarget.renderTexture : null,\r\n      onBeforeRenderPass,\r\n      onAfterRenderPass,\r\n      element: shaderPass,\r\n      stack: null, // explicitly set to null\r\n    }\r\n\r\n    this.renderPassEntries.screen.push(shaderPassEntry)\r\n\r\n    // screen passes are sorted by 2 criteria\r\n    // first we draw render passes that have an output target OR our main render pass, ordered by renderOrder\r\n    // then we draw our full postprocessing pass, ordered by renderOrder\r\n    this.renderPassEntries.screen.sort((a, b) => {\r\n      const isPostProA = a.element && !a.element.outputTarget\r\n      const renderOrderA = a.element ? a.element.renderOrder : 0\r\n      const indexA = a.element ? a.element.index : 0\r\n\r\n      const isPostProB = b.element && !b.element.outputTarget\r\n      const renderOrderB = b.element ? b.element.renderOrder : 0\r\n      const indexB = b.element ? b.element.index : 0\r\n\r\n      if (isPostProA && !isPostProB) {\r\n        return 1\r\n      } else if (!isPostProA && isPostProB) {\r\n        return -1\r\n      } else if (renderOrderA !== renderOrderB) {\r\n        return renderOrderA - renderOrderB\r\n      } else {\r\n        return indexA - indexB\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Remove a {@link ShaderPass} from our scene {@link renderPassEntries} screen array\r\n   * @param shaderPass - {@link ShaderPass} to remove\r\n   */\r\n  removeShaderPass(shaderPass: ShaderPass) {\r\n    this.renderPassEntries.screen = this.renderPassEntries.screen.filter(\r\n      (entry) => !entry.element || entry.element.uuid !== shaderPass.uuid\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Add a {@link PingPongPlane} to our scene {@link renderPassEntries} pingPong array.\r\n   * After rendering the {@link PingPongPlane}, we will copy the context current texture into its {@link PingPongPlane#renderTexture | renderTexture} so we'll be able to use it as an input for the next pass\r\n   * @see {@link https://codesandbox.io/p/sandbox/webgpu-render-ping-pong-to-texture-use-in-quad-gwjx9p | minimal code example}\r\n   * @param pingPongPlane\r\n   */\r\n  addPingPongPlane(pingPongPlane: PingPongPlane) {\r\n    this.renderPassEntries.pingPong.push({\r\n      renderPass: pingPongPlane.outputTarget.renderPass,\r\n      renderTexture: pingPongPlane.outputTarget.renderTexture,\r\n      onBeforeRenderPass: null,\r\n      onAfterRenderPass: (commandEncoder, swapChainTexture) => {\r\n        // Copy the rendering results from the swapChainTexture into our |pingPongPlane texture|.\r\n        commandEncoder.copyTextureToTexture(\r\n          {\r\n            texture: swapChainTexture,\r\n          },\r\n          {\r\n            texture: pingPongPlane.renderTexture.texture,\r\n          },\r\n          [pingPongPlane.renderTexture.size.width, pingPongPlane.renderTexture.size.height]\r\n        )\r\n      },\r\n      element: pingPongPlane,\r\n      stack: null, // explicitly set to null\r\n    } as RenderPassEntry)\r\n\r\n    // sort by their render order\r\n    this.renderPassEntries.pingPong.sort((a, b) => a.element.renderOrder - b.element.renderOrder)\r\n  }\r\n\r\n  /**\r\n   * Remove a {@link PingPongPlane} from our scene {@link renderPassEntries} pingPong array.\r\n   * @param pingPongPlane - {@link PingPongPlane} to remove\r\n   */\r\n  removePingPongPlane(pingPongPlane: PingPongPlane) {\r\n    this.renderPassEntries.pingPong = this.renderPassEntries.pingPong.filter(\r\n      (entry) => entry.element.uuid !== pingPongPlane.uuid\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Get any rendered object or {@link RenderTarget} {@link RenderPassEntry}. Useful to override a {@link RenderPassEntry#onBeforeRenderPass | RenderPassEntry onBeforeRenderPass} or {@link RenderPassEntry#onAfterRenderPass | RenderPassEntry onAfterRenderPass} default behavior.\r\n   * @param object - The object from which we want to get the parentMesh {@link RenderPassEntry}\r\n   * @returns - the {@link RenderPassEntry} if found\r\n   */\r\n  getObjectRenderPassEntry(object: RenderedMesh | RenderTarget): RenderPassEntry | undefined {\r\n    if (object instanceof RenderTarget) {\r\n      return this.renderPassEntries.renderTarget.find((entry) => entry.renderPass.uuid === object.renderPass.uuid)\r\n    } else if (object instanceof PingPongPlane) {\r\n      return this.renderPassEntries.pingPong.find((entry) => entry.element.uuid === object.uuid)\r\n    } else if (object instanceof ShaderPass) {\r\n      return this.renderPassEntries.screen.find((entry) => entry.element?.uuid === object.uuid)\r\n    } else {\r\n      const entryType = object.outputTarget ? 'renderTarget' : 'screen'\r\n      return this.renderPassEntries[entryType].find((entry) => {\r\n        return [\r\n          ...entry.stack.unProjected.opaque,\r\n          ...entry.stack.unProjected.transparent,\r\n          ...entry.stack.projected.opaque,\r\n          ...entry.stack.projected.transparent,\r\n        ].some((mesh) => mesh.uuid === object.uuid)\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Here we render a {@link RenderPassEntry}:\r\n   * - Set its {@link RenderPass#descriptor | renderPass descriptor} view or resolveTarget and get it at as swap chain texture\r\n   * - Execute {@link RenderPassEntry#onBeforeRenderPass | onBeforeRenderPass} callback if specified\r\n   * - Begin the {@link GPURenderPassEncoder | GPU render pass encoder} using our {@link RenderPass#descriptor | renderPass descriptor}\r\n   * - Render the single element if specified or the render pass entry {@link Stack}: draw unprojected opaque / transparent meshes first, then set the {@link CameraRenderer#cameraBindGroup | camera bind group} and draw projected opaque / transparent meshes\r\n   * - End the {@link GPURenderPassEncoder | GPU render pass encoder}\r\n   * - Execute {@link RenderPassEntry#onAfterRenderPass | onAfterRenderPass} callback if specified\r\n   * - Reset {@link core/pipelines/PipelineManager.PipelineManager#currentPipelineIndex | pipeline manager current pipeline}\r\n   * @param commandEncoder - current {@link GPUCommandEncoder}\r\n   * @param renderPassEntry - {@link RenderPassEntry} to render\r\n   */\r\n  renderSinglePassEntry(commandEncoder: GPUCommandEncoder, renderPassEntry: RenderPassEntry) {\r\n    // set the pass texture to render to\r\n    const swapChainTexture = renderPassEntry.renderPass.updateView(renderPassEntry.renderTexture?.texture)\r\n\r\n    renderPassEntry.onBeforeRenderPass && renderPassEntry.onBeforeRenderPass(commandEncoder, swapChainTexture)\r\n\r\n    // now begin our actual render pass\r\n    const pass = commandEncoder.beginRenderPass(renderPassEntry.renderPass.descriptor)\r\n    !this.renderer.production &&\r\n      pass.pushDebugGroup(\r\n        renderPassEntry.element\r\n          ? `${renderPassEntry.element.options.label} render pass using ${renderPassEntry.renderPass.options.label} descriptor`\r\n          : `Render stack pass using ${renderPassEntry.renderPass.options.label}${\r\n              renderPassEntry.renderTexture ? ' onto ' + renderPassEntry.renderTexture.options.label : ''\r\n            }`\r\n      )\r\n\r\n    // pass entries can have a single element or a stack\r\n    if (renderPassEntry.element) {\r\n      renderPassEntry.element.render(pass)\r\n    } else if (renderPassEntry.stack) {\r\n      // draw unProjected regular meshes\r\n      renderPassEntry.stack.unProjected.opaque.forEach((mesh) => mesh.render(pass))\r\n      renderPassEntry.stack.unProjected.transparent.forEach((mesh) => mesh.render(pass))\r\n\r\n      // then draw projected meshes\r\n      if (renderPassEntry.stack.projected.opaque.length || renderPassEntry.stack.projected.transparent.length) {\r\n        if ((this.renderer as CameraRenderer).cameraBindGroup) {\r\n          // set camera bind group once\r\n          pass.setBindGroup(\r\n            (this.renderer as CameraRenderer).cameraBindGroup.index,\r\n            (this.renderer as CameraRenderer).cameraBindGroup.bindGroup\r\n          )\r\n        }\r\n\r\n        renderPassEntry.stack.projected.opaque.forEach((mesh) => mesh.render(pass))\r\n        renderPassEntry.stack.projected.transparent.forEach((mesh) => mesh.render(pass))\r\n      }\r\n    }\r\n\r\n    !this.renderer.production && pass.popDebugGroup()\r\n    pass.end()\r\n\r\n    renderPassEntry.onAfterRenderPass && renderPassEntry.onAfterRenderPass(commandEncoder, swapChainTexture)\r\n\r\n    this.renderer.pipelineManager.resetCurrentPipeline()\r\n  }\r\n\r\n  /**\r\n   * Render our {@link Scene}\r\n   * - Render {@link computePassEntries} first\r\n   * - Then our {@link renderPassEntries}\r\n   * @param commandEncoder - current {@link GPUCommandEncoder}\r\n   */\r\n  render(commandEncoder: GPUCommandEncoder) {\r\n    this.computePassEntries.forEach((computePass) => {\r\n      const pass = commandEncoder.beginComputePass()\r\n      computePass.render(pass)\r\n      pass.end()\r\n\r\n      computePass.copyBufferToResult(commandEncoder)\r\n\r\n      this.renderer.pipelineManager.resetCurrentPipeline()\r\n    })\r\n\r\n    for (const renderPassEntryType in this.renderPassEntries) {\r\n      let passDrawnCount = 0\r\n\r\n      this.renderPassEntries[renderPassEntryType].forEach((renderPassEntry) => {\r\n        // early bail if there's nothing to draw\r\n        if (!this.getRenderPassEntryLength(renderPassEntry)) return\r\n\r\n        // if we're drawing to screen and it's not our first pass, load result from previous passes\r\n        // post processing scene pass will clear content inside onBeforeRenderPass anyway\r\n        renderPassEntry.renderPass.setLoadOp(\r\n          renderPassEntryType === 'screen' && passDrawnCount !== 0 ? 'load' : 'clear'\r\n        )\r\n\r\n        passDrawnCount++\r\n\r\n        this.renderSinglePassEntry(commandEncoder, renderPassEntry)\r\n      })\r\n    }\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;AAmEO,MAAM,KAAM,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBjB,WAAA,CAAY,EAAE,QAAA,EAAkD,EAAA;AAE9D,IAAY,QAAA,GAAA,QAAA,IAAa,SAAyB,QAAc,IAAA,QAAA,CAAA;AAEhE,IAAA,UAAA,CAAW,UAAU,OAAO,CAAA,CAAA;AAE5B,IAAA,IAAA,CAAK,QAAW,GAAA,QAAA,CAAA;AAEhB,IAAA,IAAA,CAAK,qBAAqB,EAAC,CAAA;AAE3B,IAAA,IAAA,CAAK,iBAAoB,GAAA;AAAA;AAAA,MAEvB,UAAU,EAAC;AAAA;AAAA,MAEX,cAAc,EAAC;AAAA;AAAA,MAEf,MAAQ,EAAA;AAAA;AAAA,QAEN;AAAA,UACE,UAAA,EAAY,KAAK,QAAS,CAAA,UAAA;AAAA,UAC1B,aAAe,EAAA,IAAA;AAAA,UACf,kBAAoB,EAAA,IAAA;AAAA,UACpB,iBAAmB,EAAA,IAAA;AAAA,UACnB,OAAS,EAAA,IAAA;AAAA;AAAA,UACT,KAAO,EAAA;AAAA,YACL,WAAa,EAAA;AAAA,cACX,QAAQ,EAAC;AAAA,cACT,aAAa,EAAC;AAAA,aAChB;AAAA,YACA,SAAW,EAAA;AAAA,cACT,QAAQ,EAAC;AAAA,cACT,aAAa,EAAC;AAAA,aAChB;AAAA,WACF;AAAA,SACF;AAAA,OACF;AAAA,KACF,CAAA;AAAA,GACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,yBAAyB,eAA0C,EAAA;AACjE,IAAA,IAAI,CAAC,eAAiB,EAAA;AACpB,MAAO,OAAA,CAAA,CAAA;AAAA,KACF,MAAA;AACL,MAAO,OAAA,eAAA,CAAgB,OACnB,GAAA,eAAA,CAAgB,OAAQ,CAAA,OAAA,GACtB,IACA,CACF,GAAA,eAAA,CAAgB,KAAM,CAAA,WAAA,CAAY,MAAO,CAAA,MAAA,GACvC,gBAAgB,KAAM,CAAA,WAAA,CAAY,WAAY,CAAA,MAAA,GAC9C,eAAgB,CAAA,KAAA,CAAM,SAAU,CAAA,MAAA,CAAO,MACvC,GAAA,eAAA,CAAgB,KAAM,CAAA,SAAA,CAAU,WAAY,CAAA,MAAA,CAAA;AAAA,KACpD;AAAA,GACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,eAAe,WAA0B,EAAA;AACvC,IAAK,IAAA,CAAA,kBAAA,CAAmB,KAAK,WAAW,CAAA,CAAA;AACxC,IAAA,IAAA,CAAK,kBAAmB,CAAA,IAAA,CAAK,CAAC,CAAA,EAAG,CAAM,KAAA;AACrC,MAAI,IAAA,CAAA,CAAE,WAAgB,KAAA,CAAA,CAAE,WAAa,EAAA;AACnC,QAAO,OAAA,CAAA,CAAE,cAAc,CAAE,CAAA,WAAA,CAAA;AAAA,OACpB,MAAA;AACL,QAAO,OAAA,CAAA,CAAE,QAAQ,CAAE,CAAA,KAAA,CAAA;AAAA,OACrB;AAAA,KACD,CAAA,CAAA;AAAA,GACH;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,kBAAkB,WAA0B,EAAA;AAC1C,IAAK,IAAA,CAAA,kBAAA,GAAqB,KAAK,kBAAmB,CAAA,MAAA,CAAO,CAAC,EAAO,KAAA,EAAA,CAAG,IAAS,KAAA,WAAA,CAAY,IAAI,CAAA,CAAA;AAAA,GAC/F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBAAgB,YAA4B,EAAA;AAE1C,IAAA,IAAI,CAAC,IAAA,CAAK,iBAAkB,CAAA,YAAA,CAAa,IAAK,CAAA,CAAC,KAAU,KAAA,KAAA,CAAM,UAAW,CAAA,IAAA,KAAS,YAAa,CAAA,UAAA,CAAW,IAAI,CAAA;AAC7G,MAAK,IAAA,CAAA,iBAAA,CAAkB,aAAa,IAAK,CAAA;AAAA,QACvC,YAAY,YAAa,CAAA,UAAA;AAAA,QACzB,eAAe,YAAa,CAAA,aAAA;AAAA,QAC5B,kBAAoB,EAAA,IAAA;AAAA,QACpB,iBAAmB,EAAA,IAAA;AAAA,QACnB,OAAS,EAAA,IAAA;AAAA;AAAA,QACT,KAAO,EAAA;AAAA,UACL,WAAa,EAAA;AAAA,YACX,QAAQ,EAAC;AAAA,YACT,aAAa,EAAC;AAAA,WAChB;AAAA,UACA,SAAW,EAAA;AAAA,YACT,QAAQ,EAAC;AAAA,YACT,aAAa,EAAC;AAAA,WAChB;AAAA,SACF;AAAA,OACkB,CAAA,CAAA;AAAA,GACxB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,mBAAmB,YAA4B,EAAA;AAC7C,IAAA,IAAA,CAAK,iBAAkB,CAAA,YAAA,GAAe,IAAK,CAAA,iBAAA,CAAkB,YAAa,CAAA,MAAA;AAAA,MACxE,CAAC,KAAU,KAAA,KAAA,CAAM,UAAW,CAAA,IAAA,KAAS,aAAa,UAAW,CAAA,IAAA;AAAA,KAC/D,CAAA;AAAA,GACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,uBAAuB,IAAsC,EAAA;AAE3D,IAAA,MAAM,eAAkB,GAAA,IAAA,CAAK,YACzB,GAAA,IAAA,CAAK,kBAAkB,YAAa,CAAA,IAAA;AAAA,MAClC,CAAC,SAAc,KAAA,SAAA,CAAU,WAAW,IAAS,KAAA,IAAA,CAAK,aAAa,UAAW,CAAA,IAAA;AAAA,KAE5E,GAAA,IAAA,CAAK,iBAAkB,CAAA,MAAA,CAAO,CAAC,CAAA,CAAA;AAEnC,IAAM,MAAA,EAAE,OAAU,GAAA,eAAA,CAAA;AAElB,IAAA,OAAO,KAAK,QAAS,CAAA,OAAA,CAAQ,UAAU,aAAgB,GAAA,KAAA,CAAM,YAAY,KAAM,CAAA,WAAA,CAAA;AAAA,GACjF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ,IAAqB,EAAA;AAC3B,IAAM,MAAA,eAAA,GAAkB,IAAK,CAAA,sBAAA,CAAuB,IAAI,CAAA,CAAA;AAGxD,IAAM,MAAA,aAAA,GAAgB,IAAK,CAAA,WAAA,GAAc,CAAC,GAAG,eAAgB,CAAA,WAAW,CAAI,GAAA,CAAC,GAAG,eAAA,CAAgB,MAAM,CAAA,CAAA;AAGtG,IAAA,IAAI,gBAAmB,GAAA,CAAA,CAAA,CAAA;AAEvB,IAAA,KAAA,IAAS,IAAI,aAAc,CAAA,MAAA,GAAS,CAAG,EAAA,CAAA,IAAK,GAAG,CAAK,EAAA,EAAA;AAClD,MAAI,IAAA,aAAA,CAAc,CAAC,CAAE,CAAA,QAAA,CAAS,cAAc,KAAU,KAAA,IAAA,CAAK,QAAS,CAAA,aAAA,CAAc,KAAO,EAAA;AACvF,QAAA,gBAAA,GAAmB,CAAI,GAAA,CAAA,CAAA;AACvB,QAAA,MAAA;AAAA,OACF;AAAA,KACF;AAGA,IAAmB,gBAAA,GAAA,IAAA,CAAK,GAAI,CAAA,CAAA,EAAG,gBAAgB,CAAA,CAAA;AAG/C,IAAc,aAAA,CAAA,MAAA,CAAO,gBAAkB,EAAA,CAAA,EAAG,IAAI,CAAA,CAAA;AAC9C,IAAA,aAAA,CAAc,KAAK,CAAC,CAAA,EAAG,MAAM,CAAE,CAAA,KAAA,GAAQ,EAAE,KAAK,CAAA,CAAA;AAG9C,IAAA,IAAA,CAAK,IAAgB,YAAA,OAAA,IAAW,IAAgB,YAAA,KAAA,KAAU,KAAK,WAAa,EAAA;AAC1E,MAAc,aAAA,CAAA,IAAA;AAAA,QACZ,CAAC,CAAG,EAAA,CAAA,KAAO,EAAuB,gBAAiB,CAAA,CAAA,GAAK,EAAuB,gBAAiB,CAAA,CAAA;AAAA,OAClG,CAAA;AAAA,KACF;AAGA,IAAA,aAAA,CAAc,KAAK,CAAC,CAAA,EAAG,MAAM,CAAE,CAAA,WAAA,GAAc,EAAE,WAAW,CAAA,CAAA;AAE1D,IAAA,IAAA,CAAK,WAAe,GAAA,eAAA,CAAgB,WAAc,GAAA,aAAA,GAAkB,gBAAgB,MAAS,GAAA,aAAA,CAAA;AAAA,GAC/F;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAW,IAAqB,EAAA;AAC9B,IAAM,MAAA,eAAA,GAAkB,IAAK,CAAA,sBAAA,CAAuB,IAAI,CAAA,CAAA;AAExD,IAAA,IAAI,KAAK,WAAa,EAAA;AACpB,MAAgB,eAAA,CAAA,WAAA,GAAc,gBAAgB,WAAY,CAAA,MAAA,CAAO,CAAC,CAAM,KAAA,CAAA,CAAE,IAAS,KAAA,IAAA,CAAK,IAAI,CAAA,CAAA;AAAA,KACvF,MAAA;AACL,MAAgB,eAAA,CAAA,MAAA,GAAS,gBAAgB,MAAO,CAAA,MAAA,CAAO,CAAC,CAAM,KAAA,CAAA,CAAE,IAAS,KAAA,IAAA,CAAK,IAAI,CAAA,CAAA;AAAA,KACpF;AAAA,GACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,cAAc,UAAwB,EAAA;AACpC,IAAM,MAAA,kBAAA,GACJ,WAAW,WAAe,IAAA,UAAA,CAAW,eACjC,IACA,GAAA,CAAC,gBAAgB,gBAAqB,KAAA;AAKpC,MAAI,IAAA,UAAA,CAAW,iBAAiB,gBAAkB,EAAA;AAChD,QAAe,cAAA,CAAA,oBAAA;AAAA,UACb;AAAA,YACE,OAAS,EAAA,gBAAA;AAAA,WACX;AAAA,UACA;AAAA,YACE,OAAA,EAAS,WAAW,aAAc,CAAA,OAAA;AAAA,WACpC;AAAA,UACA,CAAC,WAAW,aAAc,CAAA,IAAA,CAAK,OAAO,UAAW,CAAA,aAAA,CAAc,KAAK,MAAM,CAAA;AAAA,SAC5E,CAAA;AAAA,OACF;AAGA,MAAK,IAAA,CAAA,QAAA,CAAS,kBAAmB,CAAA,SAAA,CAAU,OAAO,CAAA,CAAA;AAAA,KACpD,CAAA;AAEN,IAAM,MAAA,iBAAA,GACJ,CAAC,UAAW,CAAA,YAAA,IAAgB,WAAW,OAAQ,CAAA,yBAAA,GAC3C,CAAC,cAAA,EAAgB,gBAAqB,KAAA;AAGpC,MAAI,IAAA,UAAA,CAAW,iBAAiB,gBAAkB,EAAA;AAChD,QAAe,cAAA,CAAA,oBAAA;AAAA,UACb;AAAA,YACE,OAAS,EAAA,gBAAA;AAAA,WACX;AAAA,UACA;AAAA,YACE,OAAA,EAAS,WAAW,aAAc,CAAA,OAAA;AAAA,WACpC;AAAA,UACA,CAAC,WAAW,aAAc,CAAA,IAAA,CAAK,OAAO,UAAW,CAAA,aAAA,CAAc,KAAK,MAAM,CAAA;AAAA,SAC5E,CAAA;AAAA,OACF;AAAA,KAEF,GAAA,IAAA,CAAA;AAEN,IAAA,MAAM,eAAkB,GAAA;AAAA;AAAA,MAEtB,YAAY,UAAW,CAAA,YAAA,GAAe,WAAW,YAAa,CAAA,UAAA,GAAa,KAAK,QAAS,CAAA,kBAAA;AAAA;AAAA,MAEzF,aAAe,EAAA,UAAA,CAAW,YAAe,GAAA,UAAA,CAAW,aAAa,aAAgB,GAAA,IAAA;AAAA,MACjF,kBAAA;AAAA,MACA,iBAAA;AAAA,MACA,OAAS,EAAA,UAAA;AAAA,MACT,KAAO,EAAA,IAAA;AAAA;AAAA,KACT,CAAA;AAEA,IAAK,IAAA,CAAA,iBAAA,CAAkB,MAAO,CAAA,IAAA,CAAK,eAAe,CAAA,CAAA;AAKlD,IAAA,IAAA,CAAK,iBAAkB,CAAA,MAAA,CAAO,IAAK,CAAA,CAAC,GAAG,CAAM,KAAA;AAC3C,MAAA,MAAM,UAAa,GAAA,CAAA,CAAE,OAAW,IAAA,CAAC,EAAE,OAAQ,CAAA,YAAA,CAAA;AAC3C,MAAA,MAAM,YAAe,GAAA,CAAA,CAAE,OAAU,GAAA,CAAA,CAAE,QAAQ,WAAc,GAAA,CAAA,CAAA;AACzD,MAAA,MAAM,MAAS,GAAA,CAAA,CAAE,OAAU,GAAA,CAAA,CAAE,QAAQ,KAAQ,GAAA,CAAA,CAAA;AAE7C,MAAA,MAAM,UAAa,GAAA,CAAA,CAAE,OAAW,IAAA,CAAC,EAAE,OAAQ,CAAA,YAAA,CAAA;AAC3C,MAAA,MAAM,YAAe,GAAA,CAAA,CAAE,OAAU,GAAA,CAAA,CAAE,QAAQ,WAAc,GAAA,CAAA,CAAA;AACzD,MAAA,MAAM,MAAS,GAAA,CAAA,CAAE,OAAU,GAAA,CAAA,CAAE,QAAQ,KAAQ,GAAA,CAAA,CAAA;AAE7C,MAAI,IAAA,UAAA,IAAc,CAAC,UAAY,EAAA;AAC7B,QAAO,OAAA,CAAA,CAAA;AAAA,OACT,MAAA,IAAW,CAAC,UAAA,IAAc,UAAY,EAAA;AACpC,QAAO,OAAA,CAAA,CAAA,CAAA;AAAA,OACT,MAAA,IAAW,iBAAiB,YAAc,EAAA;AACxC,QAAA,OAAO,YAAe,GAAA,YAAA,CAAA;AAAA,OACjB,MAAA;AACL,QAAA,OAAO,MAAS,GAAA,MAAA,CAAA;AAAA,OAClB;AAAA,KACD,CAAA,CAAA;AAAA,GACH;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,iBAAiB,UAAwB,EAAA;AACvC,IAAA,IAAA,CAAK,iBAAkB,CAAA,MAAA,GAAS,IAAK,CAAA,iBAAA,CAAkB,MAAO,CAAA,MAAA;AAAA,MAC5D,CAAC,UAAU,CAAC,KAAA,CAAM,WAAW,KAAM,CAAA,OAAA,CAAQ,SAAS,UAAW,CAAA,IAAA;AAAA,KACjE,CAAA;AAAA,GACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,iBAAiB,aAA8B,EAAA;AAC7C,IAAK,IAAA,CAAA,iBAAA,CAAkB,SAAS,IAAK,CAAA;AAAA,MACnC,UAAA,EAAY,cAAc,YAAa,CAAA,UAAA;AAAA,MACvC,aAAA,EAAe,cAAc,YAAa,CAAA,aAAA;AAAA,MAC1C,kBAAoB,EAAA,IAAA;AAAA,MACpB,iBAAA,EAAmB,CAAC,cAAA,EAAgB,gBAAqB,KAAA;AAEvD,QAAe,cAAA,CAAA,oBAAA;AAAA,UACb;AAAA,YACE,OAAS,EAAA,gBAAA;AAAA,WACX;AAAA,UACA;AAAA,YACE,OAAA,EAAS,cAAc,aAAc,CAAA,OAAA;AAAA,WACvC;AAAA,UACA,CAAC,cAAc,aAAc,CAAA,IAAA,CAAK,OAAO,aAAc,CAAA,aAAA,CAAc,KAAK,MAAM,CAAA;AAAA,SAClF,CAAA;AAAA,OACF;AAAA,MACA,OAAS,EAAA,aAAA;AAAA,MACT,KAAO,EAAA,IAAA;AAAA;AAAA,KACW,CAAA,CAAA;AAGpB,IAAK,IAAA,CAAA,iBAAA,CAAkB,QAAS,CAAA,IAAA,CAAK,CAAC,CAAA,EAAG,CAAM,KAAA,CAAA,CAAE,OAAQ,CAAA,WAAA,GAAc,CAAE,CAAA,OAAA,CAAQ,WAAW,CAAA,CAAA;AAAA,GAC9F;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,oBAAoB,aAA8B,EAAA;AAChD,IAAA,IAAA,CAAK,iBAAkB,CAAA,QAAA,GAAW,IAAK,CAAA,iBAAA,CAAkB,QAAS,CAAA,MAAA;AAAA,MAChE,CAAC,KAAA,KAAU,KAAM,CAAA,OAAA,CAAQ,SAAS,aAAc,CAAA,IAAA;AAAA,KAClD,CAAA;AAAA,GACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,yBAAyB,MAAkE,EAAA;AACzF,IAAA,IAAI,kBAAkB,YAAc,EAAA;AAClC,MAAO,OAAA,IAAA,CAAK,iBAAkB,CAAA,YAAA,CAAa,IAAK,CAAA,CAAC,KAAU,KAAA,KAAA,CAAM,UAAW,CAAA,IAAA,KAAS,MAAO,CAAA,UAAA,CAAW,IAAI,CAAA,CAAA;AAAA,KAC7G,MAAA,IAAW,kBAAkB,aAAe,EAAA;AAC1C,MAAO,OAAA,IAAA,CAAK,iBAAkB,CAAA,QAAA,CAAS,IAAK,CAAA,CAAC,UAAU,KAAM,CAAA,OAAA,CAAQ,IAAS,KAAA,MAAA,CAAO,IAAI,CAAA,CAAA;AAAA,KAC3F,MAAA,IAAW,kBAAkB,UAAY,EAAA;AACvC,MAAO,OAAA,IAAA,CAAK,iBAAkB,CAAA,MAAA,CAAO,IAAK,CAAA,CAAC,UAAU,KAAM,CAAA,OAAA,EAAS,IAAS,KAAA,MAAA,CAAO,IAAI,CAAA,CAAA;AAAA,KACnF,MAAA;AACL,MAAM,MAAA,SAAA,GAAY,MAAO,CAAA,YAAA,GAAe,cAAiB,GAAA,QAAA,CAAA;AACzD,MAAA,OAAO,KAAK,iBAAkB,CAAA,SAAS,CAAE,CAAA,IAAA,CAAK,CAAC,KAAU,KAAA;AACvD,QAAO,OAAA;AAAA,UACL,GAAG,KAAM,CAAA,KAAA,CAAM,WAAY,CAAA,MAAA;AAAA,UAC3B,GAAG,KAAM,CAAA,KAAA,CAAM,WAAY,CAAA,WAAA;AAAA,UAC3B,GAAG,KAAM,CAAA,KAAA,CAAM,SAAU,CAAA,MAAA;AAAA,UACzB,GAAG,KAAM,CAAA,KAAA,CAAM,SAAU,CAAA,WAAA;AAAA,UACzB,IAAK,CAAA,CAAC,SAAS,IAAK,CAAA,IAAA,KAAS,OAAO,IAAI,CAAA,CAAA;AAAA,OAC3C,CAAA,CAAA;AAAA,KACH;AAAA,GACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,qBAAA,CAAsB,gBAAmC,eAAkC,EAAA;AAEzF,IAAA,MAAM,mBAAmB,eAAgB,CAAA,UAAA,CAAW,UAAW,CAAA,eAAA,CAAgB,eAAe,OAAO,CAAA,CAAA;AAErG,IAAA,eAAA,CAAgB,kBAAsB,IAAA,eAAA,CAAgB,kBAAmB,CAAA,cAAA,EAAgB,gBAAgB,CAAA,CAAA;AAGzG,IAAA,MAAM,IAAO,GAAA,cAAA,CAAe,eAAgB,CAAA,eAAA,CAAgB,WAAW,UAAU,CAAA,CAAA;AACjF,IAAC,CAAA,IAAA,CAAK,QAAS,CAAA,UAAA,IACb,IAAK,CAAA,cAAA;AAAA,MACH,eAAA,CAAgB,OACZ,GAAA,CAAA,EAAG,eAAgB,CAAA,OAAA,CAAQ,OAAQ,CAAA,KAAK,CAAsB,mBAAA,EAAA,eAAA,CAAgB,UAAW,CAAA,OAAA,CAAQ,KAAK,CAAA,WAAA,CAAA,GACtG,2BAA2B,eAAgB,CAAA,UAAA,CAAW,OAAQ,CAAA,KAAK,CACjE,EAAA,eAAA,CAAgB,aAAgB,GAAA,QAAA,GAAW,eAAgB,CAAA,aAAA,CAAc,OAAQ,CAAA,KAAA,GAAQ,EAC3F,CAAA,CAAA;AAAA,KACN,CAAA;AAGF,IAAA,IAAI,gBAAgB,OAAS,EAAA;AAC3B,MAAgB,eAAA,CAAA,OAAA,CAAQ,OAAO,IAAI,CAAA,CAAA;AAAA,KACrC,MAAA,IAAW,gBAAgB,KAAO,EAAA;AAEhC,MAAgB,eAAA,CAAA,KAAA,CAAM,YAAY,MAAO,CAAA,OAAA,CAAQ,CAAC,IAAS,KAAA,IAAA,CAAK,MAAO,CAAA,IAAI,CAAC,CAAA,CAAA;AAC5E,MAAgB,eAAA,CAAA,KAAA,CAAM,YAAY,WAAY,CAAA,OAAA,CAAQ,CAAC,IAAS,KAAA,IAAA,CAAK,MAAO,CAAA,IAAI,CAAC,CAAA,CAAA;AAGjF,MAAI,IAAA,eAAA,CAAgB,MAAM,SAAU,CAAA,MAAA,CAAO,UAAU,eAAgB,CAAA,KAAA,CAAM,SAAU,CAAA,WAAA,CAAY,MAAQ,EAAA;AACvG,QAAK,IAAA,IAAA,CAAK,SAA4B,eAAiB,EAAA;AAErD,UAAK,IAAA,CAAA,YAAA;AAAA,YACF,IAAA,CAAK,SAA4B,eAAgB,CAAA,KAAA;AAAA,YACjD,IAAA,CAAK,SAA4B,eAAgB,CAAA,SAAA;AAAA,WACpD,CAAA;AAAA,SACF;AAEA,QAAgB,eAAA,CAAA,KAAA,CAAM,UAAU,MAAO,CAAA,OAAA,CAAQ,CAAC,IAAS,KAAA,IAAA,CAAK,MAAO,CAAA,IAAI,CAAC,CAAA,CAAA;AAC1E,QAAgB,eAAA,CAAA,KAAA,CAAM,UAAU,WAAY,CAAA,OAAA,CAAQ,CAAC,IAAS,KAAA,IAAA,CAAK,MAAO,CAAA,IAAI,CAAC,CAAA,CAAA;AAAA,OACjF;AAAA,KACF;AAEA,IAAA,CAAC,IAAK,CAAA,QAAA,CAAS,UAAc,IAAA,IAAA,CAAK,aAAc,EAAA,CAAA;AAChD,IAAA,IAAA,CAAK,GAAI,EAAA,CAAA;AAET,IAAA,eAAA,CAAgB,iBAAqB,IAAA,eAAA,CAAgB,iBAAkB,CAAA,cAAA,EAAgB,gBAAgB,CAAA,CAAA;AAEvG,IAAK,IAAA,CAAA,QAAA,CAAS,gBAAgB,oBAAqB,EAAA,CAAA;AAAA,GACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAO,cAAmC,EAAA;AACxC,IAAK,IAAA,CAAA,kBAAA,CAAmB,OAAQ,CAAA,CAAC,WAAgB,KAAA;AAC/C,MAAM,MAAA,IAAA,GAAO,eAAe,gBAAiB,EAAA,CAAA;AAC7C,MAAA,WAAA,CAAY,OAAO,IAAI,CAAA,CAAA;AACvB,MAAA,IAAA,CAAK,GAAI,EAAA,CAAA;AAET,MAAA,WAAA,CAAY,mBAAmB,cAAc,CAAA,CAAA;AAE7C,MAAK,IAAA,CAAA,QAAA,CAAS,gBAAgB,oBAAqB,EAAA,CAAA;AAAA,KACpD,CAAA,CAAA;AAED,IAAW,KAAA,MAAA,mBAAA,IAAuB,KAAK,iBAAmB,EAAA;AACxD,MAAA,IAAI,cAAiB,GAAA,CAAA,CAAA;AAErB,MAAA,IAAA,CAAK,iBAAkB,CAAA,mBAAmB,CAAE,CAAA,OAAA,CAAQ,CAAC,eAAoB,KAAA;AAEvE,QAAI,IAAA,CAAC,IAAK,CAAA,wBAAA,CAAyB,eAAe,CAAA;AAAG,UAAA,OAAA;AAIrD,QAAA,eAAA,CAAgB,UAAW,CAAA,SAAA;AAAA,UACzB,mBAAwB,KAAA,QAAA,IAAY,cAAmB,KAAA,CAAA,GAAI,MAAS,GAAA,OAAA;AAAA,SACtE,CAAA;AAEA,QAAA,cAAA,EAAA,CAAA;AAEA,QAAK,IAAA,CAAA,qBAAA,CAAsB,gBAAgB,eAAe,CAAA,CAAA;AAAA,OAC3D,CAAA,CAAA;AAAA,KACH;AAAA,GACF;AACF;;;;"}