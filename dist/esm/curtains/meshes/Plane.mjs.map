{"version":3,"file":"Plane.mjs","sources":["../../../../src/curtains/meshes/Plane.ts"],"sourcesContent":["import { isCurtainsRenderer } from '../../core/renderers/utils'\r\nimport { PlaneGeometry, PlaneGeometryParams } from '../../core/geometries/PlaneGeometry'\r\nimport { DOMMesh, DOMMeshBaseParams, DOMMeshParams } from './DOMMesh'\r\nimport { Vec3 } from '../../math/Vec3'\r\nimport { Vec2 } from '../../math/Vec2'\r\nimport { cacheManager } from '../../utils/CacheManager'\r\nimport { GPUCurtainsRenderer } from '../renderers/GPUCurtainsRenderer'\r\nimport { GPUCurtains } from '../GPUCurtains'\r\nimport { DOMElementParams } from '../../core/DOM/DOMElement'\r\n\r\n/**\r\n * Parameters used to create a {@link Plane}\r\n */\r\nexport interface PlaneParams extends DOMMeshBaseParams, PlaneGeometryParams {\r\n  /** Optional {@link PlaneGeometry} to use */\r\n  geometry?: PlaneGeometry\r\n}\r\n\r\n/** @const - default {@link Plane} parameters */\r\nconst defaultPlaneParams = {\r\n  label: 'Plane',\r\n\r\n  // geometry\r\n  instancesCount: 1,\r\n  vertexBuffers: [],\r\n} as PlaneParams\r\n\r\n/**\r\n * Used to create a special {@link DOMMesh} class object using a {@link PlaneGeometry}.\r\n * This means a quad that looks like an ordinary {@link HTMLElement} but with WebGPU rendering capabilities.\r\n *\r\n * @example\r\n * ```javascript\r\n * // set our main GPUCurtains instance\r\n * const gpuCurtains = new GPUCurtains({\r\n *   container: '#canvas' // selector of our WebGPU canvas container\r\n * })\r\n *\r\n * // set the GPU device\r\n * // note this is asynchronous\r\n * await gpuCurtains.setDevice()\r\n *\r\n * // create a Plane,\r\n * // assuming there's a HTML element with the \"plane\" ID in the DOM\r\n * // will use the normals colors as default shading\r\n * const plane = new Plane(gpuCurtains, '#plane', {\r\n *   label: 'My plane',\r\n * })\r\n * ```\r\n */\r\nexport class Plane extends DOMMesh {\r\n  /**\r\n   * Plane constructor\r\n   * @param renderer - {@link GPUCurtainsRenderer} object or {@link GPUCurtains} class object used to create this {@link Plane}\r\n   * @param element - {@link HTMLElement} or string representing an {@link HTMLElement} selector used to scale and position the {@link Plane}\r\n   * @param parameters - {@link PlaneParams | parameters} used to create this {@link Plane}\r\n   */\r\n  constructor(\r\n    renderer: GPUCurtainsRenderer | GPUCurtains,\r\n    element: DOMElementParams['element'],\r\n    parameters = {} as PlaneParams\r\n  ) {\r\n    // we could pass our curtains object OR our curtains renderer object\r\n    renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as GPUCurtainsRenderer)\r\n\r\n    isCurtainsRenderer(renderer, parameters.label ? parameters.label + ' Plane' : 'Plane')\r\n\r\n    // assign default params if needed\r\n    const params = { ...defaultPlaneParams, ...parameters }\r\n\r\n    let { geometry, widthSegments, heightSegments, ...DOMMeshParams } = params\r\n    const { instancesCount, vertexBuffers, ...materialParams } = DOMMeshParams\r\n\r\n    // can we get a cached geometry?\r\n    if (!geometry || geometry.type !== 'PlaneGeometry') {\r\n      widthSegments = widthSegments ?? 1\r\n      heightSegments = heightSegments ?? 1\r\n\r\n      const geometryID = widthSegments * heightSegments + widthSegments\r\n\r\n      // if there's no additional vertex buffers, try to get a geometry from cache\r\n      if (!vertexBuffers.length) {\r\n        geometry = cacheManager.getPlaneGeometryByID(geometryID)\r\n      }\r\n\r\n      if (!geometry) {\r\n        // no cached plane geometry, we need to create a new one\r\n        geometry = new PlaneGeometry({ widthSegments, heightSegments, instancesCount, vertexBuffers })\r\n        cacheManager.addPlaneGeometry(geometry as PlaneGeometry)\r\n      } else {\r\n        // if geometry comes from cache, force instances count\r\n        geometry.instancesCount = instancesCount\r\n      }\r\n    }\r\n\r\n    // get DOMMesh params\r\n    super(renderer, element, { geometry, ...materialParams } as DOMMeshParams)\r\n\r\n    this.type = 'Plane'\r\n  }\r\n\r\n  /**\r\n   * Take the pointer {@link Vec2 | vector} position relative to the document and returns it relative to our {@link Plane}\r\n   * It ranges from -1 to 1 on both axis\r\n   * @param mouseCoords - pointer {@link Vec2 | vector} coordinates\r\n   * @returns - raycasted {@link Vec2 | vector} coordinates relative to the {@link Plane}\r\n   */\r\n  mouseToPlaneCoords(mouseCoords: Vec2 = new Vec2()): Vec2 {\r\n    // TODO simplify if no rotation set?\r\n    // raycasting\r\n    // based on https://people.cs.clemson.edu/~dhouse/courses/405/notes/raycast.pdf\r\n\r\n    // convert mouse position to 3d normalised device coordinates (from [-1, -1] to [1, 1])\r\n    const worldMouse = {\r\n      x: 2 * (mouseCoords.x / this.renderer.displayBoundingRect.width) - 1,\r\n      y: 2 * (1 - mouseCoords.y / this.renderer.displayBoundingRect.height) - 1,\r\n    }\r\n\r\n    const rayOrigin = this.camera.position.clone()\r\n\r\n    // ray direction based on normalised coordinates and plane translation\r\n    const rayDirection = new Vec3(worldMouse.x, worldMouse.y, -0.5)\r\n\r\n    // unproject ray direction\r\n    rayDirection.unproject(this.camera)\r\n    rayDirection.sub(rayOrigin).normalize()\r\n\r\n    // plane normals (could also be [0, 0, -1], makes no difference, raycasting lands the same result for both face)\r\n    const planeNormals = new Vec3(0, 0, 1)\r\n\r\n    // apply plane quaternion to plane normals\r\n    planeNormals.applyQuat(this.quaternion).normalize()\r\n\r\n    const result = new Vec3(0, 0, 0)\r\n\r\n    const denominator = planeNormals.dot(rayDirection)\r\n\r\n    if (Math.abs(denominator) >= 0.0001) {\r\n      const inverseViewMatrix = this.modelMatrix.getInverse().premultiply(this.camera.viewMatrix)\r\n\r\n      // get the plane's center coordinates\r\n      // start with our transform origin point\r\n      const planeOrigin = this.worldTransformOrigin.clone().add(this.worldPosition)\r\n\r\n      // rotate our transform origin about world center\r\n      const rotatedOrigin = new Vec3(\r\n        this.worldPosition.x - planeOrigin.x,\r\n        this.worldPosition.y - planeOrigin.y,\r\n        this.worldPosition.z - planeOrigin.z\r\n      )\r\n      rotatedOrigin.applyQuat(this.quaternion)\r\n\r\n      // add it to our plane origin\r\n      planeOrigin.add(rotatedOrigin)\r\n\r\n      // distance from ray origin to plane\r\n      const distance = planeNormals.dot(planeOrigin.clone().sub(rayOrigin)) / denominator\r\n      result.copy(rayOrigin.add(rayDirection.multiplyScalar(distance)))\r\n\r\n      result.applyMat4(inverseViewMatrix)\r\n    } else {\r\n      // no intersection!\r\n      result.set(Infinity, Infinity, Infinity)\r\n    }\r\n\r\n    return new Vec2(result.x, result.y)\r\n  }\r\n}\r\n"],"names":["DOMMeshParams"],"mappings":";;;;;;;AAmBA,MAAM,kBAAqB,GAAA;AAAA,EACzB,KAAO,EAAA,OAAA;AAAA;AAAA,EAGP,cAAgB,EAAA,CAAA;AAAA,EAChB,eAAe,EAAC;AAClB,CAAA,CAAA;AAyBO,MAAM,cAAc,OAAQ,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOjC,WACE,CAAA,QAAA,EACA,OACA,EAAA,UAAA,GAAa,EACb,EAAA;AAEA,IAAY,QAAA,GAAA,QAAA,IAAa,SAAyB,QAAc,IAAA,QAAA,CAAA;AAEhE,IAAA,kBAAA,CAAmB,UAAU,UAAW,CAAA,KAAA,GAAQ,UAAW,CAAA,KAAA,GAAQ,WAAW,OAAO,CAAA,CAAA;AAGrF,IAAA,MAAM,MAAS,GAAA,EAAE,GAAG,kBAAA,EAAoB,GAAG,UAAW,EAAA,CAAA;AAEtD,IAAA,IAAI,EAAE,QAAU,EAAA,aAAA,EAAe,cAAgB,EAAA,GAAGA,gBAAkB,GAAA,MAAA,CAAA;AACpE,IAAA,MAAM,EAAE,cAAA,EAAgB,aAAe,EAAA,GAAG,gBAAmBA,GAAAA,cAAAA,CAAAA;AAG7D,IAAA,IAAI,CAAC,QAAA,IAAY,QAAS,CAAA,IAAA,KAAS,eAAiB,EAAA;AAClD,MAAA,aAAA,GAAgB,aAAiB,IAAA,CAAA,CAAA;AACjC,MAAA,cAAA,GAAiB,cAAkB,IAAA,CAAA,CAAA;AAEnC,MAAM,MAAA,UAAA,GAAa,gBAAgB,cAAiB,GAAA,aAAA,CAAA;AAGpD,MAAI,IAAA,CAAC,cAAc,MAAQ,EAAA;AACzB,QAAW,QAAA,GAAA,YAAA,CAAa,qBAAqB,UAAU,CAAA,CAAA;AAAA,OACzD;AAEA,MAAA,IAAI,CAAC,QAAU,EAAA;AAEb,QAAA,QAAA,GAAW,IAAI,aAAc,CAAA,EAAE,eAAe,cAAgB,EAAA,cAAA,EAAgB,eAAe,CAAA,CAAA;AAC7F,QAAA,YAAA,CAAa,iBAAiB,QAAyB,CAAA,CAAA;AAAA,OAClD,MAAA;AAEL,QAAA,QAAA,CAAS,cAAiB,GAAA,cAAA,CAAA;AAAA,OAC5B;AAAA,KACF;AAGA,IAAA,KAAA,CAAM,UAAU,OAAS,EAAA,EAAE,QAAU,EAAA,GAAG,gBAAiC,CAAA,CAAA;AAEzE,IAAA,IAAA,CAAK,IAAO,GAAA,OAAA,CAAA;AAAA,GACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,kBAAmB,CAAA,WAAA,GAAoB,IAAI,IAAA,EAAc,EAAA;AAMvD,IAAA,MAAM,UAAa,GAAA;AAAA,MACjB,GAAG,CAAK,IAAA,WAAA,CAAY,IAAI,IAAK,CAAA,QAAA,CAAS,oBAAoB,KAAS,CAAA,GAAA,CAAA;AAAA,MACnE,CAAA,EAAG,KAAK,CAAI,GAAA,WAAA,CAAY,IAAI,IAAK,CAAA,QAAA,CAAS,oBAAoB,MAAU,CAAA,GAAA,CAAA;AAAA,KAC1E,CAAA;AAEA,IAAA,MAAM,SAAY,GAAA,IAAA,CAAK,MAAO,CAAA,QAAA,CAAS,KAAM,EAAA,CAAA;AAG7C,IAAA,MAAM,eAAe,IAAI,IAAA,CAAK,WAAW,CAAG,EAAA,UAAA,CAAW,GAAG,CAAI,GAAA,CAAA,CAAA;AAG9D,IAAa,YAAA,CAAA,SAAA,CAAU,KAAK,MAAM,CAAA,CAAA;AAClC,IAAa,YAAA,CAAA,GAAA,CAAI,SAAS,CAAA,CAAE,SAAU,EAAA,CAAA;AAGtC,IAAA,MAAM,YAAe,GAAA,IAAI,IAAK,CAAA,CAAA,EAAG,GAAG,CAAC,CAAA,CAAA;AAGrC,IAAA,YAAA,CAAa,SAAU,CAAA,IAAA,CAAK,UAAU,CAAA,CAAE,SAAU,EAAA,CAAA;AAElD,IAAA,MAAM,MAAS,GAAA,IAAI,IAAK,CAAA,CAAA,EAAG,GAAG,CAAC,CAAA,CAAA;AAE/B,IAAM,MAAA,WAAA,GAAc,YAAa,CAAA,GAAA,CAAI,YAAY,CAAA,CAAA;AAEjD,IAAA,IAAI,IAAK,CAAA,GAAA,CAAI,WAAW,CAAA,IAAK,IAAQ,EAAA;AACnC,MAAM,MAAA,iBAAA,GAAoB,KAAK,WAAY,CAAA,UAAA,GAAa,WAAY,CAAA,IAAA,CAAK,OAAO,UAAU,CAAA,CAAA;AAI1F,MAAA,MAAM,cAAc,IAAK,CAAA,oBAAA,CAAqB,OAAQ,CAAA,GAAA,CAAI,KAAK,aAAa,CAAA,CAAA;AAG5E,MAAA,MAAM,gBAAgB,IAAI,IAAA;AAAA,QACxB,IAAA,CAAK,aAAc,CAAA,CAAA,GAAI,WAAY,CAAA,CAAA;AAAA,QACnC,IAAA,CAAK,aAAc,CAAA,CAAA,GAAI,WAAY,CAAA,CAAA;AAAA,QACnC,IAAA,CAAK,aAAc,CAAA,CAAA,GAAI,WAAY,CAAA,CAAA;AAAA,OACrC,CAAA;AACA,MAAc,aAAA,CAAA,SAAA,CAAU,KAAK,UAAU,CAAA,CAAA;AAGvC,MAAA,WAAA,CAAY,IAAI,aAAa,CAAA,CAAA;AAG7B,MAAM,MAAA,QAAA,GAAW,aAAa,GAAI,CAAA,WAAA,CAAY,OAAQ,CAAA,GAAA,CAAI,SAAS,CAAC,CAAI,GAAA,WAAA,CAAA;AACxE,MAAA,MAAA,CAAO,KAAK,SAAU,CAAA,GAAA,CAAI,aAAa,cAAe,CAAA,QAAQ,CAAC,CAAC,CAAA,CAAA;AAEhE,MAAA,MAAA,CAAO,UAAU,iBAAiB,CAAA,CAAA;AAAA,KAC7B,MAAA;AAEL,MAAO,MAAA,CAAA,GAAA,CAAI,QAAU,EAAA,QAAA,EAAU,QAAQ,CAAA,CAAA;AAAA,KACzC;AAEA,IAAA,OAAO,IAAI,IAAA,CAAK,MAAO,CAAA,CAAA,EAAG,OAAO,CAAC,CAAA,CAAA;AAAA,GACpC;AACF;;;;"}