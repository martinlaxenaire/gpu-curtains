{"version":3,"file":"DOMMesh.mjs","sources":["../../../../src/curtains/meshes/DOMMesh.ts"],"sourcesContent":["import { DOMObject3D } from '../objects3D/DOMObject3D'\nimport { isCurtainsRenderer } from '../../core/renderers/utils'\nimport { ProjectedMeshBaseMixin } from '../../core/meshes/mixins/ProjectedMeshBaseMixin'\nimport { MeshBaseRenderParams } from '../../core/meshes/mixins/MeshBaseMixin'\nimport { throwWarning } from '../../utils/utils'\nimport { GPUCurtainsRenderer } from '../renderers/GPUCurtainsRenderer'\nimport { GPUCurtains } from '../GPUCurtains'\nimport { Texture } from '../../core/textures/Texture'\nimport { AllowedGeometries } from '../../types/Materials'\nimport { RenderTexture, RenderTextureParams } from '../../core/textures/RenderTexture'\nimport { DOMElementBoundingRect, DOMElementParams } from '../../core/DOM/DOMElement'\n\n/**\n * Base parameters to create a {@link DOMMesh}\n */\nexport interface DOMMeshBaseParams extends MeshBaseRenderParams {\n  /** Whether to automatically create a {@link Texture} for all {@link HTMLImageElement}, {@link HTMLVideoElement} and {@link HTMLCanvasElement} child of the specified {@link DOMMesh} {@link HTMLElement} */\n  autoloadSources?: boolean\n  /** Whether to automatically update the {@link DOMMesh} position on scroll */\n  watchScroll?: boolean\n}\n\n/**\n * Parameters to create a {@link DOMMesh}\n */\nexport interface DOMMeshParams extends DOMMeshBaseParams {\n  /** {@link core/geometries/Geometry.Geometry | Geometry} to use with the {@link DOMMesh} */\n  geometry: AllowedGeometries\n}\n\n/** @const - default {@link DOMMesh} parameters */\nconst defaultDOMMeshParams = {\n  autoloadSources: true,\n  watchScroll: true,\n} as DOMMeshBaseParams\n\n/**\n * Create a {@link core/meshes/Mesh.Mesh | Mesh} based on a {@link DOMObject3D}, which allow the {@link core/meshes/Mesh.Mesh | Mesh} to be scaled and positioned based on a {@link HTMLElement} {@link DOMElementBoundingRect | bounding rectangle}.\n *\n * @example\n * ```javascript\n * // set our main GPUCurtains instance\n * const gpuCurtains = new GPUCurtains({\n *   container: '#canvas' // selector of our WebGPU canvas container\n * })\n *\n * // set the GPU device\n * // note this is asynchronous\n * await gpuCurtains.setDevice()\n *\n * // create a DOMMesh with a box geometry,\n * // assuming there's a HTML element with the \"mesh\" ID in the DOM\n * // will use the normals colors as default shading\n * const domMesh = new DOMMesh(gpuCurtains, '#mesh', {\n *   label: 'My DOM Mesh',\n *   geometry: new BoxGeometry(),\n * })\n * ```\n */\nexport class DOMMesh extends ProjectedMeshBaseMixin(DOMObject3D) {\n  /** {@link GPUCurtainsRenderer} used to create this {@link DOMObject3D} */\n  renderer: GPUCurtainsRenderer\n  /** Whether to automatically create a {@link Texture} for all {@link HTMLImageElement}, {@link HTMLVideoElement} and {@link HTMLCanvasElement} child of the specified {@link DOMMesh} {@link HTMLElement} */\n  autoloadSources: boolean\n  /** Whether all the sources have been successfully loaded */\n  _sourcesReady: boolean\n\n  // callbacks / events\n  /** function assigned to the {@link onLoading} callback */\n  _onLoadingCallback = (texture: Texture): void => {\n    /* allow empty callback */\n  }\n\n  /**\n   * DOMMesh constructor\n   * @param renderer - {@link GPUCurtainsRenderer} object or {@link GPUCurtains} class object used to create this {@link DOMMesh}\n   * @param element - {@link HTMLElement} or string representing an {@link HTMLElement} selector used to scale and position the {@link DOMMesh}\n   * @param parameters - {@link DOMMeshParams | parameters} used to create this {@link DOMMesh}\n   */\n  constructor(\n    renderer: GPUCurtainsRenderer | GPUCurtains,\n    element: DOMElementParams['element'],\n    parameters: DOMMeshParams\n  ) {\n    super(renderer, element, { ...defaultDOMMeshParams, ...parameters })\n\n    parameters = { ...defaultDOMMeshParams, ...parameters }\n\n    // we could pass our curtains object OR our curtains renderer object\n    renderer = (renderer && (renderer as GPUCurtains).renderer) || (renderer as GPUCurtainsRenderer)\n\n    isCurtainsRenderer(renderer, parameters.label ? parameters.label + ' DOMMesh' : 'DOMMesh')\n\n    this.type = 'DOMMesh'\n\n    const { autoloadSources } = parameters\n\n    this.autoloadSources = autoloadSources\n\n    this.sourcesReady = false\n    this.setInitSources()\n  }\n\n  /**\n   * Get/set whether our {@link material} and {@link geometry} are ready\n   * @readonly\n   */\n  get ready(): boolean {\n    return this._ready\n  }\n\n  set ready(value: boolean) {\n    this._ready = value\n\n    if (this.DOMMeshReady) {\n      this._onReadyCallback && this._onReadyCallback()\n    }\n  }\n\n  /**\n   * Get/set whether all the initial {@link DOMMesh} sources have been successfully loaded\n   * @readonly\n   */\n  get sourcesReady(): boolean {\n    return this._sourcesReady\n  }\n\n  set sourcesReady(value: boolean) {\n    this._sourcesReady = value\n\n    if (this.DOMMeshReady) {\n      this._onReadyCallback && this._onReadyCallback()\n    }\n  }\n\n  /**\n   * Get whether our {@link DOMMesh} is ready. A {@link DOMMesh} is ready when its {@link sourcesReady | sources are ready} and its {@link material} and {@link geometry} are ready.\n   * @readonly\n   */\n  get DOMMeshReady(): boolean {\n    return this.ready && this.sourcesReady\n  }\n\n  /**\n   * Add a {@link DOMMesh} to the renderer and the {@link core/scenes/Scene.Scene | Scene}\n   */\n  addToScene() {\n    super.addToScene()\n    ;(this.renderer as GPUCurtainsRenderer).domMeshes.push(this)\n  }\n\n  /**\n   * Remove a {@link DOMMesh} from the renderer and the {@link core/scenes/Scene.Scene | Scene}\n   */\n  removeFromScene() {\n    super.removeFromScene()\n    ;(this.renderer as GPUCurtainsRenderer).domMeshes = (this.renderer as GPUCurtainsRenderer).domMeshes.filter(\n      (m) => m.uuid !== this.uuid\n    )\n  }\n\n  /**\n   * Load initial {@link DOMMesh} sources if needed and create associated {@link Texture}\n   */\n  setInitSources() {\n    let loaderSize = 0\n    let sourcesLoaded = 0\n\n    if (this.autoloadSources) {\n      const images = this.domElement.element.querySelectorAll('img')\n      const videos = this.domElement.element.querySelectorAll('video')\n      const canvases = this.domElement.element.querySelectorAll('canvas')\n\n      loaderSize = images.length + videos.length + canvases.length\n\n      const onSourceUploaded = (texture) => {\n        sourcesLoaded++\n\n        this._onLoadingCallback && this._onLoadingCallback(texture)\n\n        if (sourcesLoaded === loaderSize) {\n          this.sourcesReady = true\n        }\n      }\n\n      if (!loaderSize) {\n        this.sourcesReady = true\n      }\n\n      // load images\n      if (images.length) {\n        images.forEach((image) => {\n          const texture = this.createTexture({\n            name: image.getAttribute('data-texture-name') ?? 'texture' + this.textures.length,\n          })\n\n          texture.onSourceUploaded(() => onSourceUploaded(texture)).loadImage(image.src)\n        })\n      }\n\n      // load videos\n      if (videos.length) {\n        videos.forEach((video) => {\n          const texture = this.createTexture({\n            name: video.getAttribute('data-texture-name') ?? 'texture' + this.textures.length,\n          })\n\n          texture.onSourceUploaded(() => onSourceUploaded(texture)).loadVideo(video)\n        })\n      }\n\n      // load canvases\n      if (canvases.length) {\n        canvases.forEach((canvas) => {\n          const texture = this.createTexture({\n            name: canvas.getAttribute('data-texture-name') ?? 'texture' + this.textures.length,\n          })\n\n          texture.onSourceUploaded(() => onSourceUploaded(texture)).loadCanvas(canvas)\n        })\n      }\n    } else {\n      this.sourcesReady = true\n    }\n  }\n\n  /**\n   * Reset/change the {@link domElement | DOM Element}\n   * @param element - new {@link HTMLElement} or string representing an {@link HTMLElement} selector to use\n   */\n  resetDOMElement(element: string | HTMLElement) {\n    if (!!element) {\n      super.resetDOMElement(element)\n    } else if (!element && !this.renderer.production) {\n      throwWarning(\n        `${this.options.label}: You are trying to reset a ${this.type} with a HTML element that does not exist. The old HTML element will be kept instead.`\n      )\n    }\n  }\n\n  /**\n   * Get our {@link DOMMesh#domElement | DOM Element} {@link core/DOM/DOMElement.DOMElement#boundingRect | bounding rectangle} accounting for current {@link core/renderers/GPURenderer.GPURenderer#pixelRatio | renderer pixel ratio}\n   */\n  get pixelRatioBoundingRect(): DOMElementBoundingRect {\n    const devicePixelRatio = window.devicePixelRatio ?? 1\n    const scaleBoundingRect = this.renderer.pixelRatio / devicePixelRatio\n\n    return Object.keys(this.domElement.boundingRect).reduce(\n      (a, key) => ({ ...a, [key]: this.domElement.boundingRect[key] * scaleBoundingRect }),\n      {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0,\n      }\n    )\n  }\n\n  /* EVENTS */\n\n  /**\n   * Called each time one of the initial sources associated {@link Texture#texture | GPU texture} has been uploaded to the GPU\n   * @param callback - callback to call each time a {@link Texture#texture | GPU texture} has been uploaded to the GPU\n   * @returns - our {@link DOMMesh}\n   */\n  onLoading(callback: (texture: Texture) => void): DOMMesh {\n    if (callback) {\n      this._onLoadingCallback = callback\n    }\n\n    return this\n  }\n}\n"],"names":[],"mappings":";;;;;AA+BA,MAAM,oBAAuB,GAAA;AAAA,EAC3B,eAAiB,EAAA,IAAA;AAAA,EACjB,WAAa,EAAA,IAAA;AACf,CAAA,CAAA;AAyBa,MAAA,OAAA,SAAgB,sBAAuB,CAAA,WAAW,CAAE,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAoB/D,WAAA,CACE,QACA,EAAA,OAAA,EACA,UACA,EAAA;AACA,IAAA,KAAA,CAAM,UAAU,OAAS,EAAA,EAAE,GAAG,oBAAsB,EAAA,GAAG,YAAY,CAAA,CAAA;AAfrE;AAAA;AAAA,IAAA,IAAA,CAAA,kBAAA,GAAqB,CAAC,OAA2B,KAAA;AAAA,KAEjD,CAAA;AAeE,IAAA,UAAA,GAAa,EAAE,GAAG,oBAAsB,EAAA,GAAG,UAAW,EAAA,CAAA;AAGtD,IAAY,QAAA,GAAA,QAAA,IAAa,SAAyB,QAAc,IAAA,QAAA,CAAA;AAEhE,IAAA,kBAAA,CAAmB,UAAU,UAAW,CAAA,KAAA,GAAQ,UAAW,CAAA,KAAA,GAAQ,aAAa,SAAS,CAAA,CAAA;AAEzF,IAAA,IAAA,CAAK,IAAO,GAAA,SAAA,CAAA;AAEZ,IAAM,MAAA,EAAE,iBAAoB,GAAA,UAAA,CAAA;AAE5B,IAAA,IAAA,CAAK,eAAkB,GAAA,eAAA,CAAA;AAEvB,IAAA,IAAA,CAAK,YAAe,GAAA,KAAA,CAAA;AACpB,IAAA,IAAA,CAAK,cAAe,EAAA,CAAA;AAAA,GACtB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,KAAiB,GAAA;AACnB,IAAA,OAAO,IAAK,CAAA,MAAA,CAAA;AAAA,GACd;AAAA,EAEA,IAAI,MAAM,KAAgB,EAAA;AACxB,IAAA,IAAA,CAAK,MAAS,GAAA,KAAA,CAAA;AAEd,IAAA,IAAI,KAAK,YAAc,EAAA;AACrB,MAAK,IAAA,CAAA,gBAAA,IAAoB,KAAK,gBAAiB,EAAA,CAAA;AAAA,KACjD;AAAA,GACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,YAAwB,GAAA;AAC1B,IAAA,OAAO,IAAK,CAAA,aAAA,CAAA;AAAA,GACd;AAAA,EAEA,IAAI,aAAa,KAAgB,EAAA;AAC/B,IAAA,IAAA,CAAK,aAAgB,GAAA,KAAA,CAAA;AAErB,IAAA,IAAI,KAAK,YAAc,EAAA;AACrB,MAAK,IAAA,CAAA,gBAAA,IAAoB,KAAK,gBAAiB,EAAA,CAAA;AAAA,KACjD;AAAA,GACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,YAAwB,GAAA;AAC1B,IAAO,OAAA,IAAA,CAAK,SAAS,IAAK,CAAA,YAAA,CAAA;AAAA,GAC5B;AAAA;AAAA;AAAA;AAAA,EAKA,UAAa,GAAA;AACX,IAAA,KAAA,CAAM,UAAW,EAAA,CAAA;AAChB,IAAC,IAAK,CAAA,QAAA,CAAiC,SAAU,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;AAAA,GAC7D;AAAA;AAAA;AAAA;AAAA,EAKA,eAAkB,GAAA;AAChB,IAAA,KAAA,CAAM,eAAgB,EAAA,CAAA;AACrB,IAAC,IAAK,CAAA,QAAA,CAAiC,SAAa,GAAA,IAAA,CAAK,SAAiC,SAAU,CAAA,MAAA;AAAA,MACnG,CAAC,CAAA,KAAM,CAAE,CAAA,IAAA,KAAS,IAAK,CAAA,IAAA;AAAA,KACzB,CAAA;AAAA,GACF;AAAA;AAAA;AAAA;AAAA,EAKA,cAAiB,GAAA;AACf,IAAA,IAAI,UAAa,GAAA,CAAA,CAAA;AACjB,IAAA,IAAI,aAAgB,GAAA,CAAA,CAAA;AAEpB,IAAA,IAAI,KAAK,eAAiB,EAAA;AACxB,MAAA,MAAM,MAAS,GAAA,IAAA,CAAK,UAAW,CAAA,OAAA,CAAQ,iBAAiB,KAAK,CAAA,CAAA;AAC7D,MAAA,MAAM,MAAS,GAAA,IAAA,CAAK,UAAW,CAAA,OAAA,CAAQ,iBAAiB,OAAO,CAAA,CAAA;AAC/D,MAAA,MAAM,QAAW,GAAA,IAAA,CAAK,UAAW,CAAA,OAAA,CAAQ,iBAAiB,QAAQ,CAAA,CAAA;AAElE,MAAA,UAAA,GAAa,MAAO,CAAA,MAAA,GAAS,MAAO,CAAA,MAAA,GAAS,QAAS,CAAA,MAAA,CAAA;AAEtD,MAAM,MAAA,gBAAA,GAAmB,CAAC,OAAY,KAAA;AACpC,QAAA,aAAA,EAAA,CAAA;AAEA,QAAK,IAAA,CAAA,kBAAA,IAAsB,IAAK,CAAA,kBAAA,CAAmB,OAAO,CAAA,CAAA;AAE1D,QAAA,IAAI,kBAAkB,UAAY,EAAA;AAChC,UAAA,IAAA,CAAK,YAAe,GAAA,IAAA,CAAA;AAAA,SACtB;AAAA,OACF,CAAA;AAEA,MAAA,IAAI,CAAC,UAAY,EAAA;AACf,QAAA,IAAA,CAAK,YAAe,GAAA,IAAA,CAAA;AAAA,OACtB;AAGA,MAAA,IAAI,OAAO,MAAQ,EAAA;AACjB,QAAO,MAAA,CAAA,OAAA,CAAQ,CAAC,KAAU,KAAA;AACxB,UAAM,MAAA,OAAA,GAAU,KAAK,aAAc,CAAA;AAAA,YACjC,MAAM,KAAM,CAAA,YAAA,CAAa,mBAAmB,CAAK,IAAA,SAAA,GAAY,KAAK,QAAS,CAAA,MAAA;AAAA,WAC5E,CAAA,CAAA;AAED,UAAQ,OAAA,CAAA,gBAAA,CAAiB,MAAM,gBAAiB,CAAA,OAAO,CAAC,CAAE,CAAA,SAAA,CAAU,MAAM,GAAG,CAAA,CAAA;AAAA,SAC9E,CAAA,CAAA;AAAA,OACH;AAGA,MAAA,IAAI,OAAO,MAAQ,EAAA;AACjB,QAAO,MAAA,CAAA,OAAA,CAAQ,CAAC,KAAU,KAAA;AACxB,UAAM,MAAA,OAAA,GAAU,KAAK,aAAc,CAAA;AAAA,YACjC,MAAM,KAAM,CAAA,YAAA,CAAa,mBAAmB,CAAK,IAAA,SAAA,GAAY,KAAK,QAAS,CAAA,MAAA;AAAA,WAC5E,CAAA,CAAA;AAED,UAAA,OAAA,CAAQ,iBAAiB,MAAM,gBAAA,CAAiB,OAAO,CAAC,CAAA,CAAE,UAAU,KAAK,CAAA,CAAA;AAAA,SAC1E,CAAA,CAAA;AAAA,OACH;AAGA,MAAA,IAAI,SAAS,MAAQ,EAAA;AACnB,QAAS,QAAA,CAAA,OAAA,CAAQ,CAAC,MAAW,KAAA;AAC3B,UAAM,MAAA,OAAA,GAAU,KAAK,aAAc,CAAA;AAAA,YACjC,MAAM,MAAO,CAAA,YAAA,CAAa,mBAAmB,CAAK,IAAA,SAAA,GAAY,KAAK,QAAS,CAAA,MAAA;AAAA,WAC7E,CAAA,CAAA;AAED,UAAA,OAAA,CAAQ,iBAAiB,MAAM,gBAAA,CAAiB,OAAO,CAAC,CAAA,CAAE,WAAW,MAAM,CAAA,CAAA;AAAA,SAC5E,CAAA,CAAA;AAAA,OACH;AAAA,KACK,MAAA;AACL,MAAA,IAAA,CAAK,YAAe,GAAA,IAAA,CAAA;AAAA,KACtB;AAAA,GACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,gBAAgB,OAA+B,EAAA;AAC7C,IAAI,IAAA,CAAC,CAAC,OAAS,EAAA;AACb,MAAA,KAAA,CAAM,gBAAgB,OAAO,CAAA,CAAA;AAAA,eACpB,CAAC,OAAA,IAAW,CAAC,IAAA,CAAK,SAAS,UAAY,EAAA;AAChD,MAAA,YAAA;AAAA,QACE,GAAG,IAAK,CAAA,OAAA,CAAQ,KAAK,CAAA,4BAAA,EAA+B,KAAK,IAAI,CAAA,oFAAA,CAAA;AAAA,OAC/D,CAAA;AAAA,KACF;AAAA,GACF;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,sBAAiD,GAAA;AACnD,IAAM,MAAA,gBAAA,GAAmB,OAAO,gBAAoB,IAAA,CAAA,CAAA;AACpD,IAAM,MAAA,iBAAA,GAAoB,IAAK,CAAA,QAAA,CAAS,UAAa,GAAA,gBAAA,CAAA;AAErD,IAAA,OAAO,MAAO,CAAA,IAAA,CAAK,IAAK,CAAA,UAAA,CAAW,YAAY,CAAE,CAAA,MAAA;AAAA,MAC/C,CAAC,CAAA,EAAG,GAAS,MAAA,EAAE,GAAG,CAAG,EAAA,CAAC,GAAG,GAAG,IAAK,CAAA,UAAA,CAAW,YAAa,CAAA,GAAG,IAAI,iBAAkB,EAAA,CAAA;AAAA,MAClF;AAAA,QACE,CAAG,EAAA,CAAA;AAAA,QACH,CAAG,EAAA,CAAA;AAAA,QACH,KAAO,EAAA,CAAA;AAAA,QACP,MAAQ,EAAA,CAAA;AAAA,QACR,GAAK,EAAA,CAAA;AAAA,QACL,KAAO,EAAA,CAAA;AAAA,QACP,MAAQ,EAAA,CAAA;AAAA,QACR,IAAM,EAAA,CAAA;AAAA,OACR;AAAA,KACF,CAAA;AAAA,GACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,UAAU,QAA+C,EAAA;AACvD,IAAA,IAAI,QAAU,EAAA;AACZ,MAAA,IAAA,CAAK,kBAAqB,GAAA,QAAA,CAAA;AAAA,KAC5B;AAEA,IAAO,OAAA,IAAA,CAAA;AAAA,GACT;AACF;;;;"}