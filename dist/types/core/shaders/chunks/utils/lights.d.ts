export declare const getLambert = "\nfn lessThan3(a: vec3f, b: vec3f) -> vec3f {\n  return vec3f(vec3<bool>(a.x < b.x, a.y < b.y, a.z < b.z));\n}\n\nfn linearToOutput3(value: vec3f) -> vec3f {\n  return vec3( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThan3( value.rgb, vec3( 0.0031308 ) ) ) ) );\n}\n\nfn linearToOutput4(value: vec4f) -> vec4f {\n  return vec4( linearToOutput3(value.rgb), value.a );\n}\n\nfn pow2( x: f32 ) -> f32 {\n    return x * x;\n}\n\nfn pow3( x: f32 ) -> f32 {\n    return x * x * x;\n}\n\nfn pow4( x: f32 ) -> f32 {\n    return pow2(x) * pow2(x);\n}\n\nfn rangeAttenuation(range: f32, distance: f32) -> f32 {\n  var distanceFalloff: f32 = 1.0 / max( pow( distance, 2.0 ), 0.01 );\n  if ( range > 0.0 ) {\n      distanceFalloff *= pow2( clamp( 1.0 - pow4( distance / range ), 0.0, 1.0 ) );\n  }\n  \n  return distanceFalloff;\n}\n\nfn BRDF_Lambert(diffuseColor: vec3f) -> vec3f {\n  return RECIPROCAL_PI * diffuseColor;\n  //return diffuseColor;\n}\n\n// LIGHTS INFO\n\nstruct DirectLight {\n  color: vec3f,\n  direction: vec3f,\n  visible: bool,\n}\n\nfn getDirectionalLightInfo(directionalLight: DirectionalLightsElement, worldPosition: vec3f, ptr_light: ptr<function, DirectLight>) {\n  (*ptr_light).color = directionalLight.color;\n  (*ptr_light).direction = worldPosition - directionalLight.direction;\n  (*ptr_light).visible = true;\n}\n\nfn getPointLightInfo(pointLight: PointLightsElement, worldPosition: vec3f, ptr_light: ptr<function, DirectLight>) {\n  let lightDirection: vec3f = pointLight.position - worldPosition;\n  (*ptr_light).direction = normalize(lightDirection);\n  let lightDistance: f32 = length(lightDirection);\n  (*ptr_light).color = pointLight.color;\n  (*ptr_light).color *= rangeAttenuation(pointLight.range, lightDistance);\n  \n  (*ptr_light).visible = (*ptr_light).color.r != 0.0 && (*ptr_light).color.g != 0.0 && (*ptr_light).color.b != 0.0;\n}\n\nfn getLambertDirect(\n  normal: vec3f,\n  diffuseColor: vec3f,\n  directLight: DirectLight,\n  ptr_reflectedLight: ptr<function, ReflectedLight>\n) {\n  let L = normalize(directLight.direction);\n  let NdotL = max(dot(normal, L), 0.0);\n  \n  let irradiance: vec3f = NdotL * directLight.color;\n  (*ptr_reflectedLight).directDiffuse += irradiance * BRDF_Lambert( diffuseColor );\n}\n\nfn getLambertIndirectDiffuse(irradiance: vec3f, diffuseColor: vec3f, ptr_reflectedLight: ptr<function, ReflectedLight>) {\n  (*ptr_reflectedLight).indirectDiffuse += irradiance * BRDF_Lambert( diffuseColor );\n}\n\nfn getLambertTotalIndirectDiffuse(diffuseColor: vec3f, ptr_reflectedLight: ptr<function, ReflectedLight>) {\n  var totalAmbientIrradiance: vec3f;\n  for(var i: i32 = 0; i < ambientLights.count; i++) {\n    totalAmbientIrradiance += ambientLights.color[i];\n  }\n  \n  getLambertIndirectDiffuse(totalAmbientIrradiance, diffuseColor, ptr_reflectedLight);\n}\n\nfn getLambert(\n  normal: vec3f,\n  worldPosition: vec3f,\n  diffuseColor: vec3f\n) -> vec3f {\n  var directLight: DirectLight;\n  var reflectedLight: ReflectedLight;\n\n  // point lights\n  for(var i = 0; i < pointLights.count; i++) {\n    getPointLightInfo(pointLights.elements[i], worldPosition, &directLight);\n    getLambertDirect(normal, diffuseColor, directLight, &reflectedLight);\n  }\n  \n  // directional lights\n  for(var i = 0; i < directionalLights.count; i++) {\n    getDirectionalLightInfo(directionalLights.elements[i], worldPosition, &directLight);\n    getLambertDirect(normal, diffuseColor, directLight, &reflectedLight);\n  }\n  \n  // ambient lights\n  getLambertTotalIndirectDiffuse(diffuseColor, &reflectedLight);\n  \n  let outgoingLight: vec3f = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n  \n  return linearToOutput3(outgoingLight);\n}";
export declare const getPhong: string;
