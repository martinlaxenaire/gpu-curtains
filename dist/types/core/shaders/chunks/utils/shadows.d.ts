import { CameraRenderer } from '../../../renderers/utils';
export declare const getDefaultShadowDepthVs: (lightShadowIndex?: number) => string;
export declare const getPCFShadowContribution = "\nfn getPCFShadowContribution(index: i32, worldPosition: vec3f, depthTexture: texture_depth_2d) -> f32 {\n  let directionalShadow: DirectionalShadowsElement = directionalShadows.directionalShadowsElements[index];\n  \n  // get shadow coords\n  var shadowCoords: vec3f = vec3((directionalShadow.projectionMatrix * directionalShadow.viewMatrix * vec4(worldPosition, 1.0)).xyz);\n  \n  // Convert XY to (0, 1)\n  // Y is flipped because texture coords are Y-down.\n  shadowCoords = vec3(\n    shadowCoords.xy * vec2(0.5, -0.5) + vec2(0.5),\n    shadowCoords.z\n  );\n  \n  // Percentage-closer filtering. Sample texels in the region\n  // to smooth the result.\n  var visibility = 0.0;\n  \n  let size: vec2f = vec2f(textureDimensions(depthTexture).xy);\n  \n  let texelSize: vec2f = 1.0 / size;\n  \n  let sampleCount: i32 = directionalShadow.pcfSamples;\n  let maxSamples: f32 = f32(sampleCount) - 1.0;\n  \n  for (var x = 0; x < sampleCount; x++) {\n    for (var y = 0; y < sampleCount; y++) {\n      let offset = texelSize * vec2(\n        f32(x) - maxSamples * 0.5,\n        f32(y) - maxSamples * 0.5\n      );\n      \n      visibility += textureSampleCompare(\n        depthTexture,\n        depthComparisonSampler,\n        shadowCoords.xy + offset,\n        shadowCoords.z - directionalShadow.bias\n      );\n    }\n  }\n  visibility /= f32(sampleCount * sampleCount);\n  \n  visibility = clamp(visibility, 1.0 - clamp(directionalShadow.intensity, 0.0, 1.0), 1.0);\n  \n  let inFrustum: bool = shadowCoords.x >= 0.0 && shadowCoords.x <= 1.0 && shadowCoords.y >= 0.0 && shadowCoords.y <= 1.0;\n  let frustumTest: bool = inFrustum && shadowCoords.z <= 1.0;\n  \n  return select(1.0, visibility, frustumTest);\n}\n";
export declare const getPCFDirectionalShadows: (renderer: CameraRenderer) => string;
export declare const getDefaultPointShadowDepthVs: (pointShadowIndex?: number) => string;
export declare const getDefaultPointShadowDepthFs: (pointShadowIndex?: number) => string;
export declare const getPCFPointShadowContribution = "\nfn getPCFPointShadowContribution(index: i32, shadowPosition: vec4f, depthCubeTexture: texture_depth_cube) -> f32 {\n  let pointShadow: PointShadowsElement = pointShadows.pointShadowsElements[index];\n\n  // Percentage-closer filtering. Sample texels in the region\n  // to smooth the result.\n  var visibility = 0.0;\n  var closestDepth = 0.0;\n  let currentDepth: f32 = shadowPosition.w;\n  let cameraRange: f32 = pointShadow.cameraFar - pointShadow.cameraNear;\n  let normalizedDepth: f32 = (shadowPosition.w - pointShadow.cameraNear) / cameraRange;\n\n  let maxSize: f32 = f32(max(textureDimensions(depthCubeTexture).x, textureDimensions(depthCubeTexture).y));\n\n  let texelSize: vec3f = vec3(1.0 / maxSize);\n  let sampleCount: i32 = pointShadow.pcfSamples;\n  let maxSamples: f32 = f32(sampleCount) - 1.0;\n  \n  for (var x = 0; x < sampleCount; x++) {\n    for (var y = 0; y < sampleCount; y++) {\n      for (var z = 0; z < sampleCount; z++) {\n        let offset = texelSize * vec3(\n          f32(x) - maxSamples * 0.5,\n          f32(y) - maxSamples * 0.5,\n          f32(z) - maxSamples * 0.5\n        );\n\n        closestDepth = textureSampleCompare(\n          depthCubeTexture,\n          depthComparisonSampler,\n          shadowPosition.xyz + offset,\n          normalizedDepth - pointShadow.bias\n        );\n\n        closestDepth *= cameraRange;\n        if(currentDepth <= closestDepth) {\n          visibility += 1.0;\n        }\n      }\n    }\n  }\n  \n  visibility /= f32(sampleCount * sampleCount * sampleCount);\n  \n  visibility = clamp(visibility, 1.0 - clamp(pointShadow.intensity, 0.0, 1.0), 1.0);\n  \n  return visibility;\n}";
export declare const getPCFPointShadows: (renderer: CameraRenderer) => string;
export declare const getLambertWithShadows: string;
export declare const getPhongWithShadows: string;
