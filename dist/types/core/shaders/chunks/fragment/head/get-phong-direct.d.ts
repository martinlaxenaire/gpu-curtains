/** Helper function chunk appended internally and used to compute Phong direct light contributions. */
export declare const getPhongDirect = "\nfn D_BlinnPhong( shininess: f32, NdotH: f32 ) -> f32 {\n  return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( NdotH, shininess );\n}\n\nfn BRDF_BlinnPhong(\n  normal: vec3f,\n  viewDirection: vec3f,\n  specularColor: vec3f,\n  shininess: f32,\n  directLight: DirectLight\n) -> vec3f {\n  let L = normalize(directLight.direction);\n  let NdotL = saturate(dot(normalize(normal), L));\n  let H: vec3f = normalize(viewDirection + L);\n  \n  let NdotH: f32 = saturate(dot(normalize(normal), H));\n  let VdotH: f32 = saturate(dot(normalize(viewDirection), H));\n  let NdotV: f32 = saturate(dot(normalize(normal), normalize(viewDirection)));\n  \n  let F: vec3f = F_Schlick(VdotH, specularColor, 1.0);\n  \n  let G: f32 = 0.25; // blinn phong implicit\n  \n  let D = D_BlinnPhong(shininess, NdotH);\n  \n  let specular: vec3f = F * G * D;\n        \n  return specular;\n}\n\nfn getPhongDirect(\n  normal: vec3f,\n  diffuseColor: vec3f,\n  viewDirection: vec3f,\n  specularColor: vec3f,\n  specularStrength: f32,\n  shininess: f32,\n  directLight: DirectLight,\n  ptr_reflectedLight: ptr<function, ReflectedLight>\n) {\n  let L = normalize(directLight.direction);\n  let NdotL = saturate(dot(normalize(normal), L));\n  \n  let irradiance: vec3f = NdotL * directLight.color;\n  (*ptr_reflectedLight).directDiffuse += irradiance * BRDF_Lambert( diffuseColor );\n  (*ptr_reflectedLight).directSpecular += irradiance * BRDF_BlinnPhong( normal, viewDirection, specularColor, shininess, directLight ) * specularStrength;\n}\n";
