/** Helper function chunk appended internally and used to compute PBR direct light contributions. */
export declare const getPBRDirect = "\nfn EnvironmentBRDF(\n  normal: vec3<f32>, \n  viewDir: vec3<f32>, \n  specularColor: vec3<f32>, \n  specularF90: f32, \n  roughness: f32\n) -> vec3<f32> {\n  let fab = DFGApprox(normal, viewDir, roughness);\n  return specularColor * fab.x + specularF90 * fab.y;\n}\n\nfn DistributionGGX(NdotH: f32, roughness: f32) -> f32 {\n  let a: f32 = pow2( roughness );\n  let a2: f32 = pow2( a );\n\n  let denom: f32 = (pow2( NdotH ) * (a2 - 1.0) + 1.0);\n\n  return RECIPROCAL_PI * a2 / ( pow2( denom ) );\n}\n\nfn GeometrySmith(NdotL: f32, NdotV: f32, roughness: f32) -> f32 {\n  let a: f32 = pow2( roughness );\n  let a2: f32 = pow2( a );\n  \n  let gv: f32 = NdotL * sqrt( a2 + ( 1.0 - a2 ) * pow2( NdotV ) );\n  let gl: f32 = NdotV * sqrt( a2 + ( 1.0 - a2 ) * pow2( NdotL ) );\n\n  return 0.5 / max( gv + gl, EPSILON );\n}\n\nfn BRDF_GGX(\n  NdotV: f32,\n  NdotL: f32,\n  NdotH: f32,\n  VdotH: f32,\n  roughness: f32,\n  specularFactor: f32,\n  specularColor: vec3f\n) -> vec3f {\n  // cook-torrance brdf\n  let G: f32 = GeometrySmith(NdotL, NdotV, roughness);\n  let D: f32 = DistributionGGX(NdotH, roughness);\n  let F: vec3f = F_Schlick(VdotH, specularColor, specularFactor);\n  \n  return G * D * F;\n}\n\nfn computeSpecularOcclusion( NdotV: f32, occlusion: f32, roughness: f32 ) -> f32 {\n\treturn saturate(pow(NdotV + occlusion, exp2(- 16.0 * roughness - 1.0)) - 1.0 + occlusion);\n}\n\nfn getPBRDirect(\n  normal: vec3f,\n  diffuseColor: vec3f,\n  viewDirection: vec3f,\n  specularFactor: f32,\n  specularColor: vec3f,\n  metallic: f32,\n  roughness: f32,\n  directLight: DirectLight,\n  ptr_reflectedLight: ptr<function, ReflectedLight>\n) {\n  let N: vec3f = normalize(normal);\n  let L: vec3f = normalize(directLight.direction);\n  let V: vec3f = normalize(viewDirection);\n  let H: vec3f = normalize(V + L);\n  let NdotV: f32 = saturate(dot(N, V));\n  let NdotL: f32 = saturate(dot(N, L));\n  let NdotH: f32 = saturate(dot(N, H));\n  let VdotH: f32 = saturate(dot(V, H));\n\n  let irradiance: vec3f = NdotL * directLight.color;\n  let ggx: vec3f = BRDF_GGX(NdotV, NdotL, NdotH, VdotH, roughness, specularFactor, specularColor);\n  \n  let diffuseContribution: vec3f = BRDF_Lambert(diffuseColor);\n  \n  (*ptr_reflectedLight).directDiffuse += irradiance * diffuseContribution;\n  (*ptr_reflectedLight).directSpecular += irradiance * ggx;\n}\n";
