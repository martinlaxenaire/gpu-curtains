/** Helper chunk to compute the shadow visibility of a fragment using `shadowCoords`, a 2D `depthTexture` and shadow properties using PCF. Returns `1` when fully visible and `0` when fully shadowed. */
export declare const getPCFBaseShadowContribution = "\nfn getPCFBaseShadowContribution(\n  shadowCoords: vec3f,\n  pcfSamples: i32,\n  bias: f32,\n  intensity: f32,\n  depthTexture: texture_depth_2d\n) -> f32 {\n  var visibility = 0.0;\n  \n  let inFrustum: bool = shadowCoords.x >= 0.0 && shadowCoords.x <= 1.0 && shadowCoords.y >= 0.0 && shadowCoords.y <= 1.0;\n  let frustumTest: bool = inFrustum && shadowCoords.z <= 1.0;\n  \n  if(frustumTest) {\n    // Percentage-closer filtering. Sample texels in the region\n    // to smooth the result.\n    let size: vec2f = vec2f(textureDimensions(depthTexture).xy);\n  \n    let texelSize: vec2f = 1.0 / size;\n    \n    let sampleCount: i32 = pcfSamples;\n    let maxSamples: f32 = f32(sampleCount) - 1.0;\n  \n    for (var x = 0; x < sampleCount; x++) {\n      for (var y = 0; y < sampleCount; y++) {\n        let offset = texelSize * vec2(\n          f32(x) - maxSamples * 0.5,\n          f32(y) - maxSamples * 0.5\n        );\n        \n        visibility += textureSampleCompareLevel(\n          depthTexture,\n          depthComparisonSampler,\n          shadowCoords.xy + offset,\n          shadowCoords.z - bias\n        );\n      }\n    }\n    visibility /= f32(sampleCount * sampleCount);\n    \n    visibility = clamp(visibility, 1.0 - saturate(intensity), 1.0);\n  }\n  else {\n    visibility = 1.0;\n  }\n  \n  return visibility;\n}\n";
