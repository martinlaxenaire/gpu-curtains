/** Defines all available tone mapping types */
export type ToneMappingTypes = 'linear' | 'khronos';
/** Tone mapping utils chunks. */
export declare const toneMappingUtils = "\nfn linearToOutput3(value: vec3f) -> vec3f {\n  return vec3( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThan3( value.rgb, vec3( 0.0031308 ) ) ) ) );\n}\n\nfn linearToOutput4(value: vec4f) -> vec4f {\n  return vec4( linearToOutput3(value.rgb), value.a );\n}\n\n// linear <-> sRGB conversions\nfn linearTosRGB(linear: vec3f) -> vec3f {\n  if (all(linear <= vec3(0.0031308))) {\n    return linear * 12.92;\n  }\n  return (pow(abs(linear), vec3(1.0/2.4)) * 1.055) - vec3(0.055);\n}\n\nfn sRGBToLinear(srgb: vec3f) -> vec3f {\n  if (all(srgb <= vec3(0.04045))) {\n    return srgb / vec3(12.92);\n  }\n  return pow((srgb + vec3(0.055)) / vec3(1.055), vec3(2.4));\n}\n\nfn toneMapKhronosPbrNeutral( color: vec3f ) -> vec3f {\n  var toneMapColor = color; \n  const startCompression: f32 = 0.8 - 0.04;\n  const desaturation: f32 = 0.15;\n  var x: f32 = min(toneMapColor.r, min(toneMapColor.g, toneMapColor.b));\n  var offset: f32 = select(0.04, x - 6.25 * x * x, x < 0.08);\n  toneMapColor = toneMapColor - offset;\n  var peak: f32 = max(toneMapColor.r, max(toneMapColor.g, toneMapColor.b));\n  if (peak < startCompression) {\n    return toneMapColor;\n  }\n  const d: f32 = 1. - startCompression;\n  let newPeak: f32 = 1. - d * d / (peak + d - startCompression);\n  toneMapColor *= newPeak / peak;\n  let g: f32 = 1. - 1. / (desaturation * (peak - newPeak) + 1.);\n  return mix(toneMapColor, newPeak * vec3(1, 1, 1), g);\n}\n";
